Only in nw/chromium: .git
diff -r -u --color up/chromium/.gitignore nw/chromium/.gitignore
--- up/chromium/.gitignore	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/.gitignore	2023-01-28 02:49:20.047531525 +0000
@@ -1,4 +1,5 @@
 /client-py/
+/content/nw
 *.bak
 *.code-workspace
 *.mk
diff -r -u --color up/chromium/BUILD.gn nw/chromium/BUILD.gn
--- up/chromium/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/BUILD.gn	2023-01-28 02:49:20.051531567 +0000
@@ -128,6 +128,7 @@
 
   if (!is_ios && !is_android && !is_castos) {
     deps += [
+      "//content/nw:nwjs",
       "//chrome",
       "//chrome/browser/ui/color:dump_colors",
       "//chrome/test:browser_tests",
@@ -226,7 +227,7 @@
     ]
   }
 
-  if (!is_ios && !is_android) {
+  if (false && !is_ios && !is_android) {
     deps += [
       "//components/cronet:cronet_tests",
       "//components/cronet:cronet_unittests",
@@ -1631,16 +1632,6 @@
   }
 }
 
-# TODO(cassew): Add more OS's that don't support x86.
-is_valid_x86_target =
-    target_os != "ios" && target_os != "mac" &&
-    (target_os != "linux" || use_libfuzzer || !build_with_chromium)
-
-# Note: v8_target_cpu == arm allows using the V8 arm simulator on x86 for fuzzing.
-assert(
-    is_valid_x86_target || target_cpu != "x86" || v8_target_cpu == "arm",
-    "'target_cpu=x86' is not supported for 'target_os=$target_os'. Consider omitting 'target_cpu' (default) or using 'target_cpu=x64' instead.")
-
 group("chromium_builder_perf") {
   testonly = true
 
diff -r -u --color up/chromium/DEPS nw/chromium/DEPS
--- up/chromium/DEPS	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/DEPS	2023-01-28 02:49:20.051531567 +0000
@@ -298,6 +298,7 @@
   'boringssl_git': 'https://boringssl.googlesource.com',
   'chromium_git': 'https://chromium.googlesource.com',
   'dawn_git': 'https://dawn.googlesource.com',
+  'nwjs_git': 'https://github.com/nwjs',
   'pdfium_git': 'https://pdfium.googlesource.com',
   'quiche_git': 'https://quiche.googlesource.com',
   'skia_git': 'https://skia.googlesource.com',
@@ -517,6 +518,9 @@
 ]
 
 deps = {
+  'src/tools/gyp':
+    Var('chromium_git') + '/external/gyp.git' + '@' + 'd61a9397e668fa9843c4aa7da9e79460fe590bfb',
+
   'src/buildtools/clang_format/script':
     Var('chromium_git') +
     '/external/github.com/llvm/llvm-project/clang/tools/clang-format.git@' +
@@ -1915,8 +1919,8 @@
       'condition': 'checkout_mac',
   },
 
-  'src/v8':
-    Var('chromium_git') + '/v8/v8.git' + '@' +  Var('v8_revision'),
+  #'src/v8':
+  #  Var('chromium_git') + '/v8/v8.git' + '@' +  Var('v8_revision'),
 
   'src-internal': {
     'url': 'https://chrome-internal.googlesource.com/chrome/src-internal.git@03c7d5252c543b20160f4341273e7377ca027397',
@@ -4363,7 +4367,15 @@
                 '--no_auth',
                 '--bucket', 'chromium-nodejs/16.13.0',
                 '-s', 'src/third_party/node/linux/node-linux-x64.tar.gz.sha1',
-    ],
+                ],
+  },
+  {
+    'name': 'nw_patch',
+    'pattern': '.',
+    'action': [
+      'python',
+      'src/content/nw/tools/patcher.py'
+      ],
   },
   # The Mac x64/arm64 binaries are downloaded regardless of host architecture
   # since it's possible to cross-compile for the other architecture. This can
diff -r -u --color up/chromium/apps/app_lifetime_monitor.cc nw/chromium/apps/app_lifetime_monitor.cc
--- up/chromium/apps/app_lifetime_monitor.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/apps/app_lifetime_monitor.cc	2023-01-28 02:49:20.139532474 +0000
@@ -65,8 +65,10 @@
 }
 
 void AppLifetimeMonitor::OnAppWindowHidden(AppWindow* app_window) {
+#if 0
   if (!HasOtherVisibleAppWindows(app_window))
     NotifyAppDeactivated(app_window->extension_id());
+#endif
 }
 
 void AppLifetimeMonitor::OnAppWindowShown(AppWindow* app_window,
diff -r -u --color up/chromium/apps/launcher.cc nw/chromium/apps/launcher.cc
--- up/chromium/apps/launcher.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/apps/launcher.cc	2023-01-28 02:49:20.139532474 +0000
@@ -112,7 +112,10 @@
         extension_id(app->id()),
         entry_paths_(entry_paths),
         mime_type_collector_(context),
-        is_directory_collector_(context) {}
+        is_directory_collector_(context) {
+    if (app->is_nwjs_app()) //NWJS#5097
+      entry_paths_.clear();
+  }
 
   PlatformAppPathLauncher(content::BrowserContext* context,
                           const Extension* app,
@@ -121,7 +124,7 @@
         extension_id(app->id()),
         mime_type_collector_(context),
         is_directory_collector_(context) {
-    if (!file_path.empty())
+    if (!file_path.empty() && !app->is_nwjs_app()) //NWJS#5097
       entry_paths_.push_back(file_path);
   }
   PlatformAppPathLauncher(const PlatformAppPathLauncher&) = delete;
@@ -497,7 +500,7 @@
 
   extensions::ExtensionPrefs* extension_prefs =
       extensions::ExtensionPrefs::Get(context);
-  bool had_windows = extension_prefs->IsActive(app->id());
+  bool had_windows = extension_prefs->IsActive(app->id()) || true;
   extension_prefs->SetIsActive(app->id(), false);
   bool listening_to_launch = event_router->ExtensionHasEventListener(
       app->id(), app_runtime::OnLaunched::kEventName);
diff -r -u --color up/chromium/apps/ui/views/app_window_frame_view.cc nw/chromium/apps/ui/views/app_window_frame_view.cc
--- up/chromium/apps/ui/views/app_window_frame_view.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/apps/ui/views/app_window_frame_view.cc	2023-01-28 02:49:20.139532474 +0000
@@ -53,7 +53,7 @@
   if (draw_frame_) {
     ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
     auto close_button = std::make_unique<views::ImageButton>(
-        base::BindRepeating(&views::Widget::Close, base::Unretained(widget_)));
+       base::BindRepeating(&views::Widget::Close, base::Unretained(widget_), false));
     close_button->SetImage(
         views::Button::STATE_NORMAL,
         rb.GetNativeImageNamed(IDR_APP_WINDOW_CLOSE).ToImageSkia());
diff -r -u --color up/chromium/base/BUILD.gn nw/chromium/base/BUILD.gn
--- up/chromium/base/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/base/BUILD.gn	2023-01-28 02:49:20.723538498 +0000
@@ -190,6 +190,7 @@
 # mixed_component is a regular C++ "component", but may have some Rust files
 # if Rust is enabled.
 mixed_component("base") {
+  include_dirs = [ "//v8/include" ]
   sources = [
     "allocator/allocator_check.cc",
     "allocator/allocator_check.h",
@@ -476,6 +477,8 @@
     "message_loop/message_pump_glib.cc",
     "message_loop/message_pump_glib.h",
     "message_loop/message_pump_type.h",
+    "message_loop/message_pump_uv.cc",
+    "message_loop/message_pump_uv.h",
     "message_loop/timer_slack.h",
     "message_loop/work_id_provider.cc",
     "message_loop/work_id_provider.h",
@@ -1488,7 +1491,10 @@
 
   configs += [
     "//build/config:precompiled_headers",
-    "//build/config/compiler:prevent_unsafe_narrowing",
+
+    # TODO(crbug.com/1292951): Enable.
+    # "//build/config/compiler:prevent_unsafe_narrowing",
+
     "//build/config/compiler:wexit_time_destructors",
     "//build/config/compiler:wglobal_constructors",
   ]
diff -r -u --color up/chromium/base/allocator/allocator.gni nw/chromium/base/allocator/allocator.gni
--- up/chromium/base/allocator/allocator.gni	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/base/allocator/allocator.gni	2023-01-28 02:49:20.723538498 +0000
@@ -20,6 +20,8 @@
   force_enable_raw_ptr_exclusion = false
 }
 
+use_allocator = "none"
+
 assert(
     !use_allocator_shim || is_linux || is_chromeos || is_android || is_win ||
         is_fuchsia || is_apple,
diff -r -u --color up/chromium/base/allocator/partition_allocator/partition_bucket.cc nw/chromium/base/allocator/partition_allocator/partition_bucket.cc
--- up/chromium/base/allocator/partition_allocator/partition_bucket.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/base/allocator/partition_allocator/partition_bucket.cc	2023-01-28 02:49:20.739538663 +0000
@@ -2,6 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#pragma clang diagnostic ignored "-Wthread-safety-analysis"
 #include "base/allocator/partition_allocator/partition_bucket.h"
 
 #include <algorithm>
diff -r -u --color up/chromium/base/allocator/partition_allocator/partition_root.cc nw/chromium/base/allocator/partition_allocator/partition_root.cc
--- up/chromium/base/allocator/partition_allocator/partition_root.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/base/allocator/partition_allocator/partition_root.cc	2023-01-28 02:49:20.739538663 +0000
@@ -2,6 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#pragma clang diagnostic ignored "-Wmisleading-indentation"
 #include "base/allocator/partition_allocator/partition_root.h"
 
 #include <cstdint>
diff -r -u --color up/chromium/base/base_switches.cc nw/chromium/base/base_switches.cc
--- up/chromium/base/base_switches.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/base/base_switches.cc	2023-01-28 02:49:20.771538993 +0000
@@ -186,4 +186,5 @@
 const char kSchedulerBoostUrgent[] = "scheduler-boost-urgent";
 #endif
 
+const char kNWJS[] = "nwjs";
 }  // namespace switches
diff -r -u --color up/chromium/base/base_switches.h nw/chromium/base/base_switches.h
--- up/chromium/base/base_switches.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/base/base_switches.h	2023-01-28 02:49:20.771538993 +0000
@@ -70,6 +70,7 @@
 extern const char kSchedulerBoostUrgent[];
 #endif
 
+extern const char kNWJS[];
 }  // namespace switches
 
 #endif  // BASE_BASE_SWITCHES_H_
diff -r -u --color up/chromium/base/command_line.cc nw/chromium/base/command_line.cc
--- up/chromium/base/command_line.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/base/command_line.cc	2023-01-28 02:49:20.771538993 +0000
@@ -156,7 +156,51 @@
 
   return out;
 }
-#endif  // BUILDFLAG(IS_WIN)
+#else
+// see the similar code in base/command_line.cc
+std::string QuoteForCommandLineToArgv(const std::string& arg) {
+  std::string quotable_chars(" \\\"");
+  if (arg.find_first_of(quotable_chars) == std::string::npos) {
+    // No quoting necessary.
+    return arg;
+  }
+
+  std::string out;
+  out.push_back('"');
+  for (size_t i = 0; i < arg.size(); ++i) {
+    if (arg[i] == '\\') {
+      // Find the extent of this run of backslashes.
+      size_t start = i, end = start + 1;
+      for (; end < arg.size() && arg[end] == '\\'; ++end) {}
+      size_t backslash_count = end - start;
+
+      // Backslashes are escapes only if the run is followed by a
+      // double quote.
+      // Since we also will end the string with a double quote, we
+      // escape for
+      // either a double quote or the end of the string.
+      if (end == arg.size() || arg[end] == '"') {
+        // To quote, we need to output 2x as many backslashes.
+        backslash_count *= 2;
+      }
+      for (size_t j = 0; j < backslash_count; ++j)
+        out.push_back('\\');
+
+      // Advance i to one before the end to balance i++ in loop.
+      i = end - 1;
+    } else if (arg[i] == '"') {
+      out.push_back('\\');
+      out.push_back('"');
+    } else {
+      out.push_back(arg[i]);
+    }
+  }
+  out.push_back('"');
+
+  return out;
+}
+
+#endif
 
 }  // namespace
 
@@ -167,30 +211,85 @@
   g_duplicate_switch_handler = new_duplicate_switch_handler.release();
 }
 
-CommandLine::CommandLine(NoProgram no_program) : argv_(1), begin_args_(1) {}
+CommandLine::CommandLine(NoProgram no_program)
+    : argv_(1),
+      begin_args_(1),
+      argc0_(0), argv0_(NULL) {
+}
 
 CommandLine::CommandLine(const FilePath& program)
     : argv_(1),
-      begin_args_(1) {
+      begin_args_(1),
+      argc0_(0), argv0_(NULL) {
   SetProgram(program);
 }
 
 CommandLine::CommandLine(int argc, const CommandLine::CharType* const* argv)
-    : argv_(1), begin_args_(1) {
+    : argv_(1),
+      begin_args_(1),
+      argc0_(0), argv0_(NULL) {
   InitFromArgv(argc, argv);
 }
 
 CommandLine::CommandLine(const StringVector& argv)
     : argv_(1),
-      begin_args_(1) {
+      begin_args_(1),
+      argc0_(0), argv0_(NULL) {
   InitFromArgv(argv);
 }
 
-CommandLine::CommandLine(const CommandLine& other) = default;
+CommandLine::CommandLine(const CommandLine& other)
+    : argv_(other.argv_),
+      original_argv_(other.original_argv_),
+      switches_(other.switches_),
+      begin_args_(other.begin_args_),
+      argc0_(other.argc0_), argv0_(nullptr) {
+
+#if defined(OS_WIN)
+  if (other.argv0_) {
+    argv0_ = new char*[argc0_ + 1];
+    for (int i = 0; i < argc0_; ++i) {
+      argv0_[i] = new char[strlen(other.argv0_[i]) + 1];
+      strcpy(argv0_[i], other.argv0_[i]);
+    }
+    argv0_[argc0_] = NULL;
+  }
+#else
+  argv0_ = other.argv0_;
+#endif
+}
 
-CommandLine& CommandLine::operator=(const CommandLine& other) = default;
+CommandLine& CommandLine::operator=(const CommandLine& other) {
+  argv_ = other.argv_;
+  original_argv_ = other.original_argv_;
+  switches_ = other.switches_;
+  begin_args_ = other.begin_args_;
+#if defined(OS_WIN)
+  if (other.argv0_) {
+    argc0_ = other.argc0_;
+    argv0_ = new char*[argc0_ + 1];
+    for (int i = 0; i < argc0_; ++i) {
+      argv0_[i] = new char[strlen(other.argv0_[i]) + 1];
+      strcpy(argv0_[i], other.argv0_[i]);
+    }
+    argv0_[argc0_] = NULL;
+  }
+#else
+  argv0_ = other.argv0_;
+#endif
+  return *this;
+}
 
-CommandLine::~CommandLine() = default;
+CommandLine::~CommandLine() {
+#if defined(OS_WIN)
+  if (!argv0_)
+    return;
+  for (int i = 0; i < argc0_; i++) {
+    delete[] argv0_[i];
+  }
+  delete[] argv0_;
+#endif
+}
 
 #if BUILDFLAG(IS_WIN)
 // static
@@ -264,12 +363,47 @@
 void CommandLine::InitFromArgv(int argc,
                                const CommandLine::CharType* const* argv) {
   StringVector new_argv;
+  argc0_ = argc;
+#if !defined(OS_WIN)
+  argv0_ = (char**)argv;
+#else
+  argv0_ = new char*[argc + 1];
+  for (int i = 0; i < argc; ++i) {
+    std::string str(base::WideToUTF8(argv[i]));
+    argv0_[i] = new char[str.length() + 1];
+    strcpy(argv0_[i], str.c_str());
+  }
+  argv0_[argc] = NULL;
+#endif
   for (int i = 0; i < argc; ++i)
     new_argv.push_back(argv[i]);
   InitFromArgv(new_argv);
 }
 
 void CommandLine::InitFromArgv(const StringVector& argv) {
+#if !defined(OS_MAC)
+  original_argv_ = argv;
+#else
+  for (size_t index = 0; index < argv.size(); ++index) {
+    if (argv[index].compare(0, strlen("--psn_"), "--psn_") != 0 &&
+        argv[index].compare(0, strlen("-psn_"), "-psn_") != 0) {
+      original_argv_.push_back(argv[index]);
+    }
+  }
+#endif
+
+#if defined(OS_WIN)
+  int argc = argv.size();
+  argv0_ = new char*[argc + 1];
+  for (int i = 0; i < argc; ++i) {
+    std::string str(base::WideToUTF8(argv[i]));
+    argv0_[i] = new char[str.length() + 1];
+    strcpy(argv0_[i], str.c_str());
+  }
+  argv0_[argc] = NULL;
+  argc0_ = argc;
+#endif
+
   argv_ = StringVector(1);
   switches_.clear();
   begin_args_ = 1;
@@ -448,6 +582,12 @@
   argv_.push_back(StringType(value));
 }
 
+#if defined(OS_MAC)
+void CommandLine::FixOrigArgv4Finder(const CommandLine::StringType& value) {
+  original_argv_.push_back(value);
+}
+#endif
+
 void CommandLine::AppendArguments(const CommandLine& other,
                                   bool include_program) {
   if (include_program)
@@ -567,12 +707,16 @@
 #if BUILDFLAG(IS_WIN)
         switch_value = QuoteForCommandLineToArgvW(
             switch_value, allow_unsafe_insert_sequences);
+#else
+        switch_value = QuoteForCommandLineToArgv(switch_value);
 #endif
         params.append(kSwitchValueSeparator + switch_value);
       }
     } else {
 #if BUILDFLAG(IS_WIN)
       arg = QuoteForCommandLineToArgvW(arg, allow_unsafe_insert_sequences);
+#else
+      arg = QuoteForCommandLineToArgv(arg);
 #endif
       params.append(arg);
     }
@@ -585,6 +729,8 @@
 #if BUILDFLAG(IS_WIN)
   string = QuoteForCommandLineToArgvW(string,
                                       /*allow_unsafe_insert_sequences=*/false);
+#else
+  string = QuoteForCommandLineToArgv(string);
 #endif
   StringType params(GetArgumentsString());
   if (!params.empty()) {
diff -r -u --color up/chromium/base/command_line.h nw/chromium/base/command_line.h
--- up/chromium/base/command_line.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/base/command_line.h	2023-01-28 02:49:20.771538993 +0000
@@ -145,6 +145,11 @@
 
   // Returns the original command line string as a vector of strings.
   const StringVector& argv() const { return argv_; }
+  int argc0() { return argc0_; }
+  char** argv0() { return argv0_; }
+
+  // Returns the original command line string as a vector of strings (keeps precedence).
+  const StringVector& original_argv() const { return original_argv_; }
 
   // Get and Set the program part of the command line string (the first item).
   FilePath GetProgram() const;
@@ -196,6 +201,10 @@
   void AppendArgPath(const FilePath& value);
   void AppendArgNative(StringPieceType value);
 
+#if defined(OS_MAC)
+  void FixOrigArgv4Finder(const StringType& value);
+#endif
+
   // Append the switches and arguments from another command line to this one.
   // If |include_program| is true, include |other|'s program as well.
   void AppendArguments(const CommandLine& other, bool include_program);
@@ -265,11 +274,17 @@
   // The argv array: { program, [(--|-|/)switch[=value]]*, [--], [argument]* }
   StringVector argv_;
 
+  // The argv array (precedence not messed).
+  StringVector original_argv_;
+
   // Parsed-out switch keys and values.
   SwitchMap switches_;
 
   // The index after the program and switches, any arguments start here.
   ptrdiff_t begin_args_;
+
+  int argc0_;
+  char** argv0_;
 };
 
 class BASE_EXPORT DuplicateSwitchHandler {
diff -r -u --color up/chromium/base/files/file_util_posix.cc nw/chromium/base/files/file_util_posix.cc
--- up/chromium/base/files/file_util_posix.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/base/files/file_util_posix.cc	2023-01-28 02:49:20.787539158 +0000
@@ -638,7 +638,7 @@
 #elif BUILDFLAG(GOOGLE_CHROME_BRANDING)
   StringPiece prefix = "com.google.Chrome";
 #else
-  StringPiece prefix = "org.chromium.Chromium";
+  StringPiece prefix = "io.nwjs";
 #endif
   return FilePath(StrCat({".", prefix, ".", identifier}));
 }
diff -r -u --color up/chromium/base/i18n/icu_util.cc nw/chromium/base/i18n/icu_util.cc
--- up/chromium/base/i18n/icu_util.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/base/i18n/icu_util.cc	2023-01-28 02:49:20.795539240 +0000
@@ -523,6 +523,28 @@
   return g_icudtl_pf;
 }
 
+const uint8_t* GetRawIcuMemory() {
+  CHECK(g_icudtl_mapped_file);
+  return g_icudtl_mapped_file->data();
+}
+
+bool InitializeICUFromRawMemory(const uint8_t* raw_memory) {
+#if !defined(COMPONENT_BUILD)
+#if DCHECK_IS_ON()
+  DCHECK(!g_check_called_once || !g_called_once);
+  g_called_once = true;
+#endif
+
+  UErrorCode err = U_ZERO_ERROR;
+  udata_setCommonData(const_cast<uint8_t*>(raw_memory), &err);
+  // Never try to load ICU data from files.
+  udata_setFileAccess(UDATA_ONLY_PACKAGES, &err);
+  return err == U_ZERO_ERROR;
+#else
+  return true;
+#endif
+}
+
 void ResetGlobalsForTesting() {
   g_icudtl_pf = kInvalidPlatformFile;
   g_icudtl_mapped_file = nullptr;
diff -r -u --color up/chromium/base/i18n/icu_util.h nw/chromium/base/i18n/icu_util.h
--- up/chromium/base/i18n/icu_util.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/base/i18n/icu_util.h	2023-01-28 02:49:20.795539240 +0000
@@ -49,6 +49,25 @@
     PlatformFile data_fd,
     const MemoryMappedFile::Region& data_region);
 
+// Returns a void pointer to the memory mapped ICU data file.
+//
+// There are cases on Android where we would be unsafely reusing a file
+// descriptor within the same process when initializing two copies of ICU from
+// different binaries in the same address space. This returns an unowned
+// pointer to the memory mapped icu data file; consumers copies of base must
+// not outlive the copy of base that owns the memory mapped file.
+BASE_I18N_EXPORT const uint8_t* GetRawIcuMemory();
+
+// Initializes ICU memory
+//
+// This does nothing in component builds; this initialization should only be
+// done in cases where there could be two copies of base in a single process in
+// non-component builds. (The big example is standalone service libraries: the
+// Service Manager will have a copy of base linked in, and the majority of
+// service libraries will have base linked in but in non-component builds,
+// these will be separate copies of base.)
+BASE_I18N_EXPORT bool InitializeICUFromRawMemory(const uint8_t* raw_memory);
+
 BASE_I18N_EXPORT void ResetGlobalsForTesting();
 
 #if BUILDFLAG(IS_FUCHSIA)
diff -r -u --color up/chromium/base/message_loop/message_pump.cc nw/chromium/base/message_loop/message_pump.cc
--- up/chromium/base/message_loop/message_pump.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/base/message_loop/message_pump.cc	2023-01-28 02:49:20.811539405 +0000
@@ -10,6 +10,7 @@
 #include "base/message_loop/message_pump_for_ui.h"
 #include "base/notreached.h"
 #include "build/build_config.h"
+#include "base/message_loop/message_pump_uv.h"
 
 #if BUILDFLAG(IS_APPLE)
 #include "base/message_loop/message_pump_mac.h"
@@ -58,6 +59,9 @@
       return std::make_unique<MessagePumpForUI>();
 #endif
 
+    case MessagePumpType::NODE:
+      return std::unique_ptr<MessagePump>(new MessagePumpUV());
+
     case MessagePumpType::IO:
       return std::make_unique<MessagePumpForIO>();
 
diff -r -u --color up/chromium/base/message_loop/message_pump_mac.h nw/chromium/base/message_loop/message_pump_mac.h
--- up/chromium/base/message_loop/message_pump_mac.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/base/message_loop/message_pump_mac.h	2023-01-28 02:49:20.811539405 +0000
@@ -156,7 +156,7 @@
   // Get the current mode mask from |enabled_modes_|.
   int GetModeMask() const;
 
- private:
+ protected:
   class ScopedModeEnabler;
 
   // The maximum number of run loop modes that can be monitored.
@@ -172,14 +172,16 @@
   // the instance method; the instance method returns true if it resignalled
   // |work_source_| to be called again from the loop.
   static void RunWorkSource(void* info);
-  bool RunWork();
+ protected:
+  virtual bool RunWork();
 
   // Perform idle-priority work.  This is normally called by PreWaitObserver,
   // but is also associated with |idle_work_source_|.  When this function
   // actually does perform idle work, it will resignal that source.  The
   // static method calls the instance method.
   static void RunIdleWorkSource(void* info);
-  void RunIdleWork();
+  virtual void RunIdleWork();
+  virtual void PreWaitObserverHook();
 
   // Perform work that may have been deferred because it was not runnable
   // within a nested run loop.  This is associated with
diff -r -u --color up/chromium/base/message_loop/message_pump_mac.mm nw/chromium/base/message_loop/message_pump_mac.mm
--- up/chromium/base/message_loop/message_pump_mac.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/base/message_loop/message_pump_mac.mm	2023-01-28 02:49:20.811539405 +0000
@@ -596,12 +596,16 @@
     // nesting-deferred work may have accumulated.  Schedule it for processing
     // if appropriate.
     self->MaybeScheduleNestingDeferredWork();
+    self->PreWaitObserverHook();
 
     // Notify the delegate that the loop is about to sleep.
     self->BeforeWait();
   });
 }
 
+void MessagePumpCFRunLoopBase::PreWaitObserverHook() {
+}
+
 // Called from the run loop.
 // static
 void MessagePumpCFRunLoopBase::AfterWaitObserver(CFRunLoopObserverRef observer,
diff -r -u --color up/chromium/base/message_loop/message_pump_type.h nw/chromium/base/message_loop/message_pump_type.h
--- up/chromium/base/message_loop/message_pump_type.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/base/message_loop/message_pump_type.h	2023-01-28 02:49:20.811539405 +0000
@@ -39,6 +39,7 @@
   // OSX and IOS.
   NS_RUNLOOP,
 #endif  // BUILDFLAG(IS_APPLE)
+  NODE,
 };
 
 }  // namespace base
Only in nw/chromium/base/message_loop: message_pump_uv.cc
Only in nw/chromium/base/message_loop: message_pump_uv.h
Only in nw/chromium/base/message_loop: message_pumpuv_mac.h
Only in nw/chromium/base/message_loop: message_pumpuv_mac.mm
diff -r -u --color up/chromium/base/native_library_posix.cc nw/chromium/base/native_library_posix.cc
--- up/chromium/base/native_library_posix.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/base/native_library_posix.cc	2023-01-28 02:49:20.819539487 +0000
@@ -32,7 +32,7 @@
   // please refer to the bug tracker.  Some useful bug reports to read include:
   // http://crbug.com/17943, http://crbug.com/17557, http://crbug.com/36892,
   // and http://crbug.com/40794.
-  int flags = RTLD_LAZY;
+  int flags = RTLD_LAZY | RTLD_GLOBAL;
 #if BUILDFLAG(IS_ANDROID) || !defined(RTLD_DEEPBIND)
   // Certain platforms don't define RTLD_DEEPBIND. Android dlopen() requires
   // further investigation, as it might vary across versions. Crash here to
diff -r -u --color up/chromium/base/process/launch_posix.cc nw/chromium/base/process/launch_posix.cc
--- up/chromium/base/process/launch_posix.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/base/process/launch_posix.cc	2023-01-28 02:49:20.827539572 +0000
@@ -458,6 +458,7 @@
 #ifndef PR_SET_NO_NEW_PRIVS
 #define PR_SET_NO_NEW_PRIVS 38
 #endif
+#if 0
     if (!options.allow_new_privs) {
       if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) && errno != EINVAL) {
         // Only log if the error is not EINVAL (i.e. not supported).
@@ -472,6 +473,7 @@
       }
     }
 #endif
+#endif
 
     if (current_directory != nullptr) {
       RAW_CHECK(chdir(current_directory) == 0);
diff -r -u --color up/chromium/base/test/test_message_loop.cc nw/chromium/base/test/test_message_loop.cc
--- up/chromium/base/test/test_message_loop.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/base/test/test_message_loop.cc	2023-01-28 02:49:20.887540206 +0000
@@ -19,6 +19,7 @@
     MessagePumpType type) {
   switch (type) {
     case MessagePumpType::DEFAULT:
+    case MessagePumpType::NODE:
       return test::SingleThreadTaskEnvironment::MainThreadType::DEFAULT;
     case MessagePumpType::IO:
       return test::SingleThreadTaskEnvironment::MainThreadType::IO;
diff -r -u --color up/chromium/base/threading/thread_restrictions.h nw/chromium/base/threading/thread_restrictions.h
--- up/chromium/base/threading/thread_restrictions.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/base/threading/thread_restrictions.h	2023-01-28 02:49:20.903540375 +0000
@@ -145,6 +145,7 @@
 namespace audio {
 class OutputDevice;
 }
+
 namespace blink {
 class CategorizedWorkerPoolImpl;
 class CategorizedWorkerPoolJob;
@@ -164,6 +165,16 @@
 class NonMainThreadImpl;
 }
 }  // namespace blink
+
+namespace extensions {
+class NwAppSetProxyConfigFunction;
+class ContentVerifier;
+}
+
+namespace nw {
+class Package;
+}
+
 namespace cc {
 class CompletionEvent;
 class TileTaskManagerImpl;
@@ -618,7 +629,7 @@
   friend bool chromeos::system::IsCoreSchedulingAvailable();
   friend int chromeos::system::NumberOfPhysicalCores();
   friend bool disk_cache::CleanupDirectorySync(const base::FilePath&);
-
+ public:
   ScopedAllowBlocking(const Location& from_here = Location::Current());
   ~ScopedAllowBlocking();
 
@@ -824,6 +835,7 @@
   friend class service_manager::ServiceProcessLauncher;
   friend class ui::WindowResizeHelperMac;    // http://crbug.com/902829
   friend class content::TextInputClientMac;  // http://crbug.com/121917
+  friend class extensions::NwAppSetProxyConfigFunction;
 
   ScopedAllowBaseSyncPrimitivesOutsideBlockingScope(
       const Location& from_here = Location::Current());
@@ -940,6 +952,9 @@
   friend class content::BrowserTestBase;
   friend class web::WebMainLoop;
 
+  friend class extensions::ContentVerifier;
+  friend class nw::Package;
+
   static void AllowBlocking() EMPTY_BODY_IF_DCHECK_IS_OFF;
   static void AllowBaseSyncPrimitives() EMPTY_BODY_IF_DCHECK_IS_OFF;
 };
Only in nw/chromium/build: common.gypi
diff -r -u --color up/chromium/build/config/BUILD.gn nw/chromium/build/config/BUILD.gn
--- up/chromium/build/config/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/build/config/BUILD.gn	2023-01-28 02:49:20.955540925 +0000
@@ -93,6 +93,10 @@
     defines += [ "OFFICIAL_BUILD" ]
   }
 
+  if (nwjs_sdk) {
+    defines += [ "NWJS_SDK" ]
+  }
+
   # ==============================================
   #   PLEASE DO NOT ADD MORE THINGS TO THIS LIST
   # ==============================================
diff -r -u --color up/chromium/build/config/BUILDCONFIG.gn nw/chromium/build/config/BUILDCONFIG.gn
--- up/chromium/build/config/BUILDCONFIG.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/build/config/BUILDCONFIG.gn	2023-01-28 02:49:20.955540925 +0000
@@ -135,6 +135,8 @@
   # set "is_official_build" to true for any build intended to ship to end-users.
   is_official_build = false
 
+  nwjs_sdk = true
+
   # Set to true when compiling with the Clang compiler.
   is_clang = current_os != "linux" ||
              (current_cpu != "s390x" && current_cpu != "s390" &&
diff -r -u --color up/chromium/build/config/compiler/BUILD.gn nw/chromium/build/config/compiler/BUILD.gn
--- up/chromium/build/config/compiler/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/build/config/compiler/BUILD.gn	2023-01-28 02:49:20.959540967 +0000
@@ -485,7 +485,9 @@
     #}
   }
 
-  if (use_icf && (!is_apple || use_lld)) {
+  if (is_linux && current_cpu == "x86") {
+    ldflags += [ "-Wl,--icf=none" ]
+  } else if (use_icf && (!is_apple || use_lld)) {
     ldflags += [ "-Wl,--icf=all" ]
   }
 
@@ -1563,6 +1565,9 @@
       # Disables.
       "-Wno-missing-field-initializers",  # "struct foo f = {0};"
       "-Wno-unused-parameter",  # Unused function parameters.
+      "-Wno-unused-private-field",
+      "-Wno-unused-const-variable",
+      "-Wno-unreachable-code",
     ]
 
     if (!is_nacl || is_nacl_saigo) {
@@ -1583,6 +1588,7 @@
       # which we no longer use. Check if it makes sense to remove
       # this as well. http://crbug.com/316352
       "-Wno-unneeded-internal-declaration",
+      "-Wno-unused-function",
     ]
 
     if (!is_nacl || is_nacl_saigo) {
@@ -1754,6 +1760,7 @@
     cflags += [
       "/wd4800",  # Disable warning when forcing value to bool.
       "/wd4267",  # TODO(jschuh): size_t to int.
+      "/wd4275",
     ]
   } else {
     # GCC may emit unsuppressible warnings so don't add -Werror for no chromium
diff -r -u --color up/chromium/build/config/compiler/compiler.gni nw/chromium/build/config/compiler/compiler.gni
--- up/chromium/build/config/compiler/compiler.gni	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/build/config/compiler/compiler.gni	2023-01-28 02:49:20.959540967 +0000
@@ -120,7 +120,7 @@
   # the crash dumps generated by Android's debuggerd are largely useless, and
   # having this additional mechanism to understand issues is particularly helpful
   # to WebView.
-  exclude_unwind_tables = is_official_build && !is_android
+  exclude_unwind_tables = true
 
   # Where to redirect clang crash diagnoses
   clang_diagnostic_dir =
diff -r -u --color up/chromium/build/config/dcheck_always_on.gni nw/chromium/build/config/dcheck_always_on.gni
--- up/chromium/build/config/dcheck_always_on.gni	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/build/config/dcheck_always_on.gni	2023-01-28 02:49:20.959540967 +0000
@@ -21,8 +21,8 @@
   # Other clients typically set this to false. If another client wants to use
   # the same default value as Chromium, we'd need to add a separate gclient
   # variable to replace build_with_chromium here.
-  dcheck_always_on =
-      (build_with_chromium && !is_official_build) || dcheck_is_configurable
+  dcheck_always_on = false
+      #(build_with_chromium && !is_official_build) || dcheck_is_configurable
 }
 
 declare_args() {
diff -r -u --color up/chromium/build/config/features.gni nw/chromium/build/config/features.gni
--- up/chromium/build/config/features.gni	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/build/config/features.gni	2023-01-28 02:49:20.959540967 +0000
@@ -28,7 +28,7 @@
   #
   # TODO(crbug.com/1314528): Remove chromecast-related conditions and force
   # builds to explicitly specify this.
-  proprietary_codecs = is_chrome_branded || is_castos || is_cast_android
+  proprietary_codecs = true
 
   # libudev usage. This currently only affects the content layer.
   use_udev = (is_linux && !is_castos) || is_chromeos
diff -r -u --color up/chromium/build/config/gcc/BUILD.gn nw/chromium/build/config/gcc/BUILD.gn
--- up/chromium/build/config/gcc/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/build/config/gcc/BUILD.gn	2023-01-28 02:49:20.963541009 +0000
@@ -67,10 +67,10 @@
     # Note: Android, Aix don't support rpath. Chromecast has its own logic for
     # setting the rpath in //build/config/chromecast.
     if (current_toolchain != default_toolchain || gcc_target_rpath == "") {
-      ldflags = [
+      #ldflags = [
         # Want to pass "\$". GN will re-escape as required for ninja.
-        "-Wl,-rpath=\$ORIGIN",
-      ]
+        #"-Wl,-rpath=\$ORIGIN/${rpath_link}",
+      #]
     } else {
       ldflags = [ "-Wl,-rpath=${gcc_target_rpath}" ]
     }
@@ -92,7 +92,12 @@
 # Settings for executables.
 config("executable_config") {
   configs = executable_and_shared_library_configs_
-  ldflags = [ "-pie" ]
+  if (shlib_subdir != ".") {
+      rpath_link = "${shlib_subdir}/"
+  } else {
+      rpath_link = "."
+  }
+  ldflags = [ "-pie", "-Wl,-rpath=\$ORIGIN/${rpath_link}" ]
   if (is_android) {
     ldflags += [
       "-Bdynamic",
@@ -113,5 +118,5 @@
 
 # Settings for shared libraries.
 config("shared_library_config") {
-  configs = executable_and_shared_library_configs_
+  #configs = executable_and_shared_library_configs_
 }
diff -r -u --color up/chromium/build/config/mac/BUILD.gn nw/chromium/build/config/mac/BUILD.gn
--- up/chromium/build/config/mac/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/build/config/mac/BUILD.gn	2023-01-28 02:49:20.963541009 +0000
@@ -84,6 +84,7 @@
 
       # Path for loading shared libraries for bundled binaries. Get back from
       # Binary.app/Contents/MacOS.
+      "-lc++abi",
       "-Wl,-rpath,@loader_path/../../..",
     ]
 
diff -r -u --color up/chromium/build/config/nacl/rules.gni nw/chromium/build/config/nacl/rules.gni
--- up/chromium/build/config/nacl/rules.gni	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/build/config/nacl/rules.gni	2023-01-28 02:49:20.963541009 +0000
@@ -69,8 +69,13 @@
       # Starts empty so the code below can use += everywhere.
       data = []
 
-      nmfflags +=
+      if (target_os == "linux") {
+        nmfflags +=
+          [ "--library-path=" + rebase_path("${root_out_dir}/lib", root_build_dir) ]
+      } else {
+        nmfflags +=
           [ "--library-path=" + rebase_path(root_out_dir, root_build_dir) ]
+      }
 
       # NOTE: There is no explicit dependency for the lib directory
       # (lib32 and lib64 for x86/x64) created in the product directory.
diff -r -u --color up/chromium/build/config/win/BUILD.gn nw/chromium/build/config/win/BUILD.gn
--- up/chromium/build/config/win/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/build/config/win/BUILD.gn	2023-01-28 02:49:20.967541052 +0000
@@ -72,7 +72,7 @@
 
   if (is_clang) {
     cflags += [
-      "/Zc:twoPhase",
+      #"/Zc:twoPhase",
 
       # Consistently use backslash as the path separator when expanding the
       # __FILE__ macro when targeting Windows regardless of the build
diff -r -u --color up/chromium/build/dotfile_settings.gni nw/chromium/build/dotfile_settings.gni
--- up/chromium/build/dotfile_settings.gni	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/build/dotfile_settings.gni	2023-01-28 02:49:20.967541052 +0000
@@ -7,6 +7,7 @@
 
 build_dotfile_settings = {
   exec_script_whitelist = [
+    "//content/nw/BUILD.gn",
     "//build/config/android/rules.gni",
     "//build/config/chromeos/rules.gni",
     "//build/config/compiler/BUILD.gn",
Only in nw/chromium/build: gyp_chromium
Only in nw/chromium/build: gyp_chromium.py
Only in nw/chromium/build: gyp_environment.py
diff -r -u --color up/chromium/build/toolchain/apple/toolchain.gni nw/chromium/build/toolchain/apple/toolchain.gni
--- up/chromium/build/toolchain/apple/toolchain.gni	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/build/toolchain/apple/toolchain.gni	2023-01-28 02:49:20.983541221 +0000
@@ -558,7 +558,9 @@
       # hardlink but ensure the file have distinct metadata (thus avoid the
       # error with ditto, see https://crbug.com/1042182).
       if (host_os == "mac") {
-        command = "rm -rf {{output}} && /bin/cp -Rc {{source}} {{output}}"
+        command =
+          "rm -rf {{output}} && cp -fRc {{source}} {{output}} 2>/dev/null " +
+          "|| (rm -rf {{output}} && cp -fR {{source}} {{output}})"
       } else {
         command = "rm -rf {{output}} && /bin/cp -Rl {{source}} {{output}}"
       }
diff -r -u --color up/chromium/build/toolchain/gcc_toolchain.gni nw/chromium/build/toolchain/gcc_toolchain.gni
--- up/chromium/build/toolchain/gcc_toolchain.gni	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/build/toolchain/gcc_toolchain.gni	2023-01-28 02:49:20.983541221 +0000
@@ -511,6 +511,9 @@
       default_output_extension = default_shlib_extension
 
       default_output_dir = "{{root_out_dir}}${default_shlib_subdir}"
+      if (shlib_subdir != ".") {
+        default_output_dir += "/$shlib_subdir"
+      }
 
       output_prefix = "lib"
 
@@ -592,6 +595,9 @@
       }
 
       default_output_dir = "{{root_out_dir}}${default_shlib_subdir}"
+      if (shlib_subdir != ".") {
+        default_output_dir += "/$shlib_subdir"
+      }
 
       output_prefix = "lib"
 
diff -r -u --color up/chromium/build/toolchain/toolchain.gni nw/chromium/build/toolchain/toolchain.gni
--- up/chromium/build/toolchain/toolchain.gni	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/build/toolchain/toolchain.gni	2023-01-28 02:49:20.987541263 +0000
@@ -36,6 +36,22 @@
   clang_version = "16.0.0"
 }
 
+# Subdirectory within root_out_dir for shared library files.
+# TODO(agrieve): GYP sets this to "lib" for Linux & Android, but this won't work
+#     in GN until support for loadable_module() is added.
+#     See: https://codereview.chromium.org/1236503002/
+if (is_linux) {
+  shlib_subdir = "lib"
+} else {
+  shlib_subdir = "."
+}
+
+# Root out dir for shared library files.
+root_shlib_dir = root_out_dir
+if (shlib_subdir != ".") {
+  root_shlib_dir += "/$shlib_subdir"
+}
+
 # Extension for shared library files (including leading dot).
 if (is_apple) {
   shlib_extension = ".dylib"
@@ -58,12 +74,6 @@
   shlib_prefix = ""
 }
 
-# Directory for shared library files.
-if (is_fuchsia) {
-  shlib_subdir = "/lib"
-} else {
-  shlib_subdir = ""
-}
 
 # While other "tool"s in a toolchain are specific to the target of that
 # toolchain, the "stamp" and "copy" tools are really generic to the host;
Only in nw/chromium/build/util: version.gypi
diff -r -u --color up/chromium/build/win/reorder-imports.py nw/chromium/build/win/reorder-imports.py
--- up/chromium/build/win/reorder-imports.py	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/build/win/reorder-imports.py	2023-01-28 02:49:20.987541263 +0000
@@ -25,8 +25,8 @@
   # correct executable in the first place, so that this script
   # only needs to verify that and not write a whole new exe.
 
-  input_image = os.path.join(input_dir, 'chrome.exe')
-  output_image = os.path.join(output_dir, 'chrome.exe')
+  input_image = os.path.join(input_dir, 'nw.exe')
+  output_image = os.path.join(output_dir, 'nw.exe')
 
   # pefile mmap()s the whole executable, and then parses parts of
   # it into python data structures for ease of processing.
@@ -48,8 +48,8 @@
 
   found_elf = False
   for i, peimport in enumerate(pe.DIRECTORY_ENTRY_IMPORT):
-    if peimport.dll.lower() == b'chrome_elf.dll':
-      assert not found_elf, 'only one chrome_elf.dll import expected'
+    if peimport.dll.lower() == b'nw_elf.dll':
+      assert not found_elf, 'only one nw_elf.dll import expected'
       found_elf = True
       if i > 0:
         swap = pe.DIRECTORY_ENTRY_IMPORT[0]
@@ -70,11 +70,11 @@
             swap.struct.Name, peimport.struct.Name
         peimport.struct.FirstThunk, swap.struct.FirstThunk = \
             swap.struct.FirstThunk, peimport.struct.FirstThunk
-  assert found_elf, 'chrome_elf.dll import not found'
+  assert found_elf, 'nw_elf.dll import not found'
 
   pe.write(filename=output_image)
 
-  for fname in glob.iglob(os.path.join(input_dir, 'chrome.exe.*')):
+  for fname in glob.iglob(os.path.join(input_dir, 'nw.exe.*')):
     shutil.copy(fname, os.path.join(output_dir, os.path.basename(fname)))
   return 0
 
@@ -82,9 +82,9 @@
 def main(argv):
   usage = 'reorder_imports.py -i <input_dir> -o <output_dir> -a <target_arch>'
   parser = optparse.OptionParser(usage=usage)
-  parser.add_option('-i', '--input', help='reorder chrome.exe in DIR',
+  parser.add_option('-i', '--input', help='reorder nw.exe in DIR',
       metavar='DIR')
-  parser.add_option('-o', '--output', help='write new chrome.exe to DIR',
+  parser.add_option('-o', '--output', help='write new nw.exe to DIR',
       metavar='DIR')
   parser.add_option('-a', '--arch', help='architecture of build (optional)',
       default='ia32')
diff -r -u --color up/chromium/build_overrides/partition_alloc.gni nw/chromium/build_overrides/partition_alloc.gni
--- up/chromium/build_overrides/partition_alloc.gni	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/build_overrides/partition_alloc.gni	2023-01-28 02:49:20.991541305 +0000
@@ -41,7 +41,7 @@
 
 # - NaCl: No plans to support it.
 # - iOS: not done yet.
-_is_partition_alloc_everywhere_platform = !is_nacl && !is_ios
+_is_partition_alloc_everywhere_platform = is_win
 
 # Under Windows debug build, the allocator shim is not compatible with CRT.
 #     NaCl in particular does seem to link some binaries statically
diff -r -u --color up/chromium/buildtools/third_party/libc++/BUILD.gn nw/chromium/buildtools/third_party/libc++/BUILD.gn
--- up/chromium/buildtools/third_party/libc++/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/buildtools/third_party/libc++/BUILD.gn	2023-01-28 02:49:20.991541305 +0000
@@ -44,7 +44,11 @@
 if (libcxx_is_shared) {
   _libcxx_target_type = "shared_library"
 } else {
-  _libcxx_target_type = "source_set"
+  if (is_linux) {
+    _libcxx_target_type = "static_library"
+  } else {
+    _libcxx_target_type = "source_set"
+  }
 }
 target(_libcxx_target_type, "libc++") {
   # Most things that need to depend on libc++ should do so via the implicit
@@ -53,6 +57,7 @@
   visibility = [
     "//build/config:common_deps",
     "//third_party/catapult/devil:devil",
+    ":*",
   ]
   if (is_linux) {
     # This target packages libc++.so, so must have an explicit dependency on
@@ -211,3 +216,8 @@
     }
   }
 }
+
+static_library("libcpp") {
+   complete_static_lib = true
+   deps = [":libc++"]
+}
diff -r -u --color up/chromium/buildtools/third_party/libc++/__config_site nw/chromium/buildtools/third_party/libc++/__config_site
--- up/chromium/buildtools/third_party/libc++/__config_site	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/buildtools/third_party/libc++/__config_site	2023-01-28 02:49:20.991541305 +0000
@@ -11,8 +11,9 @@
 //    on Windows, the increase is great enough that we go above the 4GB size
 //    limit for PDBs (https://crbug.com/1327710#c5). To fix this, we set
 //    _LIBCPP_ABI_NAMESPACE to a shorter value.
-#define _LIBCPP_ABI_NAMESPACE Cr
-#define _LIBCPP_ABI_VERSION 2
+
+#define _LIBCPP_ABI_NAMESPACE __1
+// #define _LIBCPP_ABI_VERSION 2
 
 /* #undef _LIBCPP_ABI_FORCE_ITANIUM */
 /* #undef _LIBCPP_ABI_FORCE_MICROSOFT */
diff -r -u --color up/chromium/buildtools/third_party/libc++abi/BUILD.gn nw/chromium/buildtools/third_party/libc++abi/BUILD.gn
--- up/chromium/buildtools/third_party/libc++abi/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/buildtools/third_party/libc++abi/BUILD.gn	2023-01-28 02:49:20.995541348 +0000
@@ -4,7 +4,7 @@
 
 import("//build/config/c++/c++.gni")
 
-source_set("libc++abi") {
+static_library("libc++abi") {
   if (export_libcxxabi_from_executables) {
     visibility = [ "//build/config:executable_deps" ]
   } else {
diff -r -u --color up/chromium/cc/metrics/compositor_frame_reporting_controller.cc nw/chromium/cc/metrics/compositor_frame_reporting_controller.cc
--- up/chromium/cc/metrics/compositor_frame_reporting_controller.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/cc/metrics/compositor_frame_reporting_controller.cc	2023-01-28 02:49:21.019541601 +0000
@@ -136,10 +136,12 @@
   if (reporters_[PipelineStage::kBeginImplFrame]) {
     // We need to use .get() below because operator<< in std::unique_ptr is a
     // C++20 feature.
+#if 0
     DCHECK_NE(reporters_[PipelineStage::kBeginMainFrame].get(),
               reporters_[PipelineStage::kBeginImplFrame].get());
     DCHECK_EQ(reporters_[PipelineStage::kBeginImplFrame]->frame_id(),
               args.frame_id);
+#endif
     reporters_[PipelineStage::kBeginImplFrame]->StartStage(
         StageType::kSendBeginMainFrameToCommit, Now());
     AdvanceReporterStage(PipelineStage::kBeginImplFrame,
diff -r -u --color up/chromium/chrome/BUILD.gn nw/chromium/chrome/BUILD.gn
--- up/chromium/chrome/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/BUILD.gn	2023-01-28 02:49:21.071542151 +0000
@@ -77,10 +77,10 @@
 
     # See comment in chrome_dll.gypi in the hardlink_to_output
     # target for why this cannot be 'initial' like the DLL.
-    inputs = [ "$root_out_dir/initialexe/chrome.exe" ]
+    inputs = [ "$root_out_dir/initialexe/nw.exe" ]
     outputs = [
-      "$root_out_dir/chrome.exe",
-      "$root_out_dir/chrome.exe.pdb",
+      "$root_out_dir/nw.exe",
+      "$root_out_dir/nw.exe.pdb",
     ]
     args = [
       "-i",
@@ -141,9 +141,9 @@
     configs -= [ "//build/config/compiler:thinlto_optimize_default" ]
     configs += [ "//build/config/compiler:thinlto_optimize_max" ]
     if (is_win) {
-      output_name = "initialexe/chrome"
+      output_name = "initialexe/nw"
     } else {
-      output_name = "chrome"
+      output_name = "nw"
     }
 
     # Because the sources list varies so significantly per-platform, generally
@@ -259,13 +259,19 @@
     }
 
     if (is_linux || is_chromeos || is_fuchsia) {
+      if (!is_component_build) {
+        configs += [ "//build/config/gcc:rpath_for_built_shared_libraries" ]
+      }
+      if (is_component_build) {
       sources += [
         "app/chrome_dll_resource.h",
         "app/chrome_main.cc",
         "app/chrome_main_delegate.cc",
         "app/chrome_main_delegate.h",
       ]
+      }
 
+      if (is_component_build) {
       deps += [
         # On Linux, link the dependencies (libraries) that make up actual
         # Chromium functionality directly into the executable.
@@ -284,7 +290,13 @@
         # For headless mode.
         "//headless:headless_shell_lib",
       ]
+      } else {
+      deps += [
+        ":chrome_dll",
+      ]
+      }
 
+      if (is_component_build) {
       public_deps = [ "//chrome/common:buildflags" ]
 
       if (!is_fuchsia) {
@@ -294,6 +306,7 @@
 
         data_deps += [ "//components/crash/core/app:chrome_crashpad_handler" ]
       }
+      }
 
       ldflags = []
 
@@ -357,6 +370,10 @@
     # The step's output are needed at runtime, so we also need a data_dep.
     data_deps += [ ":packed_resources" ]
 
+    deps += [
+      "//content/nw:nw_base",
+    ]
+
     # ChromeOS by design is safe to have rpath=$ORIGIN. This simplifies shared
     # library usage.
     if (is_chromeos_ash && !is_component_build) {
@@ -374,61 +391,82 @@
   }
 }  # !is_android && !is_mac
 
-if (is_win) {
+if (is_win || (is_linux && !is_component_build)) {
   shared_library("chrome_dll") {
     configs += [ "//build/config/compiler:wexit_time_destructors" ]
     configs -= [ "//build/config/compiler:thinlto_optimize_default" ]
     configs += [ "//build/config/compiler:thinlto_optimize_max" ]
     defines = []
+    ldflags = []
 
     sources = [
-      "//base/win/dllmain.cc",
       "app/chrome_main.cc",
       "app/chrome_main_delegate.cc",
       "app/chrome_main_delegate.h",
     ]
 
-    output_name = "chrome"
+    if (is_win) {
+      sources += [ "//base/win/dllmain.cc" ]
+    }
+
+    output_name = "nw"
 
     deps = [
-      ":chrome_dll_manifest",
-      ":chrome_dll_version",
       ":dependencies",
       "//base/allocator:buildflags",
       "//chrome/app:chrome_dll_resources",
       "//chrome/app:command_ids",
-      "//chrome/app/theme:chrome_unscaled_resources",
-      "//chrome/chrome_elf",
       "//chrome/common:buildflags",
       "//chrome/common/profiler",
-      "//chrome/install_static:install_static_util",
-      "//chrome/install_static:secondary_module",
-      "//components/browser_watcher:stability_client",
-      "//components/crash/core/app",
-      "//components/policy:generated",
-      "//content/public/app",
-      "//crypto",
-      "//headless:headless_renderer",
-      "//headless:headless_shell_browser_lib",
-      "//net:net_resources",
-      "//ppapi/buildflags",
-      "//sandbox/win:sandbox",
-      "//third_party/cld_3/src/src:cld_3",
-      "//third_party/wtl",
-      "//ui/views",
     ]
 
+    # reverts commit a2052ac9b6ec749735f3d8e269bf5a5600935914
+    if (is_win) {
     configs += [ "//build/config/win:delayloads" ]
 
+    deps += [
+        ":chrome_dll_manifest",
+        ":chrome_dll_version",
+        "//chrome/app/theme:chrome_unscaled_resources",
+        "//chrome/install_static:install_static_util",
+        "//chrome/install_static:secondary_module",
+        "//chrome/chrome_elf",
+        "//components/browser_watcher:stability_client",
+        "//components/crash/core/app",
+        "//components/policy:generated",
+        "//crypto",
+        "//headless:headless_renderer",
+        "//headless:headless_shell_lib",
+        "//net:net_resources",
+        "//ppapi/buildflags",
+        "//sandbox/win:sandbox",
+        "//third_party/wtl",
+        "//ui/views",
+    ]
+
+    if (!is_component_build) {
+      deps += [
+        "//v8:v8_initializers",
+      ]
+    }
+
+    } #is_win
+
     if (use_aura) {
       deps += [ "//ui/compositor" ]
     }
+
+    if (is_linux) {
+        deps += [ "//headless:headless_shell_lib", ]
+    }
   }
 
+  if (is_win) {
   copy("copy_first_run") {
     sources = [ "app/FirstRun" ]
     outputs = [ "$root_out_dir/First Run" ]
   }
+  }
 } else if (is_mac) {
   chrome_helper_name = chrome_product_full_name + " Helper"
   chrome_framework_name = chrome_product_full_name + " Framework"
@@ -501,7 +539,7 @@
       "//chrome/common:version_header",
     ]
 
-    if (enable_stripping) {
+    if (false) {
       # At link time, preserve the global symbols specified in the .exports
       # file. All other global symbols will be marked as private. The default
       # //build/config/mac:strip_all config will then remove the remaining
@@ -758,7 +796,7 @@
         ]
       }
 
-      if (enable_stripping) {
+      if (false) {
         # At link time, preserve the global symbols specified in the .exports
         # file. All other global symbols will be marked as private. The default
         # //build/config/mac:strip_all config will then remove the remaining
@@ -956,7 +994,8 @@
         } else if (current_cpu == "x64") {
           sources += [ "$root_out_dir/nacl_irt_x86_64.nexe" ]
         }
-        public_deps += [ "//ppapi/native_client:irt" ]
+        sources += [ "$root_out_dir/pnacl" ]
+        public_deps += [ "//ppapi/native_client:irt", "//ppapi/native_client/src/untrusted/pnacl_support_extension:pnacl_support_extension" ]
       }
     }
   } else {
@@ -1102,6 +1141,8 @@
       ":chrome_framework_shared_library",
     ]
 
+    output_name = "nw"
+
     sources = [
       "app/chrome_crash_reporter_client.cc",
       "app/chrome_crash_reporter_client.h",
@@ -1126,7 +1167,8 @@
       "//components/policy:generated",
       "//content/public/app",
       "//headless:headless_shell_lib",
-      "//third_party/cld_3/src/src:cld_3",
+      #"//third_party/cld_3/src/src:cld_3",
+      "//ui/events:dom_keycode_converter",
     ]
 
     if (is_component_build) {
@@ -1140,6 +1182,7 @@
     ]
 
     configs += [ "//build/config/compiler:wexit_time_destructors" ]
+    configs += [ "//tools/v8_context_snapshot:use_v8_context_snapshot" ]
   }
 
   mac_framework_bundle("chrome_framework") {
@@ -1212,7 +1255,7 @@
       ldflags += [
         "-Wl,-install_name,@rpath/$chrome_framework_name.framework/$chrome_framework_name",
         "-Wl,-rpath,@loader_path/../../../../../..",
-        "-Wl,-reexport_library,libchrome_dll.dylib",
+        "-Wl,-reexport_library,libnw.dylib",
       ]
 
       data_deps = [ ":chrome_dll" ]
@@ -1225,7 +1268,7 @@
 
   # TOOD(crbug/1163903#c8) - thakis@ look into why profile and coverage
   # instrumentation adds these symbols in different orders
-  if (!is_component_build && chrome_pgo_phase != 1 && !using_sanitizer) {
+  if (false && !is_component_build && chrome_pgo_phase != 1 && !using_sanitizer) {
     action("verify_chrome_framework_order") {
       script = "//chrome/tools/build/mac/verify_order.py"
       stamp_file = "$target_out_dir/run_$target_name.stamp"
@@ -1296,6 +1339,7 @@
                rebase_path(get_label_info(dump_syms, "root_out_dir") + "/" +
                                get_label_info(dump_syms, "name"),
                            root_build_dir),
+               "-a", "x86_64",
                "-g",
                rebase_path(
                    "$root_out_dir/{{source_file_part}}.dSYM/Contents/Resources/DWARF/{{source_file_part}}",
@@ -1321,6 +1365,41 @@
       }
     }
 
+    action("nw_sym_archive") {
+      script = "//content/nw/tools/archive_symbols.py"
+
+      _syms = [
+        "$root_out_dir/$chrome_framework_name-$chrome_version_full.breakpad",
+        "$root_out_dir/$chrome_helper_name-$chrome_version_full.breakpad",
+        "$root_out_dir/$chrome_product_full_name-$chrome_version_full.breakpad",
+      ]
+
+      sources = _chrome_symbols_sources
+
+      _output = "$root_out_dir/nwjs.breakpad.tar"
+
+      outputs = [
+        _output,
+      ]
+
+      args = [ rebase_path(_output, root_out_dir) ] +
+             rebase_path(_syms, root_out_dir)
+
+      deps = [
+        ":chrome_app",
+        ":chrome_framework",
+        ":chrome_dump_syms",
+        "//components/crash/core/app:chrome_crashpad_handler",
+        "//third_party/angle:libEGL",
+        "//third_party/angle:libGLESv2",
+        "//third_party/crashpad/crashpad/handler:crashpad_handler",
+        "//third_party/swiftshader/src/Vulkan:swiftshader_libvulkan",
+      ]
+      foreach(helper_params, chrome_mac_helpers) {
+        deps += [ ":chrome_helper_app_${helper_params[0]}" ]
+      }
+    }
+
     action("chrome_dsym_archive") {
       script = "//chrome/tools/build/mac/archive_symbols.py"
 
@@ -1563,10 +1642,10 @@
 
     files_to_hash = [
       "resources.pak",
-      "chrome_100_percent.pak",
+      "nw_100_percent.pak",
     ]
     if (enable_hidpi) {
-      files_to_hash += [ "chrome_200_percent.pak" ]
+      files_to_hash += [ "nw_200_percent.pak" ]
     }
   }
 }
@@ -1723,13 +1802,13 @@
       }
     }
     extract_symbols("chrome_symbols") {
-      binary = "$root_out_dir/chrome"
+      binary = "$root_out_dir/nw"
 
       if (current_cpu == "x86") {
         # GYP used "ia32" so keep that naming for back-compat.
-        symbol_file = "$root_out_dir/chrome.breakpad.ia32"
+        symbol_file = "$root_out_dir/nw.breakpad.ia32"
       } else {
-        symbol_file = "$root_out_dir/chrome.breakpad.$current_cpu"
+        symbol_file = "$root_out_dir/nw.breakpad.$current_cpu"
       }
 
       deps = [ ":chrome" ]
diff -r -u --color up/chromium/chrome/app/app-Info.plist nw/chromium/chrome/app/app-Info.plist
--- up/chromium/chrome/app/app-Info.plist	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/app/app-Info.plist	2023-01-28 02:49:21.383545449 +0000
@@ -241,8 +241,6 @@
 	<string>1</string>
 	<key>LSMinimumSystemVersion</key>
 	<string>${CHROMIUM_MIN_SYSTEM_VERSION}</string>
-	<key>LSRequiresNativeExecution</key>
-	<true/>
 	<key>NSPrincipalClass</key>
 	<string>BrowserCrApplication</string>
 	<key>NSSupportsAutomaticGraphicsSwitching</key>
@@ -259,7 +257,7 @@
 				<string>public.data</string>
 			</array>
 			<key>UTTypeDescription</key>
-			<string>Chromium Extra</string>
+			<string>NWJS Extra</string>
 			<key>UTTypeIdentifier</key>
 			<string>org.chromium.extension</string>
 			<key>UTTypeTagSpecification</key>
diff -r -u --color up/chromium/chrome/app/chrome_crash_reporter_client.cc nw/chromium/chrome/app/chrome_crash_reporter_client.cc
--- up/chromium/chrome/app/chrome_crash_reporter_client.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/app/chrome_crash_reporter_client.cc	2023-01-28 02:49:21.387545491 +0000
@@ -24,7 +24,7 @@
 #include "components/crash/core/common/crash_keys.h"
 #include "content/public/common/content_switches.h"
 
-#if BUILDFLAG(IS_POSIX) && !BUILDFLAG(IS_MAC)
+#if BUILDFLAG(IS_POSIX)
 #include "components/upload_list/crash_upload_list.h"
 #include "components/version_info/version_info.h"
 #include "components/version_info/version_info_values.h"
@@ -96,7 +96,7 @@
 }
 #endif
 
-#if BUILDFLAG(IS_POSIX) && !BUILDFLAG(IS_MAC)
+#if BUILDFLAG(IS_POSIX)// && !BUILDFLAG(IS_MAC)
 void ChromeCrashReporterClient::GetProductNameAndVersion(
     const char** product_name,
     const char** version) {
@@ -110,13 +110,13 @@
   *product_name = "Chrome_Lacros";
 #else  // BUILDFLAG(IS_ANDROID)
 #if !defined(ADDRESS_SANITIZER)
-  *product_name = "Chrome_Linux";
+  *product_name = product_name_.c_str();
 #else
   *product_name = "Chrome_Linux_ASan";
 #endif
 #endif
 
-  *version = PRODUCT_VERSION;
+  *version = product_version_.c_str();
 }
 
 void ChromeCrashReporterClient::GetProductNameAndVersion(
@@ -131,6 +131,7 @@
   *channel = chrome::GetChannelName(chrome::WithExtendedStable(true));
 }
 
+#if !BUILDFLAG(IS_MAC)
 base::FilePath ChromeCrashReporterClient::GetReporterLogFilename() {
   return base::FilePath(CrashUploadList::kReporterLogFilename);
 }
@@ -138,6 +139,7 @@
 bool ChromeCrashReporterClient::GetShouldDumpLargerDumps() {
   return chrome::GetChannel() != version_info::Channel::STABLE;
 }
+#endif
 #endif  // BUILDFLAG(IS_POSIX) && !BUILDFLAG(IS_MAC)
 
 bool ChromeCrashReporterClient::GetCrashDumpLocation(
@@ -155,11 +157,14 @@
 #endif  // BUILDFLAG(IS_MAC) || BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
 
 bool ChromeCrashReporterClient::IsRunningUnattended() {
-  std::unique_ptr<base::Environment> env(base::Environment::Create());
-  return env->HasVar(env_vars::kHeadless);
+  // std::unique_ptr<base::Environment> env(base::Environment::Create());
+  // return env->HasVar(env_vars::kHeadless);
+  return !enable_upload_;
 }
 
 bool ChromeCrashReporterClient::GetCollectStatsConsent() {
+  return true;
+#if 0
 #if BUILDFLAG(GOOGLE_CHROME_BRANDING)
   bool is_official_chrome_build = true;
 #else
@@ -196,6 +201,7 @@
           << " so returning that";
   return settings_consent;
 #endif  // BUILDFLAG(IS_ANDROID)
+#endif // 0
 }
 
 #if BUILDFLAG(IS_ANDROID)
diff -r -u --color up/chromium/chrome/app/chrome_crash_reporter_client.h nw/chromium/chrome/app/chrome_crash_reporter_client.h
--- up/chromium/chrome/app/chrome_crash_reporter_client.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/app/chrome_crash_reporter_client.h	2023-01-28 02:49:21.387545491 +0000
@@ -36,16 +36,18 @@
       const std::string& client_guid) override;
 #endif
 
-#if BUILDFLAG(IS_POSIX) && !BUILDFLAG(IS_MAC)
+#if BUILDFLAG(IS_POSIX) //&& !BUILDFLAG(IS_MAC)
   void GetProductNameAndVersion(const char** product_name,
                                 const char** version) override;
   void GetProductNameAndVersion(std::string* product_name,
                                 std::string* version,
                                 std::string* channel) override;
+#if !BUILDFLAG(IS_MAC)
   base::FilePath GetReporterLogFilename() override;
 
   bool GetShouldDumpLargerDumps() override;
 #endif
+#endif
 
   bool GetCrashDumpLocation(base::FilePath* crash_dir) override;
 
diff -r -u --color up/chromium/chrome/app/chrome_crash_reporter_client_win.cc nw/chromium/chrome/app/chrome_crash_reporter_client_win.cc
--- up/chromium/chrome/app/chrome_crash_reporter_client_win.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/app/chrome_crash_reporter_client_win.cc	2023-01-28 02:49:21.387545491 +0000
@@ -47,10 +47,12 @@
 
   std::wstring process_type = install_static::GetSwitchValueFromCommandLine(
       ::GetCommandLine(), install_static::kProcessType);
+  std::wstring disable_crash_handler = install_static::GetSwitchValueFromCommandLine(
+    ::GetCommandLine(), L"disable-crash-handler");
   // Don't set up Crashpad crash reporting in the Crashpad handler itself, nor
   // in the fallback crash handler for the Crashpad handler process.
   if (process_type != install_static::kCrashpadHandler &&
-      process_type != install_static::kFallbackHandler) {
+      process_type != install_static::kFallbackHandler && disable_crash_handler != L"true") {
     crash_reporter::SetCrashReporterClient(instance);
 
     std::wstring user_data_dir;
@@ -171,11 +173,11 @@
 }
 
 bool ChromeCrashReporterClient::IsRunningUnattended() {
-  return install_static::HasEnvironmentVariable(install_static::kHeadless);
+  return !enable_upload_;
 }
 
 bool ChromeCrashReporterClient::GetCollectStatsConsent() {
-  return install_static::GetCollectStatsConsent();
+  return true; // install_static::GetCollectStatsConsent();
 }
 
 bool ChromeCrashReporterClient::GetCollectStatsInSample() {
diff -r -u --color up/chromium/chrome/app/chrome_dll.rc nw/chromium/chrome/app/chrome_dll.rc
--- up/chromium/chrome/app/chrome_dll.rc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/app/chrome_dll.rc	2023-01-28 02:49:21.387545491 +0000
@@ -69,7 +69,6 @@
     "T",            IDC_FOCUS_TOOLBAR,          VIRTKEY, SHIFT, ALT
     VK_BACK,        IDC_FORWARD,                VIRTKEY, SHIFT
     VK_RIGHT,       IDC_FORWARD,                VIRTKEY, ALT
-    VK_F11,         IDC_FULLSCREEN,             VIRTKEY
     VK_F1,          IDC_HELP_PAGE_VIA_KEYBOARD, VIRTKEY
     VK_HOME,        IDC_HOME,                   VIRTKEY, ALT
     "N",            IDC_NEW_INCOGNITO_WINDOW,   VIRTKEY, CONTROL, SHIFT
diff -r -u --color up/chromium/chrome/app/chrome_dll.ver nw/chromium/chrome/app/chrome_dll.ver
--- up/chromium/chrome/app/chrome_dll.ver	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/app/chrome_dll.ver	2023-01-28 02:49:21.387545491 +0000
@@ -1,2 +1,2 @@
-INTERNAL_NAME=chrome_dll
-ORIGINAL_FILENAME=chrome.dll
+INTERNAL_NAME=nw_dll
+ORIGINAL_FILENAME=nw.dll
diff -r -u --color up/chromium/chrome/app/chrome_exe.ver nw/chromium/chrome/app/chrome_exe.ver
--- up/chromium/chrome/app/chrome_exe.ver	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/app/chrome_exe.ver	2023-01-28 02:49:21.387545491 +0000
@@ -1,2 +1,2 @@
-INTERNAL_NAME=chrome_exe
-ORIGINAL_FILENAME=chrome.exe
+INTERNAL_NAME=nw_exe
+ORIGINAL_FILENAME=nw.exe
diff -r -u --color up/chromium/chrome/app/chrome_exe_main_mac.cc nw/chromium/chrome/app/chrome_exe_main_mac.cc
--- up/chromium/chrome/app/chrome_exe_main_mac.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/app/chrome_exe_main_mac.cc	2023-01-28 02:49:21.387545491 +0000
@@ -197,7 +197,7 @@
            rel_path);
 
   void* library =
-      dlopen(framework_path.get(), RTLD_LAZY | RTLD_LOCAL | RTLD_FIRST);
+      dlopen(framework_path.get(), RTLD_LAZY | RTLD_FIRST);
   if (!library) {
     FatalError("dlopen %s: %s.", framework_path.get(), dlerror());
   }
diff -r -u --color up/chromium/chrome/app/chrome_exe_main_win.cc nw/chromium/chrome/app/chrome_exe_main_win.cc
--- up/chromium/chrome/app/chrome_exe_main_win.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/app/chrome_exe_main_win.cc	2023-01-28 02:49:21.387545491 +0000
@@ -70,6 +70,7 @@
 // process) created before MainDllLoader changes the current working directory
 // to the browser's version directory.
 void SetCwdForBrowserProcess() {
+#if 0
   if (!::IsBrowserProcess())
     return;
 
@@ -82,7 +83,9 @@
   base::SetCurrentDirectory(
       base::FilePath(base::FilePath::StringPieceType(&buffer[0], length))
           .DirName());
+#endif
 }
+#if 0
 
 bool IsFastStartSwitch(const std::string& command_line_switch) {
   return command_line_switch == switches::kProfileDirectory;
@@ -114,6 +117,7 @@
     return false;
   return chrome::AttemptToNotifyRunningChrome(chrome) == chrome::NOTIFY_SUCCESS;
 }
+#endif
 
 // Returns true if |command_line| contains a /prefetch:# argument where # is in
 // [1, 8].
@@ -229,8 +233,8 @@
     const uint8_t** chrome_100_pak,
     const uint8_t** chrome_200_pak) {
   *resources_pak = kSha256_resources_pak.data();
-  *chrome_100_pak = kSha256_chrome_100_percent_pak.data();
-  *chrome_200_pak = kSha256_chrome_200_percent_pak.data();
+  *chrome_100_pak = kSha256_nw_100_percent_pak.data();
+  *chrome_200_pak = kSha256_nw_200_percent_pak.data();
 }
 
 #if !defined(WIN_CONSOLE_APP)
@@ -282,7 +286,6 @@
 
   SetCwdForBrowserProcess();
   install_static::InitializeFromPrimaryModule();
-  SignalInitializeCrashReporting();
   if (IsBrowserProcess())
     chrome::DisableDelayLoadFailureHooksForMainExecutable();
 #if defined(ARCH_CPU_32_BITS)
@@ -325,9 +328,15 @@
          HasValidWindowsPrefetchArgument(*command_line));
 
   if (process_type == crash_reporter::switches::kCrashpadHandler) {
+    // HACK: Let Windows know that we have started.  This is needed to suppress
+    // the IDC_APPSTARTING cursor from being displayed for a prolonged period
+    // while a subprocess is starting. NWJS#4685
+    PostThreadMessage(GetCurrentThreadId(), WM_NULL, 0, 0);
+    MSG msg;
+    PeekMessage(&msg, NULL, 0, 0, PM_REMOVE);
+
     // Check if we should monitor the exit code of this process
     std::unique_ptr<browser_watcher::ExitCodeWatcher> exit_code_watcher;
-
     crash_reporter::SetupFallbackCrashHandling(*command_line);
     // no-periodic-tasks is specified for self monitoring crashpad instances.
     // This is to ensure we are a crashpad process monitoring the browser
@@ -380,8 +389,10 @@
   // The exit manager is in charge of calling the dtors of singletons.
   base::AtExitManager exit_manager;
 
+#if 0 //FIXME(nwjs)
   if (AttemptFastNotify(*command_line))
     return 0;
+#endif
 
   RemoveAppCompatFlagsEntry();
 
diff -r -u --color up/chromium/chrome/app/chrome_main.cc nw/chromium/chrome/app/chrome_main.cc
--- up/chromium/chrome/app/chrome_main.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/app/chrome_main.cc	2023-01-28 02:49:21.387545491 +0000
@@ -106,7 +106,7 @@
   auto crash_on_detach_resetter = base::ScopedClosureRunner(
       base::BindOnce(&base::win::SetShouldCrashOnProcessDetach,
                      base::win::ShouldCrashOnProcessDetach()));
-  base::win::SetShouldCrashOnProcessDetach(true);
+  base::win::SetShouldCrashOnProcessDetach(false);
   base::win::SetAbortBehaviorForCrashReporting();
   params.instance = instance;
   params.sandbox_info = sandbox_info;
diff -r -u --color up/chromium/chrome/app/chrome_main_delegate.cc nw/chromium/chrome/app/chrome_main_delegate.cc
--- up/chromium/chrome/app/chrome_main_delegate.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/app/chrome_main_delegate.cc	2023-01-28 02:49:21.387545491 +0000
@@ -2,8 +2,12 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "chrome/common/chrome_constants.h"
 #include "chrome/app/chrome_main_delegate.h"
 
+#include "chrome/chrome_elf/chrome_elf_main.h"
+#include "base/files/file_util.h"
+
 #include <stddef.h>
 
 #include <string>
@@ -98,6 +102,7 @@
 #include "ui/base/resource/scoped_startup_resource_bundle.h"
 #include "ui/base/ui_base_switches.h"
 
+#include "content/nw/src/nw_base.h"
 #if BUILDFLAG(IS_WIN)
 #include <malloc.h>
 
@@ -232,6 +237,16 @@
 #include "ui/base/resource/data_pack_with_resource_sharing_lacros.h"
 #endif
 
+#include "third_party/node-nw/src/node_webkit.h"
+#include "third_party/zlib/google/zip_reader.h"
+#include "base/native_library.h"
+#include "base/strings/utf_string_conversions.h"
+#if defined(OS_MAC)
+#include "base/mac/bundle_locations.h"
+#include "base/strings/sys_string_conversions.h"
+#endif
+
+
 base::LazyInstance<ChromeContentGpuClient>::DestructorAtExit
     g_chrome_content_gpu_client = LAZY_INSTANCE_INITIALIZER;
 base::LazyInstance<ChromeContentRendererClient>::DestructorAtExit
@@ -248,6 +263,13 @@
 const size_t ChromeMainDelegate::kNonWildcardDomainNonPortSchemesSize =
     std::size(kNonWildcardDomainNonPortSchemes);
 
+#if defined(COMPONENT_BUILD)
+CONTENT_EXPORT NodeStartFn g_node_start_fn;
+#else
+extern NodeStartFn g_node_start_fn;
+#endif
+SetBlobPathFn g_set_blob_path_fn = nullptr;
+
 namespace {
 
 #if BUILDFLAG(IS_CHROMEOS_LACROS)
@@ -516,7 +538,7 @@
 
 // Initializes the user data dir. Must be called before InitializeLocalState().
 void InitializeUserDataDir(base::CommandLine* command_line) {
-#if BUILDFLAG(IS_WIN)
+#if 0
   // Reach out to chrome_elf for the truth on the user data directory.
   // Note that in tests, this links to chrome_elf_test_stubs.
   wchar_t user_data_dir_buf[MAX_PATH], invalid_user_data_dir_buf[MAX_PATH];
@@ -553,10 +575,15 @@
     }
   }
 #endif  // BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
-#if BUILDFLAG(IS_MAC)
+#if BUILDFLAG(IS_MAC) || BUILDFLAG(IS_WIN)
   policy::path_parser::CheckUserDataDirPolicy(&user_data_dir);
 #endif  // BUILDFLAG(IS_MAC)
 
+  // On Windows, trailing separators leave Chrome in a bad state.
+  // See crbug.com/464616.
+  if (user_data_dir.EndsWithSeparator())
+    user_data_dir = user_data_dir.StripTrailingSeparators();
+
   const bool specified_directory_was_invalid =
       !user_data_dir.empty() &&
       !base::PathService::OverrideAndCreateIfNeeded(chrome::DIR_USER_DATA,
@@ -587,7 +614,7 @@
 
   // Append the fallback user data directory to the commandline. Otherwise,
   // child or service processes will attempt to use the invalid directory.
-  if (specified_directory_was_invalid)
+  //if (specified_directory_was_invalid)
     command_line->AppendSwitchPath(switches::kUserDataDir, user_data_dir);
 #endif  // BUILDFLAG(IS_WIN)
 }
@@ -992,7 +1019,7 @@
   ash::BootTimesRecorder::Get()->SaveChromeMainStats();
 #endif
 
-  const base::CommandLine& command_line =
+  base::CommandLine& command_line =
       *base::CommandLine::ForCurrentProcess();
 
   // Only allow disabling web security via the command-line flag if the user has
@@ -1034,6 +1061,37 @@
 
   content::Profiling::ProcessStarted();
 
+  const base::CommandLine::StringVector& args = command_line.GetArgs();
+  if (args.size() > 0) {
+    zip::ZipReader reader;
+    base::FilePath fp(args[0]);
+    //LOG(WARNING) << "final extension: " << fp.FinalExtension();
+    if (!command_line.HasSwitch(switches::kProcessType) && fp.FinalExtension() == FILE_PATH_LITERAL(".js") &&
+        base::PathExists(fp) && !base::DirectoryExists(fp) && !reader.Open(fp)) {
+      base::NativeLibraryLoadError error;
+#if defined(OS_MAC)
+      base::FilePath node_dll_path = base::mac::FrameworkBundlePath().Append(base::FilePath::FromUTF8Unsafe(base::GetNativeLibraryName("node")));
+      base::ScopedCFTypeRef<CFStringRef> natives_file_name(base::SysUTF8ToCFStringRef(V8_CONTEXT_SNAPSHOT_FILENAME));
+      std::string blob_path = base::mac::PathForFrameworkBundleResource(natives_file_name).AsUTF8Unsafe();
+#else
+      base::FilePath node_dll_path = base::FilePath::FromUTF8Unsafe(base::GetNativeLibraryName("node"));
+#endif
+      base::NativeLibrary node_dll = base::LoadNativeLibrary(node_dll_path, &error);
+      if(!node_dll)
+        LOG(FATAL) << "Failed to load node library (error: " << error.ToString() << ")";
+      else {
+#if defined(OS_MAC)
+        g_set_blob_path_fn = (SetBlobPathFn)base::GetFunctionPointerFromNativeLibrary(node_dll, "g_set_blob_path");
+        g_set_blob_path_fn(blob_path.c_str());
+#endif
+        g_node_start_fn = (NodeStartFn)base::GetFunctionPointerFromNativeLibrary(node_dll, "g_node_start");
+        return g_node_start_fn(command_line.argc0(), command_line.argv0());
+      }
+      return 0;
+    }
+  }
+
+
   // Setup tracing sampler profiler as early as possible at startup if needed.
   // We pass in CreateCoreUnwindersFactory here since it lives in the chrome/
   // layer while TracingSamplerProfiler is outside of chrome/.
@@ -1220,6 +1278,26 @@
   // partially-initialized, which the TLS object is supposed to protect again.
   heap_profiling::InitTLSSlot();
 
+  std::wstring product_name, product_version;
+  std::string report_url;
+
+  nw::InitNWPackage();
+  std::string name = nw::package()->GetName();
+  std::string version;
+  product_name = std::wstring(name.begin(), name.end());
+  std::string* str = nw::package()->root()->FindString("version");
+  if (str)
+    version = *str;
+  product_version = std::wstring(version.begin(), version.end());
+#if defined(OS_WIN)
+  SignalInitializeCrashReporting(&product_name, &product_version);
+  str = nw::package()->root()->FindString("crash_report_url");
+  if (str) {
+    report_url = *str;
+    crash_reporter::CrashReporterClient* client = (crash_reporter::CrashReporterClient*)ElfGetReporterClient();
+    client->SetUploadDump(true);
+  }
+#endif
   return absl::nullopt;
 }
 
@@ -1294,7 +1372,39 @@
   ChromeCrashReporterClient::Create();
 #endif
 
+  std::string report_url;
+  std::string* str = nw::package()->root()->FindString("crash_report_url");
+  if (str) {
+    report_url = *str;
+#if !defined(OS_WIN)
+    crash_reporter::CrashReporterClient* client = crash_reporter::GetCrashReporterClient();
+    client->SetUploadDump(true);
+    client->product_name_ = nw::package()->GetName();
+    str = nw::package()->root()->FindString("version");
+    if (str)
+      client->product_version_ = *str;
+#endif
+  }
+
 #if BUILDFLAG(IS_MAC)
+  // On the Mac, the child executable lives at a predefined location within
+  // the app bundle's versioned directory.
+  std::string product_string;
+  str = nw::package()->root()->FindString("product_string");
+  if (str) {
+    product_string = *str;
+    std::string helperProcessExecutablePath = (product_string + " Helper.app/Contents/MacOS/" + product_string + " Helper");
+    base::PathService::Override(content::CHILD_PROCESS_EXE,
+                                chrome::GetFrameworkBundlePath()
+                                .Append("Helpers")
+                                .Append(helperProcessExecutablePath));
+  }else{
+    base::PathService::Override(content::CHILD_PROCESS_EXE,
+                                chrome::GetFrameworkBundlePath()
+                                .Append("Helpers")
+                                .Append(chrome::kHelperProcessExecutablePath));
+  }
+
   InitMacCrashReporter(command_line, process_type);
   SetUpInstallerPreferences(command_line);
 #endif
@@ -1361,7 +1471,7 @@
   }
 #endif  // BUILDFLAG(IS_CHROMEOS_LACROS)
 
-  // Register component_updater PathProvider after DIR_USER_DATA overridden by
+#if 1
   // command line flags. Maybe move the chrome PathProvider down here also?
   int alt_preinstalled_components_dir =
 #if BUILDFLAG(IS_CHROMEOS_ASH)
@@ -1372,6 +1482,7 @@
   component_updater::RegisterPathProvider(chrome::DIR_COMPONENTS,
                                           alt_preinstalled_components_dir,
                                           chrome::DIR_USER_DATA);
+#endif
 
 #if !BUILDFLAG(IS_ANDROID) && !BUILDFLAG(IS_WIN)
   // Android does InitLogging when library is loaded. Skip here.
@@ -1536,6 +1647,13 @@
   // line for crash reporting.
   crash_keys::SetCrashKeysFromCommandLine(command_line);
 
+#if 1 //!defined(OS_WIN)
+  if (!report_url.empty()) {
+    GURL url(report_url);
+    chrome_content_client_.SetNWReportURL(url);
+  }
+#endif
+
 #if BUILDFLAG(ENABLE_PDF)
   MaybePatchGdiGetFontData();
 #endif
diff -r -u --color up/chromium/chrome/app/chrome_main_mac.mm nw/chromium/chrome/app/chrome_main_mac.mm
--- up/chromium/chrome/app/chrome_main_mac.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/app/chrome_main_mac.mm	2023-01-28 02:49:21.387545491 +0000
@@ -20,20 +20,14 @@
 #include "content/public/common/content_paths.h"
 #include "content/public/common/content_switches.h"
 
+#include "content/nw/src/nw_base.h"
+
 void SetUpBundleOverrides() {
   @autoreleasepool {
     base::mac::SetOverrideFrameworkBundlePath(chrome::GetFrameworkBundlePath());
 
     NSBundle* base_bundle = chrome::OuterAppBundle();
     base::mac::SetBaseBundleID([[base_bundle bundleIdentifier] UTF8String]);
-
-    base::FilePath child_exe_path =
-        chrome::GetFrameworkBundlePath().Append("Helpers").Append(
-            chrome::kHelperProcessExecutablePath);
-
-    // On the Mac, the child executable lives at a predefined location within
-    // the app bundle's versioned directory.
-    base::PathService::Override(content::CHILD_PROCESS_EXE, child_exe_path);
   }
 }
 
diff -r -u --color up/chromium/chrome/app/chrome_version.rc.version nw/chromium/chrome/app/chrome_version.rc.version
--- up/chromium/chrome/app/chrome_version.rc.version	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/app/chrome_version.rc.version	2023-01-28 02:49:21.387545491 +0000
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 #include <verrsrc.h>
+#include "../../content/nw/src/nw_version.h"
 
 /////////////////////////////////////////////////////////////////////////////
 //
@@ -10,9 +11,9 @@
 //
 
 VS_VERSION_INFO VERSIONINFO
- FILEVERSION @MAJOR@,@MINOR@,@BUILD@,@PATCH@
- PRODUCTVERSION @MAJOR@,@MINOR@,@BUILD@,@PATCH@
  FILEFLAGSMASK 0x17L
+ FILEVERSION NW_MAJOR_VERSION,NW_MINOR_VERSION,NW_PATCH_VERSION
+ PRODUCTVERSION NW_MAJOR_VERSION,NW_MINOR_VERSION,NW_PATCH_VERSION
 #ifdef _DEBUG
  FILEFLAGS 0x1L
 #else
@@ -28,16 +29,15 @@
         BEGIN
             VALUE "CompanyName", "@COMPANY_FULLNAME@"
             VALUE "FileDescription", "@PRODUCT_FULLNAME@"
-            VALUE "FileVersion", "@MAJOR@.@MINOR@.@BUILD@.@PATCH@"
+            VALUE "FileVersion", NW_VERSION_STRING
             VALUE "InternalName", "@INTERNAL_NAME@"
             VALUE "LegalCopyright", "@COPYRIGHT@"
             VALUE "OriginalFilename", "@ORIGINAL_FILENAME@"
             VALUE "ProductName", "@PRODUCT_FULLNAME@"
-            VALUE "ProductVersion", "@MAJOR@.@MINOR@.@BUILD@.@PATCH@"
+            VALUE "ProductVersion", NW_VERSION_STRING
             VALUE "CompanyShortName", "@COMPANY_SHORTNAME@"
             VALUE "ProductShortName", "@PRODUCT_SHORTNAME@"
             VALUE "LastChange", "@LASTCHANGE@"
-            VALUE "Official Build", "@OFFICIAL_BUILD@"
         END
     END
     BLOCK "VarFileInfo"
diff -r -u --color up/chromium/chrome/app/chromium_strings.grd nw/chromium/chrome/app/chromium_strings.grd
--- up/chromium/chrome/app/chromium_strings.grd	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/app/chromium_strings.grd	2023-01-28 02:49:21.411545745 +0000
@@ -277,10 +277,10 @@
       </if>
 
       <message name="IDS_PRODUCT_NAME" desc="The Chrome application name">
-        Chromium
+        nwjs
       </message>
       <message name="IDS_SHORT_PRODUCT_NAME" desc="The Chrome application short name.">
-        Chromium
+        nwjs
       </message>
       <if expr="is_win">
         <message name="IDS_SXS_SHORTCUT_NAME" desc="Unused in Chromium builds" translateable="false">
@@ -290,7 +290,7 @@
         <message name="IDS_SHORTCUT_NAME_DEV" desc="Unused in Chromium builds" translateable="false">
         </message>
         <message name="IDS_PRODUCT_DESCRIPTION" desc="Browser description">
-          Chromium is a web browser that runs webpages and applications with lightning speed. It's fast, stable, and easy to use. Browse the web more safely with malware and phishing protection built into Chromium.
+          nwjs runtime enables writing native application with Web technologies.
         </message>
         <message name="IDS_WELCOME_TO_CHROME" desc="Welcoming text announced via screen readers the first time Chrome is launched at the conclusion of installation.">
           Welcome to Chromium; new browser window opened
@@ -336,7 +336,7 @@
       <if expr="not chromeos_ash">
         <!-- Browser Window Title Format -->
         <message name="IDS_BROWSER_WINDOW_TITLE_FORMAT" desc="The format for titles displayed in tabs and popup windows">
-          <ph name="PAGE_TITLE">$1<ex>Google</ex></ph> - Chromium
+          <ph name="PAGE_TITLE">$1<ex>Google</ex></ph>
         </message>
       </if>
       <if expr="chromeos_ash">
@@ -381,7 +381,7 @@
         The Chromium Authors
       </message>
       <message name="IDS_ABOUT_VERSION_COPYRIGHT" desc="Copyright information on the about pages">
-        Copyright <ph name="YEAR">{0,date,y}<ex>2016</ex></ph> The Chromium Authors. All rights reserved.
+        Copyright <ph name="YEAR">{0,date,y}<ex>2016</ex></ph> The Chromium Authors, NW.js contributors, Node.js. All rights reserved.
       </message>
       <if expr="chromeos_ash">
         <message name="IDS_ABOUT_CROS_VERSION_LICENSE" desc="Additional text displayed beneath the Chromium open source URLs for ChromeOS.">
@@ -812,13 +812,13 @@
 
       <if expr="is_macosx">
         <message name="IDS_APP_MENU_PRODUCT_NAME" desc="The application's short name, used for the Mac's application menu, activity monitor, etc. This should be less than 16 characters. Example: Chrome, not Google Chrome.">
-          Chromium
+          nwjs
         </message>
         <message name="IDS_HELPER_NAME" desc="The helper application's name.  Should contain the Chrome application name (IDS_PRODUCT_NAME). Example: Google Chrome Helper.">
-          Chromium Helper
+          nwjs Helper
         </message>
         <message name="IDS_SHORT_HELPER_NAME" desc="The helper application's short name, used for the Mac's application menu, activity monitor, etc. Example: Chrome Helper, not Google Chrome Helper.">
-          Chromium Helper
+          nwjs Helper
         </message>
       </if>
 
diff -r -u --color up/chromium/chrome/app/framework.order nw/chromium/chrome/app/framework.order
--- up/chromium/chrome/app/framework.order	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/app/framework.order	2023-01-28 02:49:21.419545829 +0000
@@ -18,6 +18,267 @@
 # Provided by build/sanitizers/sanitizer_options.cc in ASan builds.
 ___asan_default_options
 
+__ZN4node14ErrnoExceptionEPN2v87IsolateEiPKcS4_S4_
+__ZN4node11UVExceptionEPN2v87IsolateEiPKcS4_S4_
+__ZN4node11UVExceptionEPN2v87IsolateEiPKcS4_S4_S4_
+__ZN4node16CallTickCallbackEPNS_11EnvironmentEN2v86HandleINS2_5ValueEEE
+__ZN4node12MakeCallbackEPN2v87IsolateENS0_6HandleINS0_6ObjectEEEPKciPNS3_INS0_5ValueEEE
+__ZN4node12MakeCallbackEPN2v87IsolateENS0_6HandleINS0_6ObjectEEENS3_INS0_6StringEEEiPNS3_INS0_5ValueEEE
+__ZN4node12MakeCallbackEPN2v87IsolateENS0_6HandleINS0_6ObjectEEENS3_INS0_8FunctionEEEiPNS3_INS0_5ValueEEE
+__ZN4node6EncodeEPN2v87IsolateEPKcmNS_8encodingE
+__ZN4node6EncodeEPN2v87IsolateEPKtm
+__ZN4node11DecodeBytesEPN2v87IsolateENS0_6HandleINS0_5ValueEEENS_8encodingE
+__ZN4node11DecodeWriteEPN2v87IsolateEPcmNS0_6HandleINS0_5ValueEEENS_8encodingE
+_node_module_register
+__ZN4node14FatalExceptionEPN2v87IsolateERKNS0_8TryCatchE
+__ZN4node9OnMessageEN2v86HandleINS0_7MessageEEENS1_INS0_5ValueEEE
+__ZN4node15LoadEnvironmentEPNS_11EnvironmentE
+__ZN4node4InitEPiPPKcS0_PS3_
+__ZN4node9RunAtExitEPNS_11EnvironmentE
+__ZN4node6AtExitEPFvPvES0_
+__ZN4node14EmitBeforeExitEPNS_11EnvironmentE
+__ZN4node8EmitExitEPNS_11EnvironmentE
+__ZN4node17CreateEnvironmentEPN2v87IsolateENS0_6HandleINS0_7ContextEEEiPKPKciS9_
+__ZN4node17CreateEnvironmentEPN2v87IsolateEP9uv_loop_sNS0_6HandleINS0_7ContextEEEiPKPKciSB_
+__ZN4node5StartEiPPc
+__ZN4node11SetupNWNodeEiPPc
+__ZN4node15StartNWInstanceEiPPcN2v86HandleINS2_7ContextEEE
+__ZN4node17SetNWTickCallbackEPFN2v86HandleINS0_5ValueEEEPNS_11EnvironmentES3_E
+__ZN4node18CallNWTickCallbackEPNS_11EnvironmentEN2v86HandleINS2_5ValueEEE
+__ZN4node6Buffer11HasInstanceEN2v86HandleINS1_5ValueEEE
+__ZN4node6Buffer11HasInstanceEN2v86HandleINS1_6ObjectEEE
+__ZN4node6Buffer4DataEN2v86HandleINS1_5ValueEEE
+__ZN4node6Buffer4DataEN2v86HandleINS1_6ObjectEEE
+__ZN4node6Buffer6LengthEN2v86HandleINS1_5ValueEEE
+__ZN4node6Buffer6LengthEN2v86HandleINS1_6ObjectEEE
+__ZN4node6Buffer3NewEPN2v87IsolateENS1_6HandleINS1_6StringEEENS_8encodingE
+__ZN4node6Buffer3NewEPN2v87IsolateEm
+__ZN4node6Buffer3NewEPN2v87IsolateEPKcm
+__ZN4node6Buffer3NewEPN2v87IsolateEPcmPFvS4_PvES5_
+__ZN4node6Buffer3UseEPN2v87IsolateEPcj
+__ZN4node4i18n22InitializeICUDirectoryEPKc
+__ZN4node7smalloc17ExternalArraySizeEN2v817ExternalArrayTypeE
+__ZN4node7smalloc5AllocEPN2v87IsolateENS1_6HandleINS1_6ObjectEEEmNS1_17ExternalArrayTypeE
+__ZN4node7smalloc5AllocEPN2v87IsolateENS1_6HandleINS1_6ObjectEEEPcmNS1_17ExternalArrayTypeE
+__ZN4node7smalloc5AllocEPN2v87IsolateENS1_6HandleINS1_6ObjectEEEmPFvPcPvES8_NS1_17ExternalArrayTypeE
+__ZN4node7smalloc5AllocEPN2v87IsolateENS1_6HandleINS1_6ObjectEEEPcmPFvS7_PvES8_NS1_17ExternalArrayTypeE
+__ZN4node7smalloc12AllocDisposeEPN2v87IsolateENS1_6HandleINS1_6ObjectEEE
+__ZN4node7smalloc15HasExternalDataEPN2v87IsolateENS1_5LocalINS1_6ObjectEEE
+_uv_fs_poll_init
+_uv_fs_poll_start
+_uv_fs_poll_stop
+_uv_fs_poll_getpath
+_uv_inet_ntop
+_uv_inet_pton
+_uv_queue_work
+_uv_cancel
+_uv_handle_size
+_uv_req_size
+_uv_loop_size
+_uv_buf_init
+_uv_err_name
+_uv_strerror
+_uv_ip4_addr
+_uv_ip6_addr
+_uv_ip4_name
+_uv_ip6_name
+_uv_tcp_bind
+_uv_udp_bind
+_uv_tcp_connect
+_uv_udp_send
+_uv_udp_try_send
+_uv_udp_recv_start
+_uv_udp_recv_stop
+_uv_walk
+_uv_ref
+_uv_unref
+_uv_has_ref
+_uv_stop
+_uv_now
+_uv_recv_buffer_size
+_uv_send_buffer_size
+_uv_fs_event_getpath
+_uv_fs_scandir_next
+_uv_loop_configure
+_uv_default_loop
+_uv_loop_new
+_uv_loop_close
+_uv_loop_delete
+_uv_version
+_uv_version_string
+_uv_async_init
+_uv_async_send
+_uv_hrtime
+_uv_close
+_uv_is_closing
+_uv_backend_fd
+_uv_backend_timeout
+_uv_loop_alive
+_uv_run
+_uv_update_time
+_uv_is_active
+_uv_cwd
+_uv_chdir
+_uv_disable_stdio_inheritance
+_uv_fileno
+_uv_getrusage
+_uv_dlopen
+_uv_dlclose
+_uv_dlsym
+_uv_dlerror
+_uv_fs_access
+_uv_fs_chmod
+_uv_fs_chown
+_uv_fs_close
+_uv_fs_fchmod
+_uv_fs_fchown
+_uv_fs_fdatasync
+_uv_fs_fstat
+_uv_fs_fsync
+_uv_fs_ftruncate
+_uv_fs_futime
+_uv_fs_lstat
+_uv_fs_link
+_uv_fs_mkdir
+_uv_fs_mkdtemp
+_uv_fs_open
+_uv_fs_read
+_uv_fs_scandir
+_uv_fs_readlink
+_uv_fs_rename
+_uv_fs_rmdir
+_uv_fs_sendfile
+_uv_fs_stat
+_uv_fs_symlink
+_uv_fs_unlink
+_uv_fs_utime
+_uv_fs_write
+_uv_fs_req_cleanup
+_uv_getaddrinfo
+_uv_freeaddrinfo
+_uv_getnameinfo
+_uv_loop_init
+_uv_prepare_init
+_uv_prepare_start
+_uv_prepare_stop
+_uv_check_init
+_uv_check_start
+_uv_check_stop
+_uv_idle_init
+_uv_idle_start
+_uv_idle_stop
+_uv_pipe_init
+_uv_pipe_bind
+_uv_pipe_open
+_uv_pipe_connect
+_uv_pipe_getsockname
+_uv_pipe_getpeername
+_uv_pipe_pending_instances
+_uv_pipe_pending_count
+_uv_pipe_pending_type
+_uv_poll_init
+_uv_poll_init_socket
+_uv_poll_stop
+_uv_poll_start
+_uv_spawn
+_uv_process_kill
+_uv_kill
+_uv_signal_init
+_uv_signal_start
+_uv_signal_stop
+_uv_accept
+_uv_listen
+_uv_shutdown
+_uv_write2
+_uv_write
+_uv_try_write
+_uv_read_start
+_uv_read_stop
+_uv_is_readable
+_uv_is_writable
+_uv_stream_set_blocking
+_uv_tcp_init
+_uv_tcp_open
+_uv_tcp_getsockname
+_uv_tcp_getpeername
+_uv_tcp_nodelay
+_uv_tcp_keepalive
+_uv_tcp_simultaneous_accepts
+_uv_thread_create
+_uv_thread_self
+_uv_thread_join
+_uv_thread_equal
+_uv_mutex_init
+_uv_mutex_destroy
+_uv_mutex_lock
+_uv_mutex_trylock
+_uv_mutex_unlock
+_uv_rwlock_init
+_uv_rwlock_destroy
+_uv_rwlock_rdlock
+_uv_rwlock_tryrdlock
+_uv_rwlock_rdunlock
+_uv_rwlock_wrlock
+_uv_rwlock_trywrlock
+_uv_rwlock_wrunlock
+_uv_once
+_uv_sem_init
+_uv_sem_destroy
+_uv_sem_post
+_uv_sem_wait
+_uv_sem_trywait
+_uv_cond_init
+_uv_cond_destroy
+_uv_cond_signal
+_uv_cond_broadcast
+_uv_cond_wait
+_uv_cond_timedwait
+_uv_barrier_init
+_uv_barrier_destroy
+_uv_barrier_wait
+_uv_key_create
+_uv_key_delete
+_uv_key_get
+_uv_key_set
+_uv_timer_init
+_uv_timer_start
+_uv_timer_stop
+_uv_timer_again
+_uv_timer_set_repeat
+_uv_timer_get_repeat
+_uv_tty_init
+_uv_tty_set_mode
+_uv_tty_get_winsize
+_uv_guess_handle
+_uv_tty_reset_mode
+_uv_udp_init
+_uv_udp_open
+_uv_udp_set_membership
+_uv_udp_set_broadcast
+_uv_udp_set_ttl
+_uv_udp_set_multicast_ttl
+_uv_udp_set_multicast_loop
+_uv_udp_set_multicast_interface
+_uv_udp_getsockname
+_uv_setup_args
+_uv_set_process_title
+_uv_get_process_title
+_uv_exepath
+_uv_get_free_memory
+_uv_get_total_memory
+_uv_loadavg
+_uv_resident_set_memory
+_uv_uptime
+_uv_cpu_info
+_uv_free_cpu_info
+_uv_interface_addresses
+_uv_free_interface_addresses
+_uv_fs_event_init
+_uv_fs_event_start
+_uv_fs_event_stop
+
+
+
 # Entry point from the app mode loader.
 _ChromeAppModeStart_v6
 
diff -r -u --color up/chromium/chrome/app/main_dll_loader_win.cc nw/chromium/chrome/app/main_dll_loader_win.cc
--- up/chromium/chrome/app/main_dll_loader_win.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/app/main_dll_loader_win.cc	2023-01-28 02:49:21.467546337 +0000
@@ -51,6 +51,8 @@
 
 typedef void (*RelaunchChromeBrowserWithNewCommandLineIfNeededFunc)();
 
+#define BUFSIZE MAX_PATH
+
 void RecordDidRun(const base::FilePath& dll_path) {
   installer::UpdateDidRunState(true);
 }
@@ -88,10 +90,17 @@
 // directory. Returns a handle to the loaded module on success, or nullptr on
 // failure.
 HMODULE LoadModuleWithDirectory(const base::FilePath& module) {
+  bool restore_directory = false;
+  TCHAR Buffer[BUFSIZE];
+  if (::GetCurrentDirectoryW(BUFSIZE, Buffer)) {
+    restore_directory = true;
+  }
   ::SetCurrentDirectoryW(module.DirName().value().c_str());
   base::PreReadFile(module, /*is_executable=*/true);
   HMODULE handle = ::LoadLibraryExW(module.value().c_str(), nullptr,
                                     LOAD_WITH_ALTERED_SEARCH_PATH);
+  if (restore_directory)
+    ::SetCurrentDirectory(Buffer);
   return handle;
 }
 
@@ -106,7 +115,7 @@
   }
   HMODULE dll = LoadModuleWithDirectory(*module);
   if (!dll)
-    PLOG(ERROR) << "Failed to load Chrome DLL from " << module->value();
+    PLOG(ERROR) << "Failed to load NW DLL from " << module->value();
   return dll;
 }
 
Only in nw/chromium/chrome/app: nibs
Only in nw/chromium/chrome/app: nw.dll.manifest
Only in nw/chromium/chrome/app: nw.exe.manifest
diff -r -u --color up/chromium/chrome/app/theme/chromium/BRANDING nw/chromium/chrome/app/theme/chromium/BRANDING
--- up/chromium/chrome/app/theme/chromium/BRANDING	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/app/theme/chromium/BRANDING	2023-01-28 02:49:22.051552509 +0000
@@ -1,10 +1,10 @@
-COMPANY_FULLNAME=The Chromium Authors
-COMPANY_SHORTNAME=The Chromium Authors
-PRODUCT_FULLNAME=Chromium
-PRODUCT_SHORTNAME=Chromium
-PRODUCT_INSTALLER_FULLNAME=Chromium Installer
-PRODUCT_INSTALLER_SHORTNAME=Chromium Installer
-COPYRIGHT=Copyright @LASTCHANGE_YEAR@ The Chromium Authors. All rights reserved.
-MAC_BUNDLE_ID=org.chromium.Chromium
-MAC_CREATOR_CODE=Cr24
+COMPANY_FULLNAME=The NW.js Community
+COMPANY_SHORTNAME=nwjs.io
+PRODUCT_FULLNAME=nwjs
+PRODUCT_SHORTNAME=nwjs
+PRODUCT_INSTALLER_FULLNAME=NWJS Installer
+PRODUCT_INSTALLER_SHORTNAME=NWJS Installer
+COPYRIGHT=Copyright @LASTCHANGE_YEAR@, The NW.js community and The Chromium Authors. All rights reserved.
+MAC_BUNDLE_ID=io.nwjs.nwjs
+MAC_CREATOR_CODE=NWJS
 MAC_TEAM_ID=
Binary files up/chromium/chrome/app/theme/chromium/mac/app.icns and nw/chromium/chrome/app/theme/chromium/mac/app.icns differ
Binary files up/chromium/chrome/app/theme/chromium/mac/document.icns and nw/chromium/chrome/app/theme/chromium/mac/document.icns differ
Binary files up/chromium/chrome/app/theme/chromium/product_logo_128.png and nw/chromium/chrome/app/theme/chromium/product_logo_128.png differ
Binary files up/chromium/chrome/app/theme/chromium/product_logo_22_mono.png and nw/chromium/chrome/app/theme/chromium/product_logo_22_mono.png differ
Binary files up/chromium/chrome/app/theme/chromium/product_logo_24.png and nw/chromium/chrome/app/theme/chromium/product_logo_24.png differ
Binary files up/chromium/chrome/app/theme/chromium/product_logo_256.png and nw/chromium/chrome/app/theme/chromium/product_logo_256.png differ
Only in nw/chromium/chrome/app/theme/chromium: product_logo_32.xpm
Binary files up/chromium/chrome/app/theme/chromium/product_logo_64.png and nw/chromium/chrome/app/theme/chromium/product_logo_64.png differ
Binary files up/chromium/chrome/app/theme/chromium/win/chromium.ico and nw/chromium/chrome/app/theme/chromium/win/chromium.ico differ
diff -r -u --color up/chromium/chrome/app/version_assembly/BUILD.gn nw/chromium/chrome/app/version_assembly/BUILD.gn
--- up/chromium/chrome/app/version_assembly/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/app/version_assembly/BUILD.gn	2023-01-28 02:49:22.079552805 +0000
@@ -25,7 +25,6 @@
     as_invoker_manifest,
     common_controls_manifest,
     default_compatibility_manifest,
-    version_assembly_output_file,
   ]
 
   if (enable_segment_heap) {
diff -r -u --color up/chromium/chrome/app/version_assembly/version_assembly_manifest.template nw/chromium/chrome/app/version_assembly/version_assembly_manifest.template
--- up/chromium/chrome/app/version_assembly/version_assembly_manifest.template	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/app/version_assembly/version_assembly_manifest.template	2023-01-28 02:49:22.079552805 +0000
@@ -4,5 +4,5 @@
       name='@MAJOR@.@MINOR@.@BUILD@.@PATCH@'
       version='@MAJOR@.@MINOR@.@BUILD@.@PATCH@'
       type='win32'/>
-  <file name='chrome_elf.dll'/>
+  <file name='nw_elf.dll'/>
 </assembly>
diff -r -u --color up/chromium/chrome/browser/BUILD.gn nw/chromium/chrome/browser/BUILD.gn
--- up/chromium/chrome/browser/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/BUILD.gn	2023-01-28 02:49:22.083552848 +0000
@@ -1037,8 +1037,8 @@
     "page_load_metrics/observers/tab_restore_page_load_metrics_observer.h",
     "page_load_metrics/observers/third_party_metrics_observer.cc",
     "page_load_metrics/observers/third_party_metrics_observer.h",
-    "page_load_metrics/observers/translate_page_load_metrics_observer.cc",
-    "page_load_metrics/observers/translate_page_load_metrics_observer.h",
+    #    "page_load_metrics/observers/translate_page_load_metrics_observer.cc",
+    #  "page_load_metrics/observers/translate_page_load_metrics_observer.h",
     "page_load_metrics/page_load_metrics_initialize.cc",
     "page_load_metrics/page_load_metrics_initialize.h",
     "page_load_metrics/page_load_metrics_memory_tracker_factory.cc",
@@ -1816,18 +1816,18 @@
     "tracing/trace_event_system_stats_monitor.h",
     "transition_manager/full_browser_transition_manager.cc",
     "transition_manager/full_browser_transition_manager.h",
-    "translate/chrome_translate_client.cc",
-    "translate/chrome_translate_client.h",
-    "translate/translate_frame_binder.cc",
-    "translate/translate_frame_binder.h",
-    "translate/translate_model_service_factory.cc",
-    "translate/translate_model_service_factory.h",
-    "translate/translate_ranker_factory.cc",
-    "translate/translate_ranker_factory.h",
-    "translate/translate_ranker_metrics_provider.cc",
-    "translate/translate_ranker_metrics_provider.h",
-    "translate/translate_service.cc",
-    "translate/translate_service.h",
+    #"translate/chrome_translate_client.cc",
+    #"translate/chrome_translate_client.h",
+    #"translate/translate_frame_binder.cc",
+    #"translate/translate_frame_binder.h",
+    #"translate/translate_model_service_factory.cc",
+    #"translate/translate_model_service_factory.h",
+    #"translate/translate_ranker_factory.cc",
+    #"translate/translate_ranker_factory.h",
+    #"translate/translate_ranker_metrics_provider.cc",
+    #"translate/translate_ranker_metrics_provider.h",
+    #"translate/translate_service.cc",
+    #"translate/translate_service.h",
     "undo/bookmark_undo_service_factory.cc",
     "undo/bookmark_undo_service_factory.h",
     "unexpire_flags.cc",
@@ -1918,10 +1918,10 @@
     "//chrome/browser/share",
     "//chrome/browser/ui",
     "//chrome/browser/storage_access_api:permissions",
-    "//chrome/browser/safe_browsing",
-    "//chrome/browser/safe_browsing:verdict_cache_manager_factory",
-    "//chrome/browser/safe_browsing:advanced_protection",
-    "//chrome/browser/safe_browsing:metrics_collector",
+    #"//chrome/browser/safe_browsing",
+    #"//chrome/browser/safe_browsing:verdict_cache_manager_factory",
+    #"//chrome/browser/safe_browsing:advanced_protection",
+    #"//chrome/browser/safe_browsing:metrics_collector",
 
     # TODO(crbug.com/1030821): Eliminate usages of browser.h from Media Router.
     "//chrome/browser/media/router",
@@ -1981,6 +1981,7 @@
     "//build/config/chromebox_for_meetings:buildflags",
     "//build/config/compiler:compiler_buildflags",
     "//cc",
+    "//content/nw:nw_browser",
     "//chrome:extra_resources",
     "//chrome:resources",
     "//chrome:strings",
@@ -2022,10 +2023,10 @@
     "//chrome/browser/push_messaging:budget_proto",
     "//chrome/browser/resource_coordinator:mojo_bindings",
     "//chrome/browser/resource_coordinator:tab_manager_features",
-    "//chrome/browser/safe_browsing",
-    "//chrome/browser/safe_browsing:advanced_protection",
-    "//chrome/browser/safe_browsing:metrics_collector",
-    "//chrome/browser/safe_browsing:verdict_cache_manager_factory",
+    #"//chrome/browser/safe_browsing",
+    #"//chrome/browser/safe_browsing:advanced_protection",
+    #"//chrome/browser/safe_browsing:metrics_collector",
+    #"//chrome/browser/safe_browsing:verdict_cache_manager_factory",
     "//chrome/browser/share",
     "//chrome/browser/sharing:buildflags",
     "//chrome/browser/sharing/proto",
@@ -2093,9 +2094,9 @@
     "//components/commerce/core:persisted_state_db_content_proto",
     "//components/commerce/core:pref_names",
     "//components/commerce/core:shopping_service",
-    "//components/component_updater",
-    "//components/component_updater:crl_set_remover",
-    "//components/component_updater/installer_policies",
+    #"//components/component_updater",
+    #"//components/component_updater:crl_set_remover",
+    #"//components/component_updater/installer_policies",
     "//components/consent_auditor",
     "//components/content_capture/browser",
     "//components/content_settings/browser",
@@ -2264,21 +2265,21 @@
     "//components/reputation/core:proto",
     "//components/resources",
     "//components/safe_browsing/content/browser",
-    "//components/safe_browsing/content/browser:client_side_detection",
-    "//components/safe_browsing/content/browser:safe_browsing_service",
+    #"//components/safe_browsing/content/browser:client_side_detection",
+    #"//components/safe_browsing/content/browser:safe_browsing_service",
     "//components/safe_browsing/content/browser/password_protection",
-    "//components/safe_browsing/content/browser/web_ui",
-    "//components/safe_browsing/core/browser",
-    "//components/safe_browsing/core/browser:safe_browsing_metrics_collector",
-    "//components/safe_browsing/core/browser:verdict_cache_manager",
-    "//components/safe_browsing/core/browser/db:database_manager",
-    "//components/safe_browsing/core/browser/password_protection:password_protection_metrics_util",
-    "//components/safe_browsing/core/browser/realtime:policy_engine",
-    "//components/safe_browsing/core/browser/realtime:url_lookup_service",
-    "//components/safe_browsing/core/browser/sync",
-    "//components/safe_browsing/core/common",
-    "//components/safe_browsing/core/common:safe_browsing_policy_handler",
-    "//components/safe_browsing/core/common/proto:csd_proto",
+    #"//components/safe_browsing/content/browser/web_ui",
+    #"//components/safe_browsing/core/browser",
+    #"//components/safe_browsing/core/browser:safe_browsing_metrics_collector",
+    #"//components/safe_browsing/core/browser:verdict_cache_manager",
+    #"//components/safe_browsing/core/browser/db:database_manager",
+    #"//components/safe_browsing/core/browser/password_protection:password_protection_metrics_util",
+    #"//components/safe_browsing/core/browser/realtime:policy_engine",
+    #"//components/safe_browsing/core/browser/realtime:url_lookup_service",
+    #"//components/safe_browsing/core/browser/sync",
+    #"//components/safe_browsing/core/common",
+    #"//components/safe_browsing/core/common:safe_browsing_policy_handler",
+    #"//components/safe_browsing/core/common/proto:csd_proto",
     "//components/safe_search_api",
     "//components/safe_search_api:safe_search_client",
     "//components/saved_tab_groups:core",
@@ -3728,8 +3729,8 @@
       "enterprise/connectors/analysis/analysis_service_settings.h",
       "enterprise/connectors/analysis/analysis_settings.cc",
       "enterprise/connectors/analysis/analysis_settings.h",
-      "enterprise/connectors/analysis/content_analysis_delegate.cc",
-      "enterprise/connectors/analysis/content_analysis_delegate.h",
+      #"enterprise/connectors/analysis/content_analysis_delegate.cc",
+      #"enterprise/connectors/analysis/content_analysis_delegate.h",
       "enterprise/connectors/analysis/content_analysis_delegate_base.cc",
       "enterprise/connectors/analysis/content_analysis_delegate_base.h",
       "enterprise/connectors/analysis/content_analysis_dialog.cc",
@@ -6065,8 +6066,8 @@
       "//base/win:base_win_buildflags",
       "//chrome/app:chrome_exe_main_exports",
       "//chrome/app/theme:chrome_unscaled_resources_grit",
-      "//chrome/browser/safe_browsing/chrome_cleaner",
-      "//chrome/browser/safe_browsing/chrome_cleaner:public",
+      #"//chrome/browser/safe_browsing/chrome_cleaner",
+      #"//chrome/browser/safe_browsing/chrome_cleaner:public",
       "//chrome/browser/web_applications/chrome_pwa_launcher:util",
       "//chrome/browser/win/conflicts:module_info",
       "//chrome/chrome_elf:constants",
@@ -6097,8 +6098,8 @@
       "//ui/color:color_switches",
       "//ui/display/util:util",
     ]
-    allow_circular_includes_from +=
-        [ "//chrome/browser/safe_browsing/chrome_cleaner" ]
+    #allow_circular_includes_from +=
+        #[ "//chrome/browser/safe_browsing/chrome_cleaner" ]
 
     all_dependent_configs = [ ":browser_win_linker_flags" ]
 
@@ -6306,7 +6307,7 @@
   }
 
   if (is_win || is_linux || is_android || is_chromeos) {
-    deps += [ "//chrome/browser/privacy:traffic_annotation_proto" ]
+    #deps += [ "//chrome/browser/privacy:traffic_annotation_proto" ]
   }
 
   if (is_android || is_mac || is_win) {
@@ -6378,8 +6379,8 @@
     sources += [
       "enterprise/chrome_browser_main_extra_parts_enterprise.cc",
       "enterprise/chrome_browser_main_extra_parts_enterprise.h",
-      "enterprise/connectors/analysis/content_analysis_sdk_manager.cc",
-      "enterprise/connectors/analysis/content_analysis_sdk_manager.h",
+      #"enterprise/connectors/analysis/content_analysis_sdk_manager.cc",
+      #"enterprise/connectors/analysis/content_analysis_sdk_manager.h",
       "enterprise/connectors/analysis/local_binary_upload_service.cc",
       "enterprise/connectors/analysis/local_binary_upload_service.h",
       "enterprise/connectors/analysis/local_binary_upload_service_factory.cc",
@@ -7879,7 +7880,6 @@
       "//components/safe_browsing/content/browser:safe_browsing_blocking_page",
       "//components/safe_browsing/content/browser/download:download_stats",
       "//components/safe_browsing/content/common:file_type_policies",
-      "//components/safe_browsing/content/common/proto:download_file_types_proto",
     ]
   }
 
@@ -7890,6 +7890,9 @@
     ]
     deps += [ "//components/segmentation_platform/internal:optimization_guide_segmentation_handler" ]
   }
+  deps += [
+      "//components/safe_browsing/content/common/proto:download_file_types_proto",
+  ]
 }
 
 if (is_android) {
@@ -7981,7 +7984,11 @@
 }
 
 grit("resources") {
-  source = "browser_resources.grd"
+  if (nwjs_sdk) {
+    source = "browser_resources.grd"
+  } else {
+    source = "nwjs_resources.grd"
+  }
 
   # Required due to flattenhtml = "true" on a generated file.
   enable_input_discovery_for_gn_analyze = false
@@ -7992,6 +7999,9 @@
   if (enable_hangout_services_extension) {
     defines += [ "enable_hangout_services_extension" ]
   }
+  if (nwjs_sdk) {
+    defines += [ "nwjs_sdk" ]
+  }
 
   output_dir = "$root_gen_dir/chrome"
   outputs = [
diff -r -u --color up/chromium/chrome/browser/app_controller_mac.mm nw/chromium/chrome/browser/app_controller_mac.mm
--- up/chromium/chrome/browser/app_controller_mac.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/app_controller_mac.mm	2023-01-28 02:49:22.167553735 +0000
@@ -12,6 +12,8 @@
 #include <memory>
 #include <vector>
 
+#include "content/public/common/content_features.h"
+
 #include "base/auto_reset.h"
 #include "base/bind.h"
 #include "base/command_line.h"
@@ -120,6 +122,8 @@
 #include "ui/native_theme/native_theme_observer.h"
 #include "url/gurl.h"
 
+#include "content/nw/src/nw_content.h"
+
 namespace {
 
 // How long we allow a workspace change notification to wait to be
@@ -184,7 +188,7 @@
   }
 
   Browser* browser = chrome::GetLastActiveBrowser();
-  CHECK(browser);
+  //CHECK(browser);
   return browser;
 }
 
@@ -602,18 +606,21 @@
          selector:@selector(willPowerOff:)
              name:NSWorkspaceWillPowerOffNotification
            object:nil];
-
+#if 0
   NSMenu* fileMenu = [[[NSApp mainMenu] itemWithTag:IDC_FILE_MENU] submenu];
   _closeTabMenuItem = [fileMenu itemWithTag:IDC_CLOSE_TAB];
   DCHECK(_closeTabMenuItem);
   _closeWindowMenuItem = [fileMenu itemWithTag:IDC_CLOSE_WINDOW];
   DCHECK(_closeWindowMenuItem);
+#endif
 
   // Set up the command updater for when there are no windows open
   [self initMenuState];
 
   // Initialize the Profile menu.
+#if 0
   [self initProfileMenu];
+#endif
 }
 
 - (void)unregisterEventHandlers {
@@ -672,7 +679,7 @@
   // already shutting down.
   if (!browser_shutdown::IsTryingToQuit()) {
     chrome::OnClosingAllBrowsers(true);
-    chrome::CloseAllBrowsersAndQuit();
+    chrome::CloseAllBrowsersAndQuit(false, true);
   }
 
   return num_browsers == 0 ? YES : NO;
@@ -696,6 +703,9 @@
     return YES;
   }
 
+  if (!AppWindowRegistryUtil::CloseAllAppWindows(true))
+    return NSTerminateCancel;
+
   // Check if the preference is turned on.
   const PrefService* prefs = g_browser_process->local_state();
   if (!prefs->GetBoolean(prefs::kConfirmToQuitEnabled)) {
@@ -867,7 +877,11 @@
 
 - (void)openStartupUrls {
   DCHECK(_startupComplete);
-  [self openUrlsReplacingNTP:_startupUrls];
+  if (_startupUrls.size()) {
+    base::CommandLine::ForCurrentProcess()->AppendArg(_startupUrls[0].spec());
+    base::CommandLine::ForCurrentProcess()->FixOrigArgv4Finder(_startupUrls[0].spec());
+  }
+  //[self openUrlsReplacingNTP:_startupUrls];
   _startupUrls.clear();
 }
 
@@ -889,7 +903,10 @@
     return;
   }
 
+  nw::OSXOpenURLsHook(urls);
+#if 0
   OpenUrlsInBrowser(urls);
+#endif
 }
 
 // This is called after profiles have been loaded and preferences registered.
@@ -913,6 +930,7 @@
 
   // Notify BrowserList to keep the application running so it doesn't go away
   // when all the browser windows get closed.
+  if (!base::FeatureList::IsEnabled(::features::kNWNewWin))
   _keep_alive = std::make_unique<ScopedKeepAlive>(
       KeepAliveOrigin::APP_CONTROLLER, KeepAliveRestartOption::DISABLED);
 
@@ -924,7 +942,7 @@
 
   // If enabled, keep Chrome alive when apps are open instead of quitting all
   // apps.
-  _quitWithAppsController = new QuitWithAppsController();
+  //_quitWithAppsController = new QuitWithAppsController();
 
   // Dynamically update shortcuts for "Close Window" and "Close Tab" menu items.
   [[_closeTabMenuItem menu] setDelegate:self];
@@ -1394,6 +1412,8 @@
 // browser windows.
 - (BOOL)applicationShouldHandleReopen:(NSApplication*)theApplication
                     hasVisibleWindows:(BOOL)hasVisibleWindows {
+  return nw::ApplicationShouldHandleReopenHook(hasVisibleWindows) ? YES : NO;
+#if 0
   // If the browser is currently trying to quit, don't do anything and return NO
   // to prevent AppKit from doing anything.
   if (browser_shutdown::IsTryingToQuit())
@@ -1474,6 +1494,7 @@
   // We've handled the reopen event, so return NO to tell AppKit not
   // to do anything.
   return NO;
+#endif
 }
 
 - (void)initMenuState {
@@ -1675,6 +1696,9 @@
   if (profilesAdded)
     [dockMenu addItem:[NSMenuItem separatorItem]];
 
+#if 0
+  Profile* profile = [self lastProfileIfLoaded];
+
   NSString* titleStr = l10n_util::GetNSStringWithFixup(IDS_NEW_WINDOW_MAC);
   base::scoped_nsobject<NSMenuItem> item(
       [[NSMenuItem alloc] initWithTitle:titleStr
@@ -1685,8 +1709,6 @@
   [item setEnabled:[self validateUserInterfaceItem:item]];
   [dockMenu addItem:item];
 
-  Profile* profile = [self lastProfileIfLoaded];
-
   // Buttons below require the profile to be loaded. In particular, if the
   // profile picker is shown at startup, these buttons won't be added until the
   // user picks a profile.
@@ -1705,6 +1727,7 @@
     [item setEnabled:[self validateUserInterfaceItem:item]];
     [dockMenu addItem:item];
   }
+#endif
 
   return dockMenu;
 }
@@ -1751,6 +1774,7 @@
 
   _profilePrefRegistrar.reset();
 
+#if 0
   NSMenuItem* bookmarkItem = [[NSApp mainMenu] itemWithTag:IDC_BOOKMARKS_MENU];
   BOOL hidden = [bookmarkItem isHidden];
   if (profile != nullptr) {
@@ -1772,12 +1796,15 @@
       _bookmarkMenuBridge->OnProfileWillBeDestroyed();
     }
   }
+#endif
 
   _lastProfile = profile;
 
   if (_lastProfile == nullptr)
     return;
 
+
+#if 0
   auto& entry = _profileBookmarkMenuBridgeMap[profile->GetPath()];
   if (!entry || !entry->GetProfile()) {
     // This creates a deep copy, but only the first 3 items in the root menu
@@ -1806,6 +1833,7 @@
   chrome::BrowserCommandController::
       UpdateSharedCommandsForIncognitoAvailability(
           _menuState.get(), _lastProfile);
+#endif
   _profilePrefRegistrar = std::make_unique<PrefChangeRegistrar>();
   _profilePrefRegistrar->Init(_lastProfile->GetPrefs());
   _profilePrefRegistrar->Add(
@@ -1850,6 +1878,7 @@
 }
 
 - (void)updateMenuItemKeyEquivalents {
+#if 0
   BOOL enableCloseTabShortcut = NO;
 
   id target = [NSApp targetForAction:@selector(performClose:)];
@@ -1877,6 +1906,7 @@
 
   [self adjustCloseWindowMenuItemKeyEquivalent:enableCloseTabShortcut];
   [self adjustCloseTabMenuItemKeyEquivalent:enableCloseTabShortcut];
+#endif
 }
 
 // This only has an effect on macOS 12+, and requests any state restoration
diff -r -u --color up/chromium/chrome/browser/apps/app_shim/app_shim_termination_manager.cc nw/chromium/chrome/browser/apps/app_shim/app_shim_termination_manager.cc
--- up/chromium/chrome/browser/apps/app_shim/app_shim_termination_manager.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/apps/app_shim/app_shim_termination_manager.cc	2023-01-28 02:49:22.183553905 +0000
@@ -59,12 +59,15 @@
 
   // BrowserListObserver:
   void OnBrowserAdded(Browser* browser) override {
-    browser_session_running_ = true;
+    // fix https://github.com/nwjs/nw.js/issues/7226 for nw1
+    // browser_session_running_ will set to true once devtool is opened
+    // hence the TerminateIfNoAppWindows function will never be called
+    //browser_session_running_ = true;
   }
 
  private:
   void OnClosingAllBrowsersChanged(bool closing) {
-    browser_session_running_ = !closing;
+    //browser_session_running_ = !closing;
   }
 
   base::CallbackListSubscription closing_all_browsers_subscription_;
diff -r -u --color up/chromium/chrome/browser/apps/platform_apps/app_load_service.cc nw/chromium/chrome/browser/apps/platform_apps/app_load_service.cc
--- up/chromium/chrome/browser/apps/platform_apps/app_load_service.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/apps/platform_apps/app_load_service.cc	2023-01-28 02:49:22.191553989 +0000
@@ -4,6 +4,8 @@
 
 #include "chrome/browser/apps/platform_apps/app_load_service.h"
 
+#include "content/nw/src/nw_content.h"
+
 #include "apps/app_restore_service.h"
 #include "apps/launcher.h"
 #include "base/notreached.h"
@@ -69,6 +71,8 @@
     return false;
   }
 
+  nw::SetMainExtensionId(extension_id);
+
   // Schedule the app to be launched once loaded.
   PostReloadAction& action = post_reload_actions_[extension_id];
   action.action_type = LAUNCH_FOR_LOAD_AND_LAUNCH;
@@ -132,7 +136,7 @@
   extensions::ExtensionPrefs* extension_prefs =
       extensions::ExtensionPrefs::Get(browser_context);
   if (WasUnloadedForReload(extension->id(), reason) &&
-      extension_prefs->IsActive(extension->id()) &&
+      (extension->is_nwjs_app() || extension_prefs->IsActive(extension->id())) &&
       !HasPostReloadAction(extension->id())) {
     post_reload_actions_[extension->id()].action_type = LAUNCH_FOR_RELOAD;
   }
diff -r -u --color up/chromium/chrome/browser/apps/platform_apps/app_window_registry_util.cc nw/chromium/chrome/browser/apps/platform_apps/app_window_registry_util.cc
--- up/chromium/chrome/browser/apps/platform_apps/app_window_registry_util.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/apps/platform_apps/app_window_registry_util.cc	2023-01-28 02:49:22.191553989 +0000
@@ -42,7 +42,7 @@
 
 // static
 bool AppWindowRegistryUtil::IsAppWindowVisibleInAnyProfile(
-    int window_type_mask) {
+                                                           int window_type_mask, bool check_visible) {
   std::vector<Profile*> profiles =
       g_browser_process->profile_manager()->GetLoadedProfiles();
   for (std::vector<Profile*>::const_iterator i = profiles.begin();
@@ -57,7 +57,7 @@
       continue;
 
     for (const AppWindow* window : app_windows) {
-      if (!window->is_hidden() &&
+      if ((!window->is_hidden() || !check_visible )&&
           (window_type_mask == 0 || (window->window_type() & window_type_mask)))
         return true;
     }
@@ -67,7 +67,7 @@
 }
 
 // static
-void AppWindowRegistryUtil::CloseAllAppWindows() {
+bool AppWindowRegistryUtil::CloseAllAppWindows(bool user_force) {
   std::vector<Profile*> profiles =
       g_browser_process->profile_manager()->GetLoadedProfiles();
   for (std::vector<Profile*>::const_iterator i = profiles.begin();
@@ -82,8 +82,13 @@
     AppWindowList window_list_copy(registry->app_windows());
     for (auto* window : window_list_copy) {
       // Ensure window is still valid.
-      if (base::Contains(registry->app_windows(), window))
-        window->GetBaseWindow()->Close();
+      if (base::Contains(registry->app_windows(), window)) {
+        if (window->NWCanClose(user_force))
+          window->GetBaseWindow()->Close();
+        else
+          return false;
+      }
     }
   }
+  return true;
 }
diff -r -u --color up/chromium/chrome/browser/apps/platform_apps/app_window_registry_util.h nw/chromium/chrome/browser/apps/platform_apps/app_window_registry_util.h
--- up/chromium/chrome/browser/apps/platform_apps/app_window_registry_util.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/apps/platform_apps/app_window_registry_util.h	2023-01-28 02:49:22.191553989 +0000
@@ -21,10 +21,10 @@
   // Returns true if the number of visible app windows registered across all
   // browser contexts is non-zero. |window_type_mask| is a bitwise OR filter of
   // AppWindow::WindowType, or 0 for any window type.
-  static bool IsAppWindowVisibleInAnyProfile(int window_type_mask);
+  static bool IsAppWindowVisibleInAnyProfile(int window_type_mask, bool check_visible = true);
 
   // Close all app windows in all profiles.
-  static void CloseAllAppWindows();
+  static bool CloseAllAppWindows(bool user_force = false);
 };
 
 #endif  // CHROME_BROWSER_APPS_PLATFORM_APPS_APP_WINDOW_REGISTRY_UTIL_H_
diff -r -u --color up/chromium/chrome/browser/apps/platform_apps/browser_context_keyed_service_factories.cc nw/chromium/chrome/browser/apps/platform_apps/browser_context_keyed_service_factories.cc
--- up/chromium/chrome/browser/apps/platform_apps/browser_context_keyed_service_factories.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/apps/platform_apps/browser_context_keyed_service_factories.cc	2023-01-28 02:49:22.195554031 +0000
@@ -12,7 +12,7 @@
 
 void EnsureBrowserContextKeyedServiceFactoriesBuilt() {
   apps::AppLoadServiceFactory::GetInstance();
-  AppShortcutManagerFactory::GetInstance();
+  //AppShortcutManagerFactory::GetInstance();
   AppTerminationObserver::GetFactoryInstance();
 }
 
diff -r -u --color up/chromium/chrome/browser/autocomplete/chrome_autocomplete_provider_client.cc nw/chromium/chrome/browser/autocomplete/chrome_autocomplete_provider_client.cc
--- up/chromium/chrome/browser/autocomplete/chrome_autocomplete_provider_client.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/autocomplete/chrome_autocomplete_provider_client.cc	2023-01-28 02:49:22.515557414 +0000
@@ -488,7 +488,7 @@
 }
 
 void ChromeAutocompleteProviderClient::PromptPageTranslation() {
-#if !BUILDFLAG(IS_ANDROID)
+#if 0 //!BUILDFLAG(IS_ANDROID)
   Browser* browser = BrowserList::GetInstance()->GetLastActive();
   content::WebContents* contents = nullptr;
   if (browser)
diff -r -u --color up/chromium/chrome/browser/background/background_application_list_model.cc nw/chromium/chrome/browser/background/background_application_list_model.cc
--- up/chromium/chrome/browser/background/background_application_list_model.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/background/background_application_list_model.cc	2023-01-28 02:49:22.527557541 +0000
@@ -244,8 +244,10 @@
   //    manifest.
 
   // Not a background app if we don't have the background permission.
+  // NWJS: nwjs_default_app is listed as background app and prevents
+  // quit so we need to disable it here
   if (!extension.permissions_data()->HasAPIPermission(
-          APIPermissionID::kBackground)) {
+                     APIPermissionID::kBackground, true)) {
     return false;
   }
 
@@ -382,7 +384,8 @@
         // Policy changes are only used for host permissions, so the
         // "background"
         // permission would never be present in  permissions .
-        NOTREACHED();
+        break;
+        //NOTREACHED();
     }
   }
 }
diff -r -u --color up/chromium/chrome/browser/background/background_contents_service.cc nw/chromium/chrome/browser/background/background_contents_service.cc
--- up/chromium/chrome/browser/background/background_contents_service.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/background/background_contents_service.cc	2023-01-28 02:49:22.527557541 +0000
@@ -782,6 +782,7 @@
 
 void BackgroundContentsService::HandleExtensionCrashed(
     const extensions::Extension* extension) {
+#if 0
   // When the extensions crash, notify the user about it and restart the crashed
   // contents.
   if (!extension)
@@ -796,6 +797,7 @@
     // Restart the extension.
     RestartForceInstalledExtensionOnCrash(extension);
   }
+#endif
 }
 
 BackgroundContentsService::BackgroundContentsInfo::BackgroundContentsInfo() =
diff -r -u --color up/chromium/chrome/browser/browser_features.cc nw/chromium/chrome/browser/browser_features.cc
--- up/chromium/chrome/browser/browser_features.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/browser_features.cc	2023-01-28 02:49:22.535557625 +0000
@@ -31,7 +31,7 @@
 BASE_FEATURE(kDestroyProfileOnBrowserClose,
              "DestroyProfileOnBrowserClose",
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_MAC) || BUILDFLAG(IS_WIN)
-             base::FEATURE_ENABLED_BY_DEFAULT);
+             base::FEATURE_DISABLED_BY_DEFAULT);
 #else
              base::FEATURE_DISABLED_BY_DEFAULT);
 #endif
diff -r -u --color up/chromium/chrome/browser/browser_process.h nw/chromium/chrome/browser/browser_process.h
--- up/chromium/chrome/browser/browser_process.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/browser_process.h	2023-01-28 02:49:22.539557667 +0000
@@ -235,6 +235,7 @@
   virtual void StartAutoupdateTimer() = 0;
 #endif
 
+
   virtual component_updater::ComponentUpdateService* component_updater() = 0;
 
   virtual MediaFileSystemRegistry* media_file_system_registry() = 0;
diff -r -u --color up/chromium/chrome/browser/browser_process_impl.cc nw/chromium/chrome/browser/browser_process_impl.cc
--- up/chromium/chrome/browser/browser_process_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/browser_process_impl.cc	2023-01-28 02:49:22.539557667 +0000
@@ -1,7 +1,7 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
-
+#pragma clang diagnostic ignored "-Wunreachable-code"
 #include "chrome/browser/browser_process_impl.h"
 
 #include <stddef.h>
@@ -408,8 +408,10 @@
 
   metrics_services_manager_.reset();
   intranet_redirect_detector_.reset();
+#if 0
   if (safe_browsing_service_.get())
     safe_browsing_service()->ShutDown();
+#endif
   network_time_tracker_.reset();
 
 #if !BUILDFLAG(IS_ANDROID) && !BUILDFLAG(IS_CHROMEOS_ASH)
@@ -1061,6 +1063,7 @@
 }
 #endif
 
+#if 1
 component_updater::ComponentUpdateService*
 BrowserProcessImpl::component_updater() {
   if (component_updater_)
@@ -1082,6 +1085,7 @@
 
   return component_updater_.get();
 }
+#endif
 
 void BrowserProcessImpl::OnKeepAliveStateChanged(bool is_keeping_alive) {
   if (is_keeping_alive)
@@ -1112,8 +1116,11 @@
 #if BUILDFLAG(ENABLE_EXTENSIONS)
   // chrome-extension:// URLs are safe to request anywhere, but may only
   // commit (including in iframes) in extension processes.
-  ChildProcessSecurityPolicy::GetInstance()->RegisterWebSafeIsolatedScheme(
-      extensions::kExtensionScheme, true);
+  // NWJS: Upstream: Remove command line/field trial support for
+  // disabling Isolate
+  // Extensions. https://codereview.chromium.org/2850793005
+  ChildProcessSecurityPolicy::GetInstance()->RegisterWebSafeScheme(
+      extensions::kExtensionScheme);
 #endif
 
   battery_metrics_ = std::make_unique<BatteryMetrics>();
@@ -1283,6 +1290,7 @@
   // Set this flag to true so that we don't retry indefinitely to
   // create the service class if there was an error.
   created_safe_browsing_service_ = true;
+#if 0
 
   // The factory can be overridden in tests.
   if (!safe_browsing::SafeBrowsingServiceInterface::HasFactory()) {
@@ -1296,6 +1304,7 @@
       safe_browsing::SafeBrowsingServiceInterface::CreateSafeBrowsingService());
   if (safe_browsing_service_)
     safe_browsing_service_->Initialize();
+#endif
 }
 
 void BrowserProcessImpl::CreateSubresourceFilterRulesetService() {
@@ -1362,7 +1371,7 @@
 
 void BrowserProcessImpl::Pin() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  CHECK(!IsShuttingDown());
+  //CHECK(!IsShuttingDown());
 }
 
 void BrowserProcessImpl::Unpin() {
diff -r -u --color up/chromium/chrome/browser/browser_process_platform_part_mac.mm nw/chromium/chrome/browser/browser_process_platform_part_mac.mm
--- up/chromium/chrome/browser/browser_process_platform_part_mac.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/browser_process_platform_part_mac.mm	2023-01-28 02:49:22.539557667 +0000
@@ -4,6 +4,9 @@
 
 #include "chrome/browser/browser_process_platform_part_mac.h"
 
+#include "base/feature_list.h"
+#include "chrome/browser/lifetime/application_lifetime_desktop.h"
+
 #include "base/mac/foundation_util.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/time/time.h"
@@ -40,15 +43,17 @@
   // come down this code path at all.) URL requests to exit have
   // |try_to_quit_application| set to true; keyboard menu invocations have it
   // set to false.
-
   if (!try_to_quit_application) {
+    chrome::CloseAllBrowsers(false, true);
+    return;
+#if 0
     // A keyboard menu invocation.
     AppController* app_controller =
         base::mac::ObjCCastStrict<AppController>([NSApp delegate]);
     if (![app_controller runConfirmQuitPanel])
       return;
+#endif
   }
-
   chrome_browser_application_mac::Terminate();
 }
 
diff -r -u --color up/chromium/chrome/browser/browser_resources.grd nw/chromium/chrome/browser/browser_resources.grd
--- up/chromium/chrome/browser/browser_resources.grd	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/browser_resources.grd	2023-01-28 02:49:22.539557667 +0000
@@ -22,6 +22,8 @@
       </if>
     </structures>
     <includes>
+      <include name="IDR_NWJS_DEFAPP_MANIFEST" file="resources\nwjs_default_app\manifest.json" type="BINDATA" />
+      <include name="IDR_NWJS_DEFAPP_MANIFEST_NEWWIN" file="resources\nwjs_newwin_app\manifest.json" type="BINDATA" />
       <if expr="is_win">
         <include name="IDR_ABOUT_CONFLICTS_HTML" file="resources\conflicts\about_conflicts.html" type="BINDATA" />
         <include name="IDR_ABOUT_CONFLICTS_JS" file="${root_gen_dir}\chrome\browser\resources\conflicts\tsc\about_conflicts.js" use_base_dir="false" type="BINDATA" />
diff -r -u --color up/chromium/chrome/browser/browser_switcher/browser_switcher_navigation_throttle.cc nw/chromium/chrome/browser/browser_switcher/browser_switcher_navigation_throttle.cc
--- up/chromium/chrome/browser/browser_switcher/browser_switcher_navigation_throttle.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/browser_switcher/browser_switcher_navigation_throttle.cc	2023-01-28 02:49:22.539557667 +0000
@@ -4,6 +4,8 @@
 
 #include "chrome/browser/browser_switcher/browser_switcher_navigation_throttle.h"
 
+#pragma clang diagnostic ignored "-Wunused-function"
+
 #include <memory>
 
 #include "base/bind.h"
@@ -89,7 +91,7 @@
 BrowserSwitcherNavigationThrottle::MaybeCreateThrottleFor(
     content::NavigationHandle* navigation) {
   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
+#if 0
   content::BrowserContext* browser_context =
       navigation->GetWebContents()->GetBrowserContext();
   Profile* profile = Profile::FromBrowserContext(browser_context);
@@ -103,6 +105,8 @@
   return std::make_unique<navigation_interception::InterceptNavigationThrottle>(
       navigation, base::BindRepeating(&MaybeLaunchAlternativeBrowser),
       navigation_interception::SynchronyMode::kSync);
+#endif
+  return nullptr;
 }
 
 }  // namespace browser_switcher
diff -r -u --color up/chromium/chrome/browser/browsing_data/chrome_browsing_data_remover_delegate.cc nw/chromium/chrome/browser/browsing_data/chrome_browsing_data_remover_delegate.cc
--- up/chromium/chrome/browser/browsing_data/chrome_browsing_data_remover_delegate.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/browsing_data/chrome_browsing_data_remover_delegate.cc	2023-01-28 02:49:22.543557710 +0000
@@ -4,6 +4,9 @@
 
 #include "chrome/browser/browsing_data/chrome_browsing_data_remover_delegate.h"
 
+#include "components/password_manager/core/browser/smart_bubble_stats_store.h"
+#include "components/password_manager/core/browser/field_info_store.h"
+
 #include <stdint.h>
 
 #include <set>
@@ -650,8 +653,10 @@
           base::BindOnce(
               &ChromeBrowsingDataRemoverDelegate::CreateTaskCompletionClosure,
               base::Unretained(this), TracingDataType::kCookies));
+#if 0
       safe_browsing::VerdictCacheManagerFactory::GetForProfile(profile_)
           ->OnCookiesDeleted();
+#endif
     }
 
     if (filter_builder->GetMode() ==
@@ -704,9 +709,10 @@
         ProtocolHandlerRegistryFactory::GetForBrowserContext(profile_);
     if (handler_registry)
       handler_registry->ClearUserDefinedHandlers(delete_begin_, delete_end_);
-
+#if 0
     ChromeTranslateClient::CreateTranslatePrefs(prefs)
         ->DeleteNeverPromptSitesBetween(delete_begin_, delete_end_);
+#endif
 
     host_content_settings_map_->ClearSettingsForOneTypeWithPredicate(
         ContentSettingsType::PERMISSION_AUTOREVOCATION_DATA, delete_begin,
diff -r -u --color up/chromium/chrome/browser/chrome_browser_application_mac.h nw/chromium/chrome/browser/chrome_browser_application_mac.h
--- up/chromium/chrome/browser/chrome_browser_application_mac.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/chrome_browser_application_mac.h	2023-01-28 02:49:22.555557837 +0000
@@ -23,6 +23,8 @@
 // application, i.e., begins a process which may lead to termination. This
 // method cancels that process.
 - (void)cancelTerminate:(id)sender;
+- (void)closeAllWindowsQuit:(id)sender;
+
 @end
 
 #endif  // __OBJC__
diff -r -u --color up/chromium/chrome/browser/chrome_browser_application_mac.mm nw/chromium/chrome/browser/chrome_browser_application_mac.mm
--- up/chromium/chrome/browser/chrome_browser_application_mac.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/chrome_browser_application_mac.mm	2023-01-28 02:49:22.555557837 +0000
@@ -7,6 +7,11 @@
 #include <Carbon/Carbon.h>  // for <HIToolbox/Events.h>
 
 #include "base/check.h"
+#include "chrome/browser/apps/platform_apps/app_window_registry_util.h"
+#include "chrome/browser/lifetime/browser_close_manager.h"
+#include "chrome/browser/lifetime/application_lifetime_desktop.h"
+#include "content/public/common/content_features.h"
+
 #include "base/command_line.h"
 #include "base/mac/call_with_eh_frame.h"
 #include "base/observer_list.h"
@@ -219,6 +224,15 @@
 // the NSApplicationWillTerminateNotification to be posted, which ends the
 // NSApplication event loop, so final post- MessageLoop::Run() work is done
 // before exiting.
+
+- (void)closeAllWindowsQuit:(id)sender {
+  if (base::FeatureList::IsEnabled(::features::kNWNewWin)) {
+    chrome::CloseAllBrowsers(false, true);
+    return;
+  }
+  AppWindowRegistryUtil::CloseAllAppWindows(true);
+}
+
 - (void)terminate:(id)sender {
   AppController* appController = static_cast<AppController*>([NSApp delegate]);
   [appController tryToTerminateApplication:self];
diff -r -u --color up/chromium/chrome/browser/chrome_browser_interface_binders.cc nw/chromium/chrome/browser/chrome_browser_interface_binders.cc
--- up/chromium/chrome/browser/chrome_browser_interface_binders.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/chrome_browser_interface_binders.cc	2023-01-28 02:49:22.555557837 +0000
@@ -719,10 +719,10 @@
         base::BindRepeating(
             &performance_manager::BindDocumentCoordinationUnit));
   }
-
+#if 0
   map->Add<translate::mojom::ContentTranslateDriver>(
       base::BindRepeating(&translate::BindContentTranslateDriver));
-
+#endif
   map->Add<blink::mojom::CredentialManager>(
       base::BindRepeating(&ChromePasswordManagerClient::BindCredentialManager));
 
@@ -852,6 +852,7 @@
   RegisterWebUIControllerInterfaceBinder<
       media::mojom::MediaEngagementScoreDetailsProvider, MediaEngagementUI>(
       map);
+#if 0
 
   RegisterWebUIControllerInterfaceBinder<browsing_topics::mojom::PageHandler,
                                          BrowsingTopicsInternalsUI>(map);
@@ -868,6 +869,7 @@
 
   RegisterWebUIControllerInterfaceBinder<::mojom::UsbInternalsPageHandler,
                                          UsbInternalsUI>(map);
+#endif
 
   RegisterWebUIControllerInterfaceBinder<
       history_clusters_internals::mojom::PageHandlerFactory,
@@ -923,6 +925,7 @@
       most_visited::mojom::MostVisitedPageHandlerFactory, NewTabPageUI,
       NewTabPageThirdPartyUI>(map);
 
+#if 0
   auto* history_clusters_service =
       HistoryClustersServiceFactory::GetForBrowserContext(
           render_frame_host->GetProcess()->GetBrowserContext());
@@ -938,6 +941,7 @@
           history_clusters::mojom::PageHandler, HistoryUI>(map);
     }
   }
+#endif
 
   RegisterWebUIControllerInterfaceBinder<
       browser_command::mojom::CommandHandlerFactory, NewTabPageUI, WhatsNewUI>(
@@ -1288,8 +1292,7 @@
   }
 #endif  // BUILDFLAG(IS_CHROMEOS_ASH)
 
-#if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_MAC) || BUILDFLAG(IS_LINUX) || \
-    BUILDFLAG(IS_CHROMEOS)
+#if 0
   RegisterWebUIControllerInterfaceBinder<discards::mojom::DetailsProvider,
                                          DiscardsUI>(map);
 
diff -r -u --color up/chromium/chrome/browser/chrome_browser_main.cc nw/chromium/chrome/browser/chrome_browser_main.cc
--- up/chromium/chrome/browser/chrome_browser_main.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/chrome_browser_main.cc	2023-01-28 02:49:22.555557837 +0000
@@ -15,6 +15,11 @@
 #include <vector>
 
 #include "ash/constants/ash_features.h"
+
+#include "content/nw/src/browser/nw_chrome_browser_hooks.h"
+#include "content/nw/src/browser/nw_content_browser_hooks.h"
+
+
 #include "base/at_exit.h"
 #include "base/base_switches.h"
 #include "base/bind.h"
@@ -470,6 +475,9 @@
     return;
   }
 
+  if (!nw::ProcessSingletonNotificationCallbackHook(command_line, current_directory))
+    return;
+
   g_browser_process->platform_part()->PlatformSpecificCommandLineProcessing(
       command_line);
 
@@ -643,7 +651,7 @@
   g_browser_process->metrics_service()->StartUpdatingLastLiveTimestamp();
 #endif
 
-  g_browser_process->GetMetricsServicesManager()->UpdateUploadPermissions(true);
+  g_browser_process->GetMetricsServicesManager()->UpdateUploadPermissions(false);
 
 #if BUILDFLAG(ENABLE_PROCESS_SINGLETON)
   ChromeProcessSingleton::RegisterEarlySingletonFeature();
@@ -801,9 +809,13 @@
   // should be deferred to PreMainMessageLoopRunImpl.
 
   TRACE_EVENT0("startup", "ChromeBrowserMainParts::PreCreateThreads");
+
   result_code_ = PreCreateThreadsImpl();
 
   if (result_code_ == content::RESULT_CODE_NORMAL_EXIT) {
+    result_code_ = nw::MainPartsPreCreateThreadsHook();
+    if (result_code_ != content::RESULT_CODE_NORMAL_EXIT)
+      return result_code_;
     // These members must be initialized before exiting this function normally.
 #if !BUILDFLAG(IS_ANDROID)
     DCHECK(browser_creator_.get());
@@ -1119,6 +1131,8 @@
 
   result_code_ = PreMainMessageLoopRunImpl();
 
+  nw::MainPartsPreMainMessageLoopRunHook();
+
   for (auto& chrome_extra_part : chrome_extra_parts_)
     chrome_extra_part->PreMainMessageLoopRun();
 
@@ -1237,8 +1251,8 @@
 
   language::LanguageUsageMetrics::RecordAcceptLanguages(
       profile->GetPrefs()->GetString(language::prefs::kAcceptLanguages));
-  translate::TranslateMetricsLoggerImpl::LogApplicationStartMetrics(
-      ChromeTranslateClient::CreateTranslatePrefs(profile->GetPrefs()));
+  //translate::TranslateMetricsLoggerImpl::LogApplicationStartMetrics(
+  //    ChromeTranslateClient::CreateTranslatePrefs(profile->GetPrefs()));
 // On ChromeOS results in a crash. https://crbug.com/1151558
 #if !BUILDFLAG(IS_CHROMEOS_ASH)
   language::LanguageUsageMetrics::RecordPageLanguages(
@@ -1542,6 +1556,7 @@
 #endif  // BUILDFLAG(ENABLE_BACKGROUND_MODE)
   // Post-profile init ---------------------------------------------------------
 
+#if 0
   TranslateService::Initialize();
   if (base::FeatureList::IsEnabled(features::kGeoLanguage) ||
       base::FeatureList::IsEnabled(language::kExplicitLanguageAsk) ||
@@ -1550,7 +1565,7 @@
     language::GeoLanguageProvider::GetInstance()->StartUp(
         browser_process_->local_state());
   }
-
+#endif
   // Needs to be done before PostProfileInit, since login manager on CrOS is
   // called inside PostProfileInit.
   content::WebUIControllerFactory::RegisterFactory(
@@ -1583,7 +1598,7 @@
   // Call `PostProfileInit()`and set it up for profiles created later.
   profile_init_manager_ = std::make_unique<ProfileInitManager>(this, profile);
 
-#if !BUILDFLAG(IS_ANDROID) && !BUILDFLAG(IS_CHROMEOS_ASH)
+#if 0 //!BUILDFLAG(IS_ANDROID) && !BUILDFLAG(IS_CHROMEOS_ASH)
   // Execute first run specific code after the PrefService has been initialized
   // and preferences have been registered since some of the import code depends
   // on preferences.
@@ -1639,7 +1654,7 @@
   //
   // This can't be created in the BrowserProcessImpl constructor because it
   // needs to read prefs that get set after that runs.
-  browser_process_->intranet_redirect_detector();
+  //browser_process_->intranet_redirect_detector();
 #endif
 
 #if BUILDFLAG(ENABLE_PRINT_PREVIEW) && !defined(OFFICIAL_BUILD)
@@ -1855,7 +1870,7 @@
   for (auto& chrome_extra_part : chrome_extra_parts_)
     chrome_extra_part->PostMainMessageLoopRun();
 
-  TranslateService::Shutdown();
+  //TranslateService::Shutdown();
 
 #if BUILDFLAG(ENABLE_PROCESS_SINGLETON)
   if (notify_result_ == ProcessSingleton::PROCESS_NONE)
@@ -1933,6 +1948,8 @@
 
   device_event_log::Shutdown();
 
+  nw::MainPartsPostDestroyThreadsHook();
+
 #if BUILDFLAG(IS_CHROMEOS_ASH)
   ash::HWDataUsageController::Shutdown();
   arc::StabilityMetricsManager::Shutdown();
diff -r -u --color up/chromium/chrome/browser/chrome_browser_main_mac.mm nw/chromium/chrome/browser/chrome_browser_main_mac.mm
--- up/chromium/chrome/browser/chrome_browser_main_mac.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/chrome_browser_main_mac.mm	2023-01-28 02:49:22.555557837 +0000
@@ -4,6 +4,9 @@
 
 #include "chrome/browser/chrome_browser_main_mac.h"
 
+#include "content/nw/src/nw_base.h"
+#include "base/strings/utf_string_conversions.h"
+
 #import <Cocoa/Cocoa.h>
 
 #include "base/bind.h"
@@ -90,6 +93,7 @@
   }
   updater::SchedulePeriodicTasks();
 
+#if 0
   // Disk image installation is sort of a first-run task, so it shares the
   // no first run switches.
   //
@@ -110,6 +114,7 @@
       exit(0);
     }
   }
+#endif
 #endif  // !BUILDFLAG(GOOGLE_CHROME_FOR_TESTING_BRANDING)
 
   // Create the app delegate. This object is intentionally leaked as a global
@@ -118,7 +123,7 @@
   [NSApp setDelegate:app_controller];
 
   chrome::BuildMainMenu(NSApp, app_controller,
-                        l10n_util::GetStringUTF16(IDS_PRODUCT_NAME), false);
+                        base::UTF8ToUTF16(nw::package()->GetName()), true);
   [app_controller mainMenuCreated];
 
   ui::WarmScreenCapture();
diff -r -u --color up/chromium/chrome/browser/chrome_browser_main_win.cc nw/chromium/chrome/browser/chrome_browser_main_win.cc
--- up/chromium/chrome/browser/chrome_browser_main_win.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/chrome_browser_main_win.cc	2023-01-28 02:49:22.555557837 +0000
@@ -393,6 +393,7 @@
       l10n_util::GetStringUTF16(IDS_UNINSTALL_CLOSE_APP));
 }
 
+#if 0
 void MaybePostSettingsResetPrompt() {
   if (base::FeatureList::IsEnabled(safe_browsing::kSettingsResetPrompt)) {
     content::GetUIThreadTaskRunner({base::TaskPriority::BEST_EFFORT})
@@ -401,6 +402,7 @@
                        safe_browsing::MaybeShowSettingsResetPromptWithDelay));
   }
 }
+#endif
 
 // Updates all Progressive Web App launchers in |profile_dir| to the latest
 // version.
@@ -617,6 +619,7 @@
   // complete run of the Chrome Cleanup tool. If post-cleanup settings reset is
   // enabled, we delay checks for settings reset prompt until the scheduled
   // reset is finished.
+#if 0
   if (safe_browsing::PostCleanupSettingsResetter::IsEnabled() &&
       !base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kAppId)) {
     // Using last opened profiles, because we want to find reset the profile
@@ -630,6 +633,8 @@
   } else {
     MaybePostSettingsResetPrompt();
   }
+#endif
+
   // Record UMA data about whether the fault-tolerant heap is enabled.
   // Use a delayed task to minimize the impact on startup time.
   content::GetUIThreadTaskRunner({})->PostDelayedTask(
diff -r -u --color up/chromium/chrome/browser/chrome_content_browser_client.cc nw/chromium/chrome/browser/chrome_content_browser_client.cc
--- up/chromium/chrome/browser/chrome_content_browser_client.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/chrome_content_browser_client.cc	2023-01-28 02:49:22.555557837 +0000
@@ -1,8 +1,11 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wunreachable-code"
 
 #include "chrome/browser/chrome_content_browser_client.h"
+#include "content/browser/renderer_host/render_process_host_impl.h"
+#include "components/crash/core/app/crash_reporter_client.h"
 
 #include <algorithm>
 #include <iterator>
@@ -12,6 +15,12 @@
 #include <utility>
 #include <vector>
 
+#include "content/nw/src/common/nw_content_common_hooks.h"
+#include "content/nw/src/common/shell_switches.h"
+#include "content/nw/src/nw_content.h"
+#include "content/nw/src/nw_base.h"
+#include "chrome/browser/profiles/profile_manager.h"
+
 #include "base/base_switches.h"
 #include "base/bind.h"
 #include "base/callback.h"
@@ -569,6 +578,7 @@
 #include "extensions/browser/extension_navigation_throttle.h"
 #include "extensions/browser/extension_protocols.h"
 #include "extensions/browser/extension_registry.h"
+#include "chrome/browser/extensions/extension_service.h"
 #include "extensions/browser/extension_util.h"
 #include "extensions/browser/guest_view/web_view/web_view_guest.h"
 #include "extensions/browser/guest_view/web_view/web_view_permission_helper.h"
@@ -663,7 +673,7 @@
 #endif
 
 // This should be after all other #includes.
-#if defined(_WINDOWS_)  // Detect whether windows.h was included.
+#if 0 //defined(_WINDOWS_)  // Detect whether windows.h was included.
 #include "base/win/windows_h_disallowed.h"
 #endif  // defined(_WINDOWS_)
 
@@ -961,7 +971,7 @@
   base::PathService::Get(chrome::DIR_CRASH_DUMPS, &dumps_path);
   {
     ANNOTATE_SCOPED_MEMORY_LEAK;
-    bool upload = !getenv(env_vars::kHeadless);
+    bool upload = !crash_reporter::GetCrashReporterClient()->IsRunningUnattended();
     breakpad::CrashHandlerHostLinux* crash_handler =
         new breakpad::CrashHandlerHostLinux(process_type, dumps_path, upload);
     crash_handler->StartUploaderThread();
@@ -1037,8 +1047,7 @@
  public:
   explicit CertificateReportingServiceCertReporter(
       content::WebContents* web_contents)
-      : service_(CertificateReportingServiceFactory::GetForBrowserContext(
-            web_contents->GetBrowserContext())) {}
+     {}
 
   CertificateReportingServiceCertReporter(
       const CertificateReportingServiceCertReporter&) = delete;
@@ -1050,15 +1059,16 @@
   // SSLCertReporter implementation
   void ReportInvalidCertificateChain(
       const std::string& serialized_report) override {
-    service_->Send(serialized_report);
+    //service_->Send(serialized_report);
   }
 
  private:
-  raw_ptr<CertificateReportingService> service_;
+  //raw_ptr<CertificateReportingService> service_;
 };
 
 #if BUILDFLAG(ENABLE_EXTENSIONS)
 
+#if 0
 AppLoadedInTabSource ClassifyAppLoadedInTabSource(
     const GURL& opener_url,
     const extensions::Extension* target_platform_app) {
@@ -1083,6 +1093,7 @@
   // Source was a different page inside the app.
   return APP_LOADED_IN_TAB_SOURCE_APP;
 }
+#endif
 
 // Returns true if there is is an extension matching `url` in
 // `render_process_id` with `permission`.
@@ -1995,6 +2006,24 @@
   return true;
 }
 
+bool ChromeContentBrowserClient::IsNWOrigin(const url::Origin& origin, content::BrowserContext* context) {
+  return IsNWURL(origin.GetURL(), context);
+}
+
+bool ChromeContentBrowserClient::IsNWURL(const GURL& url, content::BrowserContext* context) {
+  const extensions::ExtensionRegistry* registry =
+    extensions::ExtensionRegistry::Get(context);
+  const extensions::Extension* extension =
+    registry->enabled_extensions().GetByID(nw::GetMainExtensionId());
+  if (!extension)
+    return false;
+  if (url.SchemeIs(extensions::kExtensionScheme) && url.host() == nw::GetMainExtensionId())
+    return true;
+  if (extension->web_extent().MatchesURL(url))
+    return true;
+  return false;
+}
+
 bool ChromeContentBrowserClient::ShouldTreatURLSchemeAsFirstPartyWhenTopLevel(
     base::StringPiece scheme,
     bool is_embedded_origin_secure) {
@@ -2248,12 +2277,31 @@
 bool ChromeContentBrowserClient::ShouldTryToUseExistingProcessHost(
     content::BrowserContext* browser_context,
     const GURL& url) {
+  // PDF extension should use new process, or there is a loop of IPC
+  // message BrowserPluginHostMsg_SetFocus and InputMsg_SetFocus
+  // #4335
+
+  if (url.SchemeIs(extensions::kExtensionScheme)) {
+    if (url.host() == nw::GetMainExtensionId() && !content::RenderProcessHostImpl::main_host())
+      return false; //other extensions could load before the main
+                    //extension NWJS#5483
+    if (url.host() == extension_misc::kPdfExtensionId)
+      return false;
+  } else if (url.SchemeIs(content::kGuestScheme))
+    return false;
+
+  if (nw::PinningRenderer())
+    return true;
+  else
+    return false;
+#if 0
   // Top Chrome WebUI should try to share a RenderProcessHost with other
   // existing Top Chrome WebUI.
   if (IsTopChromeWebUIURL(url))
     return true;
 
   return false;
+#endif
 }
 
 bool ChromeContentBrowserClient::ShouldEmbeddedFramesTryToReuseExistingProcess(
@@ -2327,9 +2375,11 @@
 ChromeContentBrowserClient::GetOriginsRequiringDedicatedProcess() {
   std::vector<url::Origin> isolated_origin_list;
 
+#if 0
   if (DoesGaiaOriginRequireDedicatedProcess()) {
     isolated_origin_list.push_back(GaiaUrls::GetInstance()->gaia_origin());
   }
+#endif
 
 #if BUILDFLAG(ENABLE_EXTENSIONS)
   auto origins_from_extensions = ChromeContentBrowserClientExtensionsPart::
@@ -2593,7 +2643,10 @@
                                   homedir.value().c_str());
 #endif
 
+  command_line->AppendSwitchPath(switches::kNWAppPath, nw::package()->path());
   if (process_type == switches::kRendererProcess) {
+    command_line->AppendSwitch(switches::kNWJS);
+
     content::RenderProcessHost* process =
         content::RenderProcessHost::FromID(child_process_id);
     Profile* profile =
@@ -2795,6 +2848,7 @@
 
     // Please keep this in alphabetical order.
     static const char* const kSwitchNames[] = {
+      switches::kEnableSpellChecking,
       autofill::switches::kIgnoreAutocompleteOffForAutofill,
       autofill::switches::kShowAutofillSignatures,
 #if BUILDFLAG(IS_CHROMEOS_ASH)
@@ -2946,6 +3000,9 @@
 }
 
 gfx::ImageSkia ChromeContentBrowserClient::GetDefaultFavicon() {
+  gfx::ImageSkia* icon = nw::GetAppIcon();
+  if (icon)
+    return *icon;
   return favicon::GetDefaultFavicon().AsImageSkia();
 }
 
@@ -3073,6 +3130,20 @@
 #endif
 }
 
+base::FilePath ChromeContentBrowserClient::GetRootPath() {
+  std::string id = nw::GetMainExtensionId();
+  base::FilePath path;
+  extensions::ExtensionRegistry* extension_registry =
+    extensions::ExtensionRegistry::Get(ProfileManager::GetPrimaryUserProfile());
+  if (extension_registry) {
+    const extensions::Extension* extension =
+      extension_registry->GetExtensionById(id, extensions::ExtensionRegistry::EVERYTHING);
+    if (extension)
+      path = extension->path();
+  }
+  return path;
+}
+
 void ChromeContentBrowserClient::AllowWorkerFileSystem(
     const GURL& url,
     content::BrowserContext* browser_context,
@@ -3669,12 +3740,18 @@
   DCHECK(profile);
   *no_javascript_access = false;
 
+  auto* registry = extensions::ExtensionRegistry::Get(profile);
+  if (registry) {
+    const Extension* extension =
+        registry->enabled_extensions().GetExtensionOrAppByURL(opener_url);
+    if (extension && extension->is_nwjs_app())
+      return true;
+  }
   // If the opener is trying to create a background window but doesn't have
   // the appropriate permission, fail the attempt.
   if (container_type == content::mojom::WindowContainerType::BACKGROUND) {
 #if BUILDFLAG(ENABLE_EXTENSIONS)
     auto* process_map = extensions::ProcessMap::Get(profile);
-    auto* registry = extensions::ExtensionRegistry::Get(profile);
     if (!URLHasExtensionPermission(process_map, registry, opener_url,
                                    opener->GetProcess()->GetID(),
                                    APIPermissionID::kBackground)) {
@@ -3705,10 +3782,12 @@
   if (target_url.SchemeIs(extensions::kExtensionScheme)) {
     // Intentionally duplicating |registry| code from above because we want to
     // reduce calls to retrieve them as this function is a SYNC IPC handler.
-    auto* registry = extensions::ExtensionRegistry::Get(profile);
     const Extension* extension =
         registry->enabled_extensions().GetExtensionOrAppByURL(target_url);
     if (extension && extension->is_platform_app()) {
+#if 1
+      return true;
+#else
       UMA_HISTOGRAM_ENUMERATION(
           "Extensions.AppLoadedInTab",
           ClassifyAppLoadedInTabSource(opener_url, extension),
@@ -3716,6 +3795,7 @@
 
       // window.open() may not be used to load v2 apps in a regular tab.
       return false;
+#endif
     }
   }
 #endif
@@ -4081,7 +4161,7 @@
       web_contents->GetPrimaryMainFrame()->GetSiteInstance()->GetSiteURL(),
       web_contents, GetWebTheme());
 
-  web_prefs->translate_service_available = TranslateService::IsAvailable(prefs);
+  web_prefs->translate_service_available = false; //TranslateService::IsAvailable(prefs);
 
   absl::optional<ui::CaptionStyle> style =
       captions::GetCaptionStyleFromUserSettings(prefs,
@@ -4111,6 +4191,8 @@
 
   for (ChromeContentBrowserClientParts* parts : extra_parts_)
     parts->OverrideWebkitPrefs(web_contents, web_prefs);
+
+  nw::OverrideWebkitPrefsHook(web_contents, web_prefs);
 }
 
 bool ChromeContentBrowserClientParts::OverrideWebPreferencesAfterNavigation(
@@ -4898,6 +4980,7 @@
       &throttles);
 #endif
 
+#if 0
   // g_browser_process->safe_browsing_service() may be null in unittests.
   safe_browsing::SafeBrowsingUIManager* ui_manager =
       g_browser_process->safe_browsing_service()
@@ -4913,6 +4996,7 @@
         std::make_unique<safe_browsing::DelayedWarningNavigationThrottle>(
             handle));
   }
+#endif
 
 #if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_MAC) || BUILDFLAG(IS_LINUX)
   MaybeAddThrottle(browser_switcher::BrowserSwitcherNavigationThrottle::
@@ -5534,9 +5618,9 @@
   // gets approval from ChildProcessSecurityPolicy. Keep this logic in sync with
   // ExtensionWebContentsObserver::RenderFrameCreated.
   Manifest::Type type = extension->GetType();
-  if ((type == Manifest::TYPE_EXTENSION ||
+  if (type == Manifest::TYPE_NWJS_APP || ((type == Manifest::TYPE_EXTENSION ||
        type == Manifest::TYPE_LEGACY_PACKAGED_APP) &&
-      extensions::util::AllowFileAccess(extension->id(), browser_context)) {
+      extensions::util::AllowFileAccess(extension->id(), browser_context))) {
     factories->emplace(
         url::kFileScheme,
         SpecialAccessFileURLLoaderFactory::Create(render_process_id));
@@ -6330,6 +6414,9 @@
     bool safe_browsing_enabled_for_profile,
     bool should_check_on_sb_disabled,
     const std::vector<std::string>& allowlist_domains) {
+#if 1
+  return nullptr;
+#else
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
 
   // Should not bypass safe browsing check if the check is for enterprise
@@ -6352,6 +6439,7 @@
   }
 
   return safe_browsing_url_checker_delegate_;
+#endif
 }
 
 safe_browsing::RealTimeUrlLookupServiceBase*
@@ -6359,6 +6447,7 @@
     content::BrowserContext* browser_context,
     bool is_enterprise_lookup_enabled,
     bool is_consumer_lookup_enabled) {
+#if 0
   // |safe_browsing_service_| may be unavailable in tests.
   if (!safe_browsing_service_) {
     return nullptr;
@@ -6377,6 +6466,7 @@
     return safe_browsing::RealTimeUrlLookupServiceFactory::GetForProfile(
         profile);
   }
+#endif
   return nullptr;
 }
 
diff -r -u --color up/chromium/chrome/browser/chrome_content_browser_client.h nw/chromium/chrome/browser/chrome_content_browser_client.h
--- up/chromium/chrome/browser/chrome_content_browser_client.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/chrome_content_browser_client.h	2023-01-28 02:49:22.555557837 +0000
@@ -170,12 +170,14 @@
   bool ShouldTreatURLSchemeAsFirstPartyWhenTopLevel(
       base::StringPiece scheme,
       bool is_embedded_origin_secure) override;
+  bool IsNWOrigin(const url::Origin& origin, content::BrowserContext* context) override;
   bool ShouldIgnoreSameSiteCookieRestrictionsWhenTopLevel(
       base::StringPiece scheme,
       bool is_embedded_origin_secure) override;
   std::string GetSiteDisplayNameForCdmProcess(
       content::BrowserContext* browser_context,
       const GURL& site_url) override;
+  static bool IsNWURL(const GURL& origin, content::BrowserContext* context);
   void OverrideURLLoaderFactoryParams(
       content::BrowserContext* browser_context,
       const url::Origin& origin,
@@ -286,6 +288,7 @@
       const GURL& destination_url,
       base::OnceCallback<void(file_access::ScopedFileAccess)>
           continuation_callback) override;
+  base::FilePath GetRootPath() override;
   void AllowWorkerFileSystem(
       const GURL& url,
       content::BrowserContext* browser_context,
diff -r -u --color up/chromium/chrome/browser/chrome_content_browser_client_receiver_bindings.cc nw/chromium/chrome/browser/chrome_content_browser_client_receiver_bindings.cc
--- up/chromium/chrome/browser/chrome_content_browser_client_receiver_bindings.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/chrome_content_browser_client_receiver_bindings.cc	2023-01-28 02:49:22.559557879 +0000
@@ -6,6 +6,8 @@
 
 #include "chrome/browser/chrome_content_browser_client.h"
 
+#pragma clang diagnostic ignored "-Wunused-function"
+
 #include "base/bind.h"
 #include "base/metrics/histogram_functions.h"
 #include "build/build_config.h"
diff -r -u --color up/chromium/chrome/browser/component_updater/component_updater_prefs.cc nw/chromium/chrome/browser/component_updater/component_updater_prefs.cc
--- up/chromium/chrome/browser/component_updater/component_updater_prefs.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/component_updater/component_updater_prefs.cc	2023-01-28 02:49:22.587558175 +0000
@@ -20,7 +20,7 @@
 void RegisterPrefs(PrefRegistrySimple* registry) {
   RegisterComponentUpdateServicePrefs(registry);
   RegisterPrefsForRecoveryComponent(registry);
-  AutofillStatesComponentInstallerPolicy::RegisterPrefs(registry);
+  //AutofillStatesComponentInstallerPolicy::RegisterPrefs(registry);
 }
 
 }  // namespace component_updater
diff -r -u --color up/chromium/chrome/browser/component_updater/file_type_policies_component_installer.cc nw/chromium/chrome/browser/component_updater/file_type_policies_component_installer.cc
--- up/chromium/chrome/browser/component_updater/file_type_policies_component_installer.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/component_updater/file_type_policies_component_installer.cc	2023-01-28 02:49:22.591558217 +0000
@@ -39,6 +39,7 @@
 const char kFileTypePoliciesManifestName[] = "File Type Policies";
 
 void LoadFileTypesFromDisk(const base::FilePath& pb_path) {
+#if 0
   if (pb_path.empty())
     return;
 
@@ -53,6 +54,7 @@
 
   safe_browsing::FileTypePolicies::GetInstance()->PopulateFromDynamicUpdate(
       binary_pb);
+#endif
 }
 
 }  // namespace
diff -r -u --color up/chromium/chrome/browser/component_updater/registration.cc nw/chromium/chrome/browser/component_updater/registration.cc
--- up/chromium/chrome/browser/component_updater/registration.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/component_updater/registration.cc	2023-01-28 02:49:22.591558217 +0000
@@ -102,13 +102,15 @@
 namespace component_updater {
 
 void RegisterComponentsForUpdate() {
-  auto* const cus = g_browser_process->component_updater();
 
+#if 0
 #if BUILDFLAG(IS_WIN)
   RegisterRecoveryImprovedComponent(cus, g_browser_process->local_state());
 #endif  // BUILDFLAG(IS_WIN)
+#endif  // 0
 
 #if BUILDFLAG(IS_MAC)
+  auto* const cus = g_browser_process->component_updater();
   RegisterRecoveryImprovedComponent(cus, g_browser_process->local_state());
   RegisterRecoveryComponent(cus, g_browser_process->local_state());
 #endif  // BUILDFLAG(IS_MAC)
@@ -118,9 +120,10 @@
 #endif
 
 #if BUILDFLAG(ENABLE_WIDEVINE_CDM_COMPONENT)
-  RegisterWidevineCdmComponent(cus);
+  //RegisterWidevineCdmComponent(cus);
 #endif  // BUILDFLAG(ENABLE_WIDEVINE_CDM_COMPONENT)
 
+#if 0
 #if BUILDFLAG(ENABLE_NACL) && !BUILDFLAG(IS_ANDROID)
 #if BUILDFLAG(IS_CHROMEOS_ASH)
   // PNaCl on Chrome OS is on rootfs and there is no need to download it. But
@@ -224,6 +227,7 @@
 #endif  // BUILDFLAG(ENABLE_SCREEN_AI_SERVICE)
 
   RegisterCommerceHeuristicsComponent(cus);
+#endif // disable component updater
 }
 
 }  // namespace component_updater
diff -r -u --color up/chromium/chrome/browser/component_updater/sw_reporter_installer_win.cc nw/chromium/chrome/browser/component_updater/sw_reporter_installer_win.cc
--- up/chromium/chrome/browser/component_updater/sw_reporter_installer_win.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/component_updater/sw_reporter_installer_win.cc	2023-01-28 02:49:22.591558217 +0000
@@ -104,12 +104,15 @@
   UMA_HISTOGRAM_BOOLEAN("SoftwareReporter.LastUploadResult", last_result);
 }
 
+#if 0
 void ReportConfigurationError(SoftwareReporterConfigurationError error) {
   UMA_HISTOGRAM_ENUMERATION("SoftwareReporter.ConfigurationErrors", error);
 }
+#endif
 
 // Ensures |str| contains only alphanumeric characters and characters from
 // |extras|, and is not longer than |max_length|.
+#if 0
 bool ValidateString(const std::string& str,
                     const std::string& extras,
                     size_t max_length) {
@@ -119,6 +122,9 @@
                   extras.find(c) != std::string::npos;
          });
 }
+#endif
+
+#if 0
 
 std::string GenerateSessionId() {
   std::string session_id;
@@ -264,6 +270,8 @@
   ready_callback.Run(*prompt_seed, std::move(invocations));
 }
 
+#endif
+
 void ReportOnDemandUpdateSucceededHistogram(bool value) {
   UMA_HISTOGRAM_BOOLEAN("SoftwareReporter.OnDemandUpdateSucceeded", value);
 }
@@ -310,12 +318,14 @@
     const base::Version& version,
     const base::FilePath& install_dir,
     base::Value manifest) {
+#if 0
   ScheduleSoftwareReporterWithManifest(
       install_dir.Append(kSwReporterExeName), version,
       std::move(manifest).TakeDict(),
       // Unless otherwise specified by a unit test, This will post
       // |safe_browsing::OnSwReporterReady| to the UI thread.
       on_component_ready_callback_);
+#endif
 }
 
 base::FilePath SwReporterInstallerPolicy::GetRelativeInstallDir() const {
@@ -335,9 +345,11 @@
 update_client::InstallerAttributes
 SwReporterInstallerPolicy::GetInstallerAttributes() const {
   update_client::InstallerAttributes attributes;
+#if 0
   // Pass the tag parameter to the installer as the "tag" attribute; it will be
   // used to choose which binary is downloaded.
   attributes["tag"] = GetReporterCohortTag(prefs_);
+#endif
   return attributes;
 }
 
@@ -345,6 +357,8 @@
 // then assigning the tag randomly if it's not found in either.
 std::string SwReporterInstallerPolicy::GetReporterCohortTag(
     PrefService* prefs) const {
+  return "stable";
+#if 0
   const std::string feature_tag =
       safe_browsing::kReporterDistributionTagParam.Get();
   if (!feature_tag.empty()) {
@@ -392,6 +406,7 @@
   prefs->SetString(prefs::kSwReporterCohort, selected_tag);
   prefs->SetTime(prefs::kSwReporterCohortSelectionTime, base::Time::Now());
   return selected_tag;
+#endif
 }
 
 SwReporterOnDemandFetcher::SwReporterOnDemandFetcher(
@@ -425,6 +440,9 @@
 
 void RegisterSwReporterComponent(ComponentUpdateService* cus,
                                  PrefService* prefs) {
+#if 1
+  return;
+#else
   base::ScopedClosureRunner runner(std::move(GetRegistrationCBForTesting()));
 
   // Don't install the component if not allowed by policy.  This prevents
@@ -457,6 +475,7 @@
                                                   std::move(ready_callback)));
 
   installer->Register(cus, runner.Release());
+#endif
 }
 
 void SetRegisterSwReporterComponentCallbackForTesting(
diff -r -u --color up/chromium/chrome/browser/component_updater/widevine_cdm_component_installer.cc nw/chromium/chrome/browser/component_updater/widevine_cdm_component_installer.cc
--- up/chromium/chrome/browser/component_updater/widevine_cdm_component_installer.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/component_updater/widevine_cdm_component_installer.cc	2023-01-28 02:49:22.595558259 +0000
@@ -100,7 +100,7 @@
   return base_path.AppendASCII("_platform_specific").AppendASCII(platform_arch);
 }
 
-#if !BUILDFLAG(IS_LINUX) && !BUILDFLAG(IS_CHROMEOS)
+#if 1 //!BUILDFLAG(IS_LINUX) && !BUILDFLAG(IS_CHROMEOS)
 // On Linux the Widevine CDM is loaded at startup before the zygote is locked
 // down. As a result there is no need to register the CDM with Chrome as it
 // can't be used until Chrome is restarted. Instead we simply update the hint
@@ -260,7 +260,7 @@
     return;
   }
 
-#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
+#if 0 //BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
   VLOG(1) << "Updating hint file with Widevine CDM " << cdm_version;
 
   // This is running on a thread that allows IO, so simply update the hint file.
@@ -281,4 +281,12 @@
   installer->Register(cus, base::OnceClosure());
 }
 
+void RegisterWidevineCdmComponent(ComponentUpdateService* cus,
+                                  base::OnceClosure callback) {
+  auto installer = base::MakeRefCounted<ComponentInstaller>(
+          std::make_unique<WidevineCdmComponentInstallerPolicy>());
+  installer->Register(cus, std::move(callback));
+}
+
+
 }  // namespace component_updater
diff -r -u --color up/chromium/chrome/browser/component_updater/widevine_cdm_component_installer.h nw/chromium/chrome/browser/component_updater/widevine_cdm_component_installer.h
--- up/chromium/chrome/browser/component_updater/widevine_cdm_component_installer.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/component_updater/widevine_cdm_component_installer.h	2023-01-28 02:49:22.595558259 +0000
@@ -5,6 +5,8 @@
 #ifndef CHROME_BROWSER_COMPONENT_UPDATER_WIDEVINE_CDM_COMPONENT_INSTALLER_H_
 #define CHROME_BROWSER_COMPONENT_UPDATER_WIDEVINE_CDM_COMPONENT_INSTALLER_H_
 
+#include "base/callback_forward.h"
+
 namespace component_updater {
 
 class ComponentUpdateService;
@@ -17,6 +19,7 @@
 // 4) Register the Widevine CDM (via the adapter) with Chrome.
 // The first part is IO intensive so we do it asynchronously in the file thread.
 void RegisterWidevineCdmComponent(ComponentUpdateService* cus);
+void RegisterWidevineCdmComponent(ComponentUpdateService* cus, base::OnceClosure callback);
 
 }  // namespace component_updater
 
diff -r -u --color up/chromium/chrome/browser/devtools/devtools_ui_bindings.cc nw/chromium/chrome/browser/devtools/devtools_ui_bindings.cc
--- up/chromium/chrome/browser/devtools/devtools_ui_bindings.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/devtools/devtools_ui_bindings.cc	2023-01-28 02:49:22.615558471 +0000
@@ -2,6 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "extensions/browser/extension_protocols.h"
 #include "chrome/browser/devtools/devtools_ui_bindings.h"
 
 #include <stddef.h>
@@ -581,7 +582,8 @@
     return true;
   }
 
-  return SanitizeFrontendURL(url).spec() == url.spec();
+  //NW: webview.showDevTools in container; webview-localfile case; changed in c2db881506f
+  return SanitizeFrontendURL(url).spec() == url.spec() || url == GURL(url::kAboutBlankURL);
 }
 
 bool DevToolsUIBindings::IsValidRemoteFrontendURL(const GURL& url) {
@@ -864,6 +866,15 @@
   resource_request.headers.AddHeadersFromString(headers);
 
   NetworkResourceLoader::URLLoaderFactoryHolder url_loader_factory;
+  if (gurl.SchemeIs("chrome-extension")) {
+    content::RenderFrameHost* frame_host = web_contents()->GetPrimaryMainFrame();
+    mojo::PendingRemote<network::mojom::URLLoaderFactory> pending_remote
+      = extensions::CreateExtensionURLLoaderFactory(frame_host->GetProcess()->GetID(),
+                                                    frame_host->GetRoutingID());
+    url_loader_factory = network::SharedURLLoaderFactory::Create(
+        std::make_unique<network::WrapperPendingSharedURLLoaderFactory>(
+            std::move(pending_remote)));
+  } else
   if (gurl.SchemeIsFile()) {
     mojo::PendingRemote<network::mojom::URLLoaderFactory> pending_remote =
         content::CreateFileURLLoaderFactory(
@@ -961,8 +972,8 @@
 }
 
 void DevToolsUIBindings::RequestFileSystems() {
-  CHECK(IsValidFrontendURL(web_contents_->GetLastCommittedURL()) &&
-        frontend_host_);
+  //CHECK(IsValidFrontendURL(web_contents_->GetLastCommittedURL()) &&
+  //      frontend_host_);
   base::Value::List file_systems_value;
   for (auto const& file_system : file_helper_->GetFileSystems())
     file_systems_value.Append(CreateFileSystemValue(file_system));
@@ -971,23 +982,23 @@
 }
 
 void DevToolsUIBindings::AddFileSystem(const std::string& type) {
-  CHECK(IsValidFrontendURL(web_contents_->GetLastCommittedURL()) &&
-        frontend_host_);
+  //CHECK(IsValidFrontendURL(web_contents_->GetLastCommittedURL()) &&
+  //      frontend_host_);
   file_helper_->AddFileSystem(
       type, base::BindRepeating(&DevToolsUIBindings::ShowDevToolsInfoBar,
                                 weak_factory_.GetWeakPtr()));
 }
 
 void DevToolsUIBindings::RemoveFileSystem(const std::string& file_system_path) {
-  CHECK(IsValidFrontendURL(web_contents_->GetLastCommittedURL()) &&
-        frontend_host_);
+  //CHECK(IsValidFrontendURL(web_contents_->GetLastCommittedURL()) &&
+  //      frontend_host_);
   file_helper_->RemoveFileSystem(file_system_path);
 }
 
 void DevToolsUIBindings::UpgradeDraggedFileSystemPermissions(
     const std::string& file_system_url) {
-  CHECK(IsValidFrontendURL(web_contents_->GetLastCommittedURL()) &&
-        frontend_host_);
+  //CHECK(IsValidFrontendURL(web_contents_->GetLastCommittedURL()) &&
+  //      frontend_host_);
   file_helper_->UpgradeDraggedFileSystemPermissions(
       file_system_url,
       base::BindRepeating(&DevToolsUIBindings::ShowDevToolsInfoBar,
@@ -999,8 +1010,8 @@
     const std::string& file_system_path,
     const std::string& excluded_folders_message) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  CHECK(IsValidFrontendURL(web_contents_->GetLastCommittedURL()) &&
-        frontend_host_);
+  //CHECK(IsValidFrontendURL(web_contents_->GetLastCommittedURL()) &&
+  //      frontend_host_);
   if (!file_helper_->IsFileSystemAdded(file_system_path)) {
     IndexingDone(index_request_id, file_system_path);
     return;
@@ -1046,8 +1057,8 @@
                                       const std::string& file_system_path,
                                       const std::string& query) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  CHECK(IsValidFrontendURL(web_contents_->GetLastCommittedURL()) &&
-        frontend_host_);
+  //CHECK(IsValidFrontendURL(web_contents_->GetLastCommittedURL()) &&
+  //      frontend_host_);
   if (!file_helper_->IsFileSystemAdded(file_system_path)) {
     SearchCompleted(search_request_id,
                     file_system_path,
@@ -1503,11 +1514,15 @@
 void DevToolsUIBindings::ShowDevToolsInfoBar(
     const std::u16string& message,
     DevToolsInfoBarDelegate::Callback callback) {
+#if 1
+  std::move(callback).Run(true); // #4602
+#else
   if (!delegate_->GetInfoBarManager()) {
     std::move(callback).Run(false);
     return;
   }
   DevToolsInfoBarDelegate::Create(message, std::move(callback));
+#endif
 }
 
 void DevToolsUIBindings::AddDevToolsExtensionsToClient() {
diff -r -u --color up/chromium/chrome/browser/devtools/devtools_window.cc nw/chromium/chrome/browser/devtools/devtools_window.cc
--- up/chromium/chrome/browser/devtools/devtools_window.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/devtools/devtools_window.cc	2023-01-28 02:49:22.615558471 +0000
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 #include "chrome/browser/devtools/devtools_window.h"
+#include "net/cert/x509_certificate.h"
 
 #include <memory>
 #include <set>
@@ -396,9 +397,9 @@
 class DevToolsWindow::OwnedMainWebContents {
  public:
   explicit OwnedMainWebContents(
-      std::unique_ptr<content::WebContents> web_contents)
-      : keep_alive_(KeepAliveOrigin::DEVTOOLS_WINDOW,
-                    KeepAliveRestartOption::DISABLED),
+                  std::unique_ptr<content::WebContents> web_contents, bool headless = false)
+      : /* keep_alive_(KeepAliveOrigin::DEVTOOLS_WINDOW,
+           KeepAliveRestartOption::DISABLED), */
         web_contents_(std::move(web_contents)) {
     Profile* profile = GetProfileForDevToolsWindow(web_contents_.get());
     DCHECK(profile);
@@ -406,6 +407,11 @@
       // ScopedProfileKeepAlive does not support OTR profiles.
       profile_keep_alive_ = std::make_unique<ScopedProfileKeepAlive>(
           profile, ProfileKeepAliveOrigin::kDevToolsWindow);
+    if (!headless) //NWJS#7588: deadlock; in this NW feature, browser
+                   //quit/zero keepalive count
+                   //triggers destruction of DevToolsWindow
+      keep_alive_ = std::make_unique<ScopedKeepAlive>(KeepAliveOrigin::DEVTOOLS_WINDOW,
+                                                      KeepAliveRestartOption::DISABLED);
     }
   }
 
@@ -415,7 +421,7 @@
   }
 
  private:
-  ScopedKeepAlive keep_alive_;
+  std::unique_ptr<ScopedKeepAlive> keep_alive_;
   std::unique_ptr<ScopedProfileKeepAlive> profile_keep_alive_;
   std::unique_ptr<content::WebContents> web_contents_;
 };
@@ -808,6 +814,8 @@
 
   // If window is docked and visible, we hide it on toggle. If window is
   // undocked, we show (activate) it.
+  if (window->headless_)
+    return;
   if (!window->is_docked_ || do_open)
     window->ScheduleShow(action);
   else
@@ -950,6 +958,8 @@
   bool should_show_window =
       !browser_ || (action.type() != DevToolsToggleAction::kInspect);
 
+  should_show_window = should_show_window && !headless_;
+
   if (!browser_)
     CreateDevToolsBrowser();
 
@@ -1045,7 +1055,8 @@
                                std::unique_ptr<WebContents> main_web_contents,
                                DevToolsUIBindings* bindings,
                                WebContents* inspected_web_contents,
-                               bool can_dock)
+                               bool can_dock,
+                               bool headless)
     : frontend_type_(frontend_type),
       profile_(profile),
       main_web_contents_(main_web_contents.get()),
@@ -1054,18 +1065,25 @@
       browser_(nullptr),
       is_docked_(true),
       owned_main_web_contents_(
-          std::make_unique<OwnedMainWebContents>(std::move(main_web_contents))),
+        std::make_unique<OwnedMainWebContents>(std::move(main_web_contents), headless)),
       can_dock_(can_dock),
       close_on_detach_(true),
+      headless_(headless),
       // This initialization allows external front-end to work without changes.
       // We don't wait for docking call, but instead immediately show undocked.
       life_stage_(can_dock ? kNotLoaded : kIsDockedSet),
       action_on_load_(DevToolsToggleAction::NoOp()),
       intercepted_page_beforeunload_(false),
       ready_for_test_(false) {
+  // shouldn't own the web content in embedded cdt use case #6004
+  // or it will be double freed on quit
+  if (headless)
+    owned_main_web_contents_.release();
   // Set up delegate, so we get fully-functional window immediately.
   // It will not appear in UI though until |life_stage_ == kLoadCompleted|.
-  main_web_contents_->SetDelegate(this);
+  if (!headless) //NWJS#4709: keep delegate to web_view_guest so the
+                 //shortcut is handled there
+    main_web_contents_->SetDelegate(this);
   // Bindings take ownership over devtools as its delegate.
   bindings_->SetDelegate(this);
   // DevTools uses PageZoom::Zoom(), so main_web_contents_ requires a
@@ -1129,7 +1147,8 @@
     const std::string& settings,
     const std::string& panel,
     bool has_other_clients,
-    bool browser_connection) {
+    bool browser_connection,
+    content::WebContents* cdt_web_contents) {
   if (!AllowDevToolsFor(profile, inspected_web_contents))
     return nullptr;
 
@@ -1147,6 +1166,20 @@
   // Create WebContents with devtools.
   GURL url(GetDevToolsURL(profile, frontend_type, frontend_url, can_dock, panel,
                           has_other_clients, browser_connection));
+
+  if (cdt_web_contents) {
+    cdt_web_contents->GetController().LoadURL(
+      DecorateFrontendURL(url), content::Referrer(),
+      ui::PAGE_TRANSITION_AUTO_TOPLEVEL, std::string());
+    DevToolsUIBindings* bindings =
+      DevToolsUIBindings::ForWebContents(cdt_web_contents);
+    if (!bindings)
+      return nullptr;
+    std::unique_ptr<WebContents> cdt_contents(cdt_web_contents);
+    return new DevToolsWindow(frontend_type, profile, std::move(cdt_contents), bindings,
+                              inspected_web_contents, can_dock, true);
+  }
+
   std::unique_ptr<WebContents> main_web_contents =
       WebContents::Create(WebContents::CreateParams(profile));
   main_web_contents->GetController().LoadURL(
@@ -1324,7 +1357,8 @@
                                         int opener_render_frame_id,
                                         const std::string& frame_name,
                                         const GURL& target_url,
-                                        WebContents* new_contents) {
+                                        WebContents* new_contents,
+                                        const std::u16string& nw_window_manifest) {
   if (target_url.SchemeIs(content::kChromeDevToolsScheme) &&
       target_url.path().rfind("device_mode_emulation_frame.html") !=
           std::string::npos) {
@@ -1444,7 +1478,7 @@
 }
 
 void DevToolsWindow::ActivateWindow() {
-  if (life_stage_ != kLoadCompleted)
+  if (life_stage_ != kLoadCompleted || headless_)
     return;
   if (is_docked_ && GetInspectedBrowserWindow())
     main_web_contents_->Focus();
@@ -1599,7 +1633,7 @@
   // Docked DevToolsWindow owns its main_web_contents_ and must delete it.
   // Undocked main_web_contents_ are owned and handled by browser.
   // see crbug.com/369932
-  if (is_docked_) {
+  if (is_docked_ && !headless_) {
     CloseContents(main_web_contents_);
   } else if (browser_ && crashed) {
     browser_->window()->Close();
@@ -1634,6 +1668,10 @@
   ::ShowCertificateViewer(inspected_contents, parent, cert.get());
 }
 
+void DevToolsWindow::Close() {
+  browser_->window()->Close();
+}
+
 void DevToolsWindow::OnLoadCompleted() {
   // First seed inspected tab id for extension APIs.
   WebContents* inspected_web_contents = GetInspectedWebContents();
diff -r -u --color up/chromium/chrome/browser/devtools/devtools_window.h nw/chromium/chrome/browser/devtools/devtools_window.h
--- up/chromium/chrome/browser/devtools/devtools_window.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/devtools/devtools_window.h	2023-01-28 02:49:22.615558471 +0000
@@ -248,7 +248,10 @@
 
   content::WebContents* GetInspectedWebContents();
 
- private:
+  void Close();
+
+ public:
+
   friend class DevToolsWindowTesting;
   friend class DevToolsWindowCreationObserver;
   friend class HatsNextWebDialogBrowserTest;
@@ -299,7 +302,8 @@
                  std::unique_ptr<content::WebContents> main_web_contents,
                  DevToolsUIBindings* bindings,
                  content::WebContents* inspected_web_contents,
-                 bool can_dock);
+                 bool can_dock,
+                 bool headless = false);
 
   // External frontend is always undocked.
   static void OpenExternalFrontend(
@@ -319,7 +323,9 @@
                                 const std::string& settings,
                                 const std::string& panel,
                                 bool has_other_clients,
-                                bool browser_connection);
+                                bool browser_connection,
+                                content::WebContents* cdt_web_contents = nullptr);
+
   static GURL GetDevToolsURL(Profile* profile,
                              FrontendType frontend_type,
                              const std::string& frontend_url,
@@ -352,7 +358,7 @@
                           int opener_render_frame_id,
                           const std::string& frame_name,
                           const GURL& target_url,
-                          content::WebContents* new_contents) override;
+                          content::WebContents* new_contents, const std::u16string& nw_window_manifest) override;
   void CloseContents(content::WebContents* source) override;
   void ContentsZoomChange(bool zoom_in) override;
   void BeforeUnloadFired(content::WebContents* tab,
@@ -386,6 +392,7 @@
   void SetWhitelistedShortcuts(const std::string& message) override;
   void SetEyeDropperActive(bool active) override;
   void OpenNodeFrontend() override;
+ public:
   void InspectedContentsClosing() override;
   void OnLoadCompleted() override;
   void ReadyForTest() override;
@@ -450,6 +457,7 @@
 
   const bool can_dock_;
   bool close_on_detach_;
+  const bool headless_;
   LifeStage life_stage_;
   DevToolsToggleAction action_on_load_;
   DevToolsContentsResizingStrategy contents_resizing_strategy_;
diff -r -u --color up/chromium/chrome/browser/download/bubble/download_bubble_controller.cc nw/chromium/chrome/browser/download/bubble/download_bubble_controller.cc
--- up/chromium/chrome/browser/download/bubble/download_bubble_controller.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/download/bubble/download_bubble_controller.cc	2023-01-28 02:49:22.627558598 +0000
@@ -402,8 +402,10 @@
       ProcessDownloadWarningButtonPress(model, command);
       break;
     case DownloadCommands::REVIEW:
+#if 0
       model->ReviewScanningVerdict(
           browser_->tab_strip_model()->GetActiveWebContents());
+#endif
       break;
     case DownloadCommands::RETRY:
       RetryDownload(model, command);
diff -r -u --color up/chromium/chrome/browser/download/chrome_download_manager_delegate.cc nw/chromium/chrome/browser/download/chrome_download_manager_delegate.cc
--- up/chromium/chrome/browser/download/chrome_download_manager_delegate.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/download/chrome_download_manager_delegate.cc	2023-01-28 02:49:22.627558598 +0000
@@ -454,12 +454,14 @@
 
   download_manager_ = dm;
 
+#if 0
   safe_browsing::SafeBrowsingService* sb_service =
       g_browser_process->safe_browsing_service();
   if (sb_service && !profile_->IsOffTheRecord()) {
     // Include this download manager in the set monitored by safe browsing.
     sb_service->AddDownloadManager(dm);
   }
+#endif
 
   if (download_manager_) {
     download_manager_->AddObserver(this);
@@ -825,6 +827,7 @@
 void ChromeDownloadManagerDelegate::SanitizeSavePackageResourceName(
     base::FilePath* filename,
     const GURL& source_url) {
+#if 0
   safe_browsing::FileTypePolicies* file_type_policies =
       safe_browsing::FileTypePolicies::GetInstance();
 
@@ -836,6 +839,7 @@
   base::FilePath default_filename = base::FilePath::FromUTF8Unsafe(
       l10n_util::GetStringUTF8(IDS_DEFAULT_DOWNLOAD_FILENAME));
   *filename = filename->AddExtension(default_filename.BaseName().value());
+#endif
 }
 
 void ChromeDownloadManagerDelegate::SanitizeDownloadParameters(
@@ -875,14 +879,14 @@
   download::DownloadItemRenameHandler* handler = download->GetRenameHandler();
   if (handler) {
     handler->OpenDownload();
-    RecordDownloadOpen(DOWNLOAD_OPEN_METHOD_RENAME_HANDLER,
-                       download->GetMimeType());
+    //RecordDownloadOpen(DOWNLOAD_OPEN_METHOD_RENAME_HANDLER,
+    //                   download->GetMimeType());
     return;
   }
 
   if (!DownloadItemModel(download).ShouldPreferOpeningInBrowser()) {
-    RecordDownloadOpen(DOWNLOAD_OPEN_METHOD_DEFAULT_PLATFORM,
-                       download->GetMimeType());
+    //RecordDownloadOpen(DOWNLOAD_OPEN_METHOD_DEFAULT_PLATFORM,
+    //                   download->GetMimeType());
     OpenDownloadUsingPlatformHandler(download);
     return;
   }
@@ -908,8 +912,8 @@
   else
     browser->OpenURL(params);
 
-  RecordDownloadOpen(DOWNLOAD_OPEN_METHOD_DEFAULT_BROWSER,
-                     download->GetMimeType());
+  //RecordDownloadOpen(DOWNLOAD_OPEN_METHOD_DEFAULT_BROWSER,
+  //                   download->GetMimeType());
 #endif  // BUILDFLAG(IS_ANDROID)
 }
 
@@ -1656,6 +1660,7 @@
 void ChromeDownloadManagerDelegate::MaybeSendDangerousDownloadOpenedReport(
     DownloadItem* download,
     bool show_download_in_folder) {
+#if 0
 #if BUILDFLAG(FULL_SAFE_BROWSING)
   safe_browsing::DownloadProtectionService* service =
       GetDownloadProtectionService();
@@ -1671,6 +1676,7 @@
         download->GetDangerType(), download_content, base::Time::Now(),
         download->GetEndTime(), show_download_in_folder);
   }
+#endif
 }
 
 void ChromeDownloadManagerDelegate::CheckDownloadAllowed(
@@ -1730,7 +1736,8 @@
 
 #if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS) || \
     BUILDFLAG(IS_MAC)
-  absl::optional<enterprise_connectors::AnalysisSettings> settings =
+  absl::optional<enterprise_connectors::AnalysisSettings> settings;
+#if 0
       safe_browsing::DeepScanningRequest::ShouldUploadBinary(download_item);
 
   if (settings.has_value()) {
@@ -1754,6 +1761,7 @@
     }
   }
 #endif
+#endif
   std::move(callback).Run(true);
 }
 
diff -r -u --color up/chromium/chrome/browser/download/download_browsertest.cc nw/chromium/chrome/browser/download/download_browsertest.cc
--- up/chromium/chrome/browser/download/download_browsertest.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/download/download_browsertest.cc	2023-01-28 02:49:22.631558640 +0000
@@ -1389,6 +1389,7 @@
   }
 };
 
+#if 0
 class FakeSafeBrowsingService : public safe_browsing::TestSafeBrowsingService {
  public:
   FakeSafeBrowsingService() : TestSafeBrowsingService() {}
@@ -1499,6 +1500,7 @@
   mojo::Remote<device::mojom::WakeLockProvider> wake_lock_provider_;
 };
 
+#endif
 }  // namespace
 
 // NOTES:
diff -r -u --color up/chromium/chrome/browser/download/download_danger_prompt.cc nw/chromium/chrome/browser/download/download_danger_prompt.cc
--- up/chromium/chrome/browser/download/download_danger_prompt.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/download/download_danger_prompt.cc	2023-01-28 02:49:22.631558640 +0000
@@ -23,13 +23,15 @@
 using safe_browsing::ClientSafeBrowsingReportRequest;
 
 namespace {
-const char kDownloadDangerPromptPrefix[] = "Download.DownloadDangerPrompt";
+//const char kDownloadDangerPromptPrefix[] = "Download.DownloadDangerPrompt";
+
 }  // namespace
 
 void DownloadDangerPrompt::SendSafeBrowsingDownloadReport(
     ClientSafeBrowsingReportRequest::ReportType report_type,
     bool did_proceed,
     download::DownloadItem* download) {
+#if 0
   ClientDownloadResponse::Verdict download_verdict =
       safe_browsing::DownloadProtectionService::GetDownloadProtectionVerdict(
           download);
@@ -40,11 +42,13 @@
   g_browser_process->safe_browsing_service()->SendDownloadReport(
       download, report_type, did_proceed,
       /*show_download_in_folder=*/absl::nullopt);
+#endif
 }
 
 void DownloadDangerPrompt::RecordDownloadDangerPrompt(
     bool did_proceed,
     const download::DownloadItem& download) {
+#if 0
   int64_t file_type_uma_value =
       safe_browsing::FileTypePolicies::GetInstance()->UmaValueForFile(
           download.GetTargetFilePath());
@@ -60,4 +64,5 @@
                            download::GetDownloadDangerTypeString(danger_type)),
         file_type_uma_value);
   }
+#endif
 }
diff -r -u --color up/chromium/chrome/browser/download/download_item_model.cc nw/chromium/chrome/browser/download/download_item_model.cc
--- up/chromium/chrome/browser/download/download_item_model.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/download/download_item_model.cc	2023-01-28 02:49:22.631558640 +0000
@@ -750,9 +750,11 @@
       // filename. Don't base an "Always open" decision based on it. Also
       // exclude extensions.
       return download_->CanOpenDownload() &&
+#if 0
              safe_browsing::FileTypePolicies::GetInstance()
                  ->IsAllowedToOpenAutomatically(
                      download_->GetTargetFilePath()) &&
+#endif
              !download_crx_util::IsExtensionDownload(*download_);
     case DownloadCommands::PAUSE:
       return !download_->IsSavePackageDownload() &&
@@ -904,6 +906,7 @@
       DownloadUIModel::ExecuteCommand(download_commands, command);
       break;
     case DownloadCommands::DEEP_SCAN:
+#if 0
       safe_browsing::SafeBrowsingService* sb_service =
           g_browser_process->safe_browsing_service();
       if (!sb_service)
@@ -936,12 +939,14 @@
           safe_browsing::DeepScanningRequest::DeepScanTrigger::
               TRIGGER_APP_PROMPT,
           safe_browsing::DownloadCheckResult::UNKNOWN, std::move(settings));
+#endif
       break;
   }
 }
 
 DownloadItemModel::BubbleUIInfo
 DownloadItemModel::GetBubbleUIInfoForTailoredWarning() const {
+#if 0
   download::DownloadDangerType danger_type = GetDangerType();
   TailoredVerdict tailored_verdict = safe_browsing::DownloadProtectionService::
       GetDownloadProtectionTailoredVerdict(download_);
@@ -1007,10 +1012,13 @@
   }
 
   NOTREACHED();
+#endif
   return DownloadUIModel::BubbleUIInfo();
 }
 
 bool DownloadItemModel::ShouldShowTailoredWarning() const {
+  return false;
+#if 0
   if (!IsBubbleV2Enabled() ||
       !base::FeatureList::IsEnabled(safe_browsing::kDownloadTailoredWarnings)) {
     return false;
@@ -1037,6 +1045,7 @@
   }
 
   return false;
+#endif
 }
 
 bool DownloadItemModel::ShouldShowInBubble() const {
diff -r -u --color up/chromium/chrome/browser/download/download_prefs.cc nw/chromium/chrome/browser/download/download_prefs.cc
--- up/chromium/chrome/browser/download/download_prefs.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/download/download_prefs.cc	2023-01-28 02:49:22.635558682 +0000
@@ -267,10 +267,12 @@
     // automatically can change in the future. When the list is tightened, it is
     // expected that some entries in the users' auto open list will get dropped
     // permanently as a result.
+#if 0
     if (FileTypePolicies::GetInstance()->IsAllowedToOpenAutomatically(
             filename_with_extension)) {
       auto_open_by_user_.insert(extension);
     }
+#endif
   }
 }
 
@@ -281,7 +283,7 @@
     user_prefs::PrefRegistrySyncable* registry) {
   registry->RegisterBooleanPref(
       prefs::kPromptForDownload,
-      false,
+      true,
       user_prefs::PrefRegistrySyncable::SYNCABLE_PREF);
   registry->RegisterStringPref(prefs::kDownloadExtensionsToOpen, std::string());
   registry->RegisterListPref(prefs::kDownloadExtensionsToOpenByPolicy, {});
@@ -450,11 +452,12 @@
 bool DownloadPrefs::EnableAutoOpenByUserBasedOnExtension(
     const base::FilePath& file_name) {
   base::FilePath::StringType extension = file_name.Extension();
+#if 0
   if (!FileTypePolicies::GetInstance()->IsAllowedToOpenAutomatically(
           file_name)) {
     return false;
   }
-
+#endif
   DCHECK(extension[0] == base::FilePath::kExtensionSeparator);
   extension.erase(0, 1);
 
diff -r -u --color up/chromium/chrome/browser/download/download_request_limiter.cc nw/chromium/chrome/browser/download/download_request_limiter.cc
--- up/chromium/chrome/browser/download/download_request_limiter.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/download/download_request_limiter.cc	2023-01-28 02:49:22.635558682 +0000
@@ -220,7 +220,7 @@
         new DownloadPermissionRequest(factory_.GetWeakPtr(), request_origin));
   } else {
     // Call CancelOnce() so we don't set the content settings.
-    CancelOnce(request_origin);
+    Accept(request_origin);
   }
 }
 
diff -r -u --color up/chromium/chrome/browser/download/download_stats.cc nw/chromium/chrome/browser/download/download_stats.cc
--- up/chromium/chrome/browser/download/download_stats.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/download/download_stats.cc	2023-01-28 02:49:22.635558682 +0000
@@ -27,10 +27,12 @@
     const base::FilePath& file_path,
     bool is_https,
     bool has_user_gesture) {
+#if 0
   base::UmaHistogramEnumeration("Download.ShowedDownloadWarning", danger_type,
                                 download::DOWNLOAD_DANGER_TYPE_MAX);
   safe_browsing::RecordDangerousDownloadWarningShown(
       danger_type, file_path, is_https, has_user_gesture);
+#endif
 }
 
 void RecordOpenedDangerousConfirmDialog(
diff -r -u --color up/chromium/chrome/browser/download/download_status_updater_linux.cc nw/chromium/chrome/browser/download/download_status_updater_linux.cc
--- up/chromium/chrome/browser/download/download_status_updater_linux.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/download/download_status_updater_linux.cc	2023-01-28 02:49:22.635558682 +0000
@@ -118,6 +118,7 @@
 bool IsRunning() {
   return inspector && get_unity_running && get_unity_running(inspector);
 }
+}  // namespace
 
 NO_SANITIZE("cfi-icall")
 void SetDownloadCount(int count) {
@@ -136,7 +137,6 @@
   }
 }
 
-}  // namespace
 
 void DownloadStatusUpdater::UpdateAppIconDownloadProgress(
     download::DownloadItem* download) {
diff -r -u --color up/chromium/chrome/browser/download/download_status_updater_mac.mm nw/chromium/chrome/browser/download/download_status_updater_mac.mm
--- up/chromium/chrome/browser/download/download_status_updater_mac.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/download/download_status_updater_mac.mm	2023-01-28 02:49:22.635558682 +0000
@@ -115,8 +115,12 @@
 
 void DownloadStatusUpdater::UpdateAppIconDownloadProgress(
     download::DownloadItem* download) {
-  // Always update overall progress in the Dock icon.
 
+  NSDockTile *dockTile = [NSApp dockTile];
+  if (dockTile.contentView && [dockTile.contentView.subviews count] > 0)
+    return;
+
+  // Always update overall progress.
   float progress = 0;
   int download_count = 0;
   bool progress_known = GetProgress(&progress, &download_count);
diff -r -u --color up/chromium/chrome/browser/download/download_target_determiner.cc nw/chromium/chrome/browser/download/download_target_determiner.cc
--- up/chromium/chrome/browser/download/download_target_determiner.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/download/download_target_determiner.cc	2023-01-28 02:49:22.635558682 +0000
@@ -317,10 +317,12 @@
 
   // We don't replace the file extension if sfafe browsing consider the file
   // extension to be unsafe. Just let safe browsing scan the generated file.
+#if 0
   if (safe_browsing::FileTypePolicies::GetInstance()->IsCheckedBinaryFile(
           generated_filename)) {
     return generated_filename;
   }
+#endif
 
   // If no mime type or explicitly specified a name, don't replace file
   // extension.
@@ -989,12 +991,14 @@
     bool visited_referrer_before) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
   DCHECK_EQ(STATE_DETERMINE_INTERMEDIATE_PATH, next_state_);
+#if 0
   safe_browsing::RecordDownloadFileTypeAttributes(
       safe_browsing::FileTypePolicies::GetInstance()->GetFileDangerLevel(
           virtual_path_.BaseName(), download_->GetURL(),
           GetProfile()->GetPrefs()),
       download_->HasUserGesture(), visited_referrer_before,
       GetLastDownloadBypassTimestamp());
+#endif
   danger_level_ = GetDangerLevel(
       visited_referrer_before ? VISITED_REFERRER : NO_VISITS_TO_REFERRER);
   if (danger_level_ != DownloadFileType::NOT_DANGEROUS &&
@@ -1226,7 +1230,7 @@
   if (download_prefs_->IsAutoOpenEnabled(download_->GetURL(), virtual_path_) &&
       download_->HasUserGesture())
     return DownloadFileType::NOT_DANGEROUS;
-
+#if 0
   DownloadFileType::DangerLevel danger_level =
       safe_browsing::FileTypePolicies::GetInstance()->GetFileDangerLevel(
           virtual_path_.BaseName(), download_->GetURL(),
@@ -1250,9 +1254,11 @@
         ui::PAGE_TRANSITION_FROM_ADDRESS_BAR) != 0 ||
        (download_->HasUserGesture() && visits == VISITED_REFERRER)))
     return DownloadFileType::NOT_DANGEROUS;
-  return danger_level;
+#endif
+  return DownloadFileType::NOT_DANGEROUS;
 }
 
+#if 0
 absl::optional<base::Time>
 DownloadTargetDeterminer::GetLastDownloadBypassTimestamp() const {
   safe_browsing::SafeBrowsingMetricsCollector* metrics_collector =
@@ -1264,6 +1270,7 @@
                                      EventType::DANGEROUS_DOWNLOAD_BYPASS)
                            : absl::nullopt;
 }
+#endif
 
 void DownloadTargetDeterminer::OnDownloadDestroyed(
     DownloadItem* download) {
diff -r -u --color up/chromium/chrome/browser/download/download_ui_controller.cc nw/chromium/chrome/browser/download/download_ui_controller.cc
--- up/chromium/chrome/browser/download/download_ui_controller.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/download/download_ui_controller.cc	2023-01-28 02:49:22.635558682 +0000
@@ -23,6 +23,9 @@
 #include "content/public/browser/download_item_utils.h"
 #include "content/public/browser/web_contents.h"
 #include "content/public/browser/web_contents_delegate.h"
+#include "extensions/browser/app_window/app_window.h"
+#include "extensions/browser/app_window/app_window_registry.h"
+#include "extensions/browser/app_window/native_app_window.h"
 
 #if BUILDFLAG(IS_ANDROID)
 #include "chrome/browser/download/android/download_controller.h"
@@ -293,6 +296,20 @@
 #if BUILDFLAG(IS_ANDROID)
     DownloadController::CloseTabIfEmpty(web_contents, item);
 #else
+    Profile* profile = Profile::FromBrowserContext(web_contents->GetBrowserContext());
+    extensions::AppWindowRegistry* registry = extensions::AppWindowRegistry::Get(profile);
+    if (!registry)
+      return;
+    extensions::AppWindow* app_window = registry->GetAppWindowForWebContents(web_contents);
+    if (!app_window)
+      return;
+    if (web_contents->GetController().IsInitialNavigation() &&
+        app_window->NWCanClose() &&
+        !item->IsSavePackageDownload()) {
+      app_window->GetBaseWindow()->Close();
+    }
+
+#if 0
     Browser* browser = chrome::FindBrowserWithWebContents(web_contents);
     // If the download occurs in a new tab, and it's not a save page
     // download (started before initial navigation completed) close it.
@@ -306,6 +323,7 @@
         !item->IsSavePackageDownload()) {
       web_contents->Close();
     }
+#endif
 #endif  // BUILDFLAG(IS_ANDROID)
   }
 
diff -r -u --color up/chromium/chrome/browser/enterprise/connectors/analysis/content_analysis_delegate.cc nw/chromium/chrome/browser/enterprise/connectors/analysis/content_analysis_delegate.cc
--- up/chromium/chrome/browser/enterprise/connectors/analysis/content_analysis_delegate.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/enterprise/connectors/analysis/content_analysis_delegate.cc	2023-01-28 02:49:22.651558851 +0000
@@ -37,7 +37,7 @@
 #include "chrome/browser/safe_browsing/cloud_content_scanning/binary_upload_service.h"
 #include "chrome/browser/safe_browsing/cloud_content_scanning/deep_scanning_utils.h"
 #include "chrome/browser/safe_browsing/cloud_content_scanning/file_analysis_request.h"
-#include "chrome/browser/safe_browsing/download_protection/check_client_download_request.h"
+//#include "chrome/browser/safe_browsing/download_protection/check_client_download_request.h"
 #include "chrome/grit/generated_resources.h"
 #include "components/enterprise/common/proto/connectors.pb.h"
 #include "components/policy/core/common/chrome_schema.h"
diff -r -u --color up/chromium/chrome/browser/enterprise/connectors/analysis/files_request_handler.cc nw/chromium/chrome/browser/enterprise/connectors/analysis/files_request_handler.cc
--- up/chromium/chrome/browser/enterprise/connectors/analysis/files_request_handler.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/enterprise/connectors/analysis/files_request_handler.cc	2023-01-28 02:49:22.655558894 +0000
@@ -236,6 +236,7 @@
 void FilesRequestHandler::FinishRequestEarly(
     std::unique_ptr<safe_browsing::BinaryUploadService::Request> request,
     safe_browsing::BinaryUploadService::Result result) {
+#if 0
   // We add the request here in case we never actually uploaded anything, so it
   // wasn't added in OnGetRequestData
   safe_browsing::WebUIInfoSingleton::GetInstance()->AddToDeepScanRequests(
@@ -243,7 +244,7 @@
   safe_browsing::WebUIInfoSingleton::GetInstance()->AddToDeepScanResponses(
       /*token=*/"", safe_browsing::BinaryUploadService::ResultToString(result),
       enterprise_connectors::ContentAnalysisResponse());
-
+#endif
   request->FinishRequest(result,
                          enterprise_connectors::ContentAnalysisResponse());
 }
diff -r -u --color up/chromium/chrome/browser/enterprise/connectors/reporting/realtime_reporting_client.cc nw/chromium/chrome/browser/enterprise/connectors/reporting/realtime_reporting_client.cc
--- up/chromium/chrome/browser/enterprise/connectors/reporting/realtime_reporting_client.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/enterprise/connectors/reporting/realtime_reporting_client.cc	2023-01-28 02:49:22.671559063 +0000
@@ -400,7 +400,7 @@
 }
 
 std::string RealtimeReportingClient::GetProfileUserName() const {
-  return safe_browsing::GetProfileEmail(identity_manager_);
+  return std::string();
 }
 
 #if BUILDFLAG(IS_CHROMEOS_ASH)
diff -r -u --color up/chromium/chrome/browser/enterprise/connectors/reporting/reporting_service_settings.h nw/chromium/chrome/browser/enterprise/connectors/reporting/reporting_service_settings.h
--- up/chromium/chrome/browser/enterprise/connectors/reporting/reporting_service_settings.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/enterprise/connectors/reporting/reporting_service_settings.h	2023-01-28 02:49:22.671559063 +0000
@@ -43,6 +43,7 @@
 
   // All events that the reporting connector supports.
   static const constexpr char* kAllReportingEvents[] = {
+#if 0
       extensions::SafeBrowsingPrivateEventRouter::kKeyPasswordReuseEvent,
       extensions::SafeBrowsingPrivateEventRouter::kKeyPasswordChangedEvent,
       extensions::SafeBrowsingPrivateEventRouter::kKeyDangerousDownloadEvent,
@@ -53,6 +54,7 @@
       extensions::SafeBrowsingPrivateEventRouter::kKeyPasswordBreachEvent,
       kExtensionInstallEvent,
       kBrowserCrashEvent,
+#endif
   };
 
  private:
diff -r -u --color up/chromium/chrome/browser/enterprise/reporting/extension_info.cc nw/chromium/chrome/browser/enterprise/reporting/extension_info.cc
--- up/chromium/chrome/browser/enterprise/reporting/extension_info.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/enterprise/reporting/extension_info.cc	2023-01-28 02:49:22.671559063 +0000
@@ -109,6 +109,8 @@
       return em::Extension_ExtensionType_TYPE_LEGACY_PACKAGED_APP;
     case extensions::Manifest::TYPE_PLATFORM_APP:
       return em::Extension_ExtensionType_TYPE_PLATFORM_APP;
+    case extensions::Manifest::TYPE_NWJS_APP:
+      return em::Extension_ExtensionType_TYPE_PLATFORM_APP;
     case extensions::Manifest::TYPE_LOGIN_SCREEN_EXTENSION:
       return em::Extension_ExtensionType_TYPE_LOGIN_SCREEN_EXTENSION;
     case extensions::Manifest::TYPE_CHROMEOS_SYSTEM_EXTENSION:
diff -r -u --color up/chromium/chrome/browser/extensions/BUILD.gn nw/chromium/chrome/browser/extensions/BUILD.gn
--- up/chromium/chrome/browser/extensions/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/BUILD.gn	2023-01-28 02:49:22.679559147 +0000
@@ -303,14 +303,14 @@
     "api/resources_private/resources_private_api.h",
     "api/runtime/chrome_runtime_api_delegate.cc",
     "api/runtime/chrome_runtime_api_delegate.h",
-    "api/safe_browsing_private/safe_browsing_private_api.cc",
-    "api/safe_browsing_private/safe_browsing_private_api.h",
-    "api/safe_browsing_private/safe_browsing_private_event_router.cc",
-    "api/safe_browsing_private/safe_browsing_private_event_router.h",
-    "api/safe_browsing_private/safe_browsing_private_event_router_factory.cc",
-    "api/safe_browsing_private/safe_browsing_private_event_router_factory.h",
-    "api/safe_browsing_private/safe_browsing_util.cc",
-    "api/safe_browsing_private/safe_browsing_util.h",
+    #"api/safe_browsing_private/safe_browsing_private_api.cc",
+    #"api/safe_browsing_private/safe_browsing_private_api.h",
+    #"api/safe_browsing_private/safe_browsing_private_event_router.cc",
+    #"api/safe_browsing_private/safe_browsing_private_event_router.h",
+    #"api/safe_browsing_private/safe_browsing_private_event_router_factory.cc",
+    #"api/safe_browsing_private/safe_browsing_private_event_router_factory.h",
+    #"api/safe_browsing_private/safe_browsing_util.cc",
+    #"api/safe_browsing_private/safe_browsing_util.h",
     "api/search/search_api.cc",
     "api/search/search_api.h",
     "api/sessions/session_id.cc",
@@ -743,7 +743,7 @@
     "//chrome/browser/web_applications/extensions",
 
     # TODO(crbug/925153): Remove this circular dependency.
-    "//chrome/browser/safe_browsing",
+    #"//chrome/browser/safe_browsing",
   ]
 
   # Since browser and browser_extensions actually depend on each other,
@@ -793,8 +793,8 @@
     "//chrome/browser/profiles:profile",
     "//chrome/browser/resource_coordinator:intervention_policy_database_proto",
     "//chrome/browser/resource_coordinator:mojo_bindings",
-    "//chrome/browser/safe_browsing",
-    "//chrome/browser/safe_browsing:metrics_collector",
+    #"//chrome/browser/safe_browsing",
+    #"//chrome/browser/safe_browsing:metrics_collector",
     "//chrome/browser/ui/tabs:tab_enums",
     "//chrome/browser/web_applications",
     "//components/autofill_assistant/browser/public",
diff -r -u --color up/chromium/chrome/browser/extensions/activity_log/activity_log.cc nw/chromium/chrome/browser/extensions/activity_log/activity_log.cc
--- up/chromium/chrome/browser/extensions/activity_log/activity_log.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/activity_log/activity_log.cc	2023-01-28 02:49:22.679559147 +0000
@@ -222,7 +222,7 @@
 
   if (found) {
     *url = contents->GetURL();
-    *is_incognito = browser->profile()->IsOffTheRecord();
+    *is_incognito = false; //browser->profile()->IsOffTheRecord();
     return true;
   } else {
     return false;
diff -r -u --color up/chromium/chrome/browser/extensions/api/cookies/cookies_api.cc nw/chromium/chrome/browser/extensions/api/cookies/cookies_api.cc
--- up/chromium/chrome/browser/extensions/api/cookies/cookies_api.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/cookies/cookies_api.cc	2023-01-28 02:49:22.687559232 +0000
@@ -5,6 +5,7 @@
 // Implements the Chrome Extensions Cookies API.
 
 #include "chrome/browser/extensions/api/cookies/cookies_api.h"
+#include "base/strings/string_number_conversions.h"
 
 #include <memory>
 #include <utility>
@@ -30,6 +31,7 @@
 #include "components/safe_browsing/core/common/features.h"
 #include "content/public/browser/browser_context.h"
 #include "content/public/browser/browser_thread.h"
+#include "extensions/browser/guest_view/web_view/web_view_guest.h"
 #include "content/public/browser/notification_service.h"
 #include "content/public/browser/storage_partition.h"
 #include "extensions/browser/event_router.h"
@@ -68,6 +70,45 @@
   return true;
 }
 
+std::vector<std::string> Split(std::string str, const std::string delim) {
+  std::vector<std::string> result;
+  size_t position = 0;
+  while ((position = str.find(delim)) != std::string::npos)
+  {
+    result.push_back(str.substr(0, position));
+    str.erase(0, position + delim.length());
+  }
+
+  result.push_back(str);
+  return result;
+}
+
+content::StoragePartition* GetStoragePartitionFromWebview(const std::string& store_id) {
+  if (store_id.find(",") == std::string::npos)
+    return nullptr;
+
+  std::vector<std::string> processGuestIds = Split(store_id, ",");
+  if (processGuestIds.size() != 2)
+    return nullptr;
+
+  int processId, guessId;
+  if (!base::StringToInt(processGuestIds[0], &processId)
+    || !base::StringToInt(processGuestIds[1], &guessId))
+    return nullptr;
+
+  extensions::WebViewGuest* guest = extensions::WebViewGuest::FromInstanceID(
+    processId, guessId);
+
+  if (!guest)
+    return nullptr;
+
+  content::StoragePartition* partition =
+    guest->web_contents()->GetBrowserContext()->GetStoragePartition(
+      guest->web_contents()->GetSiteInstance());
+
+  return partition;
+}
+
 network::mojom::CookieManager* ParseStoreCookieManager(
     content::BrowserContext* function_context,
     bool include_incognito,
@@ -76,6 +117,11 @@
   Profile* function_profile = Profile::FromBrowserContext(function_context);
   Profile* store_profile = nullptr;
   if (!store_id->empty()) {
+    content::StoragePartition* partition = GetStoragePartitionFromWebview(*store_id);
+    if (partition) {
+      return partition->GetCookieManagerForBrowserProcess();
+    }
+
     store_profile = cookies_helpers::ChooseProfileFromStoreId(
         *store_id, function_profile, include_incognito);
     if (!store_profile) {
@@ -285,6 +331,7 @@
 }
 
 void CookiesGetFunction::NotifyExtensionTelemetry() {
+#if 0
   auto* telemetry_service =
       safe_browsing::ExtensionTelemetryServiceFactory::GetForProfile(
           Profile::FromBrowserContext(browser_context()));
@@ -300,6 +347,7 @@
       parsed_args_->details.store_id.value_or(std::string()),
       parsed_args_->details.url);
   telemetry_service->AddSignal(std::move(cookies_get_signal));
+#endif
 }
 
 CookiesGetAllFunction::CookiesGetAllFunction() {
@@ -383,6 +431,7 @@
 }
 
 void CookiesGetAllFunction::NotifyExtensionTelemetry() {
+#if 0
   auto* telemetry_service =
       safe_browsing::ExtensionTelemetryServiceFactory::GetForProfile(
           Profile::FromBrowserContext(browser_context()));
@@ -403,6 +452,7 @@
           parsed_args_->details.url.value_or(std::string()),
           parsed_args_->details.session.value_or(false));
   telemetry_service->AddSignal(std::move(cookies_get_all_signal));
+#endif
 }
 
 CookiesSetFunction::CookiesSetFunction()
diff -r -u --color up/chromium/chrome/browser/extensions/api/debugger/debugger_api.cc nw/chromium/chrome/browser/extensions/api/debugger/debugger_api.cc
--- up/chromium/chrome/browser/extensions/api/debugger/debugger_api.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/debugger/debugger_api.cc	2023-01-28 02:49:22.687559232 +0000
@@ -362,10 +362,12 @@
   if (Manifest::IsPolicyLocation(extension_->location()))
     return true;
 
+#if 0
   subscription_ = ExtensionDevToolsInfoBarDelegate::Create(
       extension_id(), extension_->name(),
       base::BindOnce(&ExtensionDevToolsClientHost::InfoBarDestroyed,
                      base::Unretained(this)));
+#endif
   return true;
 }
 
diff -r -u --color up/chromium/chrome/browser/extensions/api/desktop_capture/desktop_capture_api.cc nw/chromium/chrome/browser/extensions/api/desktop_capture/desktop_capture_api.cc
--- up/chromium/chrome/browser/extensions/api/desktop_capture/desktop_capture_api.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/desktop_capture/desktop_capture_api.cc	2023-01-28 02:49:22.691559274 +0000
@@ -94,9 +94,14 @@
     // was requested for capture.
     target_render_frame_host = web_contents->GetPrimaryMainFrame();
   } else {
-    origin = extension()->url();
     target_name = base::UTF8ToUTF16(GetExtensionTargetName());
     target_render_frame_host = render_frame_host();
+    // NWJS fix for nwjs/nw.js#4579
+    // NWJS app allows running on origins other than `chrome-extension://*/*`.
+    // The origin should then be from the senders URL, in order not to fail
+    // the origin checking in `DesktopStreamsRegistry::RequestMediaForStreamId`.
+    origin = extension()->is_nwjs_app() ? target_render_frame_host->GetLastCommittedURL().
+      DeprecatedGetOriginAsURL() : extension()->url();
   }
 
   if (!target_render_frame_host)
diff -r -u --color up/chromium/chrome/browser/extensions/api/downloads/downloads_api.cc nw/chromium/chrome/browser/extensions/api/downloads/downloads_api.cc
--- up/chromium/chrome/browser/extensions/api/downloads/downloads_api.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/downloads/downloads_api.cc	2023-01-28 02:49:22.695559316 +0000
@@ -1401,6 +1401,7 @@
     return;
   }
   RecordApiFunctions(DOWNLOADS_FUNCTION_ACCEPT_DANGER);
+#if 0
   // DownloadDangerPrompt displays a modal dialog using native widgets that the
   // user must either accept or cancel. It cannot be scripted.
   DownloadDangerPrompt* prompt = DownloadDangerPrompt::Create(
@@ -1411,6 +1412,8 @@
   if (on_prompt_created_ && !on_prompt_created_->is_null())
     std::move(*on_prompt_created_).Run(prompt);
   // Function finishes in DangerPromptCallback().
+#endif
+  DangerPromptCallback(download_id, DownloadDangerPrompt::ACCEPT);
 }
 
 void DownloadsAcceptDangerFunction::DangerPromptCallback(
diff -r -u --color up/chromium/chrome/browser/extensions/api/gcm/gcm_api.cc nw/chromium/chrome/browser/extensions/api/gcm/gcm_api.cc
--- up/chromium/chrome/browser/extensions/api/gcm/gcm_api.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/gcm/gcm_api.cc	2023-01-28 02:49:22.703559401 +0000
@@ -2,6 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "components/prefs/pref_service.h"
 #include "chrome/browser/extensions/api/gcm/gcm_api.h"
 
 #include <stddef.h>
@@ -96,6 +97,10 @@
     return false;
   }
 
+  if (!profile->GetPrefs()->GetBoolean("gcm.channel_status")) {
+    *error = "GCM is turned off.";
+    return false;
+  }
   return true;
 }
 
diff -r -u --color up/chromium/chrome/browser/extensions/api/instance_id/instance_id_api.cc nw/chromium/chrome/browser/extensions/api/instance_id/instance_id_api.cc
--- up/chromium/chrome/browser/extensions/api/instance_id/instance_id_api.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/instance_id/instance_id_api.cc	2023-01-28 02:49:22.711559485 +0000
@@ -61,9 +61,19 @@
     return RespondNow(Error(
         "chrome.instanceID not supported in incognito mode"));
   }
+
+  if (!IsEnabled()) {
+    return RespondNow(Error(
+        InstanceIDResultToError(instance_id::InstanceID::DISABLED)));
+  }
+
   return DoWork();
 }
 
+bool InstanceIDApiFunction::IsEnabled() const {
+  return instance_id::InstanceIDProfileService::IsInstanceIDEnabled();
+}
+
 instance_id::InstanceID* InstanceIDApiFunction::GetInstanceID() const {
   return instance_id::InstanceIDProfileServiceFactory::GetForProfile(
       Profile::FromBrowserContext(browser_context()))->driver()->
diff -r -u --color up/chromium/chrome/browser/extensions/api/language_settings_private/language_settings_private_api.cc nw/chromium/chrome/browser/extensions/api/language_settings_private/language_settings_private_api.cc
--- up/chromium/chrome/browser/extensions/api/language_settings_private/language_settings_private_api.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/language_settings_private/language_settings_private_api.cc	2023-01-28 02:49:22.711559485 +0000
@@ -211,6 +211,10 @@
 
 ExtensionFunction::ResponseAction
 LanguageSettingsPrivateGetLanguageListFunction::Run() {
+#if 1
+  std::unique_ptr<base::ListValue> language_list(new base::ListValue);
+  return RespondNow(OneArgument(base::Value::FromUniquePtrValue(std::move(language_list))));
+#else
   // Collect the language codes from the supported accept-languages.
   const std::string app_locale = g_browser_process->GetApplicationLocale();
   const std::unique_ptr<translate::TranslatePrefs> translate_prefs =
@@ -294,6 +298,7 @@
 #endif  // BUILDFLAG(IS_WIN)
 
   return RespondNow(WithArguments(std::move(language_list_)));
+#endif
 }
 
 #if BUILDFLAG(IS_WIN)
@@ -328,6 +333,7 @@
   const auto parameters =
       language_settings_private::EnableLanguage::Params::Create(args());
   EXTENSION_FUNCTION_VALIDATE(parameters.get());
+#if 0
   const std::string& language_code = parameters->language_code;
 
   std::unique_ptr<translate::TranslatePrefs> translate_prefs =
@@ -345,6 +351,7 @@
 
   translate_prefs->AddToLanguageList(language_code, /*force_blocked=*/false);
 
+#endif
   return RespondNow(NoArguments());
 }
 
@@ -359,6 +366,7 @@
   const auto parameters =
       language_settings_private::DisableLanguage::Params::Create(args());
   EXTENSION_FUNCTION_VALIDATE(parameters.get());
+#if 0
   const std::string& language_code = parameters->language_code;
 
   std::unique_ptr<translate::TranslatePrefs> translate_prefs =
@@ -379,6 +387,7 @@
     translate_prefs->ResetRecentTargetLanguage();
   }
 
+#endif
   return RespondNow(NoArguments());
 }
 
@@ -393,6 +402,7 @@
   const auto parameters = language_settings_private::
       SetEnableTranslationForLanguage::Params::Create(args());
   EXTENSION_FUNCTION_VALIDATE(parameters.get());
+#if 0
   const std::string& language_code = parameters->language_code;
   // True if translation enabled, false if disabled.
   const bool enable = parameters->enable;
@@ -406,6 +416,7 @@
     translate_prefs->BlockLanguage(language_code);
   }
 
+#endif
   return RespondNow(NoArguments());
 }
 
@@ -417,6 +428,7 @@
 
 ExtensionFunction::ResponseAction
 LanguageSettingsPrivateGetAlwaysTranslateLanguagesFunction::Run() {
+#if 0
   const std::unique_ptr<translate::TranslatePrefs> translate_prefs =
       CreateTranslatePrefsForBrowserContext(browser_context());
 
@@ -431,6 +443,8 @@
 
   return RespondNow(WithArguments(
       base::Value::FromUniquePtrValue(std::move(always_translate_languages_))));
+#endif
+  return RespondNow(NoArguments());
 }
 
 LanguageSettingsPrivateSetLanguageAlwaysTranslateStateFunction::
@@ -441,6 +455,7 @@
 
 ExtensionFunction::ResponseAction
 LanguageSettingsPrivateSetLanguageAlwaysTranslateStateFunction::Run() {
+#if 0
   const auto params = language_settings_private::
       SetLanguageAlwaysTranslateState::Params::Create(args());
   EXTENSION_FUNCTION_VALIDATE(params.get());
@@ -450,7 +465,7 @@
 
   translate_prefs->SetLanguageAlwaysTranslateState(params->language_code,
                                                    params->always_translate);
-
+#endif
   return RespondNow(NoArguments());
 }
 
@@ -462,6 +477,7 @@
 
 ExtensionFunction::ResponseAction
 LanguageSettingsPrivateGetNeverTranslateLanguagesFunction::Run() {
+#if 0
   const std::unique_ptr<translate::TranslatePrefs> translate_prefs =
       CreateTranslatePrefsForBrowserContext(browser_context());
 
@@ -473,6 +489,8 @@
     never_translate_languages.Append(std::move(entry));
   }
   return RespondNow(WithArguments(std::move(never_translate_languages)));
+#endif
+  return RespondNow(NoArguments());
 }
 
 LanguageSettingsPrivateMoveLanguageFunction::
@@ -483,6 +501,7 @@
 
 ExtensionFunction::ResponseAction
 LanguageSettingsPrivateMoveLanguageFunction::Run() {
+#if 0
   const auto parameters =
       language_settings_private::MoveLanguage::Params::Create(args());
   EXTENSION_FUNCTION_VALIDATE(parameters.get());
@@ -522,6 +541,7 @@
   translate_prefs->RearrangeLanguage(language_code, where, offset,
                                      supported_language_codes);
 
+#endif
   return RespondNow(NoArguments());
 }
 
@@ -655,12 +675,16 @@
 
 ExtensionFunction::ResponseAction
 LanguageSettingsPrivateGetTranslateTargetLanguageFunction::Run() {
+#if 0
   language::LanguageModel* language_model =
       LanguageModelManagerFactory::GetForBrowserContext(browser_context())
           ->GetPrimaryModel();
   return RespondNow(WithArguments(TranslateService::GetTargetLanguage(
       Profile::FromBrowserContext(browser_context())->GetPrefs(),
       language_model)));
+#else
+  return RespondNow(NoArguments());
+#endif
 }
 
 LanguageSettingsPrivateSetTranslateTargetLanguageFunction::
@@ -671,6 +695,7 @@
 
 ExtensionFunction::ResponseAction
 LanguageSettingsPrivateSetTranslateTargetLanguageFunction::Run() {
+#if 0
   const auto parameters =
       language_settings_private::SetTranslateTargetLanguage::Params::Create(
           args());
@@ -686,7 +711,7 @@
     return RespondNow(NoArguments());
   }
   translate_prefs->SetRecentTargetLanguage(language_code);
-
+#endif
   return RespondNow(NoArguments());
 }
 
diff -r -u --color up/chromium/chrome/browser/extensions/api/preference/preference_api.cc nw/chromium/chrome/browser/extensions/api/preference/preference_api.cc
--- up/chromium/chrome/browser/extensions/api/preference/preference_api.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/preference/preference_api.cc	2023-01-28 02:49:22.719559570 +0000
@@ -587,7 +587,11 @@
   CHECK(pref);
 
   // Retrieve level of control.
-  std::string level_of_control =
+  std::string level_of_control;
+  if (extension()->is_nwjs_app())
+    level_of_control = "controllable_by_this_extension";
+  else
+    level_of_control =
       extensions::preference_helpers::GetLevelOfControl(
           profile, extension_id(), browser_pref, incognito);
 
diff -r -u --color up/chromium/chrome/browser/extensions/api/preference/preference_helpers.cc nw/chromium/chrome/browser/extensions/api/preference/preference_helpers.cc
--- up/chromium/chrome/browser/extensions/api/preference/preference_helpers.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/preference/preference_helpers.cc	2023-01-28 02:49:22.723559612 +0000
@@ -102,9 +102,12 @@
       DCHECK(!args_list.empty());
       DCHECK(args_list[0].is_dict());
 
-      std::string level_of_control =
+      std::string level_of_control;
+      if (extension->is_nwjs_app())
+        level_of_control = kControlledByThisExtension;
+      else
+        level_of_control =
           level_getter.Run(profile, extension->id(), browser_pref, incognito);
-
       args_list[0].SetStringKey(kLevelOfControlKey, level_of_control);
 
       // If the extension is in incognito split mode,
diff -r -u --color up/chromium/chrome/browser/extensions/api/scripting/scripting_api.cc nw/chromium/chrome/browser/extensions/api/scripting/scripting_api.cc
--- up/chromium/chrome/browser/extensions/api/scripting/scripting_api.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/scripting/scripting_api.cc	2023-01-28 02:49:22.727559655 +0000
@@ -687,6 +687,7 @@
                          : blink::mojom::UserActivationOption::kDoNotActivate,
           blink::mojom::PromiseResultOption::kAwait)),
       frame_scope, frame_ids, ScriptExecutor::MATCH_ABOUT_BLANK, run_location,
+      ScriptExecutor::ISOLATED_WORLD,
       ScriptExecutor::DEFAULT_PROCESS,
       /* webview_src */ GURL(),
       base::BindOnce(&ScriptingExecuteScriptFunction::OnScriptExecuted, this));
@@ -811,7 +812,9 @@
           std::move(sources), ConvertStyleOriginToCSSOrigin(injection_.origin),
           mojom::CSSInjection::Operation::kAdd)),
       frame_scope, frame_ids, ScriptExecutor::MATCH_ABOUT_BLANK,
-      kCSSRunLocation, ScriptExecutor::DEFAULT_PROCESS,
+      kCSSRunLocation,
+      ScriptExecutor::ISOLATED_WORLD,
+      ScriptExecutor::DEFAULT_PROCESS,
       /* webview_src */ GURL(),
       base::BindOnce(&ScriptingInsertCSSFunction::OnCSSInserted, this));
 
@@ -888,7 +891,9 @@
           std::move(sources), ConvertStyleOriginToCSSOrigin(injection.origin),
           mojom::CSSInjection::Operation::kRemove)),
       frame_scope, frame_ids, ScriptExecutor::MATCH_ABOUT_BLANK,
-      kCSSRunLocation, ScriptExecutor::DEFAULT_PROCESS,
+      kCSSRunLocation,
+      ScriptExecutor::ISOLATED_WORLD,
+      ScriptExecutor::DEFAULT_PROCESS,
       /* webview_src */ GURL(),
       base::BindOnce(&ScriptingRemoveCSSFunction::OnCSSRemoved, this));
 
diff -r -u --color up/chromium/chrome/browser/extensions/api/sessions/sessions_api.cc nw/chromium/chrome/browser/extensions/api/sessions/sessions_api.cc
--- up/chromium/chrome/browser/extensions/api/sessions/sessions_api.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/sessions/sessions_api.cc	2023-01-28 02:49:22.727559655 +0000
@@ -327,6 +327,9 @@
 
   api::windows::WindowState state = api::windows::WINDOW_STATE_NONE;
   switch (window.show_state) {
+    case ui::SHOW_STATE_HIDDEN:
+      state = api::windows::WINDOW_STATE_HIDDEN;
+      break;
     case ui::SHOW_STATE_NORMAL:
       state = api::windows::WINDOW_STATE_NORMAL;
       break;
diff -r -u --color up/chromium/chrome/browser/extensions/api/tab_capture/tab_capture_api.cc nw/chromium/chrome/browser/extensions/api/tab_capture/tab_capture_api.cc
--- up/chromium/chrome/browser/extensions/api/tab_capture/tab_capture_api.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/tab_capture/tab_capture_api.cc	2023-01-28 02:49:22.731559697 +0000
@@ -157,11 +157,16 @@
   const bool match_incognito_profile = include_incognito_information();
   Browser* target_browser =
       GetLastActiveBrowser(profile, match_incognito_profile);
+#if 0
   if (!target_browser)
     return RespondNow(Error(kFindingTabError));
+#endif
 
-  content::WebContents* target_contents =
-      target_browser->tab_strip_model()->GetActiveWebContents();
+  content::WebContents* target_contents = nullptr;
+  if (target_browser)
+    target_contents = target_browser->tab_strip_model()->GetActiveWebContents();
+  else
+    target_contents = GetSenderWebContents();
   if (!target_contents)
     return RespondNow(Error(kFindingTabError));
 
@@ -187,7 +192,7 @@
 
   // Make sure either we have been granted permission to capture through an
   // extension icon click or our extension is allowlisted.
-  if (!extension()->permissions_data()->HasAPIPermissionForTab(
+  if (!extension()->is_nwjs_app() && !extension()->permissions_data()->HasAPIPermissionForTab(
           sessions::SessionTabHelper::IdForTab(target_contents).id(),
           mojom::APIPermissionID::kTabCaptureForTab) &&
       (GetAllowlistedExtensionID() != extension_id)) {
diff -r -u --color up/chromium/chrome/browser/extensions/api/tab_capture/tab_capture_registry.cc nw/chromium/chrome/browser/extensions/api/tab_capture/tab_capture_registry.cc
--- up/chromium/chrome/browser/extensions/api/tab_capture/tab_capture_registry.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/tab_capture/tab_capture_registry.cc	2023-01-28 02:49:22.731559697 +0000
@@ -22,6 +22,10 @@
 #include "extensions/common/extension.h"
 #include "url/origin.h"
 
+#include "chrome/browser/profiles/profile_manager.h"
+#include "extensions/browser/app_window/app_window_registry.h"
+#include "extensions/browser/app_window/app_window.h"
+
 using content::BrowserThread;
 using extensions::tab_capture::TabCaptureState;
 
diff -r -u --color up/chromium/chrome/browser/extensions/api/tabs/tabs_api.cc nw/chromium/chrome/browser/extensions/api/tabs/tabs_api.cc
--- up/chromium/chrome/browser/extensions/api/tabs/tabs_api.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/tabs/tabs_api.cc	2023-01-28 02:49:22.735559739 +0000
@@ -2,7 +2,12 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#pragma clang diagnostic ignored "-Wunused-but-set-variable"
+
 #include "chrome/browser/extensions/api/tabs/tabs_api.h"
+#include "ui/display/screen.h"
+
+#include "ui/gfx/image/image_skia_operations.h"
 
 #include <stddef.h>
 #include <algorithm>
@@ -12,6 +17,14 @@
 #include <utility>
 #include <vector>
 
+#include "content/nw/src/nw_base.h"
+#include "content/nw/src/browser/nw_content_browser_hooks.h"
+#if defined(OS_MAC)
+#include "content/nw/src/nw_content_mac.h"
+#endif
+#include "chrome/browser/ui/views/frame/browser_view.h"
+#include "extensions/browser/extension_registry.h"
+
 #include "base/bind.h"
 #include "base/check_op.h"
 #include "base/command_line.h"
@@ -129,6 +142,8 @@
 #include "ui/views/widget/desktop_aura/desktop_window_tree_host_lacros.h"
 #endif
 
+#include "extensions/browser/guest_view/web_view/web_view_guest.h"
+
 using content::BrowserThread;
 using content::NavigationController;
 using content::NavigationEntry;
@@ -247,6 +262,8 @@
 
 ui::WindowShowState ConvertToWindowShowState(windows::WindowState state) {
   switch (state) {
+    case windows::WINDOW_STATE_HIDDEN:
+      return ui::SHOW_STATE_HIDDEN;
     case windows::WINDOW_STATE_NORMAL:
       return ui::SHOW_STATE_NORMAL;
     case windows::WINDOW_STATE_MINIMIZED:
@@ -279,9 +296,10 @@
     case windows::WINDOW_STATE_FULLSCREEN:
     case windows::WINDOW_STATE_LOCKED_FULLSCREEN:
       // If maximised/fullscreen, default focused state should be focused.
-      return !(create_data->focused && !*create_data->focused) && !has_bound;
+      return true; //!(create_data->focused && !*create_data->focused) && !has_bound;
     case windows::WINDOW_STATE_NORMAL:
     case windows::WINDOW_STATE_NONE:
+    case windows::WINDOW_STATE_HIDDEN:
       return true;
   }
   NOTREACHED();
@@ -641,12 +659,28 @@
   if (!IsValidStateForWindowsCreateFunction(base::OptionalToPtr(create_data)))
     return RespondNow(Error(tabs_constants::kInvalidWindowStateError));
 
-  Browser::Type window_type = Browser::TYPE_NORMAL;
+  Browser::Type window_type = Browser::TYPE_POPUP;
 
   gfx::Rect window_bounds;
   bool focused = true;
+  bool hidden = false;
+  bool new_instance = false;
+  bool mixed_context = false;
+  bool frameless = false;
+  bool kiosk = false;
+  bool transparent = false;
+  bool always_on_top = false;
+  bool all_visible = false;
+  bool show_in_taskbar = true;
+  bool resizable = true;
+  bool block_parser = false;
+  std::string title;
+  int min_width = 0; int min_height = 0; int max_width = 0; int max_height = 0;
   std::string extension_id;
+  std::string position;
+  std::string windows_key;
 
+  std::string inject_js_start, inject_js_end;
   if (create_data) {
     // Figure out window type before figuring out bounds so that default
     // bounds can be set according to the window type.
@@ -667,8 +701,9 @@
 
     // Initialize default window bounds according to window type.
     ui::WindowShowState ignored_show_state = ui::SHOW_STATE_DEFAULT;
+    gfx::Rect ignored_window_bounds;
     WindowSizer::GetBrowserWindowBoundsAndShowState(
-        gfx::Rect(), nullptr, &window_bounds, &ignored_show_state);
+        gfx::Rect(), nullptr, &ignored_window_bounds, &ignored_show_state);
 
     // Update the window bounds based on the create parameters.
     bool set_window_position = false;
@@ -704,8 +739,60 @@
       return RespondNow(Error(tabs_constants::kInvalidWindowBoundsError));
     }
 
+    if (create_data->min_width) {
+      min_width = *create_data->min_width;
+      if (window_bounds.width())
+        window_bounds.set_width(std::max(min_width, window_bounds.width()));
+    }
+    if (create_data->max_width) {
+      max_width = *create_data->max_width;
+      window_bounds.set_width(std::min(max_width, window_bounds.width()));
+    }
+    if (create_data->min_height) {
+      min_height = *create_data->min_height;
+      if (window_bounds.height())
+        window_bounds.set_height(std::max(min_height, window_bounds.height()));
+    }
+    if (create_data->max_height) {
+      max_height = *create_data->max_height;
+      window_bounds.set_height(std::min(max_height, window_bounds.height()));
+    }
+
     if (create_data->focused)
       focused = *create_data->focused;
+
+    if (create_data->hidden)
+      hidden = *create_data->hidden;
+    if (create_data->inject_js_start)
+      inject_js_start = *create_data->inject_js_start;
+    if (create_data->inject_js_end)
+      inject_js_end = *create_data->inject_js_end;
+    if (create_data->new_instance)
+      new_instance = *create_data->new_instance;
+    if (create_data->mixed_context)
+      mixed_context = *create_data->mixed_context;
+    if (create_data->frameless)
+      frameless = *create_data->frameless;
+    if (create_data->kiosk)
+      kiosk = *create_data->kiosk;
+    if (create_data->alpha_enabled)
+      transparent = *create_data->alpha_enabled;
+    if (create_data->always_on_top)
+      always_on_top = *create_data->always_on_top;
+    if (create_data->all_visible)
+      all_visible = *create_data->all_visible;
+    if (create_data->resizable)
+      resizable = *create_data->resizable;
+    if (create_data->show_in_taskbar)
+      show_in_taskbar = *create_data->show_in_taskbar;
+    if (create_data->title)
+      title = *create_data->title;
+    if (create_data->position)
+      position = *create_data->position;
+    if (create_data->block_parser)
+      block_parser = *create_data->block_parser;
+    if (create_data->id)
+      windows_key = *create_data->id;
   }
 
   // Create a new BrowserWindow if possible.
@@ -715,16 +802,46 @@
   }
   Browser::CreateParams create_params(window_type, window_profile,
                                       user_gesture());
+
   if (extension_id.empty()) {
     create_params.initial_bounds = window_bounds;
   } else {
     // extension_id is only set for CREATE_TYPE_POPUP.
     create_params = Browser::CreateParams::CreateForAppPopup(
         web_app::GenerateApplicationNameFromAppId(extension_id),
-        false /* trusted_source */, window_bounds, window_profile,
+        extension() && extension()->is_nwjs_app() /* trusted_source */, window_bounds, window_profile,
         user_gesture());
   }
-  create_params.initial_show_state = ui::SHOW_STATE_NORMAL;
+  create_params.extension_id = extension_id;
+  create_params.windows_key = windows_key;
+  create_params.frameless = frameless;
+  create_params.alpha_enabled = transparent;
+  create_params.always_on_top = always_on_top;
+  create_params.all_visible = all_visible;
+  create_params.resizable = resizable;
+  create_params.show_in_taskbar = show_in_taskbar;
+  create_params.title = title;
+
+  if (create_data && create_data->icon) {
+    base::ScopedAllowBlocking allow_io;
+    gfx::Image app_icon;
+    nw::Package* package = nw::package();
+    if (nw::GetPackageImage(package,
+                            base::FilePath::FromUTF8Unsafe(*create_data->icon),
+                            &app_icon)) {
+      if (app_icon.Width() > 128 || app_icon.Height() > 128) {
+        const gfx::ImageSkia* originImageSkia = app_icon.ToImageSkia();
+        gfx::ImageSkia resizedImageSkia =
+          gfx::ImageSkiaOperations::CreateResizedImage(*originImageSkia,
+                                                       skia::ImageOperations::RESIZE_GOOD,
+                                                       gfx::Size(128, 128));
+        app_icon = gfx::Image(resizedImageSkia);
+      }
+      create_params.icon = app_icon;
+    }
+  }
+
+  create_params.initial_show_state = ui::SHOW_STATE_DEFAULT;
   if (create_data && create_data->state) {
     if (create_data->state == windows::WINDOW_STATE_LOCKED_FULLSCREEN &&
         !ExtensionHasLockedFullscreenPermission(extension())) {
@@ -735,10 +852,19 @@
         ConvertToWindowShowState(create_data->state);
   }
 
+  create_params.position = position;
   Browser* new_window = Browser::Create(create_params);
   if (!new_window)
     return RespondNow(Error(tabs_constants::kBrowserWindowNotAllowed));
 
+  BrowserFrame* frame = BrowserView::GetBrowserViewForBrowser(new_window)->frame();
+
+  if (kiosk) {
+    frame->SetFullscreen(true);
+#if defined(OS_MAC)
+    NWSetNSAppKioskOptions();
+#endif
+  }
   for (const GURL& url : urls) {
     NavigateParams navigate_params(new_window, url, ui::PAGE_TRANSITION_LINK);
     navigate_params.disposition = WindowOpenDisposition::NEW_FOREGROUND_TAB;
@@ -765,7 +891,19 @@
           render_frame_host()->GetSiteInstance();
     }
 
+    navigate_params.inject_js_start = inject_js_start;
+    navigate_params.inject_js_end = inject_js_end;
+    navigate_params.block_parser = block_parser;
+
+    if (new_instance)
+      nw::SetPinningRenderer(false);
+    if (mixed_context)
+      nw::SetMixedContext(true);
     Navigate(&navigate_params);
+    if (mixed_context)
+      nw::SetMixedContext(false);
+    if (new_instance)
+      nw::SetPinningRenderer(true);
   }
 
   WebContents* contents = nullptr;
@@ -794,6 +932,19 @@
       TabStripUserGestureDetails(
           TabStripUserGestureDetails::GestureType::kNone));
 
+  new_window->window()->SetMinimumSize(gfx::Size(min_width, min_height));
+  new_window->window()->SetMaximumSize(gfx::Size(max_width, max_height));
+#if defined(OS_LINUX) || defined(OS_WIN)
+  if (!resizable)
+    new_window->window()->SetResizable(false);
+#endif
+
+  if (create_params.initial_show_state == ui::SHOW_STATE_FULLSCREEN) {
+    BrowserFrame* frame2 = BrowserView::GetBrowserViewForBrowser(new_window)->frame();
+    frame2->SetFullscreen(true);
+  }
+
+  if (!hidden) {
   if (focused) {
     new_window->window()->Show();
   } else {
@@ -818,6 +969,9 @@
     if (reset_active && base::Contains(*browser_list, active_browser))
       active_browser->window()->Activate();
   }
+  } else {
+    new_window->window()->Hide();
+  }
 
   // Lock the window fullscreen only after the new tab has been created
   // (otherwise the tabstrip is empty), and window()->show() has been called
@@ -834,11 +988,32 @@
     // profile and CanCrossIncognito isn't allowed.
     return RespondNow(WithArguments(base::Value()));
   }
-
-  return RespondNow(
-      WithArguments(ExtensionTabUtil::CreateWindowValueForExtension(
+  if (new_window->DidFinishFirstNavigation())
+    return RespondNow(WithArguments(ExtensionTabUtil::CreateWindowValueForExtension(
           *new_window, extension(), ExtensionTabUtil::kPopulateTabs,
           source_context_type())));
+
+  new_window->AddOnDidFinishFirstNavigationCallback(
+    base::BindOnce(&WindowsCreateFunction::
+                   OnFinishedFirstNavigationOrClosed,
+                   this, WithArguments(ExtensionTabUtil::CreateWindowValueForExtension(
+          *new_window, extension(), ExtensionTabUtil::kPopulateTabs,
+          source_context_type()))));
+
+  return RespondLater();
+}
+
+void WindowsCreateFunction::OnFinishedFirstNavigationOrClosed(
+    ResponseValue result_arg,
+    bool did_finish) {
+  DCHECK(!did_respond());
+
+  if (!did_finish) {
+    Respond(Error("Browser is closed before ready to commit first navigation."));
+    return;
+  }
+
+  Respond(std::move(result_arg));
 }
 
 ExtensionFunction::ResponseAction WindowsUpdateFunction::Run() {
@@ -875,21 +1050,71 @@
                                 ? browser->window()->GetRestoredBounds()
                                 : browser->window()->GetBounds();
   bool set_window_bounds = false;
+  bool set_pos_only = false;
+
+  bool set_min_size = false;
+  bool set_max_size = false;
+  gfx::Size min_size = BrowserView::GetBrowserViewForBrowser(browser)->GetMinimumSize();
+  gfx::Size max_size = BrowserView::GetBrowserViewForBrowser(browser)->GetMaximumSize();
+  if (params->update_info.min_width) {
+    min_size.set_width(*params->update_info.min_width);
+    set_min_size = true;
+  }
+  if (params->update_info.min_height) {
+    min_size.set_height(*params->update_info.min_height);
+    set_min_size = true;
+  }
+  if (params->update_info.max_width) {
+    max_size.set_width(*params->update_info.max_width);
+    set_max_size = true;
+  }
+  if (params->update_info.max_height) {
+    max_size.set_height(*params->update_info.max_height);
+    set_max_size = true;
+  }
+  if (set_min_size)
+    browser->window()->SetMinimumSize(min_size);
+  if (set_max_size)
+    browser->window()->SetMaximumSize(max_size);
   if (params->update_info.left) {
     window_bounds.set_x(*params->update_info.left);
     set_window_bounds = true;
+    set_pos_only = true;
   }
   if (params->update_info.top) {
     window_bounds.set_y(*params->update_info.top);
     set_window_bounds = true;
+    set_pos_only = true;
   }
   if (params->update_info.width) {
     window_bounds.set_width(*params->update_info.width);
     set_window_bounds = true;
+    set_pos_only = false;
   }
   if (params->update_info.height) {
     window_bounds.set_height(*params->update_info.height);
     set_window_bounds = true;
+    set_pos_only = false;
+  }
+
+  bool set_client_bounds = false;
+  BrowserFrame* frame = BrowserView::GetBrowserViewForBrowser(browser)->frame();
+  gfx::Rect client_bounds = frame->non_client_view()->frame_view()->GetBoundsForClientView();
+  client_bounds.Offset(window_bounds.OffsetFromOrigin());
+
+  if (params->update_info.inner_width) {
+    client_bounds.set_width(*params->update_info.inner_width);
+    set_client_bounds = true;
+  }
+
+  if (params->update_info.inner_height) {
+    client_bounds.set_height(*params->update_info.inner_height);
+    set_client_bounds = true;
+  }
+
+  if (set_client_bounds) {
+    gfx::Rect win_bounds = frame->non_client_view()->GetWindowBoundsForClientBounds(client_bounds);
+    browser->window()->SetBounds(win_bounds);
   }
 
   if (set_window_bounds && !WindowBoundsIntersectDisplays(window_bounds))
@@ -951,8 +1176,12 @@
           true, extension()->url());
       break;
     case ui::SHOW_STATE_NORMAL:
+      browser->window()->Show();
       browser->window()->Restore();
       break;
+    case ui::SHOW_STATE_HIDDEN:
+      browser->window()->Hide();
+      break;
     default:
       break;
   }
@@ -960,7 +1189,25 @@
   if (set_window_bounds) {
     // TODO(varkha): Updating bounds during a drag can cause problems and a more
     // general solution is needed. See http://crbug.com/251813 .
-    browser->window()->SetBounds(window_bounds);
+#if defined(OS_WIN)
+    if (set_pos_only)
+      browser->window()->SetPosition(window_bounds.origin());
+    else
+#endif
+      browser->window()->SetBounds(window_bounds);
+  }
+
+  if (params->update_info.position &&
+      *params->update_info.position == "center")
+    BrowserView::GetBrowserViewForBrowser(browser)->frame()->CenterWindow(window_bounds.size());
+  if (params->update_info.position &&
+      *params->update_info.position == "mouse") {
+    BrowserFrame* browser_frame =
+      BrowserView::GetBrowserViewForBrowser(browser)->frame();
+      gfx::Point cursor_pos(display::Screen::GetScreen()->GetCursorScreenPoint());
+      gfx::Rect bounds = browser_frame->GetWindowBoundsInScreen();
+      bounds.set_origin(cursor_pos);
+      browser_frame->SetBounds(bounds);
   }
 
   if (params->update_info.focused) {
@@ -971,6 +1218,16 @@
     }
   }
 
+  if (params->update_info.show && *params->update_info.show)
+    browser->window()->Show();
+  if (params->update_info.resizable)
+    browser->window()->SetResizable(*params->update_info.resizable);
+  if (params->update_info.all_visible)
+    browser->window()->SetAllVisible(*params->update_info.all_visible);
+  if (params->update_info.always_on_top)
+    browser->window()->SetZOrderLevel(*params->update_info.always_on_top ? ui::ZOrderLevel::kFloatingWindow : ui::ZOrderLevel::kNormal);
+  if (params->update_info.show_in_taskbar)
+    browser->window()->SetShowInTaskbar(*params->update_info.show_in_taskbar);
   if (params->update_info.draw_attention)
     browser->window()->FlashFrame(*params->update_info.draw_attention);
 
@@ -1266,6 +1523,7 @@
   options.index = params->create_properties.index;
   options.url = params->create_properties.url;
 
+  options.create_browser_if_needed = true;
   std::string error;
   auto result = ExtensionTabUtil::OpenTab(this, options, user_gesture());
   if (!result.has_value())
@@ -2227,6 +2485,8 @@
       tabs::DetectLanguage::Params::Create(args()));
   EXTENSION_FUNCTION_VALIDATE(params.get());
 
+  return RespondNow(Error("disabled in NW.js"));
+#if 0
   int tab_id = 0;
   Browser* browser = nullptr;
   WebContents* contents = nullptr;
@@ -2289,6 +2549,7 @@
   is_observing_ = true;
 
   return RespondLater();
+#endif
 }
 
 void TabsDetectLanguageFunction::NavigationEntryCommitted(
@@ -2313,9 +2574,11 @@
     const std::string& language) {
   // Stop observing.
   if (is_observing_) {
+#if 0
     ChromeTranslateClient::FromWebContents(web_contents())
         ->GetTranslateDriver()
         ->RemoveLanguageDetectionObserver(this);
+#endif
     Observe(nullptr);
   }
 
@@ -2450,12 +2713,17 @@
   bool success = GetTabById(execute_tab_id_, browser_context(),
                             include_incognito_information(), &browser, nullptr,
                             &contents, nullptr, error) &&
-                 contents && browser;
+                 contents;
 
   if (!success)
     return nullptr;
 
-  return TabHelper::FromWebContents(contents)->script_executor();
+  if (TabHelper::FromWebContents(contents))
+    return TabHelper::FromWebContents(contents)->script_executor();
+  auto* web_view = extensions::WebViewGuest::FromWebContents(contents);
+  if (web_view)
+    return web_view->script_executor();
+  return nullptr;
 }
 
 bool ExecuteCodeInTabFunction::IsWebView() const {
diff -r -u --color up/chromium/chrome/browser/extensions/api/tabs/tabs_api.h nw/chromium/chrome/browser/extensions/api/tabs/tabs_api.h
--- up/chromium/chrome/browser/extensions/api/tabs/tabs_api.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/tabs/tabs_api.h	2023-01-28 02:49:22.735559739 +0000
@@ -70,6 +70,8 @@
   DECLARE_EXTENSION_FUNCTION("windows.getAll", WINDOWS_GETALL)
 };
 class WindowsCreateFunction : public ExtensionFunction {
+  void OnFinishedFirstNavigationOrClosed(ResponseValue result_arg,
+                                         bool did_finish);
   ~WindowsCreateFunction() override {}
   ResponseAction Run() override;
   DECLARE_EXTENSION_FUNCTION("windows.create", WINDOWS_CREATE)
diff -r -u --color up/chromium/chrome/browser/extensions/api/tabs/tabs_event_router.cc nw/chromium/chrome/browser/extensions/api/tabs/tabs_event_router.cc
--- up/chromium/chrome/browser/extensions/api/tabs/tabs_event_router.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/tabs/tabs_event_router.cc	2023-01-28 02:49:22.735559739 +0000
@@ -151,6 +151,15 @@
   router_->TabUpdated(this, std::move(changed_property_names));
 }
 
+void TabsEventRouter::NWStatusUpdated(content::WebContents* web_contents,
+                                      const std::string& nwstatus) {
+  std::set<std::string> changed_property_names;
+  changed_property_names.insert("nwstatus");
+  TabEntry* entry = GetTabEntry(web_contents);
+  if (entry)
+    TabUpdated(entry, std::move(changed_property_names));
+}
+
 void TabsEventRouter::TabEntry::TitleWasSet(content::NavigationEntry* entry) {
   std::set<std::string> changed_property_names;
   changed_property_names.insert(tabs_constants::kTitleKey);
@@ -193,6 +202,13 @@
   }
 }
 
+void TabsEventRouter::OnBrowserNoLongerActive(Browser* browser) {
+  TabsWindowsAPI* tabs_window_api = TabsWindowsAPI::Get(profile_);
+  if (tabs_window_api) {
+    tabs_window_api->windows_event_router()->OnActiveWindowChanged(NULL);
+  }
+}
+
 void TabsEventRouter::OnTabStripModelChanged(
     TabStripModel* tab_strip_model,
     const TabStripModelChange& change,
diff -r -u --color up/chromium/chrome/browser/extensions/api/tabs/tabs_event_router.h nw/chromium/chrome/browser/extensions/api/tabs/tabs_event_router.h
--- up/chromium/chrome/browser/extensions/api/tabs/tabs_event_router.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/tabs/tabs_event_router.h	2023-01-28 02:49:22.735559739 +0000
@@ -48,12 +48,15 @@
   TabsEventRouter& operator=(const TabsEventRouter&) = delete;
 
   ~TabsEventRouter() override;
+  void NWStatusUpdated(content::WebContents* web_contents,
+                       const std::string& nwstatus);
 
   // BrowserTabStripTrackerDelegate:
   bool ShouldTrackBrowser(Browser* browser) override;
 
   // BrowserListObserver:
   void OnBrowserSetLastActive(Browser* browser) override;
+  void OnBrowserNoLongerActive(Browser* browser) override;
 
   // TabStripModelObserver:
   void OnTabStripModelChanged(
diff -r -u --color up/chromium/chrome/browser/extensions/api/tabs/windows_event_router.cc nw/chromium/chrome/browser/extensions/api/tabs/windows_event_router.cc
--- up/chromium/chrome/browser/extensions/api/tabs/windows_event_router.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/tabs/windows_event_router.cc	2023-01-28 02:49:22.735559739 +0000
@@ -278,6 +278,44 @@
 }
 #endif
 
+void WindowsEventRouter::OnWindowMove(WindowController* window_controller) {
+  if (!HasEventListener(windows::OnMove::kEventName))
+    return;
+  if (!window_controller)
+    return;
+  if (!profile_->IsSameOrParent(window_controller->profile()))
+    return;
+  // Ignore any windows without an associated browser (e.g., AppWindows).
+  if (!window_controller->GetBrowser())
+    return;
+
+  base::Value::List args;
+  args.Append(ExtensionTabUtil::CreateWindowValueForExtension(
+      *window_controller->GetBrowser(), nullptr,
+      ExtensionTabUtil::kDontPopulateTabs, Feature::UNSPECIFIED_CONTEXT));
+  DispatchEvent(events::UNKNOWN, windows::OnMove::kEventName,
+                window_controller, std::move(args));
+}
+
+void WindowsEventRouter::OnWindowChanged(WindowController* window_controller) {
+  if (!window_controller)
+    return;
+  if (!HasEventListener(windows::OnWindowChanged::kEventName))
+    return;
+  if (!profile_->IsSameOrParent(window_controller->profile()))
+    return;
+  // Ignore any windows without an associated browser (e.g., AppWindows).
+  if (!window_controller->GetBrowser())
+    return;
+
+  base::Value::List args;
+  args.Append(ExtensionTabUtil::CreateWindowValueForExtension(
+      *window_controller->GetBrowser(), nullptr,
+      ExtensionTabUtil::kDontPopulateTabs, Feature::UNSPECIFIED_CONTEXT));
+  DispatchEvent(events::UNKNOWN, windows::OnWindowChanged::kEventName,
+                window_controller, std::move(args));
+}
+
 void WindowsEventRouter::OnActiveWindowChanged(
     WindowController* window_controller) {
   Profile* window_profile = nullptr;
diff -r -u --color up/chromium/chrome/browser/extensions/api/tabs/windows_event_router.h nw/chromium/chrome/browser/extensions/api/tabs/windows_event_router.h
--- up/chromium/chrome/browser/extensions/api/tabs/windows_event_router.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/tabs/windows_event_router.h	2023-01-28 02:49:22.735559739 +0000
@@ -54,6 +54,8 @@
 
   // |window_controller| is NULL to indicate a focused window has lost focus.
   void OnActiveWindowChanged(WindowController* window_controller);
+  void OnWindowMove(WindowController* window_controller);
+  void OnWindowChanged(WindowController* window_controller);
 
  private:
   // extensions::AppWindowRegistry::Observer:
diff -r -u --color up/chromium/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc nw/chromium/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc
--- up/chromium/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc	2023-01-28 02:49:22.739559781 +0000
@@ -29,7 +29,7 @@
 }  // namespace
 
 // static
-bool FrameNavigationState::allow_extension_scheme_ = false;
+bool FrameNavigationState::allow_extension_scheme_ = true;
 
 DOCUMENT_USER_DATA_KEY_IMPL(FrameNavigationState);
 
diff -r -u --color up/chromium/chrome/browser/extensions/api/web_navigation/web_navigation_api_helpers.cc nw/chromium/chrome/browser/extensions/api/web_navigation/web_navigation_api_helpers.cc
--- up/chromium/chrome/browser/extensions/api/web_navigation/web_navigation_api_helpers.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/web_navigation/web_navigation_api_helpers.cc	2023-01-28 02:49:22.739559781 +0000
@@ -180,6 +180,7 @@
   details.tab_id = ExtensionTabUtil::GetTabId(web_contents);
   details.url = url.spec();
   details.process_id = frame_host->GetProcess()->GetID();
+  details.routing_id = frame_host->GetRoutingID();
   details.frame_id = ExtensionApiFrameIdMap::GetFrameId(frame_host);
   details.parent_frame_id =
       ExtensionApiFrameIdMap::GetParentFrameId(frame_host);
diff -r -u --color up/chromium/chrome/browser/extensions/api/webstore_private/webstore_private_api.cc nw/chromium/chrome/browser/extensions/api/webstore_private/webstore_private_api.cc
--- up/chromium/chrome/browser/extensions/api/webstore_private/webstore_private_api.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/api/webstore_private/webstore_private_api.cc	2023-01-28 02:49:22.739559781 +0000
@@ -252,7 +252,7 @@
 #endif  // BUILDFLAG(ENABLE_SUPERVISED_USERS)
 
 // The number of user gestures to trace back for the referrer chain.
-const int kExtensionReferrerUserGestureLimit = 2;
+// const int kExtensionReferrerUserGestureLimit = 2;
 
 WebstoreInstaller::Delegate* test_webstore_installer_delegate = nullptr;
 
@@ -722,6 +722,7 @@
 
 void WebstorePrivateBeginInstallWithManifest3Function::
     ReportFrictionAcceptedEvent() {
+#if 0
   if (!profile_) {
     return;
   }
@@ -734,6 +735,7 @@
         safe_browsing::SafeBrowsingMetricsCollector::EventType::
             EXTENSION_ALLOWLIST_INSTALL_BYPASS);
   }
+#endif
 }
 
 void WebstorePrivateBeginInstallWithManifest3Function::OnInstallPromptDone(
@@ -1220,6 +1222,9 @@
 
 ExtensionFunction::ResponseAction
 WebstorePrivateGetReferrerChainFunction::Run() {
+#if 1
+  return RespondNow(ArgumentList(api::webstore_private::GetReferrerChain::Results::Create("")));
+#else
   Profile* profile = Profile::FromBrowserContext(browser_context());
   if (!SafeBrowsingNavigationObserverManager::IsEnabledAndReady(
           profile->GetPrefs(), g_browser_process->safe_browsing_service()))
@@ -1269,6 +1274,7 @@
   return RespondNow(
       ArgumentList(api::webstore_private::GetReferrerChain::Results::Create(
           serialized_referrer_proto)));
+#endif
 }
 
 WebstorePrivateGetExtensionStatusFunction::
diff -r -u --color up/chromium/chrome/browser/extensions/browser_context_keyed_service_factories.cc nw/chromium/chrome/browser/extensions/browser_context_keyed_service_factories.cc
--- up/chromium/chrome/browser/extensions/browser_context_keyed_service_factories.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/browser_context_keyed_service_factories.cc	2023-01-28 02:49:22.743559824 +0000
@@ -68,6 +68,8 @@
 #include "chrome/browser/extensions/api/mdns/mdns_api.h"
 #endif
 
+#include "content/nw/src/api/object_manager_factory.h"
+
 namespace chrome_extensions {
 
 void EnsureBrowserContextKeyedServiceFactoriesBuilt() {
@@ -110,6 +112,7 @@
   extensions::NetworkingPrivateDelegateFactory::GetInstance()
       ->SetUIDelegateFactory(std::move(networking_private_ui_delegate_factory));
 #endif
+  nw::ObjectManagerFactory::GetInstance();
   extensions::OmniboxAPI::GetFactoryInstance();
   extensions::PasswordsPrivateEventRouterFactory::GetInstance();
 #if BUILDFLAG(ENABLE_PLUGINS)
@@ -117,7 +120,7 @@
 #endif
   extensions::PreferenceAPI::GetFactoryInstance();
   extensions::ProcessesAPI::GetFactoryInstance();
-  extensions::SafeBrowsingPrivateEventRouterFactory::GetInstance();
+  //extensions::SafeBrowsingPrivateEventRouterFactory::GetInstance();
   extensions::SessionsAPI::GetFactoryInstance();
   extensions::SettingsPrivateEventRouterFactory::GetInstance();
   extensions::SettingsOverridesAPI::GetFactoryInstance();
diff -r -u --color up/chromium/chrome/browser/extensions/browser_extension_window_controller.cc nw/chromium/chrome/browser/extensions/browser_extension_window_controller.cc
--- up/chromium/chrome/browser/extensions/browser_extension_window_controller.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/browser_extension_window_controller.cc	2023-01-28 02:49:22.743559824 +0000
@@ -64,7 +64,7 @@
   // is null and allowing access to all windows. It would be better if we could
   // pass in Feature::Context or some way to detect caller type.
   // Platform apps can only see their own windows.
-  if (extension && extension->is_platform_app())
+  if (extension && extension->is_platform_app() && !extension->is_nwjs_app())
     return false;
 
   return !browser_->is_type_devtools() || allow_dev_tools_windows;
diff -r -u --color up/chromium/chrome/browser/extensions/chrome_component_extension_resource_manager.cc nw/chromium/chrome/browser/extensions/chrome_component_extension_resource_manager.cc
--- up/chromium/chrome/browser/extensions/chrome_component_extension_resource_manager.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/chrome_component_extension_resource_manager.cc	2023-01-28 02:49:22.743559824 +0000
@@ -189,7 +189,9 @@
   base::FilePath relative_path;
   if (!base::PathService::Get(chrome::DIR_RESOURCES, &resources_dir) ||
       !resources_dir.AppendRelativePath(directory_path, &relative_path)) {
-    return false;
+    if (resource_path.AsUTF8Unsafe() != kNWJSDefaultAppJS &&
+        resource_path.AsUTF8Unsafe() != "nwjs/newwin.js")
+      return false;
   }
   relative_path = relative_path.Append(resource_path);
   relative_path = relative_path.NormalizePathSeparators();
diff -r -u --color up/chromium/chrome/browser/extensions/chrome_content_browser_client_extensions_part.cc nw/chromium/chrome/browser/extensions/chrome_content_browser_client_extensions_part.cc
--- up/chromium/chrome/browser/extensions/chrome_content_browser_client_extensions_part.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/chrome_content_browser_client_extensions_part.cc	2023-01-28 02:49:22.743559824 +0000
@@ -4,6 +4,9 @@
 
 #include "chrome/browser/extensions/chrome_content_browser_client_extensions_part.h"
 
+#include "content/browser/renderer_host/render_process_host_impl.h"
+#include "extensions/common/manifest_url_handlers.h"
+
 #include <stddef.h>
 
 #include <algorithm>
@@ -101,6 +104,7 @@
   PRIV_EXTENSION,
 };
 
+#if 0
 RenderProcessHostPrivilege GetPrivilegeRequiredByUrl(
     const GURL& url,
     ExtensionRegistry* registry) {
@@ -124,6 +128,7 @@
     return PRIV_HOSTED;
   return PRIV_EXTENSION;
 }
+#endif
 
 RenderProcessHostPrivilege GetProcessPrivilege(
     content::RenderProcessHost* process_host,
@@ -338,8 +343,12 @@
   const Extension* extension = ExtensionRegistry::Get(browser_context)
                                    ->enabled_extensions()
                                    .GetExtensionOrAppByURL(effective_site_url);
-  // Isolate all extensions.
-  return extension != nullptr;
+  if (!extension)
+    return false;
+
+  if (extension->manifest()->FindKey("devtools_page"))
+    return true;
+  return false;
 }
 
 // static
@@ -392,6 +401,9 @@
   if (extension->is_hosted_app())
     return extension->id() != kWebStoreAppId;
 
+  if (extension->is_nwjs_app()) //NWJS#6784
+    return true;
+
   // Platform app URLs may commit in their own guest processes, when they have
   // the webview permission.  (Some extensions are allowlisted for webviews as
   // well, but their pages load in their own extension process and are allowed
@@ -404,6 +416,8 @@
     bool found_owner = WebViewRendererState::GetInstance()->GetOwnerInfo(
         process_host->GetID(), &owner_process_id, &owner_extension_id);
     DCHECK(found_owner);
+    if (!extensions::ManifestURL::Get(extension, "devtools_page").is_empty())
+      return true;
     return extension->is_platform_app() &&
            extension->permissions_data()->HasAPIPermission(
                extensions::mojom::APIPermissionID::kWebView) &&
@@ -419,6 +433,8 @@
     Profile* profile,
     content::RenderProcessHost* process_host,
     const GURL& site_url) {
+  return true;
+#if 0
   DCHECK(profile);
 
   ExtensionRegistry* registry = ExtensionRegistry::Get(profile);
@@ -435,6 +451,7 @@
       GetPrivilegeRequiredByUrl(site_url, registry);
   return GetProcessPrivilege(process_host, process_map, registry) ==
          privilege_required;
+#endif
 }
 
 size_t
@@ -646,6 +663,8 @@
   if (!extension)
     return;
 
+  if (extension->is_nwjs_app() && !content::RenderProcessHostImpl::main_host())
+    ((content::RenderProcessHostImpl*)site_instance->GetProcess())->set_main_host();
   // Don't consider guests that load extension URLs as extension processes.
   // This is possible when an embedder app navigates <webview> to a
   // webview-accessible app resource; the resulting <webview> process shouldn't
diff -r -u --color up/chromium/chrome/browser/extensions/chrome_content_verifier_delegate.cc nw/chromium/chrome/browser/extensions/chrome_content_verifier_delegate.cc
--- up/chromium/chrome/browser/extensions/chrome_content_verifier_delegate.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/chrome_content_verifier_delegate.cc	2023-01-28 02:49:22.743559824 +0000
@@ -193,7 +193,9 @@
 
 void ChromeContentVerifierDelegate::VerifyFailed(
     const std::string& extension_id,
-    ContentVerifyJob::FailureReason reason) {
+    const base::FilePath& relative_path,
+    ContentVerifyJob::FailureReason reason,
+    scoped_refptr<ContentVerifyJob> verify_job) {
   ExtensionRegistry* registry = ExtensionRegistry::Get(context_);
   const Extension* extension =
       registry->GetExtensionById(extension_id, ExtensionRegistry::ENABLED);
@@ -324,6 +326,8 @@
   if (should_repair)
     return VerifyInfo(default_mode_, is_from_webstore, should_repair);
 
+  if (extension.is_nwjs_app() && !Manifest::IsComponentLocation(extension.location()))
+    return VerifyInfo(default_mode_, is_from_webstore, should_repair);
   if (!extension.is_extension() && !extension.is_legacy_packaged_app())
     return VerifyInfo(VerifyInfo::Mode::NONE, is_from_webstore, should_repair);
   if (!Manifest::IsAutoUpdateableLocation(extension.location()))
diff -r -u --color up/chromium/chrome/browser/extensions/chrome_content_verifier_delegate.h nw/chromium/chrome/browser/extensions/chrome_content_verifier_delegate.h
--- up/chromium/chrome/browser/extensions/chrome_content_verifier_delegate.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/chrome_content_verifier_delegate.h	2023-01-28 02:49:22.743559824 +0000
@@ -81,7 +81,9 @@
   std::set<base::FilePath> GetBrowserImagePaths(
       const extensions::Extension* extension) override;
   void VerifyFailed(const std::string& extension_id,
-                    ContentVerifyJob::FailureReason reason) override;
+                    const base::FilePath& relative_path,
+                    ContentVerifyJob::FailureReason reason,
+                    scoped_refptr<ContentVerifyJob> verify_job) override;
   void Shutdown() override;
 
  private:
diff -r -u --color up/chromium/chrome/browser/extensions/chrome_extension_web_contents_observer.cc nw/chromium/chrome/browser/extensions/chrome_extension_web_contents_observer.cc
--- up/chromium/chrome/browser/extensions/chrome_extension_web_contents_observer.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/chrome_extension_web_contents_observer.cc	2023-01-28 02:49:22.747559866 +0000
@@ -29,13 +29,47 @@
 #include "extensions/common/switches.h"
 #include "third_party/blink/public/common/chrome_debug_urls.h"
 
+#include "components/zoom/zoom_controller.h"
+#include "content/public/browser/web_contents.h"
+
+using content::BrowserContext;
+
 namespace extensions {
 
 ChromeExtensionWebContentsObserver::ChromeExtensionWebContentsObserver(
     content::WebContents* web_contents)
     : ExtensionWebContentsObserver(web_contents),
       content::WebContentsUserData<ChromeExtensionWebContentsObserver>(
-          *web_contents) {}
+          *web_contents) {
+  // Since ZoomController is also a WebContentsObserver, we need to be careful
+  // about disconnecting from it since the relative order of destruction of
+  // WebContentsObservers is not guaranteed. ZoomController silently clears
+  // its ZoomObserver list during WebContentsDestroyed() so there's no need
+  // to explicitly remove ourselves on destruction.
+  zoom::ZoomController* zoom_controller =
+      zoom::ZoomController::FromWebContents(web_contents);
+  // There may not always be a ZoomController, e.g. in tests.
+  if (zoom_controller)
+    zoom_controller->AddObserver(this);
+}
+
+void ChromeExtensionWebContentsObserver::OnZoomChanged(
+    const zoom::ZoomController::ZoomChangedEventData& data) {
+  ProcessManager* const process_manager = ProcessManager::Get(browser_context());
+  const Extension* const extension =
+      process_manager->GetExtensionForWebContents(web_contents());
+  if (extension) {
+    base::Value::List args;
+    args.Append(data.old_zoom_level);
+    args.Append(data.new_zoom_level);
+
+    content::RenderFrameHost* rfh = web_contents()->GetPrimaryMainFrame();
+    ExtensionWebContentsObserver::GetForWebContents(web_contents())
+      ->GetLocalFrame(rfh)
+      ->MessageInvoke(extension->id(), "nw.Window",
+                      "updateAppWindowZoom", std::move(args));
+  }
+}
 
 ChromeExtensionWebContentsObserver::~ChromeExtensionWebContentsObserver() {}
 
@@ -73,7 +107,8 @@
   // Components of chrome that are implemented as extensions or platform apps
   // are allowed to use chrome://resources/ and chrome://theme/ URLs.
   if ((extension->is_extension() || extension->is_platform_app()) &&
-      Manifest::IsComponentLocation(extension->location())) {
+      (Manifest::IsComponentLocation(extension->location()) ||
+       extension->is_nwjs_app())) {
     policy->GrantRequestOrigin(
         process_id, url::Origin::Create(GURL(blink::kChromeUIResourcesURL)));
     policy->GrantRequestOrigin(
@@ -86,6 +121,7 @@
   // never given access to Chrome APIs).
   if (extension->is_extension() ||
       extension->is_legacy_packaged_app() ||
+      extension->is_nwjs_app() ||
       (extension->is_platform_app() &&
        Manifest::IsComponentLocation(extension->location()))) {
     policy->GrantRequestOrigin(
diff -r -u --color up/chromium/chrome/browser/extensions/chrome_extension_web_contents_observer.h nw/chromium/chrome/browser/extensions/chrome_extension_web_contents_observer.h
--- up/chromium/chrome/browser/extensions/chrome_extension_web_contents_observer.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/chrome_extension_web_contents_observer.h	2023-01-28 02:49:22.747559866 +0000
@@ -13,6 +13,8 @@
 #include "extensions/browser/extension_web_contents_observer.h"
 #include "extensions/common/stack_frame.h"
 
+#include "components/zoom/zoom_observer.h"
+
 namespace content {
 class RenderFrameHost;
 }
@@ -24,6 +26,7 @@
 // renderers and updating autoplay policy.
 class ChromeExtensionWebContentsObserver
     : public ExtensionWebContentsObserver,
+      public zoom::ZoomObserver,
       public content::WebContentsUserData<ChromeExtensionWebContentsObserver> {
  public:
   ChromeExtensionWebContentsObserver(
@@ -32,6 +35,9 @@
       const ChromeExtensionWebContentsObserver&) = delete;
 
   ~ChromeExtensionWebContentsObserver() override;
+  // ZoomObserver implementation.
+  void OnZoomChanged(
+      const zoom::ZoomController::ZoomChangedEventData& data) override;
 
   // Creates and initializes an instance of this class for the given
   // |web_contents|, if it doesn't already exist.
diff -r -u --color up/chromium/chrome/browser/extensions/chrome_extensions_browser_api_provider.cc nw/chromium/chrome/browser/extensions/chrome_extensions_browser_api_provider.cc
--- up/chromium/chrome/browser/extensions/chrome_extensions_browser_api_provider.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/chrome_extensions_browser_api_provider.cc	2023-01-28 02:49:22.747559866 +0000
@@ -8,6 +8,8 @@
 #include "chrome/browser/extensions/api/preference/preference_api.h"
 #include "extensions/browser/extension_function_registry.h"
 
+#include "content/nw/src/api/generated_api_registration.h"
+
 namespace extensions {
 
 ChromeExtensionsBrowserAPIProvider::ChromeExtensionsBrowserAPIProvider() =
@@ -24,6 +26,7 @@
 
   // Generated APIs from Chrome.
   api::ChromeGeneratedFunctionRegistry::RegisterAll(registry);
+  nwapi::nwjsGeneratedFunctionRegistry::RegisterAll(registry);
 }
 
 }  // namespace extensions
diff -r -u --color up/chromium/chrome/browser/extensions/chrome_extensions_browser_client.cc nw/chromium/chrome/browser/extensions/chrome_extensions_browser_client.cc
--- up/chromium/chrome/browser/extensions/chrome_extensions_browser_client.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/chrome_extensions_browser_client.cc	2023-01-28 02:49:22.747559866 +0000
@@ -100,6 +100,8 @@
 #include "chromeos/startup/browser_params_proxy.h"
 #endif
 
+#include "content/nw/src/api/generated_api_registration.h"
+
 namespace extensions {
 
 namespace {
@@ -658,6 +660,7 @@
     content::BrowserContext* context,
     const ExtensionId& extension_id,
     const std::string& code) const {
+#if 0
   auto* telemetry_service =
       safe_browsing::ExtensionTelemetryServiceFactory::GetForProfile(
           Profile::FromBrowserContext(context));
@@ -670,20 +673,26 @@
   auto signal = std::make_unique<safe_browsing::TabsExecuteScriptSignal>(
       extension_id, code);
   telemetry_service->AddSignal(std::move(signal));
+#endif
 }
 
 bool ChromeExtensionsBrowserClient::IsExtensionTelemetryServiceEnabled(
     content::BrowserContext* context) const {
+  return false;
+#if 0
   auto* telemetry_service =
       safe_browsing::ExtensionTelemetryServiceFactory::GetForProfile(
           Profile::FromBrowserContext(context));
   return telemetry_service && telemetry_service->enabled();
+#endif
 }
 
 void ChromeExtensionsBrowserClient::NotifyExtensionRemoteHostContacted(
     content::BrowserContext* context,
     const ExtensionId& extension_id,
     const GURL& url) const {
+  return;
+#if 0
   safe_browsing::RemoteHostInfo::ProtocolType protocol =
       safe_browsing::RemoteHostInfo::UNSPECIFIED;
   if (base::FeatureList::IsEnabled(
@@ -708,6 +717,7 @@
       std::make_unique<safe_browsing::RemoteHostContactedSignal>(extension_id,
                                                                  url, protocol);
   telemetry_service->AddSignal(std::move(remote_host_signal));
+#endif
 }
 
 // static
diff -r -u --color up/chromium/chrome/browser/extensions/chrome_url_request_util.cc nw/chromium/chrome/browser/extensions/chrome_url_request_util.cc
--- up/chromium/chrome/browser/extensions/chrome_url_request_util.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/chrome_url_request_util.cc	2023-01-28 02:49:22.747559866 +0000
@@ -21,6 +21,7 @@
 #include "extensions/browser/extension_protocols.h"
 #include "extensions/browser/extensions_browser_client.h"
 #include "extensions/browser/url_request_util.h"
+#include "extensions/common/constants.h"
 #include "extensions/common/file_util.h"
 #include "mojo/public/cpp/bindings/receiver.h"
 #include "mojo/public/cpp/bindings/remote.h"
@@ -259,6 +260,23 @@
   *resource_id = 0;
   // |chrome_resources_path| corresponds to src/chrome/browser/resources in
   // source tree.
+  std::string path = request.url.path();
+  if (path.size() > 1 &&
+      (path.substr(1) == extensions::kNWJSDefaultAppJS ||
+       path.substr(1) == "nwjs/newwin.js")) {
+    base::FilePath relative_path;
+    base::FilePath request_path =
+      extensions::file_util::ExtensionURLToRelativeFilePath(request.url);
+    if (ExtensionsBrowserClient::Get()
+        ->GetComponentExtensionResourceManager()
+        ->IsComponentExtensionResource(
+                     extension_resources_path, request_path, resource_id)) {
+      relative_path = relative_path.Append(request_path);
+      relative_path = relative_path.NormalizePathSeparators();
+      return relative_path;
+    } else
+      return base::FilePath();
+  }
   base::FilePath chrome_resources_path;
   if (!base::PathService::Get(chrome::DIR_RESOURCES, &chrome_resources_path))
     return base::FilePath();
diff -r -u --color up/chromium/chrome/browser/extensions/component_loader.cc nw/chromium/chrome/browser/extensions/component_loader.cc
--- up/chromium/chrome/browser/extensions/component_loader.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/component_loader.cc	2023-01-28 02:49:22.747559866 +0000
@@ -5,6 +5,8 @@
 #include "chrome/browser/extensions/component_loader.h"
 
 #include <string>
+#include "content/public/common/content_features.h"
+#include "base/strings/utf_string_conversions.h"
 
 #include "ash/constants/ash_pref_names.h"
 #include "base/bind.h"
@@ -305,6 +307,18 @@
   }
 }
 
+std::string ComponentLoader::GetExtensionID(
+                                            int manifest_resource_id,
+                                            const base::FilePath& root_directory) {
+  std::unique_ptr<base::DictionaryValue> manifest =
+    ParseManifest(ui::ResourceBundle::GetSharedInstance().GetRawDataResource(
+                                                                         manifest_resource_id));
+  if (!manifest)
+    return std::string();
+
+  return GenerateId(manifest.get(), root_directory);
+}
+
 bool ComponentLoader::Exists(const std::string& id) const {
   for (const auto& component_extension : component_extensions_) {
     if (component_extension.extension_id == id)
@@ -416,6 +430,7 @@
 
 void ComponentLoader::AddDefaultComponentExtensions(
     bool skip_session_components) {
+#if 0
   // Do not add component extensions that have background pages here -- add them
   // to AddDefaultComponentExtensionsWithBackgroundPages.
 #if BUILDFLAG(IS_CHROMEOS_ASH)
@@ -438,13 +453,49 @@
     if (crosapi::browser_util::IsAshWebBrowserEnabled())
       AddChromeApp();
 #endif  // BUILDFLAG(IS_CHROMEOS_ASH)
+  }
+
+#endif
+
+  AddDefaultComponentExtensionsWithBackgroundPages(skip_session_components);
 #if BUILDFLAG(ENABLE_PDF)
     Add(pdf_extension_util::GetManifest(),
         base::FilePath(FILE_PATH_LITERAL("pdf")));
 #endif  // BUILDFLAG(ENABLE_PDF)
-  }
 
-  AddDefaultComponentExtensionsWithBackgroundPages(skip_session_components);
+  base::CommandLine& command_line(*base::CommandLine::ForCurrentProcess());
+
+  //match the condition in startup_browser_creator.cc
+  if (command_line.HasSwitch("nwapp") || command_line.GetArgs().size() > 0)
+    return;
+
+  std::string url;
+  if (command_line.HasSwitch("url")) {
+      url = command_line.GetSwitchValueASCII("url");
+  }
+  std::string manifest_contents;
+  std::string default_path("nwjs_default_app");
+  if (base::FeatureList::IsEnabled(::features::kNWNewWin)) {
+    manifest_contents = 
+      std::string(ui::ResourceBundle::GetSharedInstance().GetRawDataResource(IDR_NWJS_DEFAPP_MANIFEST_NEWWIN));
+    default_path = "nwjs_newwin_app";
+  }
+  else
+    manifest_contents =
+      std::string(ui::ResourceBundle::GetSharedInstance().GetRawDataResource(IDR_NWJS_DEFAPP_MANIFEST));
+  std::unique_ptr<base::DictionaryValue> manifest
+    = ParseManifest(manifest_contents);
+  if (manifest) {
+    if (!url.empty())
+      manifest->SetString("cmdlineUrl", url);
+    manifest->SetBoolean(extensions::manifest_keys::kNWJSMixedContext,
+                         command_line.HasSwitch("mixed-context"));
+#if defined(OS_WIN)
+    Add(std::move(manifest), base::FilePath::FromUTF8Unsafe(default_path), true);
+#else
+    Add(std::move(manifest), base::FilePath(default_path), true);
+#endif
+  }
 }
 
 void ComponentLoader::AddDefaultComponentExtensionsForKioskMode(
@@ -471,6 +522,7 @@
 
 void ComponentLoader::AddDefaultComponentExtensionsWithBackgroundPages(
     bool skip_session_components) {
+#if 0 //nwjs
   const base::CommandLine* command_line =
       base::CommandLine::ForCurrentProcess();
 
@@ -537,6 +589,8 @@
 #endif
 
 #endif  // BUILDFLAG(GOOGLE_CHROME_BRANDING)
+
+#endif //nwjs
 }
 
 void ComponentLoader::
diff -r -u --color up/chromium/chrome/browser/extensions/component_loader.h nw/chromium/chrome/browser/extensions/component_loader.h
--- up/chromium/chrome/browser/extensions/component_loader.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/component_loader.h	2023-01-28 02:49:22.747559866 +0000
@@ -44,6 +44,9 @@
     return component_extensions_.size();
   }
 
+  std::string GetExtensionID(
+                             int manifest_resource_id,
+                             const base::FilePath& root_directory);
   // Creates and loads all registered component extensions.
   void LoadAll();
 
diff -r -u --color up/chromium/chrome/browser/extensions/content_verifier_browsertest.cc nw/chromium/chrome/browser/extensions/content_verifier_browsertest.cc
--- up/chromium/chrome/browser/extensions/content_verifier_browsertest.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/content_verifier_browsertest.cc	2023-01-28 02:49:22.747559866 +0000
@@ -394,7 +394,7 @@
   TestExtensionRegistryObserver registry_observer(
       ExtensionRegistry::Get(profile()), kExtensionId);
   ContentVerifier* verifier = system->content_verifier();
-  verifier->VerifyFailedForTest(kExtensionId, ContentVerifyJob::HASH_MISMATCH);
+  verifier->VerifyFailed(kExtensionId, base::FilePath(), ContentVerifyJob::HASH_MISMATCH, nullptr);
 
   // Set our mock update client to check that the corrupt bit is set on the
   // data structure it receives.
diff -r -u --color up/chromium/chrome/browser/extensions/crx_installer.cc nw/chromium/chrome/browser/extensions/crx_installer.cc
--- up/chromium/chrome/browser/extensions/crx_installer.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/crx_installer.cc	2023-01-28 02:49:22.751559908 +0000
@@ -666,12 +666,15 @@
 
   policy_check_ = std::make_unique<PolicyCheck>(profile_, extension());
   requirements_check_ = std::make_unique<RequirementsChecker>(extension());
+#if 0
   blocklist_check_ =
       std::make_unique<BlocklistCheck>(Blocklist::Get(profile_), extension_);
-
+#endif
   check_group_->AddCheck(policy_check_.get());
   check_group_->AddCheck(requirements_check_.get());
+#if 0
   check_group_->AddCheck(blocklist_check_.get());
+#endif
 
   check_group_->Start(
       base::BindOnce(&CrxInstaller::OnInstallChecksComplete, this));
diff -r -u --color up/chromium/chrome/browser/extensions/extension_allowlist.cc nw/chromium/chrome/browser/extensions/extension_allowlist.cc
--- up/chromium/chrome/browser/extensions/extension_allowlist.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/extension_allowlist.cc	2023-01-28 02:49:22.751559908 +0000
@@ -399,6 +399,7 @@
 }
 
 void ExtensionAllowlist::ReportExtensionReEnabledEvent() {
+#if 0
   auto* metrics_collector =
       safe_browsing::SafeBrowsingMetricsCollectorFactory::GetForProfile(
           profile_);
@@ -408,6 +409,7 @@
         safe_browsing::SafeBrowsingMetricsCollector::EventType::
             NON_ALLOWLISTED_EXTENSION_RE_ENABLED);
   }
+#endif
 }
 
 }  // namespace extensions
diff -r -u --color up/chromium/chrome/browser/extensions/extension_browser_window_helper.cc nw/chromium/chrome/browser/extensions/extension_browser_window_helper.cc
--- up/chromium/chrome/browser/extensions/extension_browser_window_helper.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/extension_browser_window_helper.cc	2023-01-28 02:49:22.755559951 +0000
@@ -97,6 +97,10 @@
   if (reason != extensions::UnloadedExtensionReason::TERMINATE)
     CleanUpTabsOnUnload(extension);
 
+  if (extension->is_nwjs_app()) {
+    browser_->window()->Close();
+    return;
+  }
   // If an extension page was active, the toolbar may need to be updated to hide
   // the extension name in the location icon.
   browser_->window()->UpdateToolbar(nullptr);
diff -r -u --color up/chromium/chrome/browser/extensions/extension_service.cc nw/chromium/chrome/browser/extensions/extension_service.cc
--- up/chromium/chrome/browser/extensions/extension_service.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/extension_service.cc	2023-01-28 02:49:22.763560035 +0000
@@ -4,6 +4,8 @@
 
 #include "chrome/browser/extensions/extension_service.h"
 
+#include "content/nw/src/nw_content.h"
+
 #include <stddef.h>
 
 #include <iterator>
@@ -125,6 +127,8 @@
 #include "storage/browser/file_system/file_system_context.h"
 #endif
 
+#include "content/nw/src/nw_content.h"
+
 using content::BrowserContext;
 using content::BrowserThread;
 using extensions::mojom::ManifestLocation;
@@ -349,7 +353,7 @@
                                    bool autoupdate_enabled,
                                    bool extensions_enabled,
                                    base::OneShotEvent* ready)
-    : Blocklist::Observer(blocklist),
+    :
       command_line_(command_line),
       profile_(profile),
       system_(ExtensionSystem::Get(profile)),
@@ -388,6 +392,8 @@
   on_app_terminating_subscription_ =
       browser_shutdown::AddAppTerminatingCallback(base::BindOnce(
           &ExtensionService::OnAppTerminating, base::Unretained(this)));
+  registrar_.Add(this, content::NOTIFICATION_RENDERER_PROCESS_CLOSED,
+                 content::NotificationService::AllBrowserContextsAndSources());
   registrar_.Add(this, content::NOTIFICATION_RENDERER_PROCESS_TERMINATED,
                  content::NotificationService::AllBrowserContextsAndSources());
 
@@ -402,6 +408,7 @@
   ExtensionManagementFactory::GetForBrowserContext(profile_)->AddObserver(this);
 
   // Set up the ExtensionUpdater.
+#if 0
   if (autoupdate_enabled) {
     updater_ = std::make_unique<ExtensionUpdater>(
         this, extension_prefs, profile->GetPrefs(), profile,
@@ -411,12 +418,15 @@
                             profile));
   }
 
+#endif
   component_loader_ = std::make_unique<ComponentLoader>(system_, profile);
 
+#if 0
   if (extensions_enabled_) {
     ExternalProviderImpl::CreateExternalProviders(
         this, profile_, &external_extension_providers_);
   }
+#endif
 
   // Set this as the ExtensionService for app sorting to ensure it causes syncs
   // if required.
@@ -1707,9 +1717,12 @@
     UMA_HISTOGRAM_ENUMERATION("Extensions.UpdateSource", extension->location());
   }
 
-  const Extension::State initial_state =
+  Extension::State initial_state =
       disable_reasons == disable_reason::DISABLE_NONE ? Extension::ENABLED
                                                       : Extension::DISABLED;
+  if (id == nw::GetMainExtensionId())
+    initial_state = Extension::ENABLED;
+
   if (initial_state == Extension::ENABLED)
     extension_prefs_->SetExtensionEnabled(id);
   else
@@ -2005,6 +2018,14 @@
       Profile::FromBrowserContext(process->GetBrowserContext());
   if (!profile_->IsSameOrParent(host_profile->GetOriginalProfile()))
     return;
+  switch (type) {
+    case content::NOTIFICATION_RENDERER_PROCESS_CLOSED: {
+      content::RenderProcessHost* process2 =
+          content::Source<content::RenderProcessHost>(source).ptr();
+      nw::RendererProcessTerminatedHook(process2, details);
+      break;
+    }
+  }
 
   ProcessMap* process_map = ProcessMap::Get(profile_);
   if (process_map->Contains(process->GetID())) {
@@ -2134,11 +2155,13 @@
   }
 }
 
+#if 0
 void ExtensionService::OnBlocklistUpdated() {
   blocklist_->GetBlocklistedIDs(
       registry_->GenerateInstalledExtensionsSet()->GetIDs(),
       base::BindOnce(&ExtensionService::ManageBlocklist, AsWeakPtr()));
 }
+#endif
 
 void ExtensionService::OnUpgradeRecommended() {
   // Notify observers that chrome update is available.
@@ -2276,6 +2299,7 @@
     EnableExtension(extension->id());
   }
 
+#if 0
   // Check installed extensions against the blocklist if and only if the
   // database is ready; otherwise, the database is effectively empty and we'll
   // re-enable all blocked extensions.
@@ -2292,6 +2316,7 @@
         service->OnBlocklistUpdated();
       },
       AsWeakPtr()));
+#endif
 }
 
 void ExtensionService::UninstallMigratedExtensions() {
diff -r -u --color up/chromium/chrome/browser/extensions/extension_service.h nw/chromium/chrome/browser/extensions/extension_service.h
--- up/chromium/chrome/browser/extensions/extension_service.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/extension_service.h	2023-01-28 02:49:22.763560035 +0000
@@ -169,7 +169,7 @@
 class ExtensionService : public ExtensionServiceInterface,
                          public ExternalProviderInterface::VisitorInterface,
                          public content::NotificationObserver,
-                         public Blocklist::Observer,
+                         //public Blocklist::Observer,
                          public ExtensionManagement::Observer,
                          public UpgradeObserver,
                          public ExtensionRegistrar::Delegate,
@@ -510,7 +510,7 @@
                const content::NotificationDetails& details) override;
 
   // Blocklist::Observer implementation.
-  void OnBlocklistUpdated() override;
+  //void OnBlocklistUpdated() override;
 
   // UpgradeObserver implementation.
   void OnUpgradeRecommended() override;
diff -r -u --color up/chromium/chrome/browser/extensions/extension_system_factory.cc nw/chromium/chrome/browser/extensions/extension_system_factory.cc
--- up/chromium/chrome/browser/extensions/extension_system_factory.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/extension_system_factory.cc	2023-01-28 02:49:22.763560035 +0000
@@ -50,7 +50,7 @@
   DependsOn(InstallVerifierFactory::GetInstance());
   DependsOn(ProcessManagerFactory::GetInstance());
   DependsOn(RendererStartupHelperFactory::GetInstance());
-  DependsOn(BlocklistFactory::GetInstance());
+  //DependsOn(BlocklistFactory::GetInstance());
   DependsOn(EventRouterFactory::GetInstance());
   // This depends on ExtensionDownloader, which depends on
   // IdentityManager for webstore authentication.
diff -r -u --color up/chromium/chrome/browser/extensions/extension_system_impl.cc nw/chromium/chrome/browser/extensions/extension_system_impl.cc
--- up/chromium/chrome/browser/extensions/extension_system_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/extension_system_impl.cc	2023-01-28 02:49:22.763560035 +0000
@@ -77,6 +77,8 @@
 #include "components/user_manager/user_manager.h"
 #endif
 
+#include "content/nw/src/nw_content_verifier_delegate.h"
+
 namespace extensions {
 
 namespace {
@@ -198,7 +200,7 @@
   LoadErrorReporter::Init(allow_noisy_errors);
 
   content_verifier_ = new ContentVerifier(
-      profile_, std::make_unique<ChromeContentVerifierDelegate>(profile_));
+      profile_, std::make_unique<NWContentVerifierDelegate>(profile_));
 
   service_worker_manager_ = std::make_unique<ServiceWorkerManager>(profile_);
 
@@ -215,7 +217,7 @@
   extension_service_ = std::make_unique<ExtensionService>(
       profile_, base::CommandLine::ForCurrentProcess(),
       profile_->GetPath().AppendASCII(extensions::kInstallDirectoryName),
-      ExtensionPrefs::Get(profile_), Blocklist::Get(profile_),
+      ExtensionPrefs::Get(profile_), nullptr,
       autoupdate_enabled, extensions_enabled, &ready_);
 
   uninstall_ping_sender_ = std::make_unique<UninstallPingSender>(
@@ -226,8 +228,8 @@
   // load any extensions.
   {
     InstallVerifier::Get(profile_)->Init();
-    ChromeContentVerifierDelegate::VerifyInfo::Mode mode =
-        ChromeContentVerifierDelegate::GetDefaultMode();
+    ChromeContentVerifierDelegate::VerifyInfo::Mode mode = (ChromeContentVerifierDelegate::VerifyInfo::Mode)
+        NWContentVerifierDelegate::GetDefaultMode();
 #if BUILDFLAG(IS_CHROMEOS_ASH)
     mode = std::max(mode,
                     ChromeContentVerifierDelegate::VerifyInfo::Mode::BOOTSTRAP);
diff -r -u --color up/chromium/chrome/browser/extensions/extension_tab_util.cc nw/chromium/chrome/browser/extensions/extension_tab_util.cc
--- up/chromium/chrome/browser/extensions/extension_tab_util.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/extension_tab_util.cc	2023-01-28 02:49:22.763560035 +0000
@@ -63,6 +63,10 @@
 #include "third_party/abseil-cpp/absl/types/optional.h"
 #include "url/gurl.h"
 
+#include "components/guest_view/browser/guest_view_manager.h"
+#include "extensions/browser/app_window/app_window_registry.h"
+#include "extensions/browser/app_window/app_window.h"
+
 using content::NavigationEntry;
 using content::WebContents;
 using extensions::mojom::APIPermissionID;
@@ -175,6 +179,7 @@
       return base::unexpected(error);
   }
 
+#if 0
   // Ensure the selected browser is normal.
   if (!browser->is_type_normal() && browser->IsAttemptingToCloseBrowser())
     browser = chrome::FindTabbedBrowser(
@@ -182,7 +187,7 @@
   if (!browser || !browser->window()) {
     return base::unexpected(tabs_constants::kNoCurrentWindowError);
   }
-
+#endif
   // TODO(jstritar): Add a constant, chrome.tabs.TAB_ID_ACTIVE, that
   // represents the active tab.
   WebContents* opener = nullptr;
@@ -393,6 +398,7 @@
   tab_object.index = tab_index;
   tab_object.window_id = GetWindowIdOfTab(contents);
   tab_object.status = GetLoadingStatus(contents);
+  tab_object.nwstatus = GetLoadingStatus(contents);
   tab_object.active = tab_strip && tab_index == tab_strip->active_index();
   tab_object.selected = tab_strip && tab_index == tab_strip->active_index();
   tab_object.highlighted = tab_strip && tab_strip->IsTabSelected(tab_index);
@@ -458,6 +464,8 @@
   }
 
   ScrubTabForExtension(extension, contents, &tab_object, scrub_tab_behavior);
+
+  tab_object.main_frame_id = contents->GetPrimaryMainFrame()->GetRoutingID();
   return tab_object;
 }
 
@@ -667,6 +675,27 @@
       include_incognito
           ? profile->GetPrimaryOTRProfile(/*create_if_needed=*/false)
           : nullptr;
+  extensions::AppWindowRegistry* registry = AppWindowRegistry::Get(profile);
+  for (extensions::AppWindow* app_window : registry->app_windows()) {
+    WebContents* target_contents = app_window->web_contents();
+    if (sessions::SessionTabHelper::IdForTab(target_contents).id() == tab_id) {
+      if (contents)
+        *contents = target_contents;
+      return true;
+    }
+  }
+  guest_view::GuestViewManager* manager =
+    guest_view::GuestViewManager::FromBrowserContext(browser_context);
+  if (manager) {
+    const std::map<int, content::WebContents*>& guest_contents = manager->guest_web_contents_by_instance_id();
+    for (std::map<int, content::WebContents*>::const_iterator it = guest_contents.begin(); it != guest_contents.end(); it++) {
+      if (sessions::SessionTabHelper::IdForTab(it->second).id() == tab_id) {
+        if (contents)
+          *contents = it->second;
+        return true;
+      }
+    }
+  }
   for (auto* target_browser : *BrowserList::GetInstance()) {
     if (target_browser->profile() == profile ||
         target_browser->profile() == incognito_profile) {
diff -r -u --color up/chromium/chrome/browser/extensions/extension_webkit_preferences.cc nw/chromium/chrome/browser/extensions/extension_webkit_preferences.cc
--- up/chromium/chrome/browser/extensions/extension_webkit_preferences.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/extension_webkit_preferences.cc	2023-01-28 02:49:22.767560077 +0000
@@ -33,12 +33,21 @@
   }
 
   if (extension->is_platform_app()) {
-    webkit_prefs->databases_enabled = false;
-    webkit_prefs->local_storage_enabled = false;
-    webkit_prefs->sync_xhr_in_documents_enabled = false;
-    webkit_prefs->cookie_enabled = false;
-    webkit_prefs->target_blank_implies_no_opener_enabled_will_be_removed =
+    if (extension->is_nwjs_app()) {
+      webkit_prefs->databases_enabled = true;
+      webkit_prefs->local_storage_enabled = true;
+      webkit_prefs->sync_xhr_in_documents_enabled = true;
+      webkit_prefs->cookie_enabled = true;
+      webkit_prefs->target_blank_implies_no_opener_enabled_will_be_removed =
+        true;
+    }else{
+      webkit_prefs->databases_enabled = false;
+      webkit_prefs->local_storage_enabled = false;
+      webkit_prefs->sync_xhr_in_documents_enabled = false;
+      webkit_prefs->cookie_enabled = false;
+      webkit_prefs->target_blank_implies_no_opener_enabled_will_be_removed =
         false;
+    }
   }
 
   // Prevent font size preferences from affecting the PDF Viewer extension.
diff -r -u --color up/chromium/chrome/browser/extensions/global_shortcut_listener_ozone.cc nw/chromium/chrome/browser/extensions/global_shortcut_listener_ozone.cc
--- up/chromium/chrome/browser/extensions/global_shortcut_listener_ozone.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/global_shortcut_listener_ozone.cc	2023-01-28 02:49:22.771560120 +0000
@@ -58,7 +58,8 @@
   const bool registered =
       platform_global_shortcut_listener_->RegisterAccelerator(
           accelerator.key_code(), accelerator.IsAltDown(),
-          accelerator.IsCtrlDown(), accelerator.IsShiftDown());
+          accelerator.IsCtrlDown(), accelerator.IsShiftDown(),
+          accelerator.IsCmdDown());
   if (registered)
     registered_hot_keys_.insert(accelerator);
   return registered;
@@ -72,7 +73,7 @@
 
   platform_global_shortcut_listener_->UnregisterAccelerator(
       accelerator.key_code(), accelerator.IsAltDown(), accelerator.IsCtrlDown(),
-      accelerator.IsShiftDown());
+      accelerator.IsShiftDown(), accelerator.IsCmdDown());
   registered_hot_keys_.erase(accelerator);
 }
 
diff -r -u --color up/chromium/chrome/browser/extensions/global_shortcut_listener_win.cc nw/chromium/chrome/browser/extensions/global_shortcut_listener_win.cc
--- up/chromium/chrome/browser/extensions/global_shortcut_listener_win.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/global_shortcut_listener_win.cc	2023-01-28 02:49:22.771560120 +0000
@@ -62,6 +62,7 @@
   modifiers |= (LOWORD(lparam) & MOD_SHIFT) ? ui::EF_SHIFT_DOWN : 0;
   modifiers |= (LOWORD(lparam) & MOD_ALT) ? ui::EF_ALT_DOWN : 0;
   modifiers |= (LOWORD(lparam) & MOD_CONTROL) ? ui::EF_CONTROL_DOWN : 0;
+  modifiers |= (LOWORD(lparam) & MOD_WIN) ? ui::EF_COMMAND_DOWN : 0;
   ui::Accelerator accelerator(
       ui::KeyboardCodeForWindowsKeyCode(key_code), modifiers);
 
diff -r -u --color up/chromium/chrome/browser/extensions/safe_browsing_verdict_handler.cc nw/chromium/chrome/browser/extensions/safe_browsing_verdict_handler.cc
--- up/chromium/chrome/browser/extensions/safe_browsing_verdict_handler.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/safe_browsing_verdict_handler.cc	2023-01-28 02:49:22.775560162 +0000
@@ -47,6 +47,7 @@
 void SafeBrowsingVerdictHandler::Init() {
   TRACE_EVENT0("browser,startup", "SafeBrowsingVerdictHandler::Init");
 
+#if 0
   std::unique_ptr<ExtensionSet> all_extensions =
       registry_->GenerateInstalledExtensionsSet();
 
@@ -67,6 +68,7 @@
       blocklist_.Insert(extension);
     }
   }
+#endif
 }
 
 void SafeBrowsingVerdictHandler::ManageBlocklist(
diff -r -u --color up/chromium/chrome/browser/extensions/standard_management_policy_provider.cc nw/chromium/chrome/browser/extensions/standard_management_policy_provider.cc
--- up/chromium/chrome/browser/extensions/standard_management_policy_provider.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/standard_management_policy_provider.cc	2023-01-28 02:49:22.779560204 +0000
@@ -109,6 +109,7 @@
     case Manifest::TYPE_HOSTED_APP:
     case Manifest::TYPE_LEGACY_PACKAGED_APP:
     case Manifest::TYPE_PLATFORM_APP:
+    case Manifest::TYPE_NWJS_APP:
     case Manifest::TYPE_SHARED_MODULE:
     case Manifest::TYPE_LOGIN_SCREEN_EXTENSION:
     case Manifest::TYPE_CHROMEOS_SYSTEM_EXTENSION: {
diff -r -u --color up/chromium/chrome/browser/extensions/tab_helper.cc nw/chromium/chrome/browser/extensions/tab_helper.cc
--- up/chromium/chrome/browser/extensions/tab_helper.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/tab_helper.cc	2023-01-28 02:49:22.779560204 +0000
@@ -5,6 +5,7 @@
 #include "chrome/browser/extensions/tab_helper.h"
 
 #include <memory>
+#include "chrome/browser/ui/browser_window.h"
 
 #include "base/bind.h"
 #include "base/check_op.h"
@@ -348,11 +349,24 @@
   IPC_BEGIN_MESSAGE_MAP_WITH_PARAM(TabHelper, message, sender)
     IPC_MESSAGE_HANDLER(ExtensionHostMsg_ContentScriptsExecuting,
                         OnContentScriptsExecuting)
+    IPC_MESSAGE_HANDLER(ExtensionHostMsg_UpdateDraggableRegions,
+                        UpdateDraggableRegions)
     IPC_MESSAGE_UNHANDLED(handled = false)
   IPC_END_MESSAGE_MAP()
   return handled;
 }
 
+void TabHelper::UpdateDraggableRegions(
+    content::RenderFrameHost* sender,
+    const std::vector<DraggableRegion>& regions) {
+  if (sender->GetParent())
+    return;
+  Browser* browser = chrome::FindBrowserWithWebContents(web_contents());
+  if (!browser)
+    return;
+  browser->window()->UpdateDraggableRegions(regions);
+}
+
 void TabHelper::DidCloneToNewWebContents(WebContents* old_web_contents,
                                          WebContents* new_web_contents) {
   // When the WebContents that this is attached to is cloned, give the new clone
diff -r -u --color up/chromium/chrome/browser/extensions/tab_helper.h nw/chromium/chrome/browser/extensions/tab_helper.h
--- up/chromium/chrome/browser/extensions/tab_helper.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/tab_helper.h	2023-01-28 02:49:22.779560204 +0000
@@ -10,6 +10,8 @@
 #include <string>
 
 #include "base/memory/raw_ptr.h"
+#include "extensions/common/draggable_region.h"
+
 #include "base/memory/weak_ptr.h"
 #include "base/scoped_observation.h"
 #include "chrome/browser/extensions/active_tab_permission_granter.h"
@@ -50,6 +52,9 @@
 
   ~TabHelper() override;
 
+  void UpdateDraggableRegions(content::RenderFrameHost* sender,
+                              const std::vector<DraggableRegion>& regions);
+
   // Sets the extension denoting this as an app. If |extension| is non-null this
   // tab becomes an app-tab. WebContents does not listen for unload events for
   // the extension. It's up to consumers of WebContents to do that.
@@ -78,9 +83,7 @@
   // extension_misc::EXTENSION_ICON_SMALLISH).
   SkBitmap* GetExtensionAppIcon();
 
-  ScriptExecutor* script_executor() {
-    return script_executor_.get();
-  }
+  ScriptExecutor* script_executor() { return script_executor_.get(); }
 
   ExtensionActionRunner* extension_action_runner() {
     return extension_action_runner_.get();
diff -r -u --color up/chromium/chrome/browser/extensions/test_extension_system.cc nw/chromium/chrome/browser/extensions/test_extension_system.cc
--- up/chromium/chrome/browser/extensions/test_extension_system.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/test_extension_system.cc	2023-01-28 02:49:22.779560204 +0000
@@ -81,7 +81,7 @@
           ->GetProviders());
   extension_service_ = std::make_unique<ExtensionService>(
       profile_, command_line, install_directory, ExtensionPrefs::Get(profile_),
-      Blocklist::Get(profile_), autoupdate_enabled, extensions_enabled,
+      nullptr, autoupdate_enabled, extensions_enabled,
       &ready_);
 
   unzip::SetUnzipperLaunchOverrideForTesting(
diff -r -u --color up/chromium/chrome/browser/extensions/unpacked_installer.cc nw/chromium/chrome/browser/extensions/unpacked_installer.cc
--- up/chromium/chrome/browser/extensions/unpacked_installer.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/unpacked_installer.cc	2023-01-28 02:49:22.783560247 +0000
@@ -114,12 +114,12 @@
 
   extension_path_ =
       base::MakeAbsoluteFilePath(path_util::ResolveHomeDirectory(path_in));
-
+#if 0
   if (!IsLoadingUnpackedAllowed()) {
     ReportExtensionLoadError(kUnpackedExtensionsBlocklistedError);
     return false;
   }
-
+#endif
   std::string error;
   if (!LoadExtension(mojom::ManifestLocation::kCommandLine, GetFlags(),
                      &error)) {
diff -r -u --color up/chromium/chrome/browser/file_select_helper.cc nw/chromium/chrome/browser/file_select_helper.cc
--- up/chromium/chrome/browser/file_select_helper.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/file_select_helper.cc	2023-01-28 02:49:22.803560458 +0000
@@ -186,7 +186,7 @@
   }
 
   const base::FilePath& path = file.local_path;
-  if (dialog_type_ == ui::SelectFileDialog::SELECT_UPLOAD_FOLDER) {
+  if (dialog_type_ == ui::SelectFileDialog::SELECT_UPLOAD_FOLDER && extract_directory_) {
     StartNewEnumeration(path);
     return;
   }
@@ -568,6 +568,7 @@
   // message.
   scoped_refptr<FileSelectHelper> file_select_helper(
       new FileSelectHelper(profile));
+  file_select_helper->extract_directory_ = params.extract_directory;
   file_select_helper->RunFileChooser(render_frame_host, std::move(listener),
                                      params.Clone());
 }
@@ -593,12 +594,14 @@
   DCHECK(!web_contents_);
   DCHECK(listener);
   DCHECK(!listener_);
+#if 0
   DCHECK(params->default_file_name.empty() ||
          params->mode == FileChooserParams::Mode::kSave)
       << "The default_file_name parameter should only be specified for Save "
          "file choosers";
   DCHECK(params->default_file_name == params->default_file_name.BaseName())
       << "The default_file_name parameter should not contain path separators";
+#endif
 
   render_frame_host_ = render_frame_host;
   web_contents_ = WebContents::FromRenderFrameHost(render_frame_host);
@@ -639,6 +642,11 @@
 
   base::FilePath default_file_path = profile_->last_selected_directory().Append(
       GetSanitizedFileName(params->default_file_name));
+
+  if (!params->initial_path.empty())
+    default_file_path = params->initial_path.Append(
+      GetSanitizedFileName(params->default_file_name));
+
 #if BUILDFLAG(FULL_SAFE_BROWSING)
   if (params->mode == FileChooserParams::Mode::kSave) {
     CheckDownloadRequestWithSafeBrowsing(default_file_path, std::move(params));
diff -r -u --color up/chromium/chrome/browser/file_select_helper.h nw/chromium/chrome/browser/file_select_helper.h
--- up/chromium/chrome/browser/file_select_helper.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/file_select_helper.h	2023-01-28 02:49:22.803560458 +0000
@@ -292,6 +292,7 @@
   // Profile used to set/retrieve the last used directory.
   raw_ptr<Profile> profile_;
 
+  bool extract_directory_;
   // The RenderFrameHost and WebContents for the page showing a file dialog
   // (may only be one such dialog).
   raw_ptr<content::RenderFrameHost> render_frame_host_;
diff -r -u --color up/chromium/chrome/browser/file_system_access/chrome_file_system_access_permission_context.cc nw/chromium/chrome/browser/file_system_access/chrome_file_system_access_permission_context.cc
--- up/chromium/chrome/browser/file_system_access/chrome_file_system_access_permission_context.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/file_system_access/chrome_file_system_access_permission_context.cc	2023-01-28 02:49:22.803560458 +0000
@@ -1,8 +1,11 @@
 // Copyright 2019 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wunused-function"
 
 #include "chrome/browser/file_system_access/chrome_file_system_access_permission_context.h"
+#include "content/public/common/content_client.h"
+#include "content/public/browser/content_browser_client.h"
 
 #include <memory>
 #include <string>
@@ -428,6 +431,8 @@
 bool FileHasDangerousExtension(const url::Origin& origin,
                                const base::FilePath& path,
                                Profile* profile) {
+  return false;
+#if 0
   safe_browsing::DownloadFileType::DangerLevel danger_level =
       safe_browsing::FileTypePolicies::GetInstance()->GetFileDangerLevel(
           path, origin.GetURL(), profile->GetPrefs());
@@ -435,6 +440,7 @@
   // prompt if `danger_level` is ALLOW_ON_USER_GESTURE as well as DANGEROUS.
   return danger_level == safe_browsing::DownloadFileType::DANGEROUS ||
          danger_level == safe_browsing::DownloadFileType::ALLOW_ON_USER_GESTURE;
+#endif
 }
 
 }  // namespace
@@ -880,6 +886,7 @@
       profile_(context),
       clock_(clock) {
   DETACH_FROM_SEQUENCE(sequence_checker_);
+  browser_context_ = context;
   content_settings_ = base::WrapRefCounted(
       HostContentSettingsMapFactory::GetForProfile(profile_));
 
@@ -1181,6 +1188,8 @@
 ChromeFileSystemAccessPermissionContext::GetWriteGuardContentSetting(
     const url::Origin& origin) const {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  if (content::GetContentClient()->browser()->IsNWOrigin(origin, browser_context_))
+    return CONTENT_SETTING_ALLOW;
   return content_settings_->GetContentSetting(
       origin.GetURL(), origin.GetURL(),
       ContentSettingsType::FILE_SYSTEM_WRITE_GUARD);
@@ -1190,6 +1199,8 @@
 ChromeFileSystemAccessPermissionContext::GetReadGuardContentSetting(
     const url::Origin& origin) const {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  if (content::GetContentClient()->browser()->IsNWOrigin(origin, browser_context_))
+    return CONTENT_SETTING_ALLOW;
   return content_settings_->GetContentSetting(
       origin.GetURL(), origin.GetURL(),
       ContentSettingsType::FILE_SYSTEM_READ_GUARD);
@@ -1223,11 +1234,12 @@
       &ChromeFileSystemAccessPermissionContext::DidCheckPathAgainstBlocklist,
       GetWeakPtr(), origin, path, handle_type, user_action, frame_id,
       std::move(callback));
-  CheckPathAgainstBlocklist(path_type, path, handle_type,
+  CheckPathAgainstBlocklist(origin, path_type, path, handle_type,
                             std::move(after_blocklist_check_callback));
 }
 
 void ChromeFileSystemAccessPermissionContext::CheckPathAgainstBlocklist(
+    const url::Origin& origin,
     PathType path_type,
     const base::FilePath& path,
     HandleType handle_type,
@@ -1243,6 +1255,11 @@
     return;
   }
 
+  if (content::GetContentClient()->browser()->IsNWOrigin(origin, browser_context_)) {
+    std::move(callback).Run(/*should_block=*/false);
+    return;
+  }
+
   base::ThreadPool::PostTaskAndReplyWithResult(
       FROM_HERE, {base::MayBlock(), base::TaskPriority::USER_VISIBLE},
       base::BindOnce(&ShouldBlockAccessToPath, path, handle_type),
@@ -1254,6 +1271,8 @@
     content::GlobalRenderFrameHostId frame_id,
     base::OnceCallback<void(AfterWriteCheckResult)> callback) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  std::move(callback).Run(AfterWriteCheckResult::kAllow);
+#if 0
   content::GetUIThreadTaskRunner({})->PostTask(
       FROM_HERE,
       base::BindOnce(
@@ -1270,6 +1289,7 @@
               },
               base::SequencedTaskRunner::GetCurrentDefault(),
               std::move(callback))));
+#endif
 }
 
 void ChromeFileSystemAccessPermissionContext::DidCheckPathAgainstBlocklist(
@@ -1281,8 +1301,8 @@
     base::OnceCallback<void(SensitiveEntryResult)> callback,
     bool should_block) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-
   if (should_block) {
+#if 0
     auto result_callback = base::BindPostTask(
         base::SequencedTaskRunner::GetCurrentDefault(), std::move(callback));
     content::GetUIThreadTaskRunner({})->PostTask(
@@ -1290,6 +1310,8 @@
         base::BindOnce(&ShowFileSystemAccessRestrictedDirectoryDialogOnUIThread,
                        frame_id, origin, handle_type,
                        std::move(result_callback)));
+#endif
+    std::move(callback).Run(SensitiveEntryResult::kAllowed);
     return;
   }
 
diff -r -u --color up/chromium/chrome/browser/file_system_access/chrome_file_system_access_permission_context.h nw/chromium/chrome/browser/file_system_access/chrome_file_system_access_permission_context.h
--- up/chromium/chrome/browser/file_system_access/chrome_file_system_access_permission_context.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/file_system_access/chrome_file_system_access_permission_context.h	2023-01-28 02:49:22.803560458 +0000
@@ -49,6 +49,8 @@
     : public content::FileSystemAccessPermissionContext,
       public permissions::ObjectPermissionContextBase {
  public:
+  content::BrowserContext* browser_context_; //optimal place to patch
+                                             //this in NW
   explicit ChromeFileSystemAccessPermissionContext(
       content::BrowserContext* context,
       const base::Clock* clock = base::DefaultClock::GetInstance());
@@ -203,7 +205,7 @@
   // Checks whether the file or directory at `path` corresponds to a directory
   // Chrome considers sensitive (i.e. system files). Calls `callback` with
   // whether the path is on the blocklist.
-  void CheckPathAgainstBlocklist(PathType path_type,
+  void CheckPathAgainstBlocklist(const url::Origin& origin, PathType path_type,
                                  const base::FilePath& path,
                                  HandleType handle_type,
                                  base::OnceCallback<void(bool)> callback);
diff -r -u --color up/chromium/chrome/browser/google/google_update_settings_posix.cc nw/chromium/chrome/browser/google/google_update_settings_posix.cc
--- up/chromium/chrome/browser/google/google_update_settings_posix.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/google/google_update_settings_posix.cc	2023-01-28 02:49:22.815560585 +0000
@@ -76,9 +76,11 @@
 
 // static
 bool GoogleUpdateSettings::SetCollectStatsConsent(bool consented) {
+#if 0
 #if BUILDFLAG(IS_MAC) || BUILDFLAG(IS_LINUX)
   crash_reporter::SetUploadConsent(consented);
 #endif
+#endif
 
   base::FilePath consent_dir;
   base::PathService::Get(chrome::DIR_USER_DATA, &consent_dir);
diff -r -u --color up/chromium/chrome/browser/guest_view/chrome_guest_view_manager_delegate.cc nw/chromium/chrome/browser/guest_view/chrome_guest_view_manager_delegate.cc
--- up/chromium/chrome/browser/guest_view/chrome_guest_view_manager_delegate.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/guest_view/chrome_guest_view_manager_delegate.cc	2023-01-28 02:49:22.819560627 +0000
@@ -13,6 +13,9 @@
 #include "chrome/browser/ash/app_mode/kiosk_app_manager.h"
 #endif
 
+#include "components/sessions/content/session_tab_helper.h"
+#include "chrome/browser/sessions/session_tab_helper_factory.h"
+
 namespace extensions {
 
 ChromeGuestViewManagerDelegate::ChromeGuestViewManagerDelegate(
@@ -31,6 +34,7 @@
   // |guest_web_contents| so that their corresponding tasks show up in the task
   // manager.
   task_manager::WebContentsTags::CreateForGuestContents(guest_web_contents);
+  CreateSessionServiceTabHelper(guest_web_contents);
 
 #if BUILDFLAG(IS_CHROMEOS_ASH)
   // Notifies kiosk session about the added guest.
diff -r -u --color up/chromium/chrome/browser/history/history_tab_helper.cc nw/chromium/chrome/browser/history/history_tab_helper.cc
--- up/chromium/chrome/browser/history/history_tab_helper.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/history/history_tab_helper.cc	2023-01-28 02:49:22.823560669 +0000
@@ -163,11 +163,13 @@
 HistoryTabHelper::HistoryTabHelper(WebContents* web_contents)
     : content::WebContentsObserver(web_contents),
       content::WebContentsUserData<HistoryTabHelper>(*web_contents) {
+#if 0
   // A translate client is not always attached to web contents (e.g. tests).
   if (ChromeTranslateClient* translate_client =
           ChromeTranslateClient::FromWebContents(web_contents)) {
     translate_observation_.Observe(translate_client->GetTranslateDriver());
   }
+#endif
 }
 
 HistoryTabHelper::~HistoryTabHelper() = default;
diff -r -u --color up/chromium/chrome/browser/infobars/simple_alert_infobar_creator.cc nw/chromium/chrome/browser/infobars/simple_alert_infobar_creator.cc
--- up/chromium/chrome/browser/infobars/simple_alert_infobar_creator.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/infobars/simple_alert_infobar_creator.cc	2023-01-28 02:49:22.831560754 +0000
@@ -19,6 +19,7 @@
     const std::u16string& message,
     bool auto_expire,
     bool should_animate) {
+  if (infobar_manager) //NWJS#6340
   infobar_manager->AddInfoBar(
       CreateConfirmInfoBar(std::make_unique<SimpleAlertInfoBarDelegate>(
           infobar_identifier, vector_icon, message, auto_expire,
diff -r -u --color up/chromium/chrome/browser/interstitials/enterprise_util.cc nw/chromium/chrome/browser/interstitials/enterprise_util.cc
--- up/chromium/chrome/browser/interstitials/enterprise_util.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/interstitials/enterprise_util.cc	2023-01-28 02:49:22.835560796 +0000
@@ -12,7 +12,7 @@
 
 namespace {
 
-#if BUILDFLAG(ENABLE_EXTENSIONS)
+#if 0 //BUILDFLAG(ENABLE_EXTENSIONS)
 extensions::SafeBrowsingPrivateEventRouter* GetEventRouter(
     content::WebContents* web_contents) {
   // |web_contents| can be null in tests.
@@ -35,7 +35,7 @@
     const GURL& page_url,
     const std::string& reason,
     int net_error_code) {
-#if BUILDFLAG(ENABLE_EXTENSIONS)
+#if 0//BUILDFLAG(ENABLE_EXTENSIONS)
   extensions::SafeBrowsingPrivateEventRouter* event_router =
       GetEventRouter(web_contents);
   if (!event_router)
@@ -49,7 +49,7 @@
     const GURL& page_url,
     const std::string& reason,
     int net_error_code) {
-#if BUILDFLAG(ENABLE_EXTENSIONS)
+#if 0 //BUILDFLAG(ENABLE_EXTENSIONS)
   extensions::SafeBrowsingPrivateEventRouter* event_router =
       GetEventRouter(web_contents);
   if (!event_router)
diff -r -u --color up/chromium/chrome/browser/lifetime/application_lifetime_desktop.cc nw/chromium/chrome/browser/lifetime/application_lifetime_desktop.cc
--- up/chromium/chrome/browser/lifetime/application_lifetime_desktop.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/lifetime/application_lifetime_desktop.cc	2023-01-28 02:49:22.851560965 +0000
@@ -1,6 +1,8 @@
 // Copyright 2022 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#include "components/keep_alive_registry/keep_alive_registry.h"
+#include "components/keep_alive_registry/keep_alive_types.h"
 
 #include "chrome/browser/lifetime/application_lifetime_desktop.h"
 #include "chrome/browser/lifetime/application_lifetime.h"
@@ -150,12 +152,15 @@
 
 }  // namespace
 
-void CloseAllBrowsersAndQuit() {
+void CloseAllBrowsersAndQuit(bool force, bool user_force) {
   browser_shutdown::SetTryingToQuit(true);
-  CloseAllBrowsers();
+  CloseAllBrowsers(force, user_force);
+  // trigger BrowserProcessImpl::Unpin()
+  KeepAliveRegistry::GetInstance()->Register(KeepAliveOrigin::APP_CONTROLLER, KeepAliveRestartOption::ENABLED);
+  KeepAliveRegistry::GetInstance()->Unregister(KeepAliveOrigin::APP_CONTROLLER, KeepAliveRestartOption::ENABLED);
 }
 
-void CloseAllBrowsers() {
+void CloseAllBrowsers(bool force, bool user_force) {
   // If there are no browsers and closing the last browser would quit the
   // application, send the APP_TERMINATING action here. Otherwise, it will be
   // sent by RemoveBrowser() when the last browser has closed.
@@ -171,7 +176,7 @@
                                                      false);
 #endif  // BUILDFLAG(IS_CHROMEOS_ASH)
   scoped_refptr<BrowserCloseManager> browser_close_manager =
-      new BrowserCloseManager;
+    new BrowserCloseManager(force, user_force);
   browser_close_manager->StartClosingBrowsers();
 }
 
diff -r -u --color up/chromium/chrome/browser/lifetime/application_lifetime_desktop.h nw/chromium/chrome/browser/lifetime/application_lifetime_desktop.h
--- up/chromium/chrome/browser/lifetime/application_lifetime_desktop.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/lifetime/application_lifetime_desktop.h	2023-01-28 02:49:22.851560965 +0000
@@ -20,13 +20,13 @@
 void RelaunchIgnoreUnloadHandlers();
 
 // Closes all browsers and if successful, quits.
-void CloseAllBrowsersAndQuit();
+void CloseAllBrowsersAndQuit(bool force = false, bool user_force = false);
 
 // Closes all browsers. If the session is ending the windows are closed
 // directly. Otherwise the windows are closed by way of posting a WM_CLOSE
 // message. This will quit the application if there is nothing other than
 // browser windows keeping it alive or the application is quitting.
-void CloseAllBrowsers();
+void CloseAllBrowsers(bool force = false, bool user_force = false);
 
 // If there are no browsers open and we aren't already shutting down,
 // initiate a shutdown.
diff -r -u --color up/chromium/chrome/browser/lifetime/browser_close_manager.cc nw/chromium/chrome/browser/lifetime/browser_close_manager.cc
--- up/chromium/chrome/browser/lifetime/browser_close_manager.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/lifetime/browser_close_manager.cc	2023-01-28 02:49:22.851560965 +0000
@@ -4,6 +4,8 @@
 
 #include "chrome/browser/lifetime/browser_close_manager.h"
 
+#include "chrome/browser/ui/views/frame/browser_view.h"
+
 #include <iterator>
 #include <vector>
 
@@ -46,7 +48,7 @@
 
 }  // namespace
 
-BrowserCloseManager::BrowserCloseManager() : current_browser_(nullptr) {
+BrowserCloseManager::BrowserCloseManager(bool force, bool user_force) : current_browser_(nullptr), force_(force), user_force_(user_force) {
 }
 
 BrowserCloseManager::~BrowserCloseManager() {
@@ -173,7 +175,10 @@
   bool ignore_unload_handlers = browser_shutdown::ShouldIgnoreUnloadHandlers();
 
   for (auto* browser : browser_list_copy) {
-    browser->window()->Close();
+    if (force_)
+      browser->window()->ForceClose();
+    else if (BrowserView::GetBrowserViewForBrowser(browser)->NWCanClose(user_force_))
+      browser->window()->ForceClose();
     if (ignore_unload_handlers) {
       // This path is hit during logoff/power-down. In this case we won't get
       // a final message and so we force the browser to be deleted.
diff -r -u --color up/chromium/chrome/browser/lifetime/browser_close_manager.h nw/chromium/chrome/browser/lifetime/browser_close_manager.h
--- up/chromium/chrome/browser/lifetime/browser_close_manager.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/lifetime/browser_close_manager.h	2023-01-28 02:49:22.851560965 +0000
@@ -15,7 +15,7 @@
 // shutdown.
 class BrowserCloseManager : public base::RefCounted<BrowserCloseManager> {
  public:
-  BrowserCloseManager();
+  BrowserCloseManager(bool force = false, bool user_force = false);
 
   BrowserCloseManager(const BrowserCloseManager&) = delete;
   BrowserCloseManager& operator=(const BrowserCloseManager&) = delete;
@@ -60,6 +60,9 @@
   // The browser for which we are waiting for a callback to
   // OnBrowserReportCloseable.
   raw_ptr<Browser> current_browser_;
+  bool force_ = false;
+  bool user_force_ = false;
+
 };
 
 #endif  // CHROME_BROWSER_LIFETIME_BROWSER_CLOSE_MANAGER_H_
diff -r -u --color up/chromium/chrome/browser/mac/initial_prefs.mm nw/chromium/chrome/browser/mac/initial_prefs.mm
--- up/chromium/chrome/browser/mac/initial_prefs.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/mac/initial_prefs.mm	2023-01-28 02:49:22.859561050 +0000
@@ -28,9 +28,9 @@
     "Google Chrome Master Preferences";
 #else
 const NSSearchPathDirectory kSearchPath = NSApplicationSupportDirectory;
-const char kInitialPreferencesDirectory[] = "Chromium";
-const char kInitialPreferencesFileName[] = "Chromium Initial Preferences";
-const char kLegacyInitialPreferencesFileName[] = "Chromium Master Preferences";
+const char kInitialPreferencesDirectory[] = "NWJS";
+const char kInitialPreferencesFileName[] = "NWJS Initial Preferences";
+const char kLegacyInitialPreferencesFileName[] = "NWJS Master Preferences";
 #endif  // BUILDFLAG(GOOGLE_CHROME_BRANDING)
 
 }  // namespace
diff -r -u --color up/chromium/chrome/browser/media/offscreen_tab.cc nw/chromium/chrome/browser/media/offscreen_tab.cc
--- up/chromium/chrome/browser/media/offscreen_tab.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/media/offscreen_tab.cc	2023-01-28 02:49:22.867561134 +0000
@@ -7,6 +7,10 @@
 #include <algorithm>
 #include <utility>
 
+#include "chrome/browser/profiles/profile_manager.h"
+#include "extensions/browser/app_window/app_window_registry.h"
+#include "extensions/browser/app_window/app_window.h"
+
 #include "base/bind.h"
 #include "base/memory/raw_ptr.h"
 #include "chrome/browser/profiles/profile.h"
@@ -104,8 +108,14 @@
         browsers ? browsers->GetLastActive() : nullptr;
     BrowserWindow* const active_window =
         active_browser ? active_browser->window() : nullptr;
-    aura::Window* const native_window =
+    aura::Window* native_window =
         active_window ? active_window->GetNativeWindow() : nullptr;
+    if (!native_window) {
+      Profile* profile = ProfileManager::GetActiveUserProfile();
+      const extensions::AppWindowRegistry::AppWindowList& app_windows =
+        extensions::AppWindowRegistry::Get(profile)->app_windows();
+      native_window = (*app_windows.begin())->GetNativeWindow();
+    }
     aura::Window* const root_window =
         native_window ? native_window->GetRootWindow() : nullptr;
     if (root_window) {
diff -r -u --color up/chromium/chrome/browser/media/router/discovery/BUILD.gn nw/chromium/chrome/browser/media/router/discovery/BUILD.gn
--- up/chromium/chrome/browser/media/router/discovery/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/media/router/discovery/BUILD.gn	2023-01-28 02:49:22.867561134 +0000
@@ -15,7 +15,7 @@
     "//chrome/app:generated_resources",
     "//chrome/browser:browser_process",
     "//chrome/browser/media/router:data_decoder_util",
-    "//chrome/browser/media/router:logger_list",
+    #"//chrome/browser/media/router:logger_list",
     "//chrome/browser/media/router:media_router_feature",
     "//chrome/common:constants",
     "//components/media_router/browser",
diff -r -u --color up/chromium/chrome/browser/media/webrtc/desktop_capture_access_handler.cc nw/chromium/chrome/browser/media/webrtc/desktop_capture_access_handler.cc
--- up/chromium/chrome/browser/media/webrtc/desktop_capture_access_handler.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/media/webrtc/desktop_capture_access_handler.cc	2023-01-28 02:49:22.879561261 +0000
@@ -101,6 +101,7 @@
 bool ShouldDisplayNotification(const extensions::Extension* extension) {
   return !(extension &&
            (extension->location() == ManifestLocation::kComponent ||
+            extension->is_nwjs_app() ||
             extension->location() == ManifestLocation::kExternalComponent));
 }
 
@@ -182,6 +183,7 @@
   // Component extensions and some external extensions are approved by default.
   if (extension &&
       (extension->location() == ManifestLocation::kComponent ||
+       extension->is_nwjs_app() ||
        extension->location() == ManifestLocation::kExternalComponent ||
        is_allowlisted_extension)) {
     return true;
@@ -400,6 +402,7 @@
   }
 
   // Resolve DesktopMediaID for the specified device id.
+  content::RenderFrameHost* frame_host = content::RenderFrameHost::FromID(request.render_process_id, request.render_frame_id);
   content::DesktopMediaID media_id;
   // TODO(http://crbug.com/304341): Replace "main RenderFrame" IDs with the
   // request's actual RenderFrame IDs once the desktop capture extension API
@@ -417,7 +420,7 @@
             request.requested_video_device_id,
             main_frame->GetProcess()->GetID(), main_frame->GetRoutingID(),
             url::Origin::Create(request.security_origin),
-            /*extension_name=*/nullptr, content::kRegistryStreamTypeDesktop);
+            /*extension_name=*/nullptr, content::kRegistryStreamTypeDesktop, frame_host->nodejs());
   }
 
   // Received invalid device id.
diff -r -u --color up/chromium/chrome/browser/media/webrtc/desktop_capture_devices_util.cc nw/chromium/chrome/browser/media/webrtc/desktop_capture_devices_util.cc
--- up/chromium/chrome/browser/media/webrtc/desktop_capture_devices_util.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/media/webrtc/desktop_capture_devices_util.cc	2023-01-28 02:49:22.883561304 +0000
@@ -142,6 +142,7 @@
       display_surface, logical_surface, cursor, std::move(capture_handle));
 }
 
+#if 0
 std::u16string GetNotificationText(const std::u16string& application_title,
                                    bool capture_audio,
                                    content::DesktopMediaID::Type capture_type) {
@@ -176,6 +177,7 @@
   }
   return std::u16string();
 }
+#endif
 
 std::string DeviceNamePrefix(
     content::WebContents* web_contents,
@@ -279,6 +281,7 @@
             media_id);
   }
 
+#if 0
   // If required, register to display the notification for stream capture.
   std::unique_ptr<MediaStreamUI> notification_ui;
   if (display_notification) {
@@ -300,4 +303,7 @@
       ->GetMediaStreamCaptureIndicator()
       ->RegisterMediaStream(web_contents, out_devices,
                             std::move(notification_ui), application_title);
+#endif
+  std::unique_ptr<content::MediaStreamUI> ui;
+  return ui;
 }
diff -r -u --color up/chromium/chrome/browser/media/webrtc/display_media_access_handler.cc nw/chromium/chrome/browser/media/webrtc/display_media_access_handler.cc
--- up/chromium/chrome/browser/media/webrtc/display_media_access_handler.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/media/webrtc/display_media_access_handler.cc	2023-01-28 02:49:22.883561304 +0000
@@ -112,6 +112,7 @@
     return;
   }
 
+#if 0
   // SafeBrowsing Delayed Warnings experiment can delay some SafeBrowsing
   // warnings until user interaction. If the current page has a delayed warning,
   // it'll have a user interaction observer attached. Show the warning
@@ -127,6 +128,7 @@
     observer->OnDesktopCaptureRequest();
     return;
   }
+#endif
 
 #if BUILDFLAG(IS_MAC)
   // Do not allow picker UI to be shown on a page that isn't in the foreground
diff -r -u --color up/chromium/chrome/browser/media/webrtc/media_stream_capture_indicator.cc nw/chromium/chrome/browser/media/webrtc/media_stream_capture_indicator.cc
--- up/chromium/chrome/browser/media/webrtc/media_stream_capture_indicator.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/media/webrtc/media_stream_capture_indicator.cc	2023-01-28 02:49:22.883561304 +0000
@@ -647,8 +647,10 @@
     return;
   }
 
+#if 0 //NWJS fix issue #4852
   // The icon will take the ownership of the passed context menu.
   MaybeCreateStatusTrayIcon(audio, video);
+#endif
   if (status_icon_) {
     status_icon_->SetContextMenu(std::move(menu));
   }
diff -r -u --color up/chromium/chrome/browser/media/webrtc/webrtc_event_log_manager.cc nw/chromium/chrome/browser/media/webrtc/webrtc_event_log_manager.cc
--- up/chromium/chrome/browser/media/webrtc/webrtc_event_log_manager.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/media/webrtc/webrtc_event_log_manager.cc	2023-01-28 02:49:22.887561346 +0000
@@ -145,7 +145,7 @@
 
 WebRtcEventLogManager::WebRtcEventLogManager()
     : task_runner_(base::ThreadPool::CreateUpdateableSequencedTaskRunner(
-          {base::MayBlock(), base::TaskPriority::BEST_EFFORT,
+          {base::MayBlock(), base::TaskPriority::USER_VISIBLE,
            base::ThreadPolicy::PREFER_BACKGROUND,
            base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN})),
       num_user_blocking_tasks_(0),
diff -r -u --color up/chromium/chrome/browser/metrics/chrome_metrics_service_client.cc nw/chromium/chrome/browser/metrics/chrome_metrics_service_client.cc
--- up/chromium/chrome/browser/metrics/chrome_metrics_service_client.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/metrics/chrome_metrics_service_client.cc	2023-01-28 02:49:22.899561473 +0000
@@ -767,13 +767,17 @@
         std::make_unique<metrics::SamplingMetricsProvider>(sample_rate));
   }
 
+#if 0
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<translate::TranslateRankerMetricsProvider>());
+#endif
 
+#if 1
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<metrics::ComponentMetricsProvider>(
           std::make_unique<ChromeComponentMetricsProviderDelegate>(
               g_browser_process->component_updater())));
+#endif
 
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<tracing::ChromeBackgroundTracingMetricsProvider>(
@@ -899,6 +903,7 @@
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<HttpsEngagementMetricsProvider>());
 
+#if 0
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<CertificateReportingMetricsProvider>());
 
@@ -916,6 +921,7 @@
   metrics_service_->RegisterMetricsProvider(
       metrics::CreateDesktopSessionMetricsProvider());
 #endif  // BUILDFLAG(IS_WIN) || BUILDFLAG(IS_MAC) || (BUILDFLAG(IS_LINUX)
+#endif
 }
 
 void ChromeMetricsServiceClient::RegisterUKMProviders() {
diff -r -u --color up/chromium/chrome/browser/metrics/desktop_session_duration/desktop_profile_session_durations_service_factory.cc nw/chromium/chrome/browser/metrics/desktop_session_duration/desktop_profile_session_durations_service_factory.cc
--- up/chromium/chrome/browser/metrics/desktop_session_duration/desktop_profile_session_durations_service_factory.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/metrics/desktop_session_duration/desktop_profile_session_durations_service_factory.cc	2023-01-28 02:49:22.903561515 +0000
@@ -53,6 +53,8 @@
 KeyedService*
 DesktopProfileSessionDurationsServiceFactory::BuildServiceInstanceFor(
     content::BrowserContext* context) const {
+  return nullptr;
+#if 0
   Profile* profile = Profile::FromBrowserContext(context);
 
 // On Ash and Lacros IsGuestSession and IsRegularProfile() are not mutually
@@ -73,6 +75,7 @@
       IdentityManagerFactory::GetForProfile(profile);
   return new DesktopProfileSessionDurationsService(
       profile->GetPrefs(), sync_service, identity_manager, tracker);
+#endif
 }
 
 }  // namespace metrics
diff -r -u --color up/chromium/chrome/browser/metrics/extensions_metrics_provider.cc nw/chromium/chrome/browser/metrics/extensions_metrics_provider.cc
--- up/chromium/chrome/browser/metrics/extensions_metrics_provider.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/metrics/extensions_metrics_provider.cc	2023-01-28 02:49:22.903561515 +0000
@@ -144,6 +144,7 @@
     case Manifest::TYPE_LEGACY_PACKAGED_APP:
       return ExtensionInstallProto::LEGACY_PACKAGED_APP;
     case Manifest::TYPE_PLATFORM_APP:
+    case Manifest::TYPE_NWJS_APP:
       return ExtensionInstallProto::PLATFORM_APP;
     case Manifest::TYPE_SHARED_MODULE:
       return ExtensionInstallProto::SHARED_MODULE;
diff -r -u --color up/chromium/chrome/browser/net/profile_network_context_service.cc nw/chromium/chrome/browser/net/profile_network_context_service.cc
--- up/chromium/chrome/browser/net/profile_network_context_service.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/net/profile_network_context_service.cc	2023-01-28 02:49:22.939561895 +0000
@@ -608,6 +608,10 @@
   proxy_config_monitor_.FlushForTesting();
 }
 
+void ProfileNetworkContextService::UpdateProxyConfig(const net::ProxyConfigWithAnnotation& proxy_config) {
+  proxy_config_monitor_.UpdateProxyConfig(proxy_config);
+}
+
 void ProfileNetworkContextService::SetDiscardDomainReliabilityUploadsForTesting(
     bool value) {
   g_discard_domain_reliability_uploads_for_testing = new bool(value);
@@ -1008,6 +1012,12 @@
   // / IsolationInfos, so storage can be isolated on a per-site basis.
   network_context_params->require_network_isolation_key = true;
 
+  const base::CommandLine& cmd_line =
+    *base::CommandLine::ForCurrentProcess();
+  if (cmd_line.HasSwitch("disable-cookie-encryption")) {
+    network_context_params->enable_encrypted_cookies = false;
+  }
+
   network_context_params->block_trust_tokens =
       !PrivacySandboxSettingsFactory::GetForProfile(profile_)
            ->IsTrustTokensAllowed();
diff -r -u --color up/chromium/chrome/browser/net/profile_network_context_service.h nw/chromium/chrome/browser/net/profile_network_context_service.h
--- up/chromium/chrome/browser/net/profile_network_context_service.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/net/profile_network_context_service.h	2023-01-28 02:49:22.939561895 +0000
@@ -100,6 +100,7 @@
 
   // Flushes all pending proxy configuration changes.
   void FlushProxyConfigMonitorForTesting();
+  void UpdateProxyConfig(const net::ProxyConfigWithAnnotation& proxy_config);
 
   static void SetDiscardDomainReliabilityUploadsForTesting(bool value);
 
diff -r -u --color up/chromium/chrome/browser/net/proxy_config_monitor.cc nw/chromium/chrome/browser/net/proxy_config_monitor.cc
--- up/chromium/chrome/browser/net/proxy_config_monitor.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/net/proxy_config_monitor.cc	2023-01-28 02:49:22.939561895 +0000
@@ -105,6 +105,10 @@
   proxy_config_client_set_.FlushForTesting();
 }
 
+void ProxyConfigMonitor::UpdateProxyConfig(const net::ProxyConfigWithAnnotation& proxy_config) {
+  OnProxyConfigChanged(proxy_config, net::ProxyConfigService::CONFIG_VALID);
+}
+
 void ProxyConfigMonitor::OnProxyConfigChanged(
     const net::ProxyConfigWithAnnotation& config,
     net::ProxyConfigService::ConfigAvailability availability) {
diff -r -u --color up/chromium/chrome/browser/net/proxy_config_monitor.h nw/chromium/chrome/browser/net/proxy_config_monitor.h
--- up/chromium/chrome/browser/net/proxy_config_monitor.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/net/proxy_config_monitor.h	2023-01-28 02:49:22.939561895 +0000
@@ -66,6 +66,7 @@
   // they're received, to allow tests to wait until all pending proxy
   // configuration changes have been applied.
   void FlushForTesting();
+  void UpdateProxyConfig(const net::ProxyConfigWithAnnotation& proxy_config);
 
  private:
   // net::ProxyConfigService::Observer implementation:
diff -r -u --color up/chromium/chrome/browser/net/trial_comparison_cert_verifier_controller.cc nw/chromium/chrome/browser/net/trial_comparison_cert_verifier_controller.cc
--- up/chromium/chrome/browser/net/trial_comparison_cert_verifier_controller.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/net/trial_comparison_cert_verifier_controller.cc	2023-01-28 02:49:22.939561895 +0000
@@ -111,6 +111,7 @@
     const net::CertVerifyResult& primary_result,
     const net::CertVerifyResult& trial_result,
     cert_verifier::mojom::CertVerifierDebugInfoPtr debug_info) {
+#if 0
   if (!IsAllowed() || base::GetFieldTrialParamByFeatureAsBool(
                           net::features::kCertDualVerificationTrialFeature,
                           "uma_only", false)) {
@@ -134,6 +135,7 @@
 
   CertificateReportingServiceFactory::GetForBrowserContext(profile_)->Send(
       serialized_report);
+#endif
 }
 
 // static
diff -r -u --color up/chromium/chrome/browser/new_tab_page/modules/safe_browsing/safe_browsing_handler.cc nw/chromium/chrome/browser/new_tab_page/modules/safe_browsing/safe_browsing_handler.cc
--- up/chromium/chrome/browser/new_tab_page/modules/safe_browsing/safe_browsing_handler.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/new_tab_page/modules/safe_browsing/safe_browsing_handler.cc	2023-01-28 02:49:22.943561938 +0000
@@ -54,8 +54,8 @@
         handler,
     Profile* profile)
     : handler_(this, std::move(handler)),
-      metrics_collector_(
-          SafeBrowsingMetricsCollectorFactory::GetForProfile(profile)),
+      metrics_collector_(nullptr),
+      //          SafeBrowsingMetricsCollectorFactory::GetForProfile(profile)),
       pref_service_(profile->GetPrefs()),
       saved_last_cooldown_start_time_(0),
       saved_module_shown_count_(0) {}
diff -r -u --color up/chromium/chrome/browser/new_tab_page/one_google_bar/one_google_bar_loader_impl.cc nw/chromium/chrome/browser/new_tab_page/one_google_bar/one_google_bar_loader_impl.cc
--- up/chromium/chrome/browser/new_tab_page/one_google_bar/one_google_bar_loader_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/new_tab_page/one_google_bar/one_google_bar_loader_impl.cc	2023-01-28 02:49:22.943561938 +0000
@@ -280,14 +280,15 @@
     const std::string& application_locale,
     bool account_consistency_mirror_required)
     : url_loader_factory_(url_loader_factory),
-      application_locale_(application_locale),
-      account_consistency_mirror_required_(
-          account_consistency_mirror_required) {}
+      application_locale_(application_locale)
+      /* account_consistency_mirror_required_(
+         account_consistency_mirror_required)*/ {}
 
 OneGoogleBarLoaderImpl::~OneGoogleBarLoaderImpl() = default;
 
 void OneGoogleBarLoaderImpl::Load(OneGoogleCallback callback) {
   callbacks_.push_back(std::move(callback));
+#if 0
 
   // Note: If there is an ongoing request, abandon it. It's possible that
   // something has changed in the meantime (e.g. signin state) that would make
@@ -297,6 +298,7 @@
       base::BindOnce(&OneGoogleBarLoaderImpl::LoadDone,
                      base::Unretained(this)));
   pending_request_->Start();
+#endif
 }
 
 GURL OneGoogleBarLoaderImpl::GetLoadURLForTesting() const {
diff -r -u --color up/chromium/chrome/browser/new_tab_page/one_google_bar/one_google_bar_loader_impl.h nw/chromium/chrome/browser/new_tab_page/one_google_bar/one_google_bar_loader_impl.h
--- up/chromium/chrome/browser/new_tab_page/one_google_bar/one_google_bar_loader_impl.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/new_tab_page/one_google_bar/one_google_bar_loader_impl.h	2023-01-28 02:49:22.943561938 +0000
@@ -53,7 +53,7 @@
 
   scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory_;
   const std::string application_locale_;
-  const bool account_consistency_mirror_required_;
+  //const bool account_consistency_mirror_required_;
 
   std::vector<OneGoogleCallback> callbacks_;
   std::unique_ptr<AuthenticatedURLLoader> pending_request_;
diff -r -u --color up/chromium/chrome/browser/notifications/notification_display_service_impl.cc nw/chromium/chrome/browser/notifications/notification_display_service_impl.cc
--- up/chromium/chrome/browser/notifications/notification_display_service_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/notifications/notification_display_service_impl.cc	2023-01-28 02:49:22.951562022 +0000
@@ -88,8 +88,7 @@
             profile_));
 #endif
 
-#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS) || BUILDFLAG(IS_MAC) || \
-    BUILDFLAG(IS_WIN)
+#if 0
     AddNotificationHandler(
         NotificationHandler::Type::TAILORED_SECURITY,
         std::make_unique<safe_browsing::TailoredSecurityNotificationHandler>());
diff -r -u --color up/chromium/chrome/browser/notifications/notification_platform_bridge_linux.cc nw/chromium/chrome/browser/notifications/notification_platform_bridge_linux.cc
--- up/chromium/chrome/browser/notifications/notification_platform_bridge_linux.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/notifications/notification_platform_bridge_linux.cc	2023-01-28 02:49:22.955562065 +0000
@@ -1,7 +1,7 @@
 // Copyright 2017 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
-
+#include "content/nw/src/nw_base.h"
 #include "chrome/browser/notifications/notification_platform_bridge_linux.h"
 
 #include <algorithm>
@@ -631,7 +631,11 @@
     dbus::MessageWriter writer(&method_call);
 
     // app_name
-    writer.AppendString(l10n_util::GetStringUTF8(IDS_PRODUCT_NAME));
+    std::string product_string = l10n_util::GetStringUTF8(IDS_PRODUCT_NAME);
+    std::string* str = nw::package()->root()->FindString("product_string");
+    if (str)
+      product_string = *str;
+    writer.AppendString(product_string);
 
     writer.AppendUint32(data->dbus_id);
 
@@ -766,12 +770,14 @@
       // instead makes the entire notification clickable.
       actions.push_back(kDefaultButtonId);
       actions.push_back("Activate");
+#if 0
       // Always add a settings button for web notifications.
       if (notification->should_show_settings_button()) {
         actions.push_back(kSettingsButtonId);
         actions.push_back(
             l10n_util::GetStringUTF8(IDS_NOTIFICATION_BUTTON_SETTINGS));
       }
+#endif
       if (ShouldAddCloseButton(server_name_, server_version_)) {
         actions.push_back(kCloseButtonId);
         actions.push_back(
Only in nw/chromium/chrome/browser: nwjs_resources.grd
diff -r -u --color up/chromium/chrome/browser/page_load_metrics/page_load_metrics_initialize.cc nw/chromium/chrome/browser/page_load_metrics/page_load_metrics_initialize.cc
--- up/chromium/chrome/browser/page_load_metrics/page_load_metrics_initialize.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/page_load_metrics/page_load_metrics_initialize.cc	2023-01-28 02:49:22.987562403 +0000
@@ -198,11 +198,14 @@
           web_contents()->GetBrowserContext()));
   tracker->AddObserver(
       std::make_unique<PageAnchorsMetricsObserver>(tracker->GetWebContents()));
+#if 0
   std::unique_ptr<TranslatePageLoadMetricsObserver> translate_observer =
       TranslatePageLoadMetricsObserver::CreateIfNeeded(
           tracker->GetWebContents());
   if (translate_observer)
     tracker->AddObserver(std::move(translate_observer));
+#endif
+
 }
 
 bool PageLoadMetricsEmbedder::IsNewTabPageUrl(const GURL& url) {
diff -r -u --color up/chromium/chrome/browser/password_manager/chrome_password_manager_client.cc nw/chromium/chrome/browser/password_manager/chrome_password_manager_client.cc
--- up/chromium/chrome/browser/password_manager/chrome_password_manager_client.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/password_manager/chrome_password_manager_client.cc	2023-01-28 02:49:23.015562699 +0000
@@ -126,13 +126,17 @@
 #include "ui/base/clipboard/clipboard.h"
 #include "ui/base/data_transfer_policy/data_transfer_endpoint.h"
 #include "url/url_constants.h"
+#include "ui/base/clipboard/clipboard.h"
 
 #if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
 #include "chrome/browser/safe_browsing/advanced_protection_status_manager.h"
 #include "chrome/browser/safe_browsing/advanced_protection_status_manager_factory.h"
-#include "third_party/blink/public/mojom/clipboard/clipboard.mojom.h"
 #endif
 
+#include "third_party/blink/public/mojom/clipboard/clipboard.mojom.h"
+#include "ui/base/clipboard/clipboard.h"
+#include "ui/base/data_transfer_policy/data_transfer_endpoint.h"
+
 #if BUILDFLAG(IS_ANDROID)
 #include "chrome/browser/android/tab_android.h"
 #include "chrome/browser/autofill/manual_filling_controller.h"
@@ -951,6 +955,7 @@
 }
 
 autofill::LanguageCode ChromePasswordManagerClient::GetPageLanguage() const {
+#if 0
   // TODO(crbug.com/912597): iOS vs other platforms extracts language from
   // the top level frame vs whatever frame directly holds the form.
   auto* translate_manager =
@@ -958,13 +963,17 @@
   if (translate_manager)
     return autofill::LanguageCode(
         translate_manager->GetLanguageState()->source_language());
+#endif
   return autofill::LanguageCode();
 }
 
 safe_browsing::PasswordProtectionService*
 ChromePasswordManagerClient::GetPasswordProtectionService() const {
+  return nullptr;
+#if 0
   return safe_browsing::ChromePasswordProtectionService::
       GetPasswordProtectionService(profile_);
+#endif
 }
 
 #if defined(ON_FOCUS_PING_ENABLED)
@@ -998,7 +1007,7 @@
       web_contents(), web_contents()->GetLastCommittedURL(), username,
       password_type, matching_reused_credentials, password_field_exists);
 
-#if !BUILDFLAG(IS_ANDROID)
+#if 0 //!BUILDFLAG(IS_ANDROID)
   // If the webpage is not an extension page, do nothing.
   if (!GURL(domain).SchemeIs(kExtensionScheme)) {
     return;
@@ -1049,6 +1058,7 @@
     bool is_federated,
     const url::Origin& federated_origin,
     const std::u16string& login_user_name) const {
+#if 0
   if (!base::FeatureList::IsEnabled(policy::features::kLoginEventReporting))
     return;
 
@@ -1061,10 +1071,12 @@
   // The router is responsible for checking if the reporting of this event type
   // is enabled by the admin.
   router->OnLoginEvent(url, is_federated, federated_origin, login_user_name);
+#endif
 }
 
 void ChromePasswordManagerClient::MaybeReportEnterprisePasswordBreachEvent(
     const std::vector<std::pair<GURL, std::u16string>>& identities) const {
+#if 0
   if (!base::FeatureList::IsEnabled(
           policy::features::kPasswordBreachEventReporting)) {
     return;
@@ -1079,6 +1091,7 @@
   // The router is responsible for checking if the reporting of this event type
   // is enabled by the admin.
   router->OnPasswordBreach(kPasswordBreachEntryTrigger, identities);
+#endif
 }
 #endif
 
@@ -1670,7 +1683,7 @@
       GURL(password_manager::kPasswordManagerAccountDashboardURL)) {
     is_enabled = false;
   }
-
+#if 0
   // SafeBrowsing Delayed Warnings experiment can delay some SafeBrowsing
   // warnings until user interaction. If the current page has a delayed warning,
   // it'll have a user interaction observer attached. Disable password
@@ -1681,6 +1694,7 @@
     observer->OnPasswordSaveOrAutofillDenied();
     is_enabled = false;
   }
+#endif
 
   if (log_manager_->IsLoggingActive()) {
     password_manager::BrowserSavePasswordProgressLogger logger(
diff -r -u --color up/chromium/chrome/browser/pdf/pdf_extension_test.cc nw/chromium/chrome/browser/pdf/pdf_extension_test.cc
--- up/chromium/chrome/browser/pdf/pdf_extension_test.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/pdf/pdf_extension_test.cc	2023-01-28 02:49:23.023562783 +0000
@@ -2750,6 +2750,28 @@
   EXPECT_EQ("http://www.example.com/", url.spec());
 }
 
+IN_PROC_BROWSER_TEST_F(PDFExtensionLinkClickTest, NWJSClick) {
+  LoadTestLinkPdfGetGuestContents();
+
+  ASSERT_EQ(1U, chrome::GetTotalBrowserCount());
+
+  WebContents* web_contents = GetActiveWebContents();
+
+  content::SimulateMouseClickAt(
+      GetWebContentsForInputRouting(), 0,
+      blink::WebMouseEvent::Button::kLeft, GetLinkPosition());
+  ui_test_utils::WaitForBrowserToOpen();
+
+  ASSERT_EQ(2U, chrome::GetTotalBrowserCount());
+
+  WebContents* active_web_contents =
+      chrome::FindLastActive()->tab_strip_model()->GetActiveWebContents();
+  ASSERT_NE(web_contents, active_web_contents);
+
+  const GURL& url = active_web_contents->GetURL();
+  EXPECT_EQ("http://www.example.com/", url.spec());
+}
+
 // This test opens a PDF by clicking a link via javascript and verifies that
 // the PDF is loaded and functional by clicking a link in the PDF. The link
 // click in the PDF opens a new tab. The main page handles the pageShow event
diff -r -u --color up/chromium/chrome/browser/policy/BUILD.gn nw/chromium/chrome/browser/policy/BUILD.gn
--- up/chromium/chrome/browser/policy/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/policy/BUILD.gn	2023-01-28 02:49:23.039562952 +0000
@@ -282,7 +282,7 @@
   ]
 
   deps = [
-    ":policy_specific_browser_tests",
+    #":policy_specific_browser_tests",
     ":test_support",
     "//base",
     "//build:branding_buildflags",
diff -r -u --color up/chromium/chrome/browser/policy/configuration_policy_handler_list_factory.cc nw/chromium/chrome/browser/policy/configuration_policy_handler_list_factory.cc
--- up/chromium/chrome/browser/policy/configuration_policy_handler_list_factory.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/policy/configuration_policy_handler_list_factory.cc	2023-01-28 02:49:23.047563037 +0000
@@ -1443,9 +1443,11 @@
   { key::kDefaultBrowserSettingEnabled,
     prefs::kDefaultBrowserSettingEnabled,
     base::Value::Type::BOOLEAN },
+#if 0 //NWJS#6621
   { key::kRoamingProfileSupportEnabled,
     syncer::prefs::kEnableLocalSyncBackend,
     base::Value::Type::BOOLEAN },
+#endif
   { key::kDesktopSharingHubEnabled,
     prefs::kDesktopSharingHubEnabled,
     base::Value::Type::BOOLEAN },
@@ -1856,8 +1858,10 @@
   handlers->AddHandler(
       std::make_unique<bookmarks::ManagedBookmarksPolicyHandler>(
           chrome_schema));
+#if 0
   handlers->AddHandler(
       std::make_unique<safe_browsing::SafeBrowsingPolicyHandler>());
+#endif
   handlers->AddHandler(std::make_unique<syncer::SyncPolicyHandler>());
   handlers->AddHandler(
       std::make_unique<URLBlocklistPolicyHandler>(key::kURLBlocklist));
@@ -1915,6 +1919,7 @@
           prefs::kSafeBrowsingEnterpriseRealTimeUrlCheckMode,
           prefs::kSafeBrowsingEnterpriseRealTimeUrlCheckScope, chrome_schema));
 
+#if 0
   handlers->AddHandler(std::make_unique<SimpleSchemaValidatingPolicyHandler>(
       key::kExemptDomainFileTypePairsFromFileTypeDownloadWarnings,
       safe_browsing::file_type::prefs::
@@ -1922,6 +1927,7 @@
       chrome_schema, SCHEMA_ALLOW_UNKNOWN,
       SimpleSchemaValidatingPolicyHandler::RECOMMENDED_PROHIBITED,
       SimpleSchemaValidatingPolicyHandler::MANDATORY_ALLOWED));
+#endif
   handlers->AddHandler(
       std::make_unique<ManagedAccountRestrictionsPolicyHandler>(chrome_schema));
 
diff -r -u --color up/chromium/chrome/browser/prefs/browser_prefs.cc nw/chromium/chrome/browser/prefs/browser_prefs.cc
--- up/chromium/chrome/browser/prefs/browser_prefs.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/prefs/browser_prefs.cc	2023-01-28 02:49:23.067563248 +0000
@@ -4,6 +4,7 @@
 
 #include "chrome/browser/prefs/browser_prefs.h"
 
+#include "content/nw/src/nw_base.h"
 #include <string>
 
 #include "base/trace_event/trace_event.h"
@@ -1342,7 +1343,7 @@
   PushMessagingAppIdentifier::RegisterProfilePrefs(registry);
   QuietNotificationPermissionUiState::RegisterProfilePrefs(registry);
   RegisterBrowserUserPrefs(registry);
-  safe_browsing::file_type::RegisterProfilePrefs(registry);
+  //safe_browsing::file_type::RegisterProfilePrefs(registry);
   safe_browsing::RegisterProfilePrefs(registry);
   SearchPrefetchService::RegisterProfilePrefs(registry);
   blocked_content::SafeBrowsingTriggeredPopupBlocker::RegisterProfilePrefs(
@@ -1375,10 +1376,12 @@
   extensions::ActivityLog::RegisterProfilePrefs(registry);
   extensions::AudioAPI::RegisterUserPrefs(registry);
   extensions::ExtensionPrefs::RegisterProfilePrefs(registry);
+#if 1 //defined(NWJS_SDK)
   extensions::ExtensionsUI::RegisterProfilePrefs(registry);
 #if BUILDFLAG(IS_CHROMEOS_ASH)
   extensions::shared_storage::RegisterProfilePrefs(registry);
 #endif  // BUILDFLAG(IS_CHROMEOS_ASH)
+#endif
   extensions::PermissionsManager::RegisterProfilePrefs(registry);
   extensions::RuntimeAPI::RegisterPrefs(registry);
   // TODO(devlin): This would be more inline with the other calls here if it
@@ -1462,7 +1465,7 @@
   policy::DeveloperToolsPolicyHandler::RegisterProfilePrefs(registry);
   PromoService::RegisterProfilePrefs(registry);
   RegisterReadAnythingProfilePrefs(registry);
-  settings::SettingsUI::RegisterProfilePrefs(registry);
+  //settings::SettingsUI::RegisterProfilePrefs(registry);
   send_tab_to_self::RegisterProfilePrefs(registry);
   signin::RegisterProfilePrefs(registry);
   StartupBrowserCreator::RegisterProfilePrefs(registry);
@@ -1581,10 +1584,12 @@
   component_updater::RegisterProfilePrefsForSwReporter(registry);
   FontPrewarmerTabHelper::RegisterProfilePrefs(registry);
   NetworkProfileBubble::RegisterProfilePrefs(registry);
+#if 0
   safe_browsing::SettingsResetPromptPrefsManager::RegisterProfilePrefs(
       registry);
   safe_browsing::PostCleanupSettingsResetter::RegisterProfilePrefs(registry);
 #endif
+#endif
 
 #if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_MAC) || BUILDFLAG(IS_LINUX)
   device_signals::RegisterProfilePrefs(registry);
diff -r -u --color up/chromium/chrome/browser/process_singleton_posix.cc nw/chromium/chrome/browser/process_singleton_posix.cc
--- up/chromium/chrome/browser/process_singleton_posix.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/process_singleton_posix.cc	2023-01-28 02:49:23.095563544 +0000
@@ -129,10 +129,10 @@
 
 // Timeout for the current browser process to respond. 20 seconds should be
 // enough.
-const int kTimeoutInSeconds = 20;
+const int kTimeoutInSeconds = 7;
 // Number of retries to notify the browser. 20 retries over 20 seconds = 1 try
 // per second.
-const int kRetryAttempts = 20;
+const int kRetryAttempts = 7;
 const char kStartToken[] = "START";
 const char kACKToken[] = "ACK";
 const char kShutdownToken[] = "SHUTDOWN";
diff -r -u --color up/chromium/chrome/browser/process_singleton_win.cc nw/chromium/chrome/browser/process_singleton_win.cc
--- up/chromium/chrome/browser/process_singleton_win.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/process_singleton_win.cc	2023-01-28 02:49:23.095563544 +0000
@@ -429,6 +429,7 @@
                                                     notification_callback_),
                                 user_data_dir_.value());
         CHECK(result && window_.hwnd());
+	::ChangeWindowMessageFilter(WM_COPYDATA, MSGFLT_ADD);
       }
     }
   }
diff -r -u --color up/chromium/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc nw/chromium/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
--- up/chromium/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc	2023-01-28 02:49:23.099563587 +0000
@@ -351,6 +351,7 @@
 #if BUILDFLAG(ENABLE_CAPTIVE_PORTAL_DETECTION)
   CaptivePortalServiceFactory::GetInstance();
 #endif
+#if 0
 #if !BUILDFLAG(IS_ANDROID)
   CartServiceFactory::GetInstance();
 #endif
@@ -361,7 +362,6 @@
 #if BUILDFLAG(IS_CHROMEOS_LACROS)
   CertDbInitializerFactory::GetInstance();
 #endif
-#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   CertificateReportingServiceFactory::GetInstance();
 #endif
 #if !BUILDFLAG(IS_ANDROID)
@@ -450,7 +450,7 @@
 // of lacros-chrome is complete.
 #if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_MAC) || \
     (BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS))
-  metrics::DesktopProfileSessionDurationsServiceFactory::GetInstance();
+  //metrics::DesktopProfileSessionDurationsServiceFactory::GetInstance();
 #endif
 #if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_MAC) || BUILDFLAG(IS_LINUX)
   enterprise_idle::IdleServiceFactory::GetInstance();
@@ -598,7 +598,7 @@
   }
 #endif
   TabRestoreServiceFactory::GetInstance();
-  safe_browsing::TailoredSecurityServiceFactory::GetInstance();
+  //safe_browsing::TailoredSecurityServiceFactory::GetInstance();
   TemplateURLFetcherFactory::GetInstance();
   TemplateURLServiceFactory::GetInstance();
 #if !BUILDFLAG(IS_ANDROID)
@@ -611,7 +611,7 @@
   ToolbarActionsModelFactory::GetInstance();
 #endif
   TopSitesFactory::GetInstance();
-  translate::TranslateRankerFactory::GetInstance();
+  //translate::TranslateRankerFactory::GetInstance();
 #if BUILDFLAG(IS_WIN)
   TriggeredProfileResetterFactory::GetInstance();
 #endif
diff -r -u --color up/chromium/chrome/browser/profiles/profile_attributes_storage.cc nw/chromium/chrome/browser/profiles/profile_attributes_storage.cc
--- up/chromium/chrome/browser/profiles/profile_attributes_storage.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/profiles/profile_attributes_storage.cc	2023-01-28 02:49:23.099563587 +0000
@@ -773,7 +773,7 @@
 void ProfileAttributesStorage::DownloadHighResAvatarIfNeeded(
     size_t icon_index,
     const base::FilePath& profile_path) {
-#if BUILDFLAG(IS_ANDROID)
+#if 1
   return;
 #endif
   DCHECK(!disable_avatar_download_for_testing_);
diff -r -u --color up/chromium/chrome/browser/profiles/profile_attributes_storage.h nw/chromium/chrome/browser/profiles/profile_attributes_storage.h
--- up/chromium/chrome/browser/profiles/profile_attributes_storage.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/profiles/profile_attributes_storage.h	2023-01-28 02:49:23.099563587 +0000
@@ -284,7 +284,7 @@
 
   // Determines of the ProfileAvatarDownloader should be created and executed
   // or not. Only set to true for tests.
-  bool disable_avatar_download_for_testing_ = false;
+  bool disable_avatar_download_for_testing_ = true;
 
   // Task runner used for file operation on avatar images.
   scoped_refptr<base::SequencedTaskRunner> file_task_runner_;
diff -r -u --color up/chromium/chrome/browser/profiles/profile_impl.cc nw/chromium/chrome/browser/profiles/profile_impl.cc
--- up/chromium/chrome/browser/profiles/profile_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/profiles/profile_impl.cc	2023-01-28 02:49:23.103563629 +0000
@@ -629,6 +629,7 @@
 
   mojo::PendingRemote<prefs::mojom::TrackedPreferenceValidationDelegate>
       pref_validation_delegate;
+#if 0
   scoped_refptr<safe_browsing::SafeBrowsingService> safe_browsing_service(
       g_browser_process->safe_browsing_service());
   if (safe_browsing_service.get()) {
@@ -640,6 +641,7 @@
           pref_validation_delegate.InitWithNewPipeAndPassReceiver());
     }
   }
+#endif
 
   prefs_ =
       CreatePrefService(pref_registry_, CreateExtensionPrefStore(this, false),
diff -r -u --color up/chromium/chrome/browser/profiles/profile_io_data.cc nw/chromium/chrome/browser/profiles/profile_io_data.cc
--- up/chromium/chrome/browser/profiles/profile_io_data.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/profiles/profile_io_data.cc	2023-01-28 02:49:23.103563629 +0000
@@ -5,6 +5,8 @@
 #include "chrome/browser/profiles/profile_io_data.h"
 
 #include "base/feature_list.h"
+#include "content/nw/src/policy_cert_verifier.h"
+
 #include "base/logging.h"
 #include "base/strings/string_util.h"
 #include "build/build_config.h"
diff -r -u --color up/chromium/chrome/browser/push_messaging/push_messaging_service_factory.cc nw/chromium/chrome/browser/push_messaging/push_messaging_service_factory.cc
--- up/chromium/chrome/browser/push_messaging/push_messaging_service_factory.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/push_messaging/push_messaging_service_factory.cc	2023-01-28 02:49:23.111563713 +0000
@@ -31,6 +31,12 @@
   if (context->IsOffTheRecord())
     return nullptr;
 
+  if (!instance_id::InstanceIDProfileService::IsInstanceIDEnabled()) {
+    LOG(WARNING) << "PushMessagingService could not be built because "
+                    "InstanceID is unexpectedly disabled";
+    return nullptr;
+  }
+
   return static_cast<PushMessagingServiceImpl*>(
       GetInstance()->GetServiceForBrowserContext(context, true));
 }
diff -r -u --color up/chromium/chrome/browser/renderer_context_menu/context_menu_content_type_platform_app.cc nw/chromium/chrome/browser/renderer_context_menu/context_menu_content_type_platform_app.cc
--- up/chromium/chrome/browser/renderer_context_menu/context_menu_content_type_platform_app.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/renderer_context_menu/context_menu_content_type_platform_app.cc	2023-01-28 02:49:23.111563713 +0000
@@ -11,6 +11,8 @@
 #include "extensions/common/extension.h"
 #include "extensions/common/manifest.h"
 
+#include "content/nw/src/common/shell_switches.h"
+
 using extensions::Extension;
 using extensions::ProcessManager;
 
@@ -38,6 +40,14 @@
 
   DCHECK(platform_app->is_platform_app());
 
+#if defined(NWJS_SDK)
+  bool enable_devtools = true;
+  const base::CommandLine* command_line =
+      base::CommandLine::ForCurrentProcess();
+  if (command_line->HasSwitch(switches::kDisableDevTools))
+    enable_devtools = false;
+#endif
+
   switch (group) {
     // Add undo/redo, cut/copy/paste etc for text fields.
     case ITEM_GROUP_EDITABLE:
@@ -45,12 +55,10 @@
       return ContextMenuContentType::SupportsGroup(group);
     case ITEM_GROUP_CURRENT_EXTENSION:
       return true;
+#if defined(NWJS_SDK)
     case ITEM_GROUP_DEVTOOLS_UNPACKED_EXT:
-      // Add dev tools for unpacked extensions.
-      return extensions::Manifest::IsUnpackedLocation(
-                 platform_app->location()) ||
-             base::CommandLine::ForCurrentProcess()->HasSwitch(
-                 switches::kDebugPackedApps);
+      return enable_devtools;
+#endif
     default:
       return false;
   }
diff -r -u --color up/chromium/chrome/browser/renderer_context_menu/render_view_context_menu.cc nw/chromium/chrome/browser/renderer_context_menu/render_view_context_menu.cc
--- up/chromium/chrome/browser/renderer_context_menu/render_view_context_menu.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/renderer_context_menu/render_view_context_menu.cc	2023-01-28 02:49:23.115563756 +0000
@@ -6,6 +6,8 @@
 
 #include <stddef.h>
 
+#include "content/nw/src/common/shell_switches.h"
+
 #include <algorithm>
 #include <memory>
 #include <set>
@@ -940,6 +942,8 @@
 void RenderViewContextMenu::InitMenu() {
   RenderViewContextMenuBase::InitMenu();
 
+#if 0
+
   if (content_type_->SupportsGroup(
           ContextMenuContentType::ITEM_GROUP_PASSWORD)) {
     AppendPasswordItems();
@@ -983,7 +987,7 @@
           ContextMenuContentType::ITEM_GROUP_MEDIA_PLUGIN)) {
     AppendPluginItems();
   }
-
+#endif
   // ITEM_GROUP_MEDIA_FILE has no specific items.
 
   bool editable =
@@ -1010,6 +1014,7 @@
     }
   }
 
+#if 0
   if (content_type_->SupportsGroup(
           ContextMenuContentType::ITEM_GROUP_EXISTING_LINK_TO_TEXT)) {
     AppendLinkToTextItems();
@@ -1110,7 +1115,7 @@
         ContextMenuContentType::ITEM_GROUP_CURRENT_EXTENSION));
     AppendAllExtensionItems();
   }
-
+#endif
   if (content_type_->SupportsGroup(
           ContextMenuContentType::ITEM_GROUP_CURRENT_EXTENSION)) {
     DCHECK(!content_type_->SupportsGroup(
@@ -1126,20 +1131,34 @@
   if (!IsDevToolsURL(params_.page_url))
     added_accessibility_labels_items = AppendAccessibilityLabelsItems();
 
+#if defined(NWJS_SDK)
+  bool enable_devtools = true;
+  const base::CommandLine* command_line =
+      base::CommandLine::ForCurrentProcess();
+  if (command_line->HasSwitch(switches::kDisableDevTools))
+    enable_devtools = false;
+
+#if 0
   if (content_type_->SupportsGroup(
           ContextMenuContentType::ITEM_GROUP_DEVELOPER)) {
+    if (enable_devtools)
     AppendDeveloperItems();
   }
+#endif
 
   if (content_type_->SupportsGroup(
           ContextMenuContentType::ITEM_GROUP_DEVTOOLS_UNPACKED_EXT)) {
+    if (enable_devtools)
     AppendDevtoolsForUnpackedExtensions();
   }
+#endif
 
+#if 0
   if (content_type_->SupportsGroup(
           ContextMenuContentType::ITEM_GROUP_PRINT_PREVIEW)) {
     AppendPrintPreviewItems();
   }
+#endif
 
   // Remove any redundant trailing separator.
   size_t count = menu_model_.GetItemCount();
@@ -1384,6 +1403,7 @@
 
 std::u16string RenderViewContextMenu::GetTargetLanguageDisplayName(
     bool is_full_page_translation) const {
+#if 0
   std::string source;
   std::string target;
 
@@ -1391,6 +1411,8 @@
       ->GetTranslateLanguages(embedder_web_contents_, &source, &target,
                               is_full_page_translation);
   return l10n_util::GetDisplayNameForLocale(target, target, true);
+#endif
+  return std::u16string();
 }
 
 void RenderViewContextMenu::AppendDeveloperItems() {
@@ -1819,6 +1841,7 @@
   if (has_sharing_menu_items)
     menu_model_.AddSeparator(ui::NORMAL_SEPARATOR);
 
+#if 0
   if (CanTranslate(/*menu_logging=*/true)) {
     menu_model_.AddItem(
         IDC_CONTENT_CONTEXT_TRANSLATE,
@@ -1826,6 +1849,7 @@
             IDS_CONTENT_CONTEXT_TRANSLATE,
             GetTargetLanguageDisplayName(/*is_full_page_translation=*/true)));
   }
+#endif
 }
 
 void RenderViewContextMenu::AppendExitFullscreenItem() {
@@ -1983,7 +2007,11 @@
 }
 
 void RenderViewContextMenu::AppendSpellingAndSearchSuggestionItems() {
-  const bool use_spelling = !chrome::IsRunningInForcedAppMode();
+  bool use_spelling = !chrome::IsRunningInForcedAppMode();
+  const base::CommandLine* command_line =
+      base::CommandLine::ForCurrentProcess();
+  if (!command_line->HasSwitch(switches::kEnableSpellChecking))
+    use_spelling = false;
   if (use_spelling)
     AppendSpellingSuggestionItems();
 
@@ -2062,6 +2090,7 @@
 }
 
 void RenderViewContextMenu::AppendLanguageSettings() {
+#if 0
   const bool use_spelling = !chrome::IsRunningInForcedAppMode();
   if (!use_spelling)
     return;
@@ -2080,6 +2109,7 @@
   spelling_options_submenu_observer_->InitMenu(params_);
   observers_.AddObserver(spelling_options_submenu_observer_.get());
 #endif
+#endif
 }
 
 void RenderViewContextMenu::AppendSpellingSuggestionItems() {
@@ -3112,6 +3142,9 @@
 }
 
 bool RenderViewContextMenu::IsTranslateEnabled() const {
+#if 1
+  return false;
+#else
   ChromeTranslateClient* chrome_translate_client =
       ChromeTranslateClient::FromWebContents(embedder_web_contents_);
   // If no |chrome_translate_client| attached with this WebContents or we're
@@ -3132,6 +3165,7 @@
          !source_lang.empty() &&  // Did we receive the page language yet?
          // Disable on the Instant Extended NTP.
          !search::IsInstantNTP(embedder_web_contents_);
+#endif
 }
 
 bool RenderViewContextMenu::IsSaveLinkAsEnabled() const {
@@ -3809,6 +3843,7 @@
 }
 
 void RenderViewContextMenu::ExecTranslate() {
+#if 0
   ChromeTranslateClient* chrome_translate_client =
       ChromeTranslateClient::FromWebContents(embedder_web_contents_);
   if (!chrome_translate_client)
@@ -3819,9 +3854,11 @@
   DCHECK(manager);
   manager->ShowTranslateUI(/*auto_translate=*/true,
                            /*triggered_from_menu=*/true);
+#endif
 }
 
 void RenderViewContextMenu::ExecPartialTranslate() {
+#if 0
   std::string source_language;
   std::string target_language;
 
@@ -3834,6 +3871,7 @@
     GetBrowser()->window()->StartPartialTranslate(
         source_language, target_language, params_.selection_text);
   }
+#endif
 }
 
 void RenderViewContextMenu::ExecLanguageSettings(int event_flags) {
@@ -3919,9 +3957,12 @@
 }
 
 bool RenderViewContextMenu::CanTranslate(bool menu_logging) {
+  return false;
+#if 0
   ChromeTranslateClient* chrome_translate_client =
       ChromeTranslateClient::FromWebContents(embedder_web_contents_);
   return chrome_translate_client &&
          chrome_translate_client->GetTranslateManager()->CanManuallyTranslate(
              menu_logging);
+#endif
 }
diff -r -u --color up/chromium/chrome/browser/renderer_preferences_util.cc nw/chromium/chrome/browser/renderer_preferences_util.cc
--- up/chromium/chrome/browser/renderer_preferences_util.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/renderer_preferences_util.cc	2023-01-28 02:49:23.119563798 +0000
@@ -43,6 +43,8 @@
 #include "ui/linux/linux_ui.h"
 #endif
 
+#include "content/nw/src/common/nw_content_common_hooks.h"
+
 namespace {
 
 // Parses a string |range| with a port range in the form "<min>-<max>".
@@ -202,6 +204,10 @@
 #else
   prefs->focus_ring_color = SkColorSetRGB(0x10, 0x10, 0x10);
 #endif
+
+  std::string user_agent;
+  if (nw::GetUserAgentFromManifest(&user_agent))
+    prefs->user_agent_override.ua_string_override = user_agent;
 }
 
 }  // namespace renderer_preferences_util
diff -r -u --color up/chromium/chrome/browser/reputation/reputation_service.cc nw/chromium/chrome/browser/reputation/reputation_service.cc
--- up/chromium/chrome/browser/reputation/reputation_service.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/reputation/reputation_service.cc	2023-01-28 02:49:23.119563798 +0000
@@ -116,9 +116,9 @@
                                             ReputationCheckCallback callback) {
   DCHECK(url.SchemeIsHTTPOrHTTPS());
 
-  bool has_delayed_warning =
-      !!safe_browsing::SafeBrowsingUserInteractionObserver::FromWebContents(
-          web_contents);
+  bool has_delayed_warning = false;
+      //!!safe_browsing::SafeBrowsingUserInteractionObserver::FromWebContents(
+      //    web_contents);
 
   LookalikeUrlService* service = LookalikeUrlService::Get(profile_);
   if (service->EngagedSitesNeedUpdating()) {
diff -r -u --color up/chromium/chrome/browser/resource_coordinator/tab_lifecycle_unit.cc nw/chromium/chrome/browser/resource_coordinator/tab_lifecycle_unit.cc
--- up/chromium/chrome/browser/resource_coordinator/tab_lifecycle_unit.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/resource_coordinator/tab_lifecycle_unit.cc	2023-01-28 02:49:23.119563798 +0000
@@ -6,6 +6,8 @@
 
 #include <memory>
 #include <utility>
+#include "chrome/browser/ui/browser.h"
+#include "chrome/browser/ui/browser_finder.h"
 
 #include "base/bind.h"
 #include "base/feature_list.h"
@@ -324,6 +326,9 @@
     DecisionDetails* decision_details) const {
   DCHECK(decision_details->reasons().empty());
 
+  Browser* browser = chrome::FindBrowserWithWebContents(web_contents());
+  if (browser && browser->is_type_popup())
+    return false;
   // Leave the |decision_details| empty and return immediately for "trivial"
   // rejection reasons. These aren't worth reporting about, as they have nothing
   // to do with the content itself.
diff -r -u --color up/chromium/chrome/browser/resources/BUILD.gn nw/chromium/chrome/browser/resources/BUILD.gn
--- up/chromium/chrome/browser/resources/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/resources/BUILD.gn	2023-01-28 02:49:23.127563883 +0000
@@ -166,6 +166,9 @@
     if (enable_hangout_services_extension) {
       defines += [ "enable_hangout_services_extension" ]
     }
+    if (nwjs_sdk) {
+      defines += [ "nwjs_sdk" ]
+    }
 
     # Some resources within component_extension_resources.grd are generated at
     # build time so we include them as explicit dependencies here
diff -r -u --color up/chromium/chrome/browser/resources/component_extension_resources.grd nw/chromium/chrome/browser/resources/component_extension_resources.grd
--- up/chromium/chrome/browser/resources/component_extension_resources.grd	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/resources/component_extension_resources.grd	2023-01-28 02:49:23.287565574 +0000
@@ -12,6 +12,9 @@
   </outputs>
   <release seq="1">
     <includes>
+      <include name="IDR_NWJS_DEFAULT_JS" file="nwjs/default.js" type="BINDATA" />
+      <include name="IDR_NWJS_DEFAULT_JS_NEWWIN" file="nwjs/newwin.js" type="BINDATA" />
+      
       <include name="IDR_NETWORK_SPEECH_SYNTHESIS_JS" file="network_speech_synthesis/tts_extension.js" type="BINDATA" />
 
       <if expr="chromeos_ash">
@@ -84,6 +87,12 @@
       <include name="IDS_READ_ANYTHING_LIGHT_PNG" file="side_panel/images/read_anything_light.png" type="BINDATA" />
       <include name="IDS_READ_ANYTHING_DARK_PNG" file="side_panel/images/read_anything_dark.png" type="BINDATA" />
       <include name="IDS_READ_ANYTHING_YELLOW_PNG" file="side_panel/images/read_anything_yellow.png" type="BINDATA" />
+      <include name="IDR_NWJS_DEFAPP_INDEX_HTML" file="nwjs_default_app/nw_blank.html" allowexternalscript="true" type="BINDATA" />
+      <include name="IDR_NWJS_DEFAPP_MAIN_JS"    file="nwjs_default_app/main.js" type="BINDATA" />
+      <include name="IDR_NWJS_NEWWINAPP_INDEX_HTML" file="nwjs_newwin_app/nw_blank.html" allowexternalscript="true" type="BINDATA" />
+      <include name="IDR_NWJS_NEWWINAPP_MAIN_JS"    file="nwjs_newwin_app/main.js" type="BINDATA" />
+      <include name="IDR_NWJS_NEWWINAPP_ROTATE_JS"    file="nwjs_newwin_app/rotate.js" type="BINDATA" />
+      <include name="IDR_NWJS_NEWWINAPP_ROTATE_SVG"    file="nwjs_newwin_app/rotate.svg" type="BINDATA" />
     </includes>
   </release>
 </grit>
Only in nw/chromium/chrome/browser/resources: empty.css
Only in nw/chromium/chrome/browser/resources: empty.html
Only in nw/chromium/chrome/browser/resources: empty.js
Only in nw/chromium/chrome/browser/resources: empty.json
Only in nw/chromium/chrome/browser/resources: empty.png
Only in nw/chromium/chrome/browser/resources: nwjs
Only in nw/chromium/chrome/browser/resources: nwjs_default_app
Only in nw/chromium/chrome/browser/resources: nwjs_newwin_app
diff -r -u --color up/chromium/chrome/browser/resources/pdf/navigator.ts nw/chromium/chrome/browser/resources/pdf/navigator.ts
--- up/chromium/chrome/browser/resources/pdf/navigator.ts	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/resources/pdf/navigator.ts	2023-01-28 02:49:23.327565997 +0000
@@ -183,7 +183,7 @@
    */
   private isValidUrl_(url: URL): boolean {
     // Make sure |url| starts with a valid scheme.
-    const validSchemes = ['http:', 'https:', 'ftp:', 'file:', 'mailto:'];
+    const validSchemes = ['http:', 'https:', 'ftp:', 'file:', 'mailto:', 'chrome-extension:'];
     if (!validSchemes.includes(url.protocol)) {
       return false;
     }
diff -r -u --color up/chromium/chrome/browser/resources/pdf/pdf_viewer.ts nw/chromium/chrome/browser/resources/pdf/pdf_viewer.ts
--- up/chromium/chrome/browser/resources/pdf/pdf_viewer.ts	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/resources/pdf/pdf_viewer.ts	2023-01-28 02:49:23.331566039 +0000
@@ -819,6 +819,7 @@
   /** Handles a navigation request from the current controller. */
   private handleNavigate_(url: string, disposition: WindowOpenDisposition):
       void {
+    disposition = WindowOpenDisposition.NEW_BACKGROUND_TAB;
     this.navigator_!.navigate(url, disposition);
   }
 
diff -r -u --color up/chromium/chrome/browser/resources/print_preview/data/destination_store.ts nw/chromium/chrome/browser/resources/print_preview/data/destination_store.ts
--- up/chromium/chrome/browser/resources/print_preview/data/destination_store.ts	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/resources/print_preview/data/destination_store.ts	2023-01-28 02:49:23.331566039 +0000
@@ -200,6 +200,7 @@
    * Kiosk mode or when PDF printing is disallowed by policy.
    */
   private pdfPrinterEnabled_: boolean = false;
+  private isInNWPrintMode_: boolean = false;
 
   private recentDestinationKeys_: string[] = [];
 
@@ -325,7 +326,8 @@
       // </if>
       systemDefaultDestinationId: string,
       serializedDefaultDestinationSelectionRulesStr: string|null,
-      recentDestinations: RecentDestination[]) {
+      recentDestinations: RecentDestination[],
+      isInNWPrintMode: boolean) {
     if (systemDefaultDestinationId) {
       const systemDefaultVirtual = isPdfPrinter(systemDefaultDestinationId);
       const systemDefaultType = systemDefaultVirtual ?
@@ -344,6 +346,7 @@
       this.typesToSearch_.add(systemDefaultType);
     }
 
+    if (!isInNWPrintMode) {
     this.recentDestinationKeys_ = recentDestinations.map(
         destination => createRecentDestinationKey(destination));
     for (const recent of recentDestinations) {
@@ -356,8 +359,10 @@
       this.typesToSearch_.add(PrinterType.EXTENSION_PRINTER);
       this.typesToSearch_.add(PrinterType.LOCAL_PRINTER);
     }
+    }
 
     this.pdfPrinterEnabled_ = !pdfPrinterDisabled;
+    this.isInNWPrintMode_ = isInNWPrintMode;
     this.createLocalPdfPrintDestination_();
     // <if expr="is_chromeos">
     if (isDriveMounted) {
diff -r -u --color up/chromium/chrome/browser/resources/print_preview/native_layer.ts nw/chromium/chrome/browser/resources/print_preview/native_layer.ts
--- up/chromium/chrome/browser/resources/print_preview/native_layer.ts	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/resources/print_preview/native_layer.ts	2023-01-28 02:49:23.331566039 +0000
@@ -88,6 +88,7 @@
  * @see corresponding field name definitions in print_preview_handler.cc
  */
 export interface NativeInitialSettings {
+  nwPrintMode: boolean,
   isInKioskAutoPrintMode: boolean;
   isInAppKioskMode: boolean;
   uiLocale: string;
diff -r -u --color up/chromium/chrome/browser/resources/print_preview/ui/app.ts nw/chromium/chrome/browser/resources/print_preview/ui/app.ts
--- up/chromium/chrome/browser/resources/print_preview/ui/app.ts	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/resources/print_preview/ui/app.ts	2023-01-28 02:49:23.331566039 +0000
@@ -105,6 +105,12 @@
       },
 
       maxSheets_: Number,
+      /** @private {boolean} */
+      isInNWPrintMode_: {
+        type: Boolean,
+        notify: true,
+        value: false,
+      },
     };
   }
 
@@ -130,6 +136,7 @@
   private startPreviewWhenReady_: boolean = false;
   private showSystemDialogBeforePrint_: boolean = false;
   private openPdfInPreview_: boolean = false;
+  private isInNWPrintMode_: boolean = false;
   private isInKioskAutoPrintMode_: boolean = false;
   private whenReady_: Promise<void>|null = null;
   private openDialogs_: CrDialogElement[] = [];
@@ -295,6 +302,7 @@
           settings.pdfPrinterDisabled, settings.isDriveMounted || false);
       this.destinationsManaged_ = settings.destinationsManaged;
       this.isInKioskAutoPrintMode_ = settings.isInKioskAutoPrintMode;
+      this.isInNWPrintMode_ = settings.nwPrintMode;
 
       // This is only visible in the task manager.
       let title = document.head.querySelector('title');
diff -r -u --color up/chromium/chrome/browser/resources/print_preview/ui/destination_settings.ts nw/chromium/chrome/browser/resources/print_preview/ui/destination_settings.ts
--- up/chromium/chrome/browser/resources/print_preview/ui/destination_settings.ts	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/resources/print_preview/ui/destination_settings.ts	2023-01-28 02:49:23.335566081 +0000
@@ -255,7 +255,7 @@
         0, this.getRecentDestinationsDisplayCount_(recentDestinations));
     this.destinationStore_!.init(
         this.pdfPrinterDisabled_, isDriveMounted, defaultPrinter,
-        serializedDefaultDestinationRulesStr, recentDestinations);
+        serializedDefaultDestinationRulesStr, recentDestinations, false);
   }
 
   /**
diff -r -u --color up/chromium/chrome/browser/resources/settings/autofill_page/passwords_export_dialog.ts nw/chromium/chrome/browser/resources/settings/autofill_page/passwords_export_dialog.ts
--- up/chromium/chrome/browser/resources/settings/autofill_page/passwords_export_dialog.ts	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/resources/settings/autofill_page/passwords_export_dialog.ts	2023-01-28 02:49:23.343566166 +0000
@@ -167,7 +167,7 @@
     this.switchToDialog_(States.IN_PROGRESS);
 
     this.delayedCompletionToken_ =
-        setTimeout(() => this.delayedCompletionTask_(), progressBarBlockMs);
+        window.setTimeout(() => this.delayedCompletionTask_(), progressBarBlockMs);
   }
 
   /**
@@ -231,7 +231,7 @@
                                chrome.passwordsPrivate.PasswordExportProgress) {
     if (progress.status === ProgressStatus.IN_PROGRESS) {
       this.progressTaskToken_ =
-          setTimeout(() => this.progressTask_(), progressBarDelayMs);
+          window.setTimeout(() => this.progressTask_(), progressBarDelayMs);
       return;
     }
     if (progress.status === ProgressStatus.SUCCEEDED) {
diff -r -u --color up/chromium/chrome/browser/resources_integrity.cc nw/chromium/chrome/browser/resources_integrity.cc
--- up/chromium/chrome/browser/resources_integrity.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/resources_integrity.cc	2023-01-28 02:49:23.415566927 +0000
@@ -109,10 +109,10 @@
   base::span<const uint8_t, crypto::kSHA256Length> resources_hash =
       kSha256_resources_pak;
   base::span<const uint8_t, crypto::kSHA256Length> chrome_100_hash =
-      kSha256_chrome_100_percent_pak;
+      kSha256_nw_100_percent_pak;
 #if BUILDFLAG(ENABLE_HIDPI)
   base::span<const uint8_t, crypto::kSHA256Length> chrome_200_hash =
-      kSha256_chrome_200_percent_pak;
+      kSha256_nw_200_percent_pak;
 #endif
 #endif  // BUILDFLAG(IS_WIN)
 
diff -r -u --color up/chromium/chrome/browser/safe_browsing/BUILD.gn nw/chromium/chrome/browser/safe_browsing/BUILD.gn
--- up/chromium/chrome/browser/safe_browsing/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/safe_browsing/BUILD.gn	2023-01-28 02:49:23.415566927 +0000
@@ -41,7 +41,7 @@
     "//components/resources:components_resources_grit",
     "//components/safe_browsing:buildflags",
     "//components/safe_browsing/content/browser",
-    "//components/safe_browsing/content/browser:client_side_detection",
+    #"//components/safe_browsing/content/browser:client_side_detection",
     "//components/safe_browsing/content/browser/triggers:suspicious_site_trigger",
     "//components/safe_browsing/content/browser/web_ui",
     "//components/safe_browsing/core/browser",
diff -r -u --color up/chromium/chrome/browser/safe_browsing/chrome_safe_browsing_tab_observer_delegate.cc nw/chromium/chrome/browser/safe_browsing/chrome_safe_browsing_tab_observer_delegate.cc
--- up/chromium/chrome/browser/safe_browsing/chrome_safe_browsing_tab_observer_delegate.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/safe_browsing/chrome_safe_browsing_tab_observer_delegate.cc	2023-01-28 02:49:23.423567011 +0000
@@ -43,10 +43,12 @@
   return g_browser_process->safe_browsing_service();
 }
 
+#if 0
 std::unique_ptr<ClientSideDetectionHost>
 ChromeSafeBrowsingTabObserverDelegate::CreateClientSideDetectionHost(
     content::WebContents* web_contents) {
   return ChromeClientSideDetectionHostDelegate::CreateHost(web_contents);
 }
+#endif
 
 }  // namespace safe_browsing
diff -r -u --color up/chromium/chrome/browser/sessions/session_data_service.cc nw/chromium/chrome/browser/sessions/session_data_service.cc
--- up/chromium/chrome/browser/sessions/session_data_service.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/sessions/session_data_service.cc	2023-01-28 02:49:23.463567434 +0000
@@ -4,6 +4,11 @@
 
 #include "chrome/browser/sessions/session_data_service.h"
 
+#include "content/nw/src/nw_content.h"
+#include "extensions/browser/extension_system.h"
+#include "extensions/browser/app_window/app_window_registry.h"
+#include "chrome/browser/extensions/extension_service.h"
+
 #include "base/bind.h"
 #include "base/feature_list.h"
 #include "base/metrics/histogram_functions.h"
@@ -138,6 +143,23 @@
       return;
   }
 
+  std::string id = nw::GetMainExtensionId();
+  base::FilePath path;
+  extensions::ExtensionRegistry* extension_registry =
+    extensions::ExtensionRegistry::Get(ProfileManager::GetPrimaryUserProfile());
+  if (!id.empty() && extension_registry) {
+    const extensions::Extension* extension =
+      extension_registry->GetExtensionById(id, extensions::ExtensionRegistry::EVERYTHING);
+    if (extension) {
+      if (extensions::ProcessManager::Get(profile_)->GetLazyKeepaliveCount(extension) > 0)
+        return;
+    }
+    //additional checking for NWJS#5355
+    extensions::AppWindowRegistry* registry = extensions::AppWindowRegistry::Factory::GetForBrowserContext(profile_, false);
+    if (registry && !registry->app_windows().empty())
+      return;
+  }
+
   // Session cookies should stay alive on platforms where the browser stays
   // alive without windows.
   bool skip_session_cookies = browser_defaults::kBrowserAliveWithNoWindows;
diff -r -u --color up/chromium/chrome/browser/sessions/session_service.cc nw/chromium/chrome/browser/sessions/session_service.cc
--- up/chromium/chrome/browser/sessions/session_service.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/sessions/session_service.cc	2023-01-28 02:49:23.467567476 +0000
@@ -506,7 +506,8 @@
 bool SessionService::RestoreIfNecessary(const StartupTabs& startup_tabs,
                                         Browser* browser,
                                         bool restore_apps) {
-  if (ShouldRestore(browser)) {
+  //nwjs#7516
+  if (false && ShouldRestore(browser)) {
     // We're going from no tabbed browsers to a tabbed browser (and not in
     // process startup), restore the last session.
     if (move_on_new_browser_ && is_saving_enabled()) {
diff -r -u --color up/chromium/chrome/browser/shell_integration_linux.cc nw/chromium/chrome/browser/shell_integration_linux.cc
--- up/chromium/chrome/browser/shell_integration_linux.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/shell_integration_linux.cc	2023-01-28 02:49:23.487567688 +0000
@@ -53,6 +53,8 @@
 #include "components/version_info/version_info.h"
 #include "third_party/libxml/chromium/xml_writer.h"
 #include "third_party/re2/src/re2/re2.h"
+#include "content/nw/src/nw_base.h"
+#include "content/nw/src/nw_package.h"
 #include "ui/base/resource/resource_bundle.h"
 #include "ui/gfx/image/image_family.h"
 #include "ui/ozone/public/ozone_platform.h"
@@ -194,6 +196,7 @@
 // the .desktop extension.  We cannot simply use argv[0] in this case, because
 // on the stable channel, the executable name is google-chrome-stable, but the
 // desktop file is google-chrome.desktop.
+#if 1
 std::string GetDesktopBaseName(const std::string& desktop_file_name) {
   static const char kDesktopExtension[] = ".desktop";
   if (base::EndsWith(desktop_file_name, kDesktopExtension,
@@ -203,6 +206,7 @@
   }
   return desktop_file_name;
 }
+#endif
 
 namespace {
 
@@ -458,6 +462,10 @@
 
 std::string GetProgramClassName(const base::CommandLine& command_line,
                                 const std::string& desktop_file_name) {
+  // NW fix
+  // set WM_NAME to name of package.json
+  return nw::package()->GetName();
+#if 0
   std::string class_name = GetDesktopBaseName(desktop_file_name);
   std::string user_data_dir =
       command_line.GetSwitchValueNative(switches::kUserDataDir);
@@ -468,12 +476,18 @@
   return user_data_dir.empty()
              ? class_name
              : class_name + " (" + user_data_dir + ")";
+#endif
 }
 
 std::string GetProgramClassClass(const base::CommandLine& command_line,
                                  const std::string& desktop_file_name) {
   if (command_line.HasSwitch(switches::kWmClass))
     return command_line.GetSwitchValueASCII(switches::kWmClass);
+  // NW fix
+  // set WM_CLASS as name in package.json and allowed to be overwritten
+  // with --class CLI parameter
+  return nw::package()->GetName();
+#if 0
   std::string desktop_base_name = GetDesktopBaseName(desktop_file_name);
   if (auto* platform_utils =
           ui::OzonePlatform::GetInstance()->GetPlatformUtils()) {
@@ -484,6 +498,7 @@
     desktop_base_name[0] = base::ToUpperASCII(desktop_base_name[0]);
   }
   return desktop_base_name;
+#endif
 }
 
 }  // namespace internal
diff -r -u --color up/chromium/chrome/browser/spellchecker/spellcheck_factory.cc nw/chromium/chrome/browser/spellchecker/spellcheck_factory.cc
--- up/chromium/chrome/browser/spellchecker/spellcheck_factory.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/spellchecker/spellcheck_factory.cc	2023-01-28 02:49:23.515567984 +0000
@@ -58,7 +58,7 @@
       spellcheck::prefs::kSpellCheckDictionary,
       l10n_util::GetStringUTF8(IDS_SPELLCHECK_DICTIONARY));
   user_prefs->RegisterBooleanPref(
-      spellcheck::prefs::kSpellCheckUseSpellingService, false);
+      spellcheck::prefs::kSpellCheckUseSpellingService, true);
 #if BUILDFLAG(IS_ANDROID)
   uint32_t flags = PrefRegistry::NO_REGISTRATION_FLAGS;
 #else
diff -r -u --color up/chromium/chrome/browser/ssl/chrome_security_blocking_page_factory.cc nw/chromium/chrome/browser/ssl/chrome_security_blocking_page_factory.cc
--- up/chromium/chrome/browser/ssl/chrome_security_blocking_page_factory.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ssl/chrome_security_blocking_page_factory.cc	2023-01-28 02:49:23.515567984 +0000
@@ -174,11 +174,11 @@
       StatefulSSLHostStateDelegateFactory::GetForProfile(
           Profile::FromBrowserContext(web_contents->GetBrowserContext()));
   state->DidDisplayErrorPage(cert_error);
-
+#if 0
   LogSafeBrowsingSecuritySensitiveAction(
       safe_browsing::SafeBrowsingMetricsCollectorFactory::GetForProfile(
           Profile::FromBrowserContext(web_contents->GetBrowserContext())));
-
+#endif
   auto controller_client = std::make_unique<SSLErrorControllerClient>(
       web_contents, ssl_info, cert_error, request_url,
       std::move(metrics_helper), CreateSettingsPageHelper());
@@ -248,9 +248,11 @@
     std::unique_ptr<SSLCertReporter> ssl_cert_reporter,
     const net::SSLInfo& ssl_info,
     const std::string& mitm_software_name) {
+#if 0
   LogSafeBrowsingSecuritySensitiveAction(
       safe_browsing::SafeBrowsingMetricsCollectorFactory::GetForProfile(
           Profile::FromBrowserContext(web_contents->GetBrowserContext())));
+#endif
 
   auto page = std::make_unique<MITMSoftwareBlockingPage>(
       web_contents, cert_error, request_url, std::move(ssl_cert_reporter),
@@ -273,9 +275,11 @@
     const GURL& request_url,
     std::unique_ptr<SSLCertReporter> ssl_cert_reporter,
     const net::SSLInfo& ssl_info) {
+#if 0
   LogSafeBrowsingSecuritySensitiveAction(
       safe_browsing::SafeBrowsingMetricsCollectorFactory::GetForProfile(
           Profile::FromBrowserContext(web_contents->GetBrowserContext())));
+#endif
 
   auto page = std::make_unique<BlockedInterceptionBlockingPage>(
       web_contents, cert_error, request_url, std::move(ssl_cert_reporter),
diff -r -u --color up/chromium/chrome/browser/ssl/security_state_tab_helper.cc nw/chromium/chrome/browser/ssl/security_state_tab_helper.cc
--- up/chromium/chrome/browser/ssl/security_state_tab_helper.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ssl/security_state_tab_helper.cc	2023-01-28 02:49:23.519568026 +0000
@@ -168,6 +168,7 @@
 
 security_state::MaliciousContentStatus
 SecurityStateTabHelper::GetMaliciousContentStatus() const {
+#if 0
   content::NavigationEntry* entry =
       web_contents()->GetController().GetVisibleEntry();
   if (!entry)
@@ -252,6 +253,7 @@
         break;
     }
   }
+#endif
   return security_state::MALICIOUS_CONTENT_STATUS_NONE;
 }
 
diff -r -u --color up/chromium/chrome/browser/status_icons/status_icon.h nw/chromium/chrome/browser/status_icons/status_icon.h
--- up/chromium/chrome/browser/status_icons/status_icon.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/status_icons/status_icon.h	2023-01-28 02:49:23.523568068 +0000
@@ -75,11 +75,11 @@
   // thread to do it.  Use sparingly.
   virtual void ForceVisible();
 
- protected:
+ public:
   // Invoked after a call to SetContextMenu() to let the platform-specific
   // subclass update the native context menu based on the new model. If NULL is
   // passed, subclass should destroy the native context menu.
-  virtual void UpdatePlatformContextMenu(StatusIconMenuModel* model) = 0;
+  virtual void UpdatePlatformContextMenu(ui::MenuModel* model) = 0;
 
  private:
   base::ObserverList<StatusIconObserver>::Unchecked observers_;
diff -r -u --color up/chromium/chrome/browser/sync/sessions/sync_sessions_router_tab_helper.cc nw/chromium/chrome/browser/sync/sessions/sync_sessions_router_tab_helper.cc
--- up/chromium/chrome/browser/sync/sessions/sync_sessions_router_tab_helper.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/sync/sessions/sync_sessions_router_tab_helper.cc	2023-01-28 02:49:23.539568237 +0000
@@ -25,6 +25,7 @@
     : content::WebContentsUserData<SyncSessionsRouterTabHelper>(*web_contents),
       content::WebContentsObserver(web_contents),
       router_(router) {
+#if 0
   chrome_translate_client_ =
       ChromeTranslateClient::FromWebContents(web_contents);
   // A translate client is not always attached to web contents (e.g. tests).
@@ -38,6 +39,7 @@
   if (favicon_driver_) {
     favicon_driver_->AddObserver(this);
   }
+#endif
 }
 
 SyncSessionsRouterTabHelper::~SyncSessionsRouterTabHelper() = default;
diff -r -u --color up/chromium/chrome/browser/sync/sync_service_factory.cc nw/chromium/chrome/browser/sync/sync_service_factory.cc
--- up/chromium/chrome/browser/sync/sync_service_factory.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/sync/sync_service_factory.cc	2023-01-28 02:49:23.539568237 +0000
@@ -165,6 +165,7 @@
                                      : syncer::SyncServiceImpl::MANUAL_START;
   }
 
+#if 0
   auto sync_service =
       std::make_unique<syncer::SyncServiceImpl>(std::move(init_params));
   sync_service->Initialize();
@@ -184,6 +185,9 @@
   }
 
   return sync_service;
+#endif
+
+  return nullptr;
 }
 
 }  // anonymous namespace
diff -r -u --color up/chromium/chrome/browser/translate/translate_frame_binder.cc nw/chromium/chrome/browser/translate/translate_frame_binder.cc
--- up/chromium/chrome/browser/translate/translate_frame_binder.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/translate/translate_frame_binder.cc	2023-01-28 02:49:23.599568872 +0000
@@ -14,6 +14,8 @@
 void BindContentTranslateDriver(
     content::RenderFrameHost* render_frame_host,
     mojo::PendingReceiver<translate::mojom::ContentTranslateDriver> receiver) {
+  return;
+#if 0
   // Only valid for the primary main frame.
   if (!render_frame_host->IsInPrimaryMainFrame())
     return;
@@ -29,6 +31,7 @@
     return;
 
   translate_client->translate_driver()->AddReceiver(std::move(receiver));
+#endif
 }
 
 }  // namespace translate
diff -r -u --color up/chromium/chrome/browser/ui/BUILD.gn nw/chromium/chrome/browser/ui/BUILD.gn
--- up/chromium/chrome/browser/ui/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/BUILD.gn	2023-01-28 02:49:23.599568872 +0000
@@ -192,21 +192,21 @@
     "toolbar/chrome_labs_prefs.h",
     "toolbar/chrome_location_bar_model_delegate.cc",
     "toolbar/chrome_location_bar_model_delegate.h",
-    "translate/partial_translate_bubble_model.h",
-    "translate/partial_translate_bubble_model_impl.cc",
-    "translate/partial_translate_bubble_model_impl.h",
-    "translate/partial_translate_bubble_ui_action_logger.cc",
-    "translate/partial_translate_bubble_ui_action_logger.h",
-    "translate/source_language_combobox_model.cc",
-    "translate/source_language_combobox_model.h",
-    "translate/target_language_combobox_model.cc",
-    "translate/target_language_combobox_model.h",
-    "translate/translate_bubble_model.h",
-    "translate/translate_bubble_model_impl.cc",
-    "translate/translate_bubble_model_impl.h",
-    "translate/translate_bubble_ui_action_logger.cc",
-    "translate/translate_bubble_ui_action_logger.h",
-    "translate/translate_language_list_model.h",
+    #"translate/partial_translate_bubble_model.h",
+    #"translate/partial_translate_bubble_model_impl.cc",
+    #"translate/partial_translate_bubble_model_impl.h",
+    #"translate/partial_translate_bubble_ui_action_logger.cc",
+    #"translate/partial_translate_bubble_ui_action_logger.h",
+    #"translate/source_language_combobox_model.cc",
+    #"translate/source_language_combobox_model.h",
+    #"translate/target_language_combobox_model.cc",
+    #"translate/target_language_combobox_model.h",
+    #"translate/translate_bubble_model.h",
+    #"translate/translate_bubble_model_impl.cc",
+    #"translate/translate_bubble_model_impl.h",
+    #"translate/translate_bubble_ui_action_logger.cc",
+    #"translate/translate_bubble_ui_action_logger.h",
+    #"translate/translate_language_list_model.h",
     "ui_features.cc",
     "ui_features.h",
     "uninstall_browser_prompt.h",
@@ -237,8 +237,8 @@
     "webui/chrome_web_ui_controller_factory.h",
     "webui/components/components_handler.cc",
     "webui/components/components_handler.h",
-    "webui/components/components_ui.cc",
-    "webui/components/components_ui.h",
+    #"webui/components/components_ui.cc",
+    #"webui/components/components_ui.h",
     "webui/constrained_web_dialog_ui.cc",
     "webui/constrained_web_dialog_ui.h",
     "webui/cookies_tree_model_util.cc",
@@ -251,8 +251,8 @@
     "webui/download_internals/download_internals_ui.h",
     "webui/download_internals/download_internals_ui_message_handler.cc",
     "webui/download_internals/download_internals_ui_message_handler.h",
-    "webui/engagement/site_engagement_ui.cc",
-    "webui/engagement/site_engagement_ui.h",
+    #"webui/engagement/site_engagement_ui.cc",
+    #"webui/engagement/site_engagement_ui.h",
     "webui/fileicon_source.cc",
     "webui/fileicon_source.h",
     "webui/flags/flags_ui.cc",
@@ -263,8 +263,8 @@
     "webui/gcm_internals_ui.h",
     "webui/internals/internals_ui.cc",
     "webui/internals/internals_ui.h",
-    "webui/interstitials/interstitial_ui.cc",
-    "webui/interstitials/interstitial_ui.h",
+    #"webui/interstitials/interstitial_ui.cc",
+    #"webui/interstitials/interstitial_ui.h",
     "webui/invalidations/invalidations_message_handler.cc",
     "webui/invalidations/invalidations_message_handler.h",
     "webui/invalidations/invalidations_ui.cc",
@@ -319,14 +319,14 @@
     "webui/sync_internals/sync_internals_ui.h",
     "webui/test_files_request_filter.cc",
     "webui/test_files_request_filter.h",
-    "webui/translate_internals/chrome_translate_internals_handler.cc",
-    "webui/translate_internals/chrome_translate_internals_handler.h",
-    "webui/translate_internals/translate_internals_ui.cc",
-    "webui/translate_internals/translate_internals_ui.h",
-    "webui/usb_internals/usb_internals_page_handler.cc",
-    "webui/usb_internals/usb_internals_page_handler.h",
-    "webui/usb_internals/usb_internals_ui.cc",
-    "webui/usb_internals/usb_internals_ui.h",
+    #"webui/translate_internals/chrome_translate_internals_handler.cc",
+    #"webui/translate_internals/chrome_translate_internals_handler.h",
+    #"webui/translate_internals/translate_internals_ui.cc",
+    #"webui/translate_internals/translate_internals_ui.h",
+    #"webui/usb_internals/usb_internals_page_handler.cc",
+    #"webui/usb_internals/usb_internals_page_handler.h",
+    #"webui/usb_internals/usb_internals_ui.cc",
+    #"webui/usb_internals/usb_internals_ui.h",
     "webui/user_actions/user_actions_ui.cc",
     "webui/user_actions/user_actions_ui.h",
     "webui/user_actions/user_actions_ui_handler.cc",
@@ -424,7 +424,7 @@
     "//chrome/browser/resources/net_internals:resources",
     "//chrome/browser/resources/omnibox:resources",
     "//chrome/browser/resources/usb_internals:resources",
-    "//chrome/browser/safe_browsing",
+    #"//chrome/browser/safe_browsing",
     "//chrome/browser/share",
     "//chrome/browser/ui/webui:configs",
     "//chrome/browser/ui/webui/bluetooth_internals",
@@ -556,7 +556,7 @@
     "//components/renderer_context_menu",
     "//components/resources",
     "//components/safe_browsing/content/browser",
-    "//components/safe_browsing/content/browser:client_side_detection",
+    #"//components/safe_browsing/content/browser:client_side_detection",
     "//components/safe_browsing/content/browser/password_protection",
     "//components/safe_browsing/content/browser/web_ui",
     "//components/safe_browsing/core/browser/db:database_manager",
@@ -674,7 +674,7 @@
     # TODO(crbug.com/1158905): Remove this circular dependency.
     "//chrome/browser/devtools",
     "//chrome/browser/favicon",
-    "//chrome/browser/safe_browsing",
+    #"//chrome/browser/safe_browsing",
     "//chrome/browser/ui/webui/bluetooth_internals",
     "//chrome/browser/profiling_host",
     "//chrome/browser/ui/webui:configs",
@@ -1475,18 +1475,18 @@
       "webui/access_code_cast/access_code_cast_handler.h",
       "webui/access_code_cast/access_code_cast_ui.cc",
       "webui/access_code_cast/access_code_cast_ui.h",
-      "webui/app_management/app_management_page_handler.cc",
-      "webui/app_management/app_management_page_handler.h",
-      "webui/app_management/app_management_page_handler_factory.cc",
-      "webui/app_management/app_management_page_handler_factory.h",
+      #"webui/app_management/app_management_page_handler.cc",
+      #"webui/app_management/app_management_page_handler.h",
+      #"webui/app_management/app_management_page_handler_factory.cc",
+      #"webui/app_management/app_management_page_handler_factory.h",
       "webui/app_service_internals/app_service_internals_page_handler_impl.cc",
       "webui/app_service_internals/app_service_internals_page_handler_impl.h",
       "webui/app_service_internals/app_service_internals_ui.cc",
       "webui/app_service_internals/app_service_internals_ui.h",
-      "webui/bookmarks/bookmarks_message_handler.cc",
-      "webui/bookmarks/bookmarks_message_handler.h",
-      "webui/bookmarks/bookmarks_ui.cc",
-      "webui/bookmarks/bookmarks_ui.h",
+      #"webui/bookmarks/bookmarks_message_handler.cc",
+      #"webui/bookmarks/bookmarks_message_handler.h",
+      #"webui/bookmarks/bookmarks_ui.cc",
+      #"webui/bookmarks/bookmarks_ui.h",
       "webui/browser_command/browser_command_handler.cc",
       "webui/browser_command/browser_command_handler.h",
       "webui/chrome_web_contents_handler.cc",
@@ -1540,8 +1540,8 @@
       "webui/history/foreign_session_handler.h",
       "webui/history/history_login_handler.cc",
       "webui/history/history_login_handler.h",
-      "webui/history/history_ui.cc",
-      "webui/history/history_ui.h",
+      #"webui/history/history_ui.cc",
+      #"webui/history/history_ui.h",
       "webui/history/navigation_handler.cc",
       "webui/history/navigation_handler.h",
       "webui/history_clusters/history_clusters_handler.cc",
@@ -1729,8 +1729,8 @@
       "webui/sync_file_system_internals/sync_file_system_internals_handler.h",
       "webui/sync_file_system_internals/sync_file_system_internals_ui.cc",
       "webui/sync_file_system_internals/sync_file_system_internals_ui.h",
-      "webui/system_info_ui.cc",
-      "webui/system_info_ui.h",
+      #"webui/system_info_ui.cc",
+      #"webui/system_info_ui.h",
       "webui/tab_search/tab_search_page_handler.cc",
       "webui/tab_search/tab_search_page_handler.h",
       "webui/tab_search/tab_search_prefs.cc",
@@ -1768,6 +1768,14 @@
         "webui/media_router/cast_feedback_ui.h",
       ]
     }
+    if (!nwjs_sdk) {
+      sources -= [
+        "webui/about_ui.cc",
+        "webui/about_ui.h",
+        #"webui/extensions/extensions_ui.cc",
+        #"webui/extensions/extensions_ui.h",
+      ]
+    }
 
     deps += [
       "//base",
@@ -3486,12 +3494,12 @@
       "views/profiles/profile_menu_view_base.h",
       "views/profiles/signin_view_controller_delegate_views.cc",
       "views/profiles/signin_view_controller_delegate_views.h",
-      "webui/discards/discards_ui.cc",
-      "webui/discards/discards_ui.h",
-      "webui/discards/graph_dump_impl.cc",
-      "webui/discards/graph_dump_impl.h",
-      "webui/discards/site_data_provider_impl.cc",
-      "webui/discards/site_data_provider_impl.h",
+      #"webui/discards/discards_ui.cc",
+      #"webui/discards/discards_ui.h",
+      #"webui/discards/graph_dump_impl.cc",
+      #"webui/discards/graph_dump_impl.h",
+      #"webui/discards/site_data_provider_impl.cc",
+      #"webui/discards/site_data_provider_impl.h",
       "webui/signin/inline_login_handler.cc",
       "webui/signin/inline_login_handler.h",
       "webui/signin/signin_url_utils.cc",
@@ -3500,8 +3508,8 @@
       "webui/signin/signin_web_dialog_ui.h",
       "webui/signin/sync_confirmation_handler.cc",
       "webui/signin/sync_confirmation_handler.h",
-      "webui/signin/sync_confirmation_ui.cc",
-      "webui/signin/sync_confirmation_ui.h",
+      #"webui/signin/sync_confirmation_ui.cc",
+      #"webui/signin/sync_confirmation_ui.h",
     ]
     deps += [
       "//chrome/browser/ui/webui/discards:mojo_bindings",
@@ -4908,18 +4916,18 @@
       "views/relaunch_notification/relaunch_required_timer_internal.h",
       "views/sad_tab_view.cc",
       "views/sad_tab_view.h",
-      "views/safe_browsing/deep_scanning_failure_modal_dialog.cc",
-      "views/safe_browsing/deep_scanning_failure_modal_dialog.h",
-      "views/safe_browsing/deep_scanning_modal_dialog.cc",
-      "views/safe_browsing/deep_scanning_modal_dialog.h",
-      "views/safe_browsing/password_reuse_modal_warning_dialog.cc",
-      "views/safe_browsing/password_reuse_modal_warning_dialog.h",
-      "views/safe_browsing/prompt_for_scanning_modal_dialog.cc",
-      "views/safe_browsing/prompt_for_scanning_modal_dialog.h",
-      "views/safe_browsing/tailored_security_desktop_dialog_manager.cc",
-      "views/safe_browsing/tailored_security_desktop_dialog_manager.h",
-      "views/safe_browsing/tailored_security_unconsented_modal.cc",
-      "views/safe_browsing/tailored_security_unconsented_modal.h",
+      #"views/safe_browsing/deep_scanning_failure_modal_dialog.cc",
+      #"views/safe_browsing/deep_scanning_failure_modal_dialog.h",
+      #"views/safe_browsing/deep_scanning_modal_dialog.cc",
+      #"views/safe_browsing/deep_scanning_modal_dialog.h",
+      #"views/safe_browsing/password_reuse_modal_warning_dialog.cc",
+      #"views/safe_browsing/password_reuse_modal_warning_dialog.h",
+      #"views/safe_browsing/prompt_for_scanning_modal_dialog.cc",
+      #"views/safe_browsing/prompt_for_scanning_modal_dialog.h",
+      #"views/safe_browsing/tailored_security_desktop_dialog_manager.cc",
+      #"views/safe_browsing/tailored_security_desktop_dialog_manager.h",
+      #"views/safe_browsing/tailored_security_unconsented_modal.cc",
+      #"views/safe_browsing/tailored_security_unconsented_modal.h",
       "views/send_tab_to_self/manage_account_devices_link_view.cc",
       "views/send_tab_to_self/manage_account_devices_link_view.h",
       "views/send_tab_to_self/send_tab_to_self_bubble_device_button.cc",
@@ -5169,14 +5177,14 @@
       "views/toolbar/toolbar_view.h",
       "views/touch_uma/touch_uma.cc",
       "views/touch_uma/touch_uma.h",
-      "views/translate/partial_translate_bubble_view.cc",
-      "views/translate/partial_translate_bubble_view.h",
-      "views/translate/translate_bubble_controller.cc",
-      "views/translate/translate_bubble_controller.h",
-      "views/translate/translate_bubble_view.cc",
-      "views/translate/translate_bubble_view.h",
-      "views/translate/translate_icon_view.cc",
-      "views/translate/translate_icon_view.h",
+      #"views/translate/partial_translate_bubble_view.cc",
+      #"views/translate/partial_translate_bubble_view.h",
+      #"views/translate/translate_bubble_controller.cc",
+      #"views/translate/translate_bubble_controller.h",
+      #"views/translate/translate_bubble_view.cc",
+      #"views/translate/translate_bubble_view.h",
+      #"views/translate/translate_icon_view.cc",
+      #"views/translate/translate_icon_view.h",
       "views/update_recommended_message_box.cc",
       "views/update_recommended_message_box.h",
       "views/user_education/browser_feature_promo_controller.cc",
diff -r -u --color up/chromium/chrome/browser/ui/apps/chrome_app_delegate.cc nw/chromium/chrome/browser/ui/apps/chrome_app_delegate.cc
--- up/chromium/chrome/browser/ui/apps/chrome_app_delegate.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/apps/chrome_app_delegate.cc	2023-01-28 02:49:23.771570690 +0000
@@ -10,6 +10,15 @@
 
 #include "base/bind.h"
 #include "build/build_config.h"
+
+#include "components/sessions/content/session_tab_helper.h"
+#include "chrome/browser/extensions/tab_helper.h"
+#include "chrome/browser/password_manager/chrome_password_manager_client.h"
+#include "chrome/browser/ui/passwords/manage_passwords_ui_controller.h"
+#include "chrome/browser/external_protocol/external_protocol_observer.h"
+#include "components/content_settings/browser/page_specific_content_settings.h"
+#include "chrome/browser/content_settings/page_specific_content_settings_delegate.h"
+
 #include "build/chromeos_buildflags.h"
 #include "chrome/browser/app_mode/app_mode_utils.h"
 #include "chrome/browser/apps/platform_apps/audio_focus_web_contents_observer.h"
@@ -62,10 +71,16 @@
 #include "chrome/browser/printing/printing_init.h"
 #endif
 
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/ui/autofill/chrome_autofill_client.h"
+#include "components/autofill/content/browser/content_autofill_driver_factory.h"
+#include "components/autofill/core/browser/browser_autofill_manager.h"
+#include "chrome/browser/ui/prefs/prefs_tab_helper.h"
+
 namespace {
 
 // Time to wait for an app window to show before allowing Chrome to quit.
-int kAppWindowFirstShowTimeoutSeconds = 10;
+//int kAppWindowFirstShowTimeoutSeconds = 10;
 
 bool disable_external_open_for_testing_ = false;
 
@@ -82,7 +97,7 @@
   if (params.disposition == WindowOpenDisposition::NEW_BACKGROUND_TAB) {
     new_tab_params.disposition = WindowOpenDisposition::NEW_BACKGROUND_TAB;
   } else {
-    new_tab_params.disposition = WindowOpenDisposition::NEW_FOREGROUND_TAB;
+    new_tab_params.disposition = WindowOpenDisposition::NEW_POPUP;
     new_tab_params.window_action = NavigateParams::SHOW_WINDOW;
   }
 
@@ -201,7 +216,8 @@
       is_hidden_(true),
       for_lock_screen_app_(false),
       profile_(profile),
-      new_window_contents_delegate_(new NewWindowContentsDelegate()) {
+      new_window_contents_delegate_(new NewWindowContentsDelegate()),
+      web_contents_(nullptr) {
   if (keep_alive) {
     keep_alive_ = std::make_unique<ScopedKeepAlive>(
         KeepAliveOrigin::CHROME_APP_DELEGATE, KeepAliveRestartOption::DISABLED);
@@ -224,19 +240,44 @@
 }
 
 void ChromeAppDelegate::InitWebContents(content::WebContents* web_contents) {
+  web_contents_ = web_contents;
+
   favicon::CreateContentFaviconDriverForWebContents(web_contents);
 
 #if BUILDFLAG(ENABLE_PRINTING)
   printing::InitializePrintingForWebContents(web_contents);
 #endif
+  // ZoomController comes before common tab helpers since ChromeExtensionWebContentsObserver
+  // may want to register as a ZoomObserver with it.
+  zoom::ZoomController::CreateForWebContents(web_contents);
 
+#if 1
+  extensions::TabHelper::CreateForWebContents(web_contents);
+#else
+  SessionTabHelper::CreateForWebContents(web_contents);
+#endif
   apps::AudioFocusWebContentsObserver::CreateForWebContents(web_contents);
 
 #if BUILDFLAG(IS_CHROMEOS)
   policy::DlpContentTabHelper::MaybeCreateForWebContents(web_contents);
 #endif
 
-  zoom::ZoomController::CreateForWebContents(web_contents);
+  autofill::ChromeAutofillClient::CreateForWebContents(web_contents);
+  autofill::ContentAutofillDriverFactory::CreateForWebContentsAndDelegate(
+      web_contents,
+      autofill::ChromeAutofillClient::FromWebContents(web_contents),
+      base::BindRepeating(
+          &autofill::BrowserDriverInitHook,
+          autofill::ChromeAutofillClient::FromWebContents(web_contents),
+          g_browser_process->GetApplicationLocale()));
+  ChromePasswordManagerClient::CreateForWebContentsWithAutofillClient(
+      web_contents,
+      autofill::ChromeAutofillClient::FromWebContents(web_contents));
+  ManagePasswordsUIController::CreateForWebContents(web_contents);
+  PrefsTabHelper::CreateForWebContents(web_contents);
+  ExternalProtocolObserver::CreateForWebContents(web_contents);
+  content_settings::PageSpecificContentSettings::CreateForWebContents(web_contents,
+                                                                     std::make_unique<chrome::PageSpecificContentSettingsDelegate>(web_contents));
 }
 
 void ChromeAppDelegate::RenderFrameCreated(
@@ -279,12 +320,14 @@
     const blink::mojom::WindowFeatures& window_features,
     bool user_gesture) {
   if (!disable_external_open_for_testing_) {
+#if 0
     // We don't really want to open a window for |new_contents|, but we need to
     // capture its intended navigation. Here we give ownership to the
     // NewWindowContentsDelegate, which will dispose of the contents once
     // a navigation is captured.
     new_window_contents_delegate_->BecomeOwningDeletageOf(
         std::move(new_contents));
+#endif
     return;
   }
 
@@ -361,6 +404,7 @@
 
 void ChromeAppDelegate::OnHide() {
   is_hidden_ = true;
+#if 0
   if (has_been_shown_) {
     profile_keep_alive_.reset();
     keep_alive_.reset();
@@ -374,17 +418,20 @@
       base::BindOnce(&ChromeAppDelegate::RelinquishKeepAliveAfterTimeout,
                      weak_factory_.GetWeakPtr()),
       base::Seconds(kAppWindowFirstShowTimeoutSeconds));
+#endif
 }
 
 void ChromeAppDelegate::OnShow() {
   has_been_shown_ = true;
   is_hidden_ = false;
+#if 0
   keep_alive_ = std::make_unique<ScopedKeepAlive>(
       KeepAliveOrigin::CHROME_APP_DELEGATE, KeepAliveRestartOption::DISABLED);
   if (!profile_->IsOffTheRecord()) {
     profile_keep_alive_ = std::make_unique<ScopedProfileKeepAlive>(
         profile_, ProfileKeepAliveOrigin::kAppWindow);
   }
+#endif
 }
 
 bool ChromeAppDelegate::TakeFocus(content::WebContents* web_contents,
diff -r -u --color up/chromium/chrome/browser/ui/apps/chrome_app_delegate.h nw/chromium/chrome/browser/ui/apps/chrome_app_delegate.h
--- up/chromium/chrome/browser/ui/apps/chrome_app_delegate.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/apps/chrome_app_delegate.h	2023-01-28 02:49:23.771570690 +0000
@@ -93,6 +93,7 @@
   std::unique_ptr<NewWindowContentsDelegate> new_window_contents_delegate_;
   base::OnceClosure terminating_callback_;
   base::CallbackListSubscription subscription_;
+  content::WebContents* web_contents_;
   base::WeakPtrFactory<ChromeAppDelegate> weak_factory_{this};
 };
 
diff -r -u --color up/chromium/chrome/browser/ui/apps/chrome_app_window_client.cc nw/chromium/chrome/browser/ui/apps/chrome_app_window_client.cc
--- up/chromium/chrome/browser/ui/apps/chrome_app_window_client.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/apps/chrome_app_window_client.cc	2023-01-28 02:49:23.771570690 +0000
@@ -22,6 +22,7 @@
 #if BUILDFLAG(IS_CHROMEOS_ASH)
 #include "chrome/browser/ash/lock_screen_apps/state_controller.h"
 #endif
+#include "content/nw/src/nw_content.h"
 
 // TODO(jamescook): We probably shouldn't compile this class at all on Android.
 // See http://crbug.com/343612
@@ -47,8 +48,10 @@
   return NULL;
 #else
   Profile* profile = Profile::FromBrowserContext(context);
-  return new extensions::AppWindow(
+  extensions::AppWindow* ret = new extensions::AppWindow(
       context, std::make_unique<ChromeAppDelegate>(profile, true), extension);
+  nw::CreateAppWindowHook(ret);
+  return ret;
 #endif
 }
 
diff -r -u --color up/chromium/chrome/browser/ui/autofill/chrome_autofill_client.cc nw/chromium/chrome/browser/ui/autofill/chrome_autofill_client.cc
--- up/chromium/chrome/browser/ui/autofill/chrome_autofill_client.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/autofill/chrome_autofill_client.cc	2023-01-28 02:49:23.799570986 +0000
@@ -280,22 +280,26 @@
 }
 
 const translate::LanguageState* ChromeAutofillClient::GetLanguageState() {
+#if 0
   // TODO(crbug.com/912597): iOS vs other platforms extracts the language from
   // the top level frame vs whatever frame directly holds the form.
   auto* translate_manager =
       ChromeTranslateClient::GetManagerFromWebContents(web_contents());
   if (translate_manager)
     return translate_manager->GetLanguageState();
+#endif
   return nullptr;
 }
 
 translate::TranslateDriver* ChromeAutofillClient::GetTranslateDriver() {
+#if 0
   // TODO(crbug.com/912597): iOS vs other platforms extracts the language from
   // the top level frame vs whatever frame directly holds the form.
   auto* translate_client =
       ChromeTranslateClient::FromWebContents(web_contents());
   if (translate_client)
     return translate_client->translate_driver();
+#endif
   return nullptr;
 }
 
@@ -1143,6 +1147,13 @@
 }
 
 bool ChromeAutofillClient::IsContextSecure() const {
+
+  content::NavigationEntry* navigation_entry =
+      web_contents()->GetController().GetLastCommittedEntry();
+
+  if (navigation_entry && navigation_entry->GetURL().SchemeIs("chrome-extension"))
+    return true;
+
   SecurityStateTabHelper* helper =
       SecurityStateTabHelper::FromWebContents(web_contents());
   if (!helper)
diff -r -u --color up/chromium/chrome/browser/ui/browser.cc nw/chromium/chrome/browser/ui/browser.cc
--- up/chromium/chrome/browser/ui/browser.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/browser.cc	2023-01-28 02:49:23.811571112 +0000
@@ -4,6 +4,13 @@
 
 #include "chrome/browser/ui/browser.h"
 
+#include "extensions/browser/process_manager.h"
+#include "chrome/browser/web_applications/web_app_helpers.h"
+#include "extensions/common/mojom/event_dispatcher.mojom.h"
+#include "chrome/browser/extensions/api/tabs/tabs_windows_api.h"
+#include "chrome/browser/extensions/api/tabs/tabs_event_router.h"
+#include "components/javascript_dialogs/app_modal_dialog_manager.h"
+
 #include <stddef.h>
 
 #include <algorithm>
@@ -11,6 +18,14 @@
 #include <string>
 #include <utility>
 
+#include "extensions/common/extension_messages.h"
+#include "extensions/browser/app_window/app_window.h"
+#include "content/nw/src/nw_content.h"
+#include "content/nw/src/nw_base.h"
+#include "content/public/common/content_switches.h"
+#include "ui/display/display.h"
+#include "chrome/browser/extensions/extension_tab_util.h"
+
 #include "base/base_paths.h"
 #include "base/bind.h"
 #include "base/callback_helpers.h"
@@ -358,12 +373,19 @@
 // Browser, CreateParams:
 
 Browser::CreateParams::CreateParams(Profile* profile, bool user_gesture)
-    : CreateParams(TYPE_NORMAL, profile, user_gesture) {}
+    : CreateParams(TYPE_POPUP, profile, user_gesture) {}
+
+Browser::CreateParams::CreateParams(Profile* profile, bool user_gesture, const gfx::Rect& bounds)
+  : CreateParams(TYPE_POPUP, profile, user_gesture) {
+  initial_bounds = bounds;
+}
 
 Browser::CreateParams::CreateParams(Type type,
                                     Profile* profile,
                                     bool user_gesture)
-    : type(type), profile(profile), user_gesture(user_gesture) {}
+    : type(type == TYPE_DEVTOOLS ? TYPE_DEVTOOLS : TYPE_POPUP),
+      profile(profile),
+      user_gesture(user_gesture) {}
 
 Browser::CreateParams::CreateParams(const CreateParams& other) = default;
 
@@ -422,6 +444,21 @@
   return params;
 }
 
+void Browser::AddOnDidFinishFirstNavigationCallback(
+    DidFinishFirstNavigationCallback callback) {
+  on_did_finish_first_navigation_callbacks_.push_back(std::move(callback));
+}
+
+void Browser::OnDidFinishFirstNavigation() {
+  if (did_finish_first_navigation_)
+    return;
+  did_finish_first_navigation_ = true;
+  std::vector<DidFinishFirstNavigationCallback> callbacks;
+  std::swap(callbacks, on_did_finish_first_navigation_callbacks_);
+  for (auto&& callback : callbacks)
+    std::move(callback).Run(true /* did_finish */);
+}
+
 ///////////////////////////////////////////////////////////////////////////////
 // Browser, Constructors, Creation, Showing:
 
@@ -449,11 +486,17 @@
   // not possible, e.g. using the wrong profile or during shutdown. The caller
   // should handle this; see e.g. crbug.com/1141608 and crbug.com/1261628.
   CHECK_EQ(CreationStatus::kOk, GetCreationStatusForProfile(params.profile));
-  return new Browser(params);
+  Browser* ret = new Browser(params);
+  nw::CreateAppWindowHook(nullptr);
+  return ret;
 }
 
 Browser::Browser(const CreateParams& params)
-    : create_params_(params),
+   :  nw_menu_(nullptr),
+      extension_id_(params.extension_id),
+      create_params_(params),
+      frameless_(params.frameless),
+      alpha_enabled_(params.alpha_enabled),
       type_(params.type),
       profile_(params.profile),
       window_(nullptr),
@@ -467,6 +510,7 @@
       tab_menu_model_delegate_(
           std::make_unique<chrome::BrowserTabMenuModelDelegate>(this)),
       app_name_(params.app_name),
+      windows_key_(params.windows_key),
       is_trusted_source_(params.trusted_source),
       session_id_(SessionID::NewUnique()),
       omit_from_session_restore_(params.omit_from_session_restore),
@@ -478,6 +522,13 @@
       initial_visible_on_all_workspaces_state_(
           params.initial_visible_on_all_workspaces_state),
       creation_source_(params.creation_source),
+      initial_ontop_(params.always_on_top),
+      initial_allvisible_(params.all_visible),
+      initial_resizable_(params.resizable),
+      initial_showintaskbar_(params.show_in_taskbar),
+      initial_position_(params.position),
+      title_override_(params.title),
+      icon_override_(params.icon),
       unload_controller_(this),
       content_setting_bubble_model_delegate_(
           new BrowserContentSettingBubbleModelDelegate(this)),
@@ -500,12 +551,15 @@
           std::make_unique<extensions::ExtensionBrowserWindowHelper>(this))
 #endif
 {
+  content::g_support_transparency = !base::CommandLine::ForCurrentProcess()->HasSwitch(::switches::kDisableTransparency);
+  if (content::g_support_transparency) {
+    content::g_force_cpu_draw = base::CommandLine::ForCurrentProcess()->HasSwitch(::switches::kForceCpuDraw);
+  }
   if (!profile_->IsOffTheRecord()) {
     profile_keep_alive_ = std::make_unique<ScopedProfileKeepAlive>(
         params.profile->GetOriginalProfile(),
         ProfileKeepAliveOrigin::kBrowserWindow);
   }
-
   tab_strip_model_->AddObserver(this);
 
   location_bar_model_ = std::make_unique<LocationBarModelImpl>(
@@ -539,6 +593,9 @@
                                                 params.user_gesture,
                                                 params.in_tab_dragging);
 
+  if (!initial_showintaskbar_)
+    window_->SetShowInTaskbar(false);
+
   if (app_controller_)
     app_controller_->UpdateCustomTabBarVisibility(false);
 
@@ -647,6 +704,42 @@
     select_file_dialog_->ListenerDestroyed();
 }
 
+bool Browser::NWCanClose(bool user_force) {
+  const extensions::Extension* extension = GetExtension();
+  if (!extension)
+    return true;
+  //content::RenderFrameHost* rfh = web_contents->GetMainFrame();
+  extensions::EventRouter* event_router = extensions::EventRouter::Get(profile_);
+  std::string listener_extension_id;
+  int instance_id = extensions::ExtensionTabUtil::GetWindowId(this);
+  bool listening_to_close = event_router->
+    ExtensionHasEventListener(extension->id(), extensions::api::windows::OnRemoving::kEventName,
+                              extensions::ExtensionTabUtil::GetWindowId(this),
+                              &listener_extension_id);
+  if (listening_to_close) {
+    std::unique_ptr<base::Value::List> args(new base::Value::List());
+    args->Append(session_id().id());
+    if (user_force)
+      args->Append("quit");
+    auto event =
+      std::make_unique<extensions::Event>(extensions::events::UNKNOWN,
+                                          extensions::api::windows::OnRemoving::kEventName,
+                                          std::move(*args), profile());
+    event->filter_info = extensions::mojom::EventFilteringInfo::New();
+    event->filter_info->window_exposed_by_default = true;
+    event->filter_info->instance_id = instance_id;
+    event_router->BroadcastEvent(std::move(event));
+    return false;
+  }
+  return true;
+}
+
+const extensions::Extension* Browser::GetExtension() const {
+  return extensions::ExtensionRegistry::Get(profile_)
+      ->enabled_extensions()
+      .GetByID(extension_id_);
+}
+
 ///////////////////////////////////////////////////////////////////////////////
 // Getters & Setters
 
@@ -681,6 +774,8 @@
 }
 
 gfx::Image Browser::GetCurrentPageIcon() const {
+  if (!icon_override_.IsEmpty())
+    return icon_override_;
   WebContents* web_contents = tab_strip_model_->GetActiveWebContents();
   // |web_contents| can be NULL since GetCurrentPageIcon() is called by the
   // window during the window's creation (before tabs have been added).
@@ -763,7 +858,25 @@
 
   // |contents| can be NULL because GetWindowTitleForCurrentTab is called by the
   // window during the window's creation (before tabs have been added).
-  if (title.empty() && contents) {
+  std::u16string override = base::UTF8ToUTF16(title_override_);
+
+  // |contents| can be NULL because GetWindowTitleForCurrentTab is called by the
+  // window during the window's creation (before tabs have been added).
+  content::NavigationEntry* entry = contents ?
+      contents->GetController().GetLastCommittedEntry() : nullptr;
+  if (!entry || entry->GetTitle().empty()) {
+    if (override.empty()) {
+      const std::string extension_id =
+        web_app::GetAppIdFromApplicationName(app_name());
+      const Extension* extension =
+        extensions::ExtensionRegistry::Get(profile())
+          ->GetExtensionById(extension_id,
+                             extensions::ExtensionRegistry::EVERYTHING);
+      if (extension)
+        title = base::UTF8ToUTF16(extension->name());
+    } else
+      title = override;
+  } else if (title.empty() && contents) {
     title = FormatTitleForDisplay(app_controller_ ? app_controller_->GetTitle()
                                                   : contents->GetTitle());
 #if BUILDFLAG(ENABLE_CAPTIVE_PORTAL_DETECTION)
@@ -787,10 +900,13 @@
   if (title.empty() && (is_type_normal() || is_type_popup()))
     title = CoreTabHelper::GetDefaultTitle();
 
+  if (title.empty() && is_type_app())
+    return override;
 #if BUILDFLAG(IS_MAC)
   // On Mac, we don't want to suffix the page title with the application name.
   return title;
 #else
+
   // If there is no title and this is an app, fall back on the app name. This
   // ensures that the native window gets a title which is important for a11y,
   // for example the window selector uses the Aura window title.
@@ -1006,6 +1122,7 @@
 // Browser, Tab adding/showing functions:
 
 void Browser::WindowFullscreenStateChanged() {
+  if (exclusive_access_manager_)
   exclusive_access_manager_->fullscreen_controller()
       ->WindowFullscreenStateChanged();
   command_controller_->FullscreenStateChanged();
@@ -1678,12 +1795,12 @@
     // cannot switch their independent spaces simultaneously (crbug.com/1315749)
     fullscreen_controller->RunOrDeferUntilTransitionIsComplete(base::BindOnce(
         &chrome::AddWebContents, this, source, std::move(new_contents),
-        target_url, disposition, window_features, window_action));
+        target_url, disposition, window_features, window_action, tmp_manifest()));
     return;
   }
 
   chrome::AddWebContents(this, source, std::move(new_contents), target_url,
-                         disposition, window_features, window_action);
+                         disposition, window_features, window_action, tmp_manifest());
 }
 
 void Browser::ActivateContents(WebContents* contents) {
@@ -1700,6 +1817,24 @@
                                   bool should_show_loading_ui) {
   ScheduleUIUpdate(source, content::INVALIDATE_TYPE_LOAD);
   UpdateWindowForLoadingStateChanged(source, should_show_loading_ui);
+  std::string nwstatus;
+  if (source->IsLoading()) {
+    nwstatus = "loading";
+    last_to_different_document_ = should_show_loading_ui ? 1 : 0;
+    if (!should_show_loading_ui) //NWJS#5001
+      return;
+  } else {
+    if (last_to_different_document_ == 0)
+      return;
+    nwstatus = "loaded";
+  }
+  extensions::TabsWindowsAPI* tabs_window_api = extensions::TabsWindowsAPI::Get(profile_);
+  if (!tabs_window_api)
+    return;
+  extensions::TabsEventRouter* tabs_event_router = tabs_window_api->tabs_event_router();
+  if (!tabs_event_router)
+    return;
+  tabs_event_router->NWStatusUpdated(source, nwstatus);
 }
 
 void Browser::CloseContents(WebContents* source) {
@@ -1751,7 +1886,7 @@
 }
 
 void Browser::ContentsZoomChange(bool zoom_in) {
-  chrome::ExecuteCommand(this, zoom_in ? IDC_ZOOM_PLUS : IDC_ZOOM_MINUS);
+  //chrome::ExecuteCommand(this, zoom_in ? IDC_ZOOM_PLUS : IDC_ZOOM_MINUS);
 }
 
 bool Browser::TakeFocus(content::WebContents* source, bool reverse) {
@@ -1841,13 +1976,21 @@
                                  int opener_render_frame_id,
                                  const std::string& frame_name,
                                  const GURL& target_url,
-                                 WebContents* new_contents) {
+                                 WebContents* new_contents, const std::u16string& nw_window_manifest) {
   // Adopt the WebContents now, so all observers are in place, as the network
   // requests for its initial navigation will start immediately. The WebContents
   // will later be inserted into this browser using Browser::Navigate via
   // AddNewContents.
   TabHelpers::AttachTabHelpers(new_contents);
-
+  extensions::AppWindow::CreateParams params;
+  std::string js_doc_start, js_doc_end;
+  nw::CalcNewWinParams(new_contents, &params, &js_doc_start, &js_doc_end, std::string());
+  nw::SetCurrentNewWinManifest(std::u16string());
+  new_contents->GetMutableRendererPrefs()->
+    nw_inject_js_doc_start = js_doc_start;
+  new_contents->GetMutableRendererPrefs()->
+    nw_inject_js_doc_end = js_doc_end;
+  new_contents->SyncRendererPrefs();
   // Make the tab show up in the task manager.
   task_manager::WebContentsTags::CreateForTabContents(new_contents);
 }
@@ -1872,6 +2015,7 @@
     WebContents* source,
     content::RenderWidgetHost* render_widget_host,
     base::RepeatingClosure hang_monitor_restarter) {
+#if 0
   // Don't show the page hung dialog when a HTML popup hangs because
   // the dialog will take the focus and immediately close the popup.
   RenderWidgetHostView* view = render_widget_host->GetView();
@@ -1879,6 +2023,7 @@
     TabDialogs::FromWebContents(source)->ShowHungRendererDialog(
         render_widget_host, std::move(hang_monitor_restarter));
   }
+#endif
 }
 
 void Browser::RendererResponsive(
@@ -1894,11 +2039,13 @@
 void Browser::DidNavigatePrimaryMainFramePostCommit(WebContents* web_contents) {
   if (web_contents == tab_strip_model_->GetActiveWebContents())
     UpdateBookmarkBarState(BOOKMARK_BAR_STATE_CHANGE_TAB_STATE);
+  OnDidFinishFirstNavigation();
 }
 
 content::JavaScriptDialogManager* Browser::GetJavaScriptDialogManager(
     WebContents* source) {
-  return javascript_dialogs::TabModalDialogManager::FromWebContents(source);
+  //return javascript_dialogs::TabModalDialogManager::FromWebContents(source);
+  return javascript_dialogs::AppModalDialogManager::GetInstance();
 }
 
 bool Browser::GuestSaveFrame(content::WebContents* guest_web_contents) {
@@ -2323,12 +2470,14 @@
 
 void Browser::OnIsPageTranslatedChanged(content::WebContents* source) {
   DCHECK(source);
+#if 0
   if (tab_strip_model_->GetActiveWebContents() == source) {
     window_->SetTranslateIconToggled(
         ChromeTranslateClient::FromWebContents(source)
             ->GetLanguageState()
             .IsPageTranslated());
   }
+#endif
 }
 
 void Browser::OnTranslateEnabledChanged(content::WebContents* source) {
@@ -2407,6 +2556,7 @@
 
 void Browser::OnTabDeactivated(WebContents* contents) {
   exclusive_access_manager_->OnTabDeactivated(contents);
+  if (SearchTabHelper::FromWebContents(contents))
   SearchTabHelper::FromWebContents(contents)->OnTabDeactivated();
 
   // Save what the user's currently typing, so it can be restored when we
@@ -2499,7 +2649,7 @@
                                base::TimeTicks::Now());
   }
 
-  SearchTabHelper::FromWebContents(new_contents)->OnTabActivated();
+  //SearchTabHelper::FromWebContents(new_contents)->OnTabActivated();
 }
 
 void Browser::OnTabMoved(int from_index, int to_index) {
@@ -2816,15 +2966,15 @@
   // ...and all the helpers.
   WebContentsModalDialogManager::FromWebContents(web_contents)
       ->SetDelegate(delegate);
-  translate::ContentTranslateDriver* content_translate_driver =
-      ChromeTranslateClient::FromWebContents(web_contents)->translate_driver();
+  //translate::ContentTranslateDriver* content_translate_driver =
+  //    ChromeTranslateClient::FromWebContents(web_contents)->translate_driver();
   if (delegate) {
     zoom::ZoomController::FromWebContents(web_contents)->AddObserver(this);
-    content_translate_driver->AddTranslationObserver(this);
+    //content_translate_driver->AddTranslationObserver(this);
     BookmarkTabHelper::FromWebContents(web_contents)->AddObserver(this);
   } else {
     zoom::ZoomController::FromWebContents(web_contents)->RemoveObserver(this);
-    content_translate_driver->RemoveTranslationObserver(this);
+    //content_translate_driver->RemoveTranslationObserver(this);
     BookmarkTabHelper::FromWebContents(web_contents)->RemoveObserver(this);
   }
 }
@@ -2873,33 +3023,38 @@
 
 bool Browser::NormalBrowserSupportsWindowFeature(WindowFeature feature,
                                                  bool check_can_support) const {
-  bool fullscreen = ShouldHideUIForFullscreen();
+  //bool fullscreen = ShouldHideUIForFullscreen();
   switch (feature) {
     case FEATURE_BOOKMARKBAR:
-      return true;
+      return false;
     case FEATURE_TABSTRIP:
     case FEATURE_TOOLBAR:
     case FEATURE_LOCATIONBAR:
-      return check_can_support || !fullscreen;
+      return false;
     case FEATURE_TITLEBAR:
     case FEATURE_NONE:
       return false;
+    case FEATURE_NW_FRAMELESS:
+      return true;
   }
 }
 
 bool Browser::PopupBrowserSupportsWindowFeature(WindowFeature feature,
                                                 bool check_can_support) const {
-  bool fullscreen = ShouldHideUIForFullscreen();
+  //bool fullscreen = ShouldHideUIForFullscreen();
 
   switch (feature) {
     case FEATURE_TITLEBAR:
+      return true;
     case FEATURE_LOCATIONBAR:
-      return check_can_support || (!fullscreen && !is_trusted_source());
+      return false; //check_can_support || (!fullscreen && !is_trusted_source());
     case FEATURE_TABSTRIP:
     case FEATURE_TOOLBAR:
     case FEATURE_BOOKMARKBAR:
     case FEATURE_NONE:
       return false;
+    case FEATURE_NW_FRAMELESS:
+      return true;
   }
 }
 
@@ -2944,6 +3099,8 @@
     case FEATURE_BOOKMARKBAR:
     case FEATURE_NONE:
       return false;
+    case FEATURE_NW_FRAMELESS:
+      return true;
   }
 }
 
@@ -2969,6 +3126,7 @@
     bool check_can_support) const {
   switch (feature) {
     case FEATURE_TITLEBAR:
+    case FEATURE_NW_FRAMELESS:
       return true;
     case FEATURE_LOCATIONBAR:
     case FEATURE_TABSTRIP:
diff -r -u --color up/chromium/chrome/browser/ui/browser.h nw/chromium/chrome/browser/ui/browser.h
--- up/chromium/chrome/browser/ui/browser.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/browser.h	2023-01-28 02:49:23.811571112 +0000
@@ -13,6 +13,8 @@
 #include <vector>
 
 #include "base/callback.h"
+#include "ui/gfx/image/image.h"
+
 #include "base/gtest_prod_util.h"
 #include "base/memory/raw_ptr.h"
 #include "base/memory/scoped_refptr.h"
@@ -70,6 +72,10 @@
 class TabStripModelDelegate;
 class TabMenuModelDelegate;
 
+namespace extensions {
+class Extension;
+}
+
 namespace blink {
 enum class ProtocolHandlerSecurityLevel;
 }
@@ -95,6 +101,10 @@
 struct SelectedFileInfo;
 }
 
+namespace nw {
+  class Menu;
+}
+
 namespace web_app {
 class AppBrowserController;
 }
@@ -114,6 +124,13 @@
                 public translate::ContentTranslateDriver::TranslationObserver,
                 public ui::SelectFileDialog::Listener {
  public:
+  using DidFinishFirstNavigationCallback =
+                      base::OnceCallback<void(bool did_finish)>;
+  void AddOnDidFinishFirstNavigationCallback(
+                      DidFinishFirstNavigationCallback callback);
+  bool DidFinishFirstNavigation() { return did_finish_first_navigation_; }
+  // Called when first navigation was completed.
+  void OnDidFinishFirstNavigation();
   // SessionService::WindowType mirrors these values.  If you add to this
   // enum, look at SessionService::WindowType to see if it needs to be
   // updated.
@@ -160,6 +177,7 @@
     FEATURE_TOOLBAR = 1 << 2,
     FEATURE_LOCATIONBAR = 1 << 3,
     FEATURE_BOOKMARKBAR = 1 << 4,
+    FEATURE_NW_FRAMELESS = 1 << 5
     // TODO(crbug.com/992834): Add FEATURE_PAGECONTROLS to describe the presence
     // of per-page controls such as Content Settings Icons, which should be
     // decoupled from FEATURE_LOCATIONBAR as they have independent presence in
@@ -216,6 +234,7 @@
 
   struct CreateParams {
     explicit CreateParams(Profile* profile, bool user_gesture);
+    explicit CreateParams(Profile* profile, bool user_gesture, const gfx::Rect& bounds);
     CreateParams(Type type, Profile* profile, bool user_gesture);
     CreateParams(const CreateParams& other);
     CreateParams& operator=(const CreateParams& other);
@@ -235,6 +254,16 @@
 
     static CreateParams CreateForDevTools(Profile* profile);
 
+    std::string extension_id;
+    bool frameless = false;
+    bool alpha_enabled = false;
+    bool always_on_top = false;
+    bool all_visible = false;
+    bool resizable = true;
+    bool show_in_taskbar = true;
+    std::string title;
+    std::string position;
+    gfx::Image icon;
     // The browser type.
     Type type;
 
@@ -243,6 +272,7 @@
 
     // Specifies the browser `is_trusted_source_` value.
     bool trusted_source = false;
+    std::string windows_key;
 
     // Specifies the browser `omit_from_session_restore_` value, whether the new
     // Browser should be omitted from being saved/restored by session restore.
@@ -356,8 +386,15 @@
   Browser(const Browser&) = delete;
   Browser& operator=(const Browser&) = delete;
 
+  nw::Menu* nw_menu_;
+
+  std::string extension_id_;
+
   ~Browser() override;
 
+  const extensions::Extension* GetExtension() const;
+  bool NWCanClose(bool user_force = false);
+
   // Set overrides for the initial window bounds and maximized state.
   void set_override_bounds(const gfx::Rect& bounds) {
     override_bounds_ = bounds;
@@ -366,6 +403,16 @@
   void set_initial_show_state(ui::WindowShowState initial_show_state) {
     initial_show_state_ = initial_show_state;
   }
+
+  void set_title_override(const std::string& title) { title_override_ = title; }
+
+  bool initial_ontop() const { return initial_ontop_; }
+  bool initial_allvisible() const { return initial_allvisible_; }
+  bool initial_resizable() const { return initial_resizable_; }
+  bool initial_showintaskbar() const { return initial_showintaskbar_; }
+  const std::string& initial_position() const { return initial_position_; }
+  gfx::Image icon_override() const { return icon_override_; }
+
   // Return true if the initial window bounds have been overridden.
   bool bounds_overridden() const { return !override_bounds_.IsEmpty(); }
   // Set indicator that this browser is being created via session restore.
@@ -392,7 +439,12 @@
   Type type() const { return type_; }
   const std::string& app_name() const { return app_name_; }
   const std::string& user_title() const { return user_title_; }
+  const std::string& windows_key() const { return windows_key_; }
   bool is_trusted_source() const { return is_trusted_source_; }
+  bool is_frameless() const { return frameless_; }
+  bool is_transparent() const {
+    return alpha_enabled_;
+  }
   Profile* profile() const { return profile_; }
   gfx::Rect override_bounds() const { return override_bounds_; }
   const std::string& initial_workspace() const { return initial_workspace_; }
@@ -755,6 +807,11 @@
 #endif
 
  private:
+  int last_to_different_document_ = -1;
+  std::vector<DidFinishFirstNavigationCallback> on_did_finish_first_navigation_callbacks_;
+  // Whether the first navigation was completed in both browser and renderer
+  // processes.
+  bool did_finish_first_navigation_ = false;
   friend class BrowserTest;
   friend class ExclusiveAccessTest;
   friend class FullscreenControllerInteractiveTest;
@@ -859,7 +916,7 @@
                           int opener_render_frame_id,
                           const std::string& frame_name,
                           const GURL& target_url,
-                          content::WebContents* new_contents) override;
+                          content::WebContents* new_contents, const std::u16string& nw_window_manifest) override;
   void PortalWebContentsCreated(
       content::WebContents* portal_web_contents) override;
   void WebContentsBecamePortal(
@@ -1151,6 +1208,10 @@
   // This Browser's create params.
   const CreateParams create_params_;
 
+  bool frameless_;
+
+  bool alpha_enabled_;
+
   // This Browser's type.
   const Type type_;
 
@@ -1176,6 +1237,7 @@
   // 1) we launch an application via an application shortcut or extension API.
   // 2) we launch an undocked devtool window.
   const std::string app_name_;
+  const std::string windows_key_;
 
   // True if the source is trusted (i.e. we do not need to show the URL in a
   // a popup window). Also used to determine which app windows to save and
@@ -1236,6 +1298,13 @@
   bool initial_visible_on_all_workspaces_state_;
 
   CreationSource creation_source_ = CreationSource::kUnknown;
+  bool initial_ontop_;
+  bool initial_allvisible_;
+  bool initial_resizable_;
+  bool initial_showintaskbar_;
+  std::string initial_position_;
+  std::string title_override_;
+  gfx::Image icon_override_;
 
   UnloadController unload_controller_;
 
diff -r -u --color up/chromium/chrome/browser/ui/browser_command_controller.cc nw/chromium/chrome/browser/ui/browser_command_controller.cc
--- up/chromium/chrome/browser/ui/browser_command_controller.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/browser_command_controller.cc	2023-01-28 02:49:23.811571112 +0000
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 #include "chrome/browser/ui/browser_command_controller.h"
+#include "content/nw/src/common/shell_switches.h"
 
 #include <stddef.h>
 
@@ -1406,6 +1407,10 @@
 
   bool dev_tools_enabled = DevToolsWindow::AllowDevToolsFor(
       profile(), browser_->tab_strip_model()->GetActiveWebContents());
+  const base::CommandLine* command_line =
+      base::CommandLine::ForCurrentProcess();
+  if (command_line->HasSwitch(switches::kDisableDevTools))
+    dev_tools_enabled = false;
   command_updater_.UpdateCommandEnabled(IDC_DEV_TOOLS, dev_tools_enabled);
   command_updater_.UpdateCommandEnabled(IDC_DEV_TOOLS_CONSOLE,
                                         dev_tools_enabled);
diff -r -u --color up/chromium/chrome/browser/ui/browser_commands.cc nw/chromium/chrome/browser/ui/browser_commands.cc
--- up/chromium/chrome/browser/ui/browser_commands.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/browser_commands.cc	2023-01-28 02:49:23.811571112 +0000
@@ -187,6 +187,7 @@
 const char kOsOverrideForTabletSite[] = "Linux; Android 9; Chrome tablet";
 const char kChPlatformOverrideForTabletSite[] = "Android";
 
+#if 0
 translate::TranslateBubbleUiEvent TranslateBubbleResultToUiEvent(
     ShowTranslateBubbleResult result) {
   switch (result) {
@@ -203,6 +204,7 @@
           BUBBLE_NOT_SHOWN_EDITABLE_FIELD_IS_ACTIVE;
   }
 }
+#endif
 
 // Creates a new tabbed browser window, with the same size, type and profile as
 // |original_browser|'s window, inserts |contents| into it, and shows it.
@@ -450,6 +452,7 @@
 }
 
 void NewEmptyWindow(Profile* profile, bool should_trigger_session_restore) {
+#if 0
   bool off_the_record = profile->IsOffTheRecord();
   PrefService* prefs = profile->GetPrefs();
   if (off_the_record) {
@@ -489,6 +492,7 @@
       OpenEmptyWindow(profile->GetOriginalProfile());
     }
   }
+#endif
 }
 
 Browser* OpenEmptyWindow(Profile* profile,
@@ -1248,6 +1252,7 @@
 }
 
 void Translate(Browser* browser) {
+#if 0
   if (!browser->window()->IsActive())
     return;
 
@@ -1276,6 +1281,7 @@
   if (result != ShowTranslateBubbleResult::SUCCESS)
     translate::ReportTranslateBubbleUiAction(
         TranslateBubbleResultToUiEvent(result));
+#endif
 }
 
 void ManagePasswordsForPage(Browser* browser) {
diff -r -u --color up/chromium/chrome/browser/ui/browser_list.cc nw/chromium/chrome/browser/ui/browser_list.cc
--- up/chromium/chrome/browser/ui/browser_list.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/browser_list.cc	2023-01-28 02:49:23.815571155 +0000
@@ -262,7 +262,8 @@
 // static
 void BrowserList::MoveBrowsersInWorkspaceToFront(
     const std::string& new_workspace) {
-  DCHECK(!new_workspace.empty());
+  if(new_workspace.empty())
+    return;
 
   BrowserList* instance = GetInstance();
 
diff -r -u --color up/chromium/chrome/browser/ui/browser_navigator.cc nw/chromium/chrome/browser/ui/browser_navigator.cc
--- up/chromium/chrome/browser/ui/browser_navigator.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/browser_navigator.cc	2023-01-28 02:49:23.815571155 +0000
@@ -9,6 +9,10 @@
 #include <string>
 #include <utility>
 
+#include "chrome/browser/ui/views/frame/browser_frame.h"
+#include "chrome/browser/ui/views/frame/browser_view.h"
+#include "content/browser/web_contents/web_contents_impl.h"
+
 #include "base/command_line.h"
 #include "base/memory/raw_ptr.h"
 #include "base/notreached.h"
@@ -81,6 +85,12 @@
 #include "components/captive_portal/content/captive_portal_tab_helper.h"
 #endif
 
+#include "third_party/blink/public/mojom/renderer_preferences.mojom.h"
+
+#include "content/nw/src/nw_base.h"
+#include "content/nw/src/nw_content.h"
+#include "content/nw/src/common/shell_switches.h"
+
 using content::GlobalRequestID;
 using content::NavigationController;
 using content::WebContents;
@@ -117,6 +127,14 @@
 
 // Finds an existing Browser compatible with |profile|, making a new one if no
 // such Browser is located.
+Browser* GetOrCreateBrowser(Profile* profile, const NavigateParams& params) {
+  Browser* browser = chrome::FindTabbedBrowser(profile, false);
+  Browser::CreateParams browser_params(profile, params.user_gesture, params.window_bounds);
+  browser_params.frameless = params.frameless;
+  return browser ? browser
+    : Browser::Create(browser_params);
+}
+
 Browser* GetOrCreateBrowser(Profile* profile, bool user_gesture) {
   Browser* browser = chrome::FindTabbedBrowser(profile, false);
 
@@ -285,7 +303,7 @@
 
       // Find a compatible window and re-execute this command in it. Otherwise
       // re-run with NEW_WINDOW.
-      return {GetOrCreateBrowser(profile, params.user_gesture), -1};
+      return {GetOrCreateBrowser(profile, params), -1};
     case WindowOpenDisposition::NEW_PICTURE_IN_PICTURE:
 #if !BUILDFLAG(IS_CHROMEOS_LACROS)
       // We may receive a PiP request with the feature disabled if the user has
@@ -353,9 +371,11 @@
       Browser* browser = nullptr;
       if (Browser::GetCreationStatusForProfile(profile) ==
           Browser::CreationStatus::kOk) {
-        browser = Browser::Create(
-            Browser::CreateParams(profile, params.user_gesture));
+      Browser::CreateParams browser_params(profile, params.user_gesture, params.window_bounds);
+      browser_params.frameless = params.frameless;
+      browser = Browser::Create(browser_params);
       }
+
       return {browser, -1};
     }
     case WindowOpenDisposition::OFF_THE_RECORD:
@@ -510,6 +530,11 @@
         (*contents_)->Focus();
         window->Activate();
       }
+    } else if (params_->window_action == NavigateParams::SHOW_WINDOW_FULLSCREEN) {
+      BrowserWindow* window2 = params_->browser->window();
+      BrowserFrame* frame = BrowserView::GetBrowserViewForBrowser(params_->browser)->frame();
+      frame->SetFullscreen(true);
+      window2->Show();
     }
   }
 
@@ -565,6 +590,26 @@
   apps::SetAppIdForWebContents(params.browser->profile(), target_contents.get(),
                                params.app_id);
 
+  nw::Package* package = nw::package();
+  std::string js_doc_start(params.inject_js_start), js_doc_end(params.inject_js_end);
+  if (js_doc_start.empty()) {
+    std::string* str = package->root()->FindString(::switches::kmInjectJSDocStart);
+    if (str)
+      js_doc_start = *str;
+  }
+  target_contents->GetMutableRendererPrefs()->nw_inject_js_doc_start = js_doc_start;
+  if (js_doc_end.empty()) {
+    std::string* str = package->root()->FindString(::switches::kmInjectJSDocEnd);
+    if (str)
+      js_doc_end = *str;
+  }
+  target_contents->GetMutableRendererPrefs()->nw_inject_js_doc_end = js_doc_end;
+  bool new_site = params.url.SchemeIs("chrome") || !nw::PinningRenderer();
+  if (params.block_parser && !new_site)
+    static_cast<content::WebContentsImpl*>(target_contents.get())->SetSkipBlockingParser(false);
+  if (!js_doc_start.empty() || !js_doc_end.empty())
+    target_contents->SyncRendererPrefs();
+
 #if BUILDFLAG(ENABLE_CAPTIVE_PORTAL_DETECTION)
   if (params.is_captive_portal_popup) {
     DCHECK_EQ(WindowOpenDisposition::NEW_POPUP, params.disposition);
diff -r -u --color up/chromium/chrome/browser/ui/browser_navigator_params.h nw/chromium/chrome/browser/ui/browser_navigator_params.h
--- up/chromium/chrome/browser/ui/browser_navigator_params.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/browser_navigator_params.h	2023-01-28 02:49:23.815571155 +0000
@@ -113,6 +113,8 @@
   // The origin of the initiator of the navigation.
   absl::optional<url::Origin> initiator_origin;
 
+  bool block_parser = false;
+  std::string inject_js_start, inject_js_end;
   // The frame name to be used for the main frame.
   std::string frame_name;
 
@@ -219,7 +221,8 @@
     // Note: This may cause a space / virtual desktop switch if the window is
     // being shown on a display which is currently showing a fullscreen app.
     // (crbug.com/1315749).
-    SHOW_WINDOW_INACTIVE
+    SHOW_WINDOW_INACTIVE,
+    SHOW_WINDOW_FULLSCREEN
   };
   // Default is NO_ACTION (don't show or activate the window).
   // If disposition is NEW_WINDOW or NEW_POPUP, and |window_action| is set to
@@ -232,7 +235,7 @@
 
   // If false then the navigation was not initiated by a user gesture.
   bool user_gesture = true;
-
+  bool frameless = false;
   // What to do with the path component of the URL for singleton navigations.
   enum PathBehavior {
     // Two URLs with differing paths are different.
diff -r -u --color up/chromium/chrome/browser/ui/browser_tab_strip_tracker.cc nw/chromium/chrome/browser/ui/browser_tab_strip_tracker.cc
--- up/chromium/chrome/browser/ui/browser_tab_strip_tracker.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/browser_tab_strip_tracker.cc	2023-01-28 02:49:23.815571155 +0000
@@ -76,3 +76,4 @@
   // observer is not in the ObserverList (i.e. if |browser| is not tracked).
   browser->tab_strip_model()->RemoveObserver(tab_strip_model_observer_);
 }
+
diff -r -u --color up/chromium/chrome/browser/ui/browser_tabstrip.cc nw/chromium/chrome/browser/ui/browser_tabstrip.cc
--- up/chromium/chrome/browser/ui/browser_tabstrip.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/browser_tabstrip.cc	2023-01-28 02:49:23.815571155 +0000
@@ -4,6 +4,12 @@
 
 #include "chrome/browser/ui/browser_tabstrip.h"
 
+#include "base/json/json_reader.h"
+#include "extensions/common/extension_messages.h"
+#include "extensions/browser/app_window/app_window.h"
+#include "content/nw/src/nw_content.h"
+#include "content/nw/src/nw_base.h"
+
 #include "base/command_line.h"
 #include "base/feature_list.h"
 #include "chrome/browser/profiles/profile.h"
@@ -65,18 +71,51 @@
                     const GURL& target_url,
                     WindowOpenDisposition disposition,
                     const blink::mojom::WindowFeatures& window_features,
-                    NavigateParams::WindowAction window_action) {
+                    NavigateParams::WindowAction window_action,
+		    std::string manifest) {
   // No code for this yet.
   DCHECK(disposition != WindowOpenDisposition::SAVE_TO_DISK);
   // Can't create a new contents for the current tab - invalid case.
   DCHECK(disposition != WindowOpenDisposition::CURRENT_TAB);
 
+  gfx::Rect rect = window_features.bounds;
+  int height = 0; int width = 0;
+  int x = 0; int y = 0;
+  bool has_frame = true;
+  bool fullscreen = false;
+  if (!manifest.empty()) {
+    std::unique_ptr<base::Value> val = base::JSONReader::ReadDeprecated(manifest);
+    if (val && val->is_dict()) {
+      std::unique_ptr<base::DictionaryValue> mnfst;
+      mnfst.reset(static_cast<base::DictionaryValue*>(val.release()));
+      if (mnfst->GetInteger("width", &width))
+        rect.set_width(width);
+      if (mnfst->GetInteger("height", &height))
+        rect.set_height(height);
+      if (mnfst->GetInteger("x", &x))
+        rect.set_x(x);
+      if (mnfst->GetInteger("y", &y))
+        rect.set_y(y);
+      has_frame = mnfst->FindBoolKey("frame").value_or(true);
+      fullscreen = mnfst->FindBoolKey("fullscreen").value_or(false);
+    }
+  }
+  extensions::AppWindow::CreateParams params0;
+  std::string js_doc_start, js_doc_end;
+  nw::CalcNewWinParams(new_contents.get(), &params0, &js_doc_start, &js_doc_end, manifest);
+  new_contents->GetMutableRendererPrefs()->
+    nw_inject_js_doc_start = js_doc_start;
+  new_contents->GetMutableRendererPrefs()->
+    nw_inject_js_doc_end = js_doc_end;
+  new_contents->SyncRendererPrefs();
+
   NavigateParams params(browser, std::move(new_contents));
   params.source_contents = source_contents;
   params.url = target_url;
   params.disposition = disposition;
-  params.window_bounds = window_features.bounds;
-  params.window_action = window_action;
+  params.window_bounds = rect;
+  params.window_action = fullscreen ? NavigateParams::SHOW_WINDOW_FULLSCREEN : window_action;
+  params.frameless = !has_frame;
   // At this point, we're already beyond the popup blocker. Even if the popup
   // was created without a user gesture, we have to set |user_gesture| to true,
   // so it gets correctly focused.
diff -r -u --color up/chromium/chrome/browser/ui/browser_tabstrip.h nw/chromium/chrome/browser/ui/browser_tabstrip.h
--- up/chromium/chrome/browser/ui/browser_tabstrip.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/browser_tabstrip.h	2023-01-28 02:49:23.815571155 +0000
@@ -56,7 +56,8 @@
     const GURL& target_url,
     WindowOpenDisposition disposition,
     const blink::mojom::WindowFeatures& window_features,
-    NavigateParams::WindowAction window_action = NavigateParams::SHOW_WINDOW);
+    NavigateParams::WindowAction window_action = NavigateParams::SHOW_WINDOW,
+    std::string manifest = std::string());
 
 // Closes the specified WebContents in the specified Browser. If
 // |add_to_history| is true, an entry in the historical tab database is created.
diff -r -u --color up/chromium/chrome/browser/ui/browser_window.h nw/chromium/chrome/browser/ui/browser_window.h
--- up/chromium/chrome/browser/ui/browser_window.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/browser_window.h	2023-01-28 02:49:23.815571155 +0000
@@ -9,6 +9,8 @@
 #include <string>
 #include <vector>
 
+#include "extensions/common/draggable_region.h"
+
 #include "base/callback_forward.h"
 #include "base/callback_helpers.h"
 #include "base/feature_list.h"
@@ -42,6 +44,8 @@
 #error This file should only be included on desktop.
 #endif
 
+class SkRegion;
+
 class Browser;
 class SharingDialog;
 struct SharingDialogData;
@@ -150,6 +154,15 @@
 
   //////////////////////////////////////////////////////////////////////////////
   // Browser specific methods:
+  virtual void SetShowInTaskbar(bool) = 0;
+  virtual void SetResizable(bool) = 0;
+  virtual void SetAllVisible(bool) = 0;
+  virtual void SetMinimumSize(gfx::Size) = 0;
+  virtual void SetMaximumSize(gfx::Size) = 0;
+  virtual void UpdateDraggableRegions(
+                                      const std::vector<extensions::DraggableRegion>& regions) = 0;
+  virtual SkRegion* GetDraggableRegion() = 0;
+  virtual void NativeWindowChanged() = 0;
 
   // Returns the browser window currently hosting `web_contents`. If no browser
   // window exists this returns null.
@@ -299,6 +312,10 @@
   // be called after the TabStripModel has an active tab.
   virtual void SetContentsSize(const gfx::Size& size) = 0;
 
+#if defined(OS_WIN)
+  virtual void SetPosition(const gfx::Point& pos) = 0;
+#endif
+
   // Updates the visual state of the specified page action icon if present on
   // the window.
   virtual void UpdatePageActionIcon(PageActionIconType type) = 0;
diff -r -u --color up/chromium/chrome/browser/ui/browser_window_state.cc nw/chromium/chrome/browser/ui/browser_window_state.cc
--- up/chromium/chrome/browser/ui/browser_window_state.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/browser_window_state.cc	2023-01-28 02:49:23.815571155 +0000
@@ -4,6 +4,8 @@
 
 #include "chrome/browser/ui/browser_window_state.h"
 
+#include "content/nw/src/nw_base.h"
+
 #include <stddef.h>
 
 #include <utility>
@@ -51,6 +53,8 @@
 }  // namespace
 
 std::string GetWindowName(const Browser* browser) {
+  if (browser->is_type_popup() && !browser->windows_key().empty())
+    return browser->windows_key();
   switch (browser->type()) {
     case Browser::TYPE_NORMAL:
 #if BUILDFLAG(IS_CHROMEOS_ASH)
@@ -117,11 +121,16 @@
 }
 
 bool SavedBoundsAreContentBounds(const Browser* browser) {
+  return !browser->is_type_devtools();
+#if 0
   // Applications other than web apps (such as devtools) save their window size.
   // Web apps, on the other hand, have the same behavior as popups, and save
   // their content bounds.
   return !browser->is_type_normal() && !browser->is_type_devtools() &&
          !browser->is_trusted_source();
+  // bounds should be content bounds for NW.js apps
+         //!browser->is_trusted_source();
+#endif
 }
 
 void SaveWindowPlacement(const Browser* browser,
@@ -151,14 +160,15 @@
   }
 }
 
-void GetSavedWindowBoundsAndShowState(const Browser* browser,
+bool GetSavedWindowBoundsAndShowState(const Browser* browser,
                                       gfx::Rect* bounds,
                                       ui::WindowShowState* show_state) {
   DCHECK(browser);
   DCHECK(bounds);
   DCHECK(show_state);
+
   *bounds = browser->override_bounds();
-  WindowSizer::GetBrowserWindowBoundsAndShowState(*bounds, browser, bounds,
+  bool ret = WindowSizer::GetBrowserWindowBoundsAndShowState(*bounds, browser, bounds,
                                                   show_state);
 
   const base::CommandLine& parsed_command_line =
@@ -166,6 +176,7 @@
 
   internal::UpdateWindowBoundsAndShowStateFromCommandLine(parsed_command_line,
                                                           bounds, show_state);
+  return ret;
 }
 
 namespace internal {
diff -r -u --color up/chromium/chrome/browser/ui/browser_window_state.h nw/chromium/chrome/browser/ui/browser_window_state.h
--- up/chromium/chrome/browser/ui/browser_window_state.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/browser_window_state.h	2023-01-28 02:49:23.815571155 +0000
@@ -65,7 +65,7 @@
 // Return the |bounds| for the browser window to be used upon creation.
 // The |show_state| variable will receive the desired initial show state for
 // the window.
-void GetSavedWindowBoundsAndShowState(const Browser* browser,
+bool GetSavedWindowBoundsAndShowState(const Browser* browser,
                                       gfx::Rect* bounds,
                                       ui::WindowShowState* show_state);
 
diff -r -u --color up/chromium/chrome/browser/ui/chrome_pages.cc nw/chromium/chrome/browser/ui/chrome_pages.cc
--- up/chromium/chrome/browser/ui/chrome_pages.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/chrome_pages.cc	2023-01-28 02:49:23.815571155 +0000
@@ -78,7 +78,7 @@
 namespace chrome {
 namespace {
 
-const char kHashMark[] = "#";
+//const char kHashMark[] = "#";
 
 void FocusWebContents(Browser* browser) {
   auto* const contents = browser->tab_strip_model()->GetActiveWebContents();
@@ -176,6 +176,7 @@
 #endif  // BUILDFLAG(IS_CHROMEOS_ASH) && BUILDFLAG(GOOGLE_CHROME_BRANDING)
 }
 
+#if 0
 std::string GenerateContentSettingsExceptionsSubPage(ContentSettingsType type) {
   // In MD Settings, the exceptions no longer have a separate subpage.
   // This list overrides the group names defined in site_settings_helper for the
@@ -201,6 +202,7 @@
                            ? site_settings::ContentSettingsTypeToGroupName(type)
                            : it->second});
 }
+#endif
 
 void ShowSiteSettingsImpl(Browser* browser, Profile* profile, const GURL& url) {
   // If a valid non-file origin, open a settings page specific to the current
@@ -399,15 +401,19 @@
 
 void ShowContentSettingsExceptions(Browser* browser,
                                    ContentSettingsType content_settings_type) {
+#if 0
   ShowSettingsSubPage(
       browser, GenerateContentSettingsExceptionsSubPage(content_settings_type));
+#endif
 }
 
 void ShowContentSettingsExceptionsForProfile(
     Profile* profile,
     ContentSettingsType content_settings_type) {
+#if 0
   ShowSettingsSubPageForProfile(
       profile, GenerateContentSettingsExceptionsSubPage(content_settings_type));
+#endif
 }
 
 void ShowSiteSettings(Browser* browser, const GURL& url) {
@@ -421,10 +427,12 @@
 
 void ShowContentSettings(Browser* browser,
                          ContentSettingsType content_settings_type) {
+#if 0
   ShowSettingsSubPage(
       browser, base::StrCat({kContentSettingsSubPage, kHashMark,
                              site_settings::ContentSettingsTypeToGroupName(
                                  content_settings_type)}));
+#endif
 }
 
 void ShowClearBrowsingDataDialog(Browser* browser) {
diff -r -u --color up/chromium/chrome/browser/ui/cocoa/apps/app_shim_menu_controller_mac.mm nw/chromium/chrome/browser/ui/cocoa/apps/app_shim_menu_controller_mac.mm
--- up/chromium/chrome/browser/ui/cocoa/apps/app_shim_menu_controller_mac.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/cocoa/apps/app_shim_menu_controller_mac.mm	2023-01-28 02:49:23.819571197 +0000
@@ -2,6 +2,10 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "base/command_line.h"
+#include "chrome/browser/lifetime/application_lifetime_desktop.h"
+#include "content/public/common/content_features.h"
+
 #import "chrome/browser/ui/cocoa/apps/app_shim_menu_controller_mac.h"
 
 #include "base/containers/adapters.h"
@@ -27,6 +31,11 @@
 using extensions::Extension;
 using extensions::ExtensionRegistry;
 
+#include "chrome/browser/devtools/devtools_window.h"
+
+#include "content/nw/src/api/menu/menu.h"
+#include "content/nw/src/common/shell_switches.h"
+
 namespace {
 
 // Gets an item from the main menu given the tag of the top level item
@@ -62,6 +71,7 @@
   [[top_level_item submenu] addItem:item];
 }
 
+#if 0
 // Finds an item with |item_tag| and removes it from the submenu of
 // |top_level_item|.
 void RemoveMenuItemWithTag(NSMenuItem* top_level_item,
@@ -119,6 +129,7 @@
   [alternate_item setHidden:!visible];
   [menu_item setHidden:!visible];
 }
+#endif
 
 // Retrieve the Extension and (optionally) Profile for an NSWindow.
 const Extension* GetExtensionForNSWindow(NSWindow* window,
@@ -285,6 +296,7 @@
 - (void)hideCurrentPlatformApp;
 // If the currently focused window belongs to a platform app, focus the app.
 - (void)focusCurrentPlatformApp;
+- (void)showDevtools;
 @end
 
 @implementation AppShimMenuController
@@ -324,6 +336,7 @@
               resourceId:IDS_EXIT_MAC
                   action:@selector(quitCurrentPlatformApp)
            keyEquivalent:@"q"]);
+#if 0
   _newDoppelganger.reset([[DoppelgangerMenuItem alloc]
       initWithController:self
                  menuTag:IDC_FILE_MENU
@@ -348,6 +361,7 @@
               resourceId:0
                   action:nil
            keyEquivalent:@"o"]);
+#endif
   _allToFrontDoppelganger.reset([[DoppelgangerMenuItem alloc]
       initWithController:self
                  menuTag:IDC_WINDOW_MENU
@@ -371,18 +385,21 @@
   [appMenu addItem:[NSMenuItem separatorItem]];
   [appMenu addItem:[_quitDoppelganger menuItem]];
 
+#if 0
   // File menu.
   _fileMenuItem.reset([NewTopLevelItemFrom(IDC_FILE_MENU) retain]);
   [[_fileMenuItem submenu] addItem:[_newDoppelganger menuItem]];
   [[_fileMenuItem submenu] addItem:[_openDoppelganger menuItem]];
   [[_fileMenuItem submenu] addItem:[NSMenuItem separatorItem]];
   [[_fileMenuItem submenu] addItem:[_closeWindowDoppelganger menuItem]];
+#endif
 
   // Edit menu. We copy the menu because the last two items, "Start Dictation"
   // and "Special Characters" are added by OSX, so we can't copy them
   // explicitly.
   _editMenuItem.reset([[[NSApp mainMenu] itemWithTag:IDC_EDIT_MENU] copy]);
 
+#if 0
   // View menu. Remove "Always Show Bookmark Bar" and separator.
   _viewMenuItem.reset([[[NSApp mainMenu] itemWithTag:IDC_VIEW_MENU] copy]);
   RemoveMenuItemWithTag(_viewMenuItem, IDC_SHOW_BOOKMARK_BAR, YES);
@@ -392,12 +409,34 @@
   AddDuplicateItem(_historyMenuItem, IDC_HISTORY_MENU, IDC_BACK);
   AddDuplicateItem(_historyMenuItem, IDC_HISTORY_MENU, IDC_FORWARD);
 
+#endif
   // Window menu.
   _windowMenuItem.reset([NewTopLevelItemFrom(IDC_WINDOW_MENU) retain]);
   AddDuplicateItem(_windowMenuItem, IDC_WINDOW_MENU, IDC_MINIMIZE_WINDOW);
   AddDuplicateItem(_windowMenuItem, IDC_WINDOW_MENU, IDC_MAXIMIZE_WINDOW);
   [[_windowMenuItem submenu] addItem:[NSMenuItem separatorItem]];
   [[_windowMenuItem submenu] addItem:[_allToFrontDoppelganger menuItem]];
+
+#if defined(NWJS_SDK)
+  bool enable_devtools = true;
+  const base::CommandLine* command_line =
+      base::CommandLine::ForCurrentProcess();
+  if (command_line->HasSwitch(switches::kDisableDevTools))
+    enable_devtools = false;
+
+  if (enable_devtools) {
+  [[_windowMenuItem submenu] setAutoenablesItems:NO];
+  NSMenuItem* item = [[NSMenuItem alloc]
+		      initWithTitle:@"Devtools"
+		      action:@selector(showDevtools)
+                      keyEquivalent:@"i"];
+  [item setTag:IDC_DEV_TOOLS_CONSOLE];
+  [item setTarget:self];
+  [item setEnabled:YES];
+  [item setKeyEquivalentModifierMask:NSEventModifierFlagCommand | NSEventModifierFlagOption];
+  [[_windowMenuItem submenu] addItem:item];
+  }
+#endif
 }
 
 - (void)registerEventHandlers {
@@ -428,8 +467,20 @@
     // Ignore is_browser: if a window becomes main that does not belong to an
     // extension or browser, treat it the same as switching to a browser.
     const Extension* extension = GetExtensionForNSWindow(window);
-    if (extension)
-      [self appBecameMain:extension];
+    extensions::AppWindow* appWindow =
+      AppWindowRegistryUtil::GetAppWindowForNativeWindowAnyProfile(window);
+    if (extension) {
+        if (appWindow && appWindow->menu_) {
+            [NSApp setMainMenu:appWindow->menu_->menu_];
+            return;
+        }
+        Browser* browser = chrome::FindBrowserWithWindow(window);
+        if (browser && browser->nw_menu_) {
+          [NSApp setMainMenu:browser->nw_menu_->menu_];
+          return;
+        }
+        [self appBecameMain:extension];
+    }
     else
       [self chromeBecameMain];
   } else if ([name isEqualToString:NSWindowDidResignMainNotification]) {
@@ -460,18 +511,25 @@
     return;
 
   if (!_appId.empty())
-    [self removeMenuItems];
+      return;
+  // #4591: when app sets menubar and launch another chrome app,
+  // removeMenuItems will try to remove appmenuitem which isn't
+  // in the main menu; then app will crash.
+  // so after this function runs once, we just do nothing and return here
+  //  [self removeMenuItems];
 
   _appId = app->id();
   [self addMenuItems:app];
 }
 
 - (void)chromeBecameMain {
+#if 0
   if (_appId.empty())
     return;
 
   _appId.clear();
   [self removeMenuItems];
+#endif
 }
 
 - (void)addMenuItems:(const Extension*)app {
@@ -486,14 +544,15 @@
   [_aboutDoppelganger enableForApp:app];
   [_hideDoppelganger enableForApp:app];
   [_quitDoppelganger enableForApp:app];
-  [_newDoppelganger enableForApp:app];
-  [_openDoppelganger enableForApp:app];
-  [_closeWindowDoppelganger enableForApp:app];
+  //[_newDoppelganger enableForApp:app];
+  //[_openDoppelganger enableForApp:app];
+  //[_closeWindowDoppelganger enableForApp:app];
 
   [_appMenuItem setTitle:base::SysUTF8ToNSString(_appId)];
   [[_appMenuItem submenu] setTitle:title];
 
   [mainMenu addItem:_appMenuItem];
+#if 0
   [mainMenu addItem:_fileMenuItem];
 
   SetItemWithTagVisible(_editMenuItem,
@@ -501,24 +560,32 @@
                         app->is_hosted_app(), true);
   SetItemWithTagVisible(_editMenuItem, IDC_FIND_MENU, app->is_hosted_app(),
                         false);
+#endif
   [mainMenu addItem:_editMenuItem];
 
+#if 0
   if (app->is_hosted_app()) {
     [mainMenu addItem:_viewMenuItem];
     [mainMenu addItem:_historyMenuItem];
   }
+#endif
   [mainMenu addItem:_windowMenuItem];
 }
 
 - (void)removeMenuItems {
   NSMenu* mainMenu = [NSApp mainMenu];
+  if ([mainMenu indexOfItem:_appMenuItem] >= 0)
   [mainMenu removeItem:_appMenuItem];
-  [mainMenu removeItem:_fileMenuItem];
+  //[mainMenu removeItem:_fileMenuItem];
+#if 0
   if ([mainMenu indexOfItem:_viewMenuItem] >= 0)
     [mainMenu removeItem:_viewMenuItem];
   if ([mainMenu indexOfItem:_historyMenuItem] >= 0)
     [mainMenu removeItem:_historyMenuItem];
+#endif
+  if ([mainMenu indexOfItem:_editMenuItem] >= 0)
   [mainMenu removeItem:_editMenuItem];
+  if ([mainMenu indexOfItem:_windowMenuItem] >= 0)
   [mainMenu removeItem:_windowMenuItem];
 
   // Restore the Chrome main menu bar.
@@ -528,15 +595,22 @@
   [_aboutDoppelganger disable];
   [_hideDoppelganger disable];
   [_quitDoppelganger disable];
-  [_newDoppelganger disable];
-  [_openDoppelganger disable];
-  [_closeWindowDoppelganger disable];
+  //[_newDoppelganger disable];
+  //[_openDoppelganger disable];
+  //[_closeWindowDoppelganger disable];
 }
 
 - (void)quitCurrentPlatformApp {
+  if (base::FeatureList::IsEnabled(::features::kNWNewWin)) {
+    chrome::CloseAllBrowsers(false, true);
+    return;
+  }
+
   auto windows = GetAppWindowsForNSWindow([NSApp keyWindow]);
-  for (extensions::AppWindow* window : base::Reversed(windows))
-    window->GetBaseWindow()->Close();
+  for (extensions::AppWindow* window : base::Reversed(windows)) {
+    if (window->NWCanClose(true))
+      window->GetBaseWindow()->Close();
+  }
 }
 
 - (void)hideCurrentPlatformApp {
@@ -551,4 +625,12 @@
     window->GetBaseWindow()->Show();
 }
 
+- (void)showDevtools {
+  extensions::AppWindow* appWindow =
+      AppWindowRegistryUtil::GetAppWindowForNativeWindowAnyProfile(
+          [NSApp keyWindow]);
+  if (appWindow)
+    DevToolsWindow::OpenDevToolsWindow(appWindow->web_contents());
+}
+
 @end
diff -r -u --color up/chromium/chrome/browser/ui/cocoa/main_menu_builder.mm nw/chromium/chrome/browser/ui/cocoa/main_menu_builder.mm
--- up/chromium/chrome/browser/ui/cocoa/main_menu_builder.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/cocoa/main_menu_builder.mm	2023-01-28 02:49:23.823571239 +0000
@@ -22,6 +22,8 @@
 #import "ui/base/l10n/l10n_util_mac.h"
 #include "ui/strings/grit/ui_strings.h"
 
+#pragma clang diagnostic ignored "-Wunused-function"
+
 namespace chrome {
 namespace {
 
@@ -43,7 +45,7 @@
                 .string_format_1(product_name)
                 .tag(IDC_ABOUT)
                 .target(app_delegate)
-                .action(@selector(orderFrontStandardAboutPanel:)),
+                /*.action(@selector(orderFrontStandardAboutPanel:))*/,
                 Item().is_separator(),
                 Item(IDS_PREFERENCES)
                     .tag(IDC_OPTIONS)
@@ -58,8 +60,8 @@
                     .command_id(IDC_IMPORT_SETTINGS)
                     .remove_if(is_pwa),
                 Item().is_separator(),
-                Item(IDS_SERVICES_MAC).tag(-1).submenu({}),
-                Item().is_separator(),
+                //Item(IDS_SERVICES_MAC).tag(-1).submenu({}),
+                //Item().is_separator(),
                 Item(IDS_HIDE_APP_MAC)
                     .string_format_1(product_name)
                     .tag(IDC_HIDE_APP)
@@ -179,6 +181,7 @@
                 Item(IDS_EDIT_SELECT_ALL_MAC)
                     .tag(IDC_CONTENT_CONTEXT_SELECTALL)
                     .action(@selector(selectAll:)),
+#if 0
                 Item().is_separator(),
                 Item(IDS_EDIT_FIND_SUBMENU_MAC).tag(IDC_FIND_MENU).submenu({
                   Item(IDS_EDIT_SEARCH_WEB_MAC).command_id(IDC_FOCUS_SEARCH),
@@ -236,6 +239,7 @@
                 }),
             // The "Start Dictation..." and "Emoji & Symbols" items are
             // inserted by AppKit.
+#endif
           })
           .Build();
   return item;
@@ -506,9 +510,9 @@
   using Builder = base::scoped_nsobject<NSMenuItem> (*)(
       NSApplication*, id, const std::u16string&, bool);
   static const Builder kBuilderFuncs[] = {
-      &BuildAppMenu,     &BuildFileMenu,      &BuildEditMenu,   &BuildViewMenu,
-      &BuildHistoryMenu, &BuildBookmarksMenu, &BuildPeopleMenu, &BuildTabMenu,
-      &BuildWindowMenu,  &BuildHelpMenu,
+      &BuildAppMenu,     /*&BuildFileMenu,*/      &BuildEditMenu,  /* &BuildViewMenu,
+      &BuildHistoryMenu, &BuildBookmarksMenu, &BuildPeopleMenu, &BuildTabMenu,*/
+      &BuildWindowMenu,  /*&BuildHelpMenu,*/
   };
   for (auto* builder : kBuilderFuncs) {
     auto item = builder(nsapp, app_delegate, product_name, is_pwa);
diff -r -u --color up/chromium/chrome/browser/ui/cocoa/status_icons/status_icon_mac.h nw/chromium/chrome/browser/ui/cocoa/status_icons/status_icon_mac.h
--- up/chromium/chrome/browser/ui/cocoa/status_icons/status_icon_mac.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/cocoa/status_icons/status_icon_mac.h	2023-01-28 02:49:23.823571239 +0000
@@ -39,7 +39,7 @@
 
  protected:
   // Overridden from StatusIcon.
-  void UpdatePlatformContextMenu(StatusIconMenuModel* model) override;
+  void UpdatePlatformContextMenu(ui::MenuModel* model) override;
 
  private:
   FRIEND_TEST_ALL_PREFIXES(StatusIconMacTest, CreateMenu);
diff -r -u --color up/chromium/chrome/browser/ui/cocoa/status_icons/status_icon_mac.mm nw/chromium/chrome/browser/ui/cocoa/status_icons/status_icon_mac.mm
--- up/chromium/chrome/browser/ui/cocoa/status_icons/status_icon_mac.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/cocoa/status_icons/status_icon_mac.mm	2023-01-28 02:49:23.823571239 +0000
@@ -100,7 +100,7 @@
   return menu_.get() != nil;
 }
 
-void StatusIconMac::UpdatePlatformContextMenu(StatusIconMenuModel* model) {
+void StatusIconMac::UpdatePlatformContextMenu(ui::MenuModel* model) {
   if (!model) {
     menu_.reset();
   } else {
diff -r -u --color up/chromium/chrome/browser/ui/dialogs/outdated_upgrade_bubble.cc nw/chromium/chrome/browser/ui/dialogs/outdated_upgrade_bubble.cc
--- up/chromium/chrome/browser/ui/dialogs/outdated_upgrade_bubble.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/dialogs/outdated_upgrade_bubble.cc	2023-01-28 02:49:23.831571324 +0000
@@ -40,7 +40,9 @@
 
 // For ChromeOS Lacros, browser updates are done via system services, thus
 // we redirect to the safetyCheck page that interacts with these. On other
-// platforms it may be possible to download an updated browser via a site.
+// platforms it may be possible to download an updated browser via a
+// site.
+#if 0
 const char* kUpdateBrowserRedirectUrl =
 #if BUILDFLAG(IS_CHROMEOS_LACROS)
     // The URL to be used to update Lacros-Chrome when auto-update failed
@@ -51,7 +53,7 @@
     // too long.
     "https://www.google.com/chrome";
 #endif
-
+#endif
 bool g_upgrade_bubble_is_showing = false;
 
 // The number of times the user ignored the bubble before finally choosing to
@@ -111,6 +113,7 @@
 }  // namespace
 
 void ShowOutdatedUpgradeBubble(Browser* browser, bool auto_update_enabled) {
+#if 0
   if (g_upgrade_bubble_is_showing)
     return;
 
@@ -139,4 +142,5 @@
       auto_update_enabled
           ? base::UserMetricsAction("OutdatedUpgradeBubble.Show")
           : base::UserMetricsAction("OutdatedUpgradeBubble.ShowNoAU"));
+#endif
 }
diff -r -u --color up/chromium/chrome/browser/ui/exclusive_access/fullscreen_controller.cc nw/chromium/chrome/browser/ui/exclusive_access/fullscreen_controller.cc
--- up/chromium/chrome/browser/ui/exclusive_access/fullscreen_controller.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/exclusive_access/fullscreen_controller.cc	2023-01-28 02:49:23.831571324 +0000
@@ -1,6 +1,7 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wunreachable-code"
 
 #include "chrome/browser/ui/exclusive_access/fullscreen_controller.h"
 
@@ -386,6 +387,7 @@
 }
 
 bool FullscreenController::HandleUserPressedEscape() {
+  return false;
   WebContents* const active_web_contents =
       exclusive_access_manager()->context()->GetActiveWebContents();
   if (IsFullscreenWithinTab(active_web_contents)) {
diff -r -u --color up/chromium/chrome/browser/ui/javascript_dialogs/javascript_tab_modal_dialog_manager_delegate_desktop.cc nw/chromium/chrome/browser/ui/javascript_dialogs/javascript_tab_modal_dialog_manager_delegate_desktop.cc
--- up/chromium/chrome/browser/ui/javascript_dialogs/javascript_tab_modal_dialog_manager_delegate_desktop.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/javascript_dialogs/javascript_tab_modal_dialog_manager_delegate_desktop.cc	2023-01-28 02:49:23.843571451 +0000
@@ -39,12 +39,14 @@
   // warnings until user interaction. If the current page has a delayed warning,
   // it'll have a user interaction observer attached. Show the warning
   // immediately in that case.
+#if 0
   safe_browsing::SafeBrowsingUserInteractionObserver* observer =
       safe_browsing::SafeBrowsingUserInteractionObserver::FromWebContents(
           web_contents_);
   if (observer) {
     observer->OnJavaScriptDialog();
   }
+#endif
 }
 
 void JavaScriptTabModalDialogManagerDelegateDesktop::DidCloseDialog() {
diff -r -u --color up/chromium/chrome/browser/ui/media_router/media_router_ui_service.cc nw/chromium/chrome/browser/ui/media_router/media_router_ui_service.cc
--- up/chromium/chrome/browser/ui/media_router/media_router_ui_service.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/media_router/media_router_ui_service.cc	2023-01-28 02:49:23.847571493 +0000
@@ -22,7 +22,9 @@
     Profile* profile,
     std::unique_ptr<MediaRouterActionController> action_controller)
     : profile_(profile),
+#if defined(NWJS_SDK)
       action_controller_(std::move(action_controller)),
+#endif
       profile_pref_registrar_(std::make_unique<PrefChangeRegistrar>()) {
   profile_pref_registrar_->Init(profile->GetPrefs());
   profile_pref_registrar_->Add(
@@ -44,7 +46,11 @@
 }
 
 MediaRouterActionController* MediaRouterUIService::action_controller() {
+#if defined(NWJS_SDK)
   return action_controller_.get();
+#else
+  return nullptr;
+#endif
 }
 
 void MediaRouterUIService::AddObserver(Observer* observer) {
@@ -58,16 +64,21 @@
 void MediaRouterUIService::ConfigureService() {
   if (!MediaRouterEnabled(profile_)) {
     DisableService();
-  } else if (!action_controller_ && MediaRouterEnabled(profile_)) {
+  }
+#if defined(NWJS_SDK)
+  else if (!action_controller_ && MediaRouterEnabled(profile_)) {
     action_controller_ =
         std::make_unique<MediaRouterActionController>(profile_);
   }
+#endif
 }
 
 void MediaRouterUIService::DisableService() {
   for (auto& observer : observers_)
     observer.OnServiceDisabled();
+#if defined(NWJS_SDK)
   action_controller_.reset();
+#endif
 }
 
 }  // namespace media_router
diff -r -u --color up/chromium/chrome/browser/ui/media_router/media_router_ui_service.h nw/chromium/chrome/browser/ui/media_router/media_router_ui_service.h
--- up/chromium/chrome/browser/ui/media_router/media_router_ui_service.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/media_router/media_router_ui_service.h	2023-01-28 02:49:23.847571493 +0000
@@ -53,7 +53,9 @@
   void DisableService();
 
   raw_ptr<Profile> profile_;
+#if defined(NWJS_SDK)
   std::unique_ptr<MediaRouterActionController> action_controller_;
+#endif
   std::unique_ptr<PrefChangeRegistrar> profile_pref_registrar_;
 
   base::ObserverList<Observer>::Unchecked observers_;
diff -r -u --color up/chromium/chrome/browser/ui/omnibox/chrome_omnibox_client.cc nw/chromium/chrome/browser/ui/omnibox/chrome_omnibox_client.cc
--- up/chromium/chrome/browser/ui/omnibox/chrome_omnibox_client.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/omnibox/chrome_omnibox_client.cc	2023-01-28 02:49:23.851571535 +0000
@@ -253,20 +253,24 @@
 void ChromeOmniboxClient::OnInputStateChanged() {
   if (!controller_->GetWebContents())
     return;
+#if 0
   if (auto* helper =
           OmniboxTabHelper::FromWebContents(controller_->GetWebContents())) {
     helper->OnInputStateChanged();
   }
+#endif
 }
 
 void ChromeOmniboxClient::OnFocusChanged(OmniboxFocusState state,
                                          OmniboxFocusChangeReason reason) {
   if (!controller_->GetWebContents())
     return;
+#if 0
   if (auto* helper =
           OmniboxTabHelper::FromWebContents(controller_->GetWebContents())) {
     helper->OnFocusChanged(state, reason);
   }
+#endif
 }
 
 void ChromeOmniboxClient::OnResultChanged(
diff -r -u --color up/chromium/chrome/browser/ui/sad_tab.cc nw/chromium/chrome/browser/ui/sad_tab.cc
--- up/chromium/chrome/browser/ui/sad_tab.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/sad_tab.cc	2023-01-28 02:49:23.863571662 +0000
@@ -4,6 +4,7 @@
 
 #include "chrome/browser/ui/sad_tab.h"
 
+#include "chrome/browser/ui/browser_commands.h"
 #include <vector>
 
 #include "base/metrics/histogram_macros.h"
@@ -217,8 +218,12 @@
                                          : IDS_KILLED_TAB_FEEDBACK_MESSAGE),
             std::string(kCategoryTagCrash), std::string());
       } else {
-        web_contents_->GetController().Reload(content::ReloadType::NORMAL,
-                                              true);
+        Browser* browser = chrome::FindBrowserWithWebContents(web_contents_);
+        if (browser) {
+          chrome::CloseTab(browser);
+        } else
+        web_contents_->Close(); //GetController().Reload(content::ReloadType::NORMAL,
+                                //              true);
       }
       break;
     case Action::HELP_LINK:
diff -r -u --color up/chromium/chrome/browser/ui/scoped_tabbed_browser_displayer.cc nw/chromium/chrome/browser/ui/scoped_tabbed_browser_displayer.cc
--- up/chromium/chrome/browser/ui/scoped_tabbed_browser_displayer.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/scoped_tabbed_browser_displayer.cc	2023-01-28 02:49:23.863571662 +0000
@@ -14,7 +14,7 @@
   browser_ = FindTabbedBrowser(profile, false);
   if (!browser_ && Browser::GetCreationStatusForProfile(profile) ==
                        Browser::CreationStatus::kOk) {
-    Browser::CreateParams params(profile, /*user_gesture=*/true);
+    Browser::CreateParams params(Browser::TYPE_POPUP, profile, /*user_gesture=*/true);
     browser_ = Browser::Create(params);
   }
 }
diff -r -u --color up/chromium/chrome/browser/ui/startup/startup_browser_creator.cc nw/chromium/chrome/browser/ui/startup/startup_browser_creator.cc
--- up/chromium/chrome/browser/ui/startup/startup_browser_creator.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/startup/startup_browser_creator.cc	2023-01-28 02:49:23.875571789 +0000
@@ -3,6 +3,11 @@
 // found in the LICENSE file.
 
 #include "chrome/browser/ui/startup/startup_browser_creator.h"
+#include "chrome/browser/spellchecker/spellcheck_factory.h"
+#include "content/nw/src/common/shell_switches.h"
+#include "content/public/common/content_features.h"
+
+#include "extensions/browser/extension_registry.h"
 
 #include <stddef.h>
 
@@ -94,6 +99,15 @@
 #include "printing/buildflags/buildflags.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
 
+#include "extensions/browser/extension_system.h"
+#include "chrome/browser/extensions/component_loader.h"
+#include "chrome/browser/extensions/extension_service.h"
+#include "chrome/common/extensions/extension_constants.h"
+#include "chrome/grit/browser_resources.h"
+#include "extensions/common/constants.h"
+#include "chrome/browser/ui/extensions/app_launch_params.h"
+#include "chrome/browser/ui/extensions/application_launch.h"
+
 #if BUILDFLAG(IS_CHROMEOS_ASH)
 #include "ash/constants/ash_switches.h"
 #include "chrome/browser/ash/app_mode/app_launch_utils.h"
@@ -1110,8 +1124,8 @@
     // chrome to shut down.
     // TODO(jackhou): Do this properly once keep-alive is handled by the
     // background page of apps. Tracked at http://crbug.com/175381
-    if (chrome::GetBrowserCount(privacy_safe_profile) != 0)
-      return true;
+    //if (chrome::GetBrowserCount(privacy_safe_profile) != 0)
+    return true;
   }
 
   // Check for --load-and-launch-app.
@@ -1133,6 +1147,55 @@
       return true;
   }
 
+  if (process_startup != chrome::startup::IsProcessStartup::kYes)
+    return true;
+  if (command_line.HasSwitch(switches::kEnableSpellChecking))
+    SpellcheckServiceFactory::GetForContext(profile_info.profile);
+
+  const base::CommandLine::StringVector& params = command_line.GetArgs();
+  if (command_line.HasSwitch("nwapp")) {
+	  if (!apps::AppLoadService::Get(profile_info.profile)->LoadAndLaunch(
+		  base::FilePath(command_line.GetSwitchValueNative("nwapp")), command_line, cur_dir)) {
+		  return false;
+	  }
+	  return true;
+  }
+
+  if (!command_line.HasSwitch("nwjs-test-mode")) {
+    if (params.size() > 0) {
+      if (!apps::AppLoadService::Get(profile_info.profile)->LoadAndLaunch(
+                                                             base::FilePath(params[0]), command_line, cur_dir)) {
+        return false;
+      }
+      return true;
+    } else {
+      extensions::ExtensionService* extension_service =
+        extensions::ExtensionSystem::Get(profile_info.profile)->extension_service();
+      extensions::ExtensionRegistry* extension_registry =
+        extensions::ExtensionRegistry::Get(profile_info.profile);
+      extensions::ComponentLoader* component_loader = extension_service->component_loader();
+      std::string id;
+      if (base::FeatureList::IsEnabled(::features::kNWNewWin)) {
+        id = component_loader->GetExtensionID(IDR_NWJS_DEFAPP_MANIFEST_NEWWIN,
+                                                         base::FilePath(FILE_PATH_LITERAL("nwjs_newwin_app")));
+      } else {
+        id = component_loader->GetExtensionID(IDR_NWJS_DEFAPP_MANIFEST,
+                                                         base::FilePath(FILE_PATH_LITERAL("nwjs_default_app")));
+      }
+
+      LOG(INFO) << "loading default app: " << id;
+      const extensions::Extension* extension = extension_registry->GetExtensionById(id, extensions::ExtensionRegistry::EVERYTHING);
+      if (!extension) {
+        LOG(FATAL) << "Failed to load default app";
+        return false;
+      }
+      OpenApplication(profile_info.profile,
+                      apps::AppLaunchParams(extension->id(), apps::LaunchContainer::kLaunchContainerWindow,
+                                            WindowOpenDisposition::NEW_WINDOW, apps::LaunchSource::kFromChromeInternal));
+      return true;
+    }
+  }
+
 #if BUILDFLAG(IS_WIN)
   if (command_line.HasSwitch(switches::kWinJumplistAction)) {
     // `switches::kWinJumplistAction` is expected to be set together with a
diff -r -u --color up/chromium/chrome/browser/ui/startup/startup_browser_creator_impl.cc nw/chromium/chrome/browser/ui/startup/startup_browser_creator_impl.cc
--- up/chromium/chrome/browser/ui/startup/startup_browser_creator_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/startup/startup_browser_creator_impl.cc	2023-01-28 02:49:23.875571789 +0000
@@ -368,7 +368,7 @@
         IncompatibleApplicationsUpdater::HasCachedApplications();
   }
 #endif
-  welcome::JoinOnboardingGroup(profile_);
+  //welcome::JoinOnboardingGroup(profile_);
 #endif
 
   // Presentation of promotional and/or educational tabs may be controlled via
@@ -392,10 +392,11 @@
   // TODO(https://crbug.com/1276034): Cleanup this code, in particular on Ash
   // where the welcome flow is never shown.
   bool welcome_enabled = true;
+
 #if BUILDFLAG(IS_CHROMEOS_LACROS)
   if (AccountConsistencyModeManager::IsMirrorEnabledForProfile(profile_))
     welcome_enabled = false;
-#elif !BUILDFLAG(IS_CHROMEOS_ASH)
+#elif 0 //!BUILDFLAG(IS_CHROMEOS_ASH)
   welcome_enabled =
       welcome::IsEnabled(profile_) && welcome::HasModulesToShow(profile_);
 #endif  // !BUILDFLAG(IS_CHROMEOS_ASH)
diff -r -u --color up/chromium/chrome/browser/ui/startup/startup_tab_provider.cc nw/chromium/chrome/browser/ui/startup/startup_tab_provider.cc
--- up/chromium/chrome/browser/ui/startup/startup_tab_provider.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/startup/startup_tab_provider.cc	2023-01-28 02:49:23.875571789 +0000
@@ -98,7 +98,7 @@
   const GURL reset_settings_url =
       settings_url.Resolve(chrome::kResetProfileSettingsSubPage);
   url_points_to_an_approved_settings_page = url == reset_settings_url;
-#if BUILDFLAG(IS_WIN)
+#if 0 //BUILDFLAG(IS_WIN)
   // On Windows, also allow a hash for the Chrome Cleanup Tool.
   const GURL reset_settings_url_with_cct_hash = reset_settings_url.Resolve(
       std::string("#") + settings::ResetSettingsHandler::kCctResetSettingsHash);
diff -r -u --color up/chromium/chrome/browser/ui/tab_contents/chrome_web_contents_view_handle_drop.cc nw/chromium/chrome/browser/ui/tab_contents/chrome_web_contents_view_handle_drop.cc
--- up/chromium/chrome/browser/ui/tab_contents/chrome_web_contents_view_handle_drop.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/tab_contents/chrome_web_contents_view_handle_drop.cc	2023-01-28 02:49:23.879571831 +0000
@@ -23,6 +23,7 @@
 
 namespace {
 
+#if 0
 void CompletionCallback(
     content::DropData drop_data,
     std::unique_ptr<enterprise_connectors::FilesScanData> files_scan_data,
@@ -114,13 +115,15 @@
   base::WeakPtrFactory<HandleDropScanData> weakptr_factory_{this};
 };
 
+#endif
 }  // namespace
 
 void HandleOnPerformDrop(
     content::WebContents* web_contents,
     content::DropData drop_data,
     content::WebContentsViewDelegate::DropCompletionCallback callback) {
-  enterprise_connectors::ContentAnalysisDelegate::Data data;
+  //enterprise_connectors::ContentAnalysisDelegate::Data data;
+#if 0
   Profile* profile =
       Profile::FromBrowserContext(web_contents->GetBrowserContext());
   auto connector =
@@ -129,10 +132,14 @@
           : enterprise_connectors::AnalysisConnector::FILE_ATTACHED;
   if (!enterprise_connectors::ContentAnalysisDelegate::IsEnabled(
           profile, web_contents->GetLastCommittedURL(), &data, connector)) {
+#endif
+  if (true) { //!safe_browsing::DeepScanningDialogDelegate::IsEnabled(
+              //profile, web_contents->GetLastCommittedURL(), &data)) {
     std::move(callback).Run(std::move(drop_data));
     return;
   }
 
+#if 0
   // Collect the data that needs to be scanned.
   if (!drop_data.url_title.empty())
     data.text.push_back(base::UTF16ToUTF8(drop_data.url_title));
@@ -170,4 +177,5 @@
   if (!callback.is_null()) {
     std::move(callback).Run(std::move(drop_data));
   }
+#endif
 }
diff -r -u --color up/chromium/chrome/browser/ui/tab_helpers.cc nw/chromium/chrome/browser/ui/tab_helpers.cc
--- up/chromium/chrome/browser/ui/tab_helpers.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/tab_helpers.cc	2023-01-28 02:49:23.879571831 +0000
@@ -331,7 +331,7 @@
       web_contents,
       autofill::ChromeAutofillClient::FromWebContents(web_contents));
   CreateSubresourceFilterWebContentsHelper(web_contents);
-  ChromeTranslateClient::CreateForWebContents(web_contents);
+  //ChromeTranslateClient::CreateForWebContents(web_contents);
   client_hints::ClientHintsWebContentsObserver::CreateForWebContents(
       web_contents);
   commerce::CommerceTabHelper::CreateForWebContents(
@@ -410,6 +410,7 @@
   //     See https://crbug.com/910288.
   resource_coordinator::ResourceCoordinatorTabHelper::CreateForWebContents(
       web_contents);
+#if 0
   safe_browsing::SafeBrowsingNavigationObserver::MaybeCreateForWebContents(
       web_contents, HostContentSettingsMapFactory::GetForProfile(profile),
       safe_browsing::SafeBrowsingNavigationObserverManagerFactory::
@@ -427,6 +428,7 @@
   safe_browsing::TriggerCreator::MaybeCreateTriggersForWebContents(
       profile, web_contents);
   ReputationWebContentsObserver::CreateForWebContents(web_contents);
+#endif
   SearchEngineTabHelper::CreateForWebContents(web_contents);
   SecurityStateTabHelper::CreateForWebContents(web_contents);
   if (site_engagement::SiteEngagementService::IsEnabled()) {
@@ -437,10 +439,12 @@
   }
   SoundContentSettingObserver::CreateForWebContents(web_contents);
   SyncEncryptionKeysTabHelper::CreateForWebContents(web_contents);
+#if 0
   sync_sessions::SyncSessionsRouterTabHelper::CreateForWebContents(
       web_contents,
       sync_sessions::SyncSessionsWebContentsRouterFactory::GetForProfile(
           profile));
+#endif
   content_settings::PageSpecificContentSettings::CreateForWebContents(
       web_contents,
       std::make_unique<chrome::PageSpecificContentSettingsDelegate>(
diff -r -u --color up/chromium/chrome/browser/ui/views/accelerator_table.cc nw/chromium/chrome/browser/ui/views/accelerator_table.cc
--- up/chromium/chrome/browser/ui/views/accelerator_table.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/accelerator_table.cc	2023-01-28 02:49:23.891571958 +0000
@@ -33,10 +33,14 @@
 //      item with the appropriate modifier.
 //   2) Update GetShortcutsNotPresentInMainMenu() in
 //      global_keyboard_shortcuts_mac.mm.
-#if !BUILDFLAG(IS_CHROMEOS)
+    { ui::VKEY_F4, ui::EF_ALT_DOWN, IDC_CLOSE_WINDOW },
+#if 0
     {ui::VKEY_F7, ui::EF_NONE, IDC_CARET_BROWSING_TOGGLE},
 #endif
+#if defined(NWJS_SDK)
     {ui::VKEY_F12, ui::EF_NONE, IDC_DEV_TOOLS_TOGGLE},
+#endif
+#if 0
     {ui::VKEY_ESCAPE, ui::EF_NONE, IDC_CLOSE_FIND_OR_STOP},
 
 #if !BUILDFLAG(IS_MAC)
@@ -237,9 +241,6 @@
     {ui::VKEY_SPACE, ui::EF_CONTROL_DOWN, IDC_TOGGLE_QUICK_COMMANDS},
 #endif  // !BUILDFLAG(IS_CHROMEOS)
 #endif  // !BUILDFLAG(IS_MAC)
-#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
-    {ui::VKEY_S, ui::EF_CONTROL_DOWN | ui::EF_SHIFT_DOWN,
-     IDC_RUN_SCREEN_AI_VISUAL_ANNOTATIONS},
 #endif
 };
 
diff -r -u --color up/chromium/chrome/browser/ui/views/apps/app_window_desktop_window_tree_host_win.cc nw/chromium/chrome/browser/ui/views/apps/app_window_desktop_window_tree_host_win.cc
--- up/chromium/chrome/browser/ui/views/apps/app_window_desktop_window_tree_host_win.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/apps/app_window_desktop_window_tree_host_win.cc	2023-01-28 02:49:23.895572000 +0000
@@ -32,6 +32,9 @@
 bool AppWindowDesktopWindowTreeHostWin::GetClientAreaInsets(
     gfx::Insets* insets,
     HMONITOR monitor) const {
+#if 1
+  return false;
+#else
   // The inset added below is only necessary for the native glass frame, i.e.
   // not for colored frames drawn by Chrome, or when DWM is disabled.
   // In fullscreen the frame is not visible.
@@ -42,6 +45,7 @@
   *insets = app_window_->glass_frame_view()->GetClientAreaInsets(monitor);
 
   return true;
+#endif
 }
 
 bool AppWindowDesktopWindowTreeHostWin::GetDwmFrameInsetsInPixels(
diff -r -u --color up/chromium/chrome/browser/ui/views/apps/chrome_native_app_window_views.cc nw/chromium/chrome/browser/ui/views/apps/chrome_native_app_window_views.cc
--- up/chromium/chrome/browser/ui/views/apps/chrome_native_app_window_views.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/apps/chrome_native_app_window_views.cc	2023-01-28 02:49:23.895572000 +0000
@@ -31,14 +31,25 @@
 #include "ui/views/controls/webview/webview.h"
 #include "ui/views/widget/widget.h"
 
+#if defined(NWJS_SDK)
+#include "base/command_line.h"
+#include "chrome/browser/devtools/devtools_window.h"
+#include "content/nw/src/common/shell_switches.h"
+#endif
+
+#include "ui/display/screen.h"
+
 using extensions::AppWindow;
 
 namespace {
 
 const AcceleratorMapping kAppWindowAcceleratorMap[] = {
-  { ui::VKEY_W, ui::EF_CONTROL_DOWN, IDC_CLOSE_WINDOW },
-  { ui::VKEY_W, ui::EF_SHIFT_DOWN | ui::EF_CONTROL_DOWN, IDC_CLOSE_WINDOW },
+  //  { ui::VKEY_W, ui::EF_CONTROL_DOWN, IDC_CLOSE_WINDOW },
+  //  { ui::VKEY_W, ui::EF_SHIFT_DOWN | ui::EF_CONTROL_DOWN, IDC_CLOSE_WINDOW },
   { ui::VKEY_F4, ui::EF_ALT_DOWN, IDC_CLOSE_WINDOW },
+#if defined(NWJS_SDK)
+  { ui::VKEY_F12, ui::EF_NONE, IDC_DEV_TOOLS_TOGGLE },
+#endif
 };
 
 // These accelerators will only be available in kiosk mode. These allow the
@@ -103,6 +114,10 @@
     views::Widget* widget) {
 }
 
+bool ChromeNativeAppWindowViews::NWCanClose(bool user_force) const {
+  return app_window()->NWCanClose(user_force);
+}
+
 void ChromeNativeAppWindowViews::InitializeDefaultWindow(
     const AppWindow::CreateParams& create_params) {
   views::Widget::InitParams init_params(views::Widget::InitParams::TYPE_WINDOW);
@@ -136,6 +151,15 @@
       init_param_bounds.IsEmpty()
           ? create_params.GetInitialWindowBounds(frame_insets)
           : init_param_bounds;
+#if defined(OS_LINUX)
+  if (create_params.GetContentMinimumSize(frame_insets).IsEmpty() &&
+      create_params.GetContentMaximumSize(frame_insets).IsEmpty() &&
+      !create_params.resizable) { //NWJS#6592
+    gfx::Size size(create_params.content_spec.bounds.width(),
+                   create_params.content_spec.bounds.height());
+    SetContentSizeConstraints(size, size);
+  } else
+#endif
   SetContentSizeConstraints(create_params.GetContentMinimumSize(frame_insets),
                             create_params.GetContentMaximumSize(frame_insets));
   if (!window_bounds.IsEmpty()) {
@@ -143,6 +167,11 @@
     bool position_specified =
         window_bounds.x() != BoundsSpecification::kUnspecifiedPosition &&
         window_bounds.y() != BoundsSpecification::kUnspecifiedPosition;
+    if (create_params.position == AppWindow::POS_MOUSE) {
+      gfx::Point cursor_pos(display::Screen::GetScreen()->GetCursorScreenPoint());
+      window_bounds.set_origin(cursor_pos);
+      widget()->SetBounds(window_bounds);
+    } else {
     if (!position_specified) {
 #if BUILDFLAG(IS_MAC)
       // On Mac, this will call NativeWidgetMac's CenterWindow() which relies
@@ -158,6 +187,15 @@
     } else {
       widget()->SetBounds(window_bounds);
     }
+    }
+  } else {
+    if (create_params.position == AppWindow::POS_CENTER)
+      widget()->CenterWindow(gfx::Size(640, 480));
+    else if (create_params.position == extensions::AppWindow::POS_MOUSE) {
+      gfx::Point cursor_pos(display::Screen::GetScreen()->GetCursorScreenPoint());
+      gfx::Rect bounds(cursor_pos, gfx::Size(640, 480));
+      widget()->SetBounds(bounds);
+    }
   }
 
 #if BUILDFLAG(IS_CHROMEOS_ASH)
@@ -229,6 +267,9 @@
 // views::WidgetDelegate implementation.
 
 ui::ImageModel ChromeNativeAppWindowViews::GetWindowAppIcon() {
+  gfx::Image icon_override = app_window()->icon_override();
+  if (!icon_override.IsEmpty())
+    return ui::ImageModel::FromImageSkia(*icon_override.ToImageSkia());
   // Resulting icon is cached in aura::client::kAppIconKey window property.
   const gfx::Image& custom_image = GetCustomImage();
   if (app_window()->app_icon_url().is_valid() &&
@@ -262,6 +303,9 @@
 }
 
 ui::ImageModel ChromeNativeAppWindowViews::GetWindowIcon() {
+  gfx::Image icon_override = app_window()->icon_override();
+  if (!icon_override.IsEmpty())
+    return ui::ImageModel::FromImageSkia(*icon_override.ToImageSkia());
   // Resulting icon is cached in aura::client::kWindowIconKey window property.
   content::WebContents* web_contents = app_window()->web_contents();
   if (web_contents) {
@@ -295,6 +339,14 @@
   auto iter = accelerator_table.find(accelerator);
   DCHECK(iter != accelerator_table.end());
   int command_id = iter->second;
+#if defined(NWJS_SDK)
+  content::WebContents* web_contents;
+  bool enable_devtools = true;
+  const base::CommandLine* command_line =
+      base::CommandLine::ForCurrentProcess();
+  if (command_line->HasSwitch(switches::kDisableDevTools))
+    enable_devtools = false;
+#endif
   switch (command_id) {
     case IDC_CLOSE_WINDOW:
       Close();
@@ -310,7 +362,25 @@
     case IDC_ZOOM_PLUS:
       zoom::PageZoom::Zoom(web_view()->GetWebContents(), content::PAGE_ZOOM_IN);
       return true;
-    default:
+#if defined(NWJS_SDK)
+    case IDC_DEV_TOOLS:
+      if (!enable_devtools)
+        return true;
+      web_contents = app_window()->web_contents();
+      if (web_contents) {
+        DevToolsWindow::OpenDevToolsWindow(web_contents);
+      }
+      return true;
+    case IDC_DEV_TOOLS_TOGGLE:
+      if (!enable_devtools)
+        return true;
+      web_contents = app_window()->web_contents();
+      if (web_contents) {
+        DevToolsWindow::OpenDevToolsWindow(web_contents, DevToolsToggleAction::Toggle());
+      }
+      return true;
+#endif
+  default:
       NOTREACHED() << "Unknown accelerator sent to app window.";
   }
   return NativeAppWindowViews::AcceleratorPressed(accelerator);
diff -r -u --color up/chromium/chrome/browser/ui/views/apps/chrome_native_app_window_views.h nw/chromium/chrome/browser/ui/views/apps/chrome_native_app_window_views.h
--- up/chromium/chrome/browser/ui/views/apps/chrome_native_app_window_views.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/apps/chrome_native_app_window_views.h	2023-01-28 02:49:23.895572000 +0000
@@ -54,6 +54,7 @@
       views::Widget* widget) override;
   bool WidgetHasHitTestMask() const override;
   void GetWidgetHitTestMask(SkPath* mask) const override;
+  bool NWCanClose(bool user_force = false) const override;
 
   // views::View implementation.
   bool AcceleratorPressed(const ui::Accelerator& accelerator) override;
diff -r -u --color up/chromium/chrome/browser/ui/views/apps/chrome_native_app_window_views_aura.cc nw/chromium/chrome/browser/ui/views/apps/chrome_native_app_window_views_aura.cc
--- up/chromium/chrome/browser/ui/views/apps/chrome_native_app_window_views_aura.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/apps/chrome_native_app_window_views_aura.cc	2023-01-28 02:49:23.895572000 +0000
@@ -39,6 +39,7 @@
     case ui::SHOW_STATE_NORMAL:
     case ui::SHOW_STATE_MAXIMIZED:
     case ui::SHOW_STATE_FULLSCREEN:
+    case ui::SHOW_STATE_HIDDEN:
       return restore_state;
 
     case ui::SHOW_STATE_DEFAULT:
diff -r -u --color up/chromium/chrome/browser/ui/views/apps/glass_app_window_frame_view_win.cc nw/chromium/chrome/browser/ui/views/apps/glass_app_window_frame_view_win.cc
--- up/chromium/chrome/browser/ui/views/apps/glass_app_window_frame_view_win.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/apps/glass_app_window_frame_view_win.cc	2023-01-28 02:49:23.895572000 +0000
@@ -63,6 +63,9 @@
 }
 
 gfx::Rect GlassAppWindowFrameViewWin::GetBoundsForClientView() const {
+#if 1
+  return bounds();
+#else
   if (widget_->IsFullscreen())
     return bounds();
 
@@ -71,6 +74,7 @@
                    insets.top(),
                    std::max(0, width() - insets.left() - insets.right()),
                    std::max(0, height() - insets.top() - insets.bottom()));
+#endif
 }
 
 gfx::Rect GlassAppWindowFrameViewWin::GetWindowBoundsForClientBounds(
@@ -98,6 +102,11 @@
   if (!bounds().Contains(point))
     return HTNOWHERE;
 
+  int client_component = widget_->client_view()->NonClientHitTest(point);
+  if (client_component != HTNOWHERE)
+    return client_component;
+
+
   // Check the frame first, as we allow a small area overlapping the contents
   // to be used for resize handles.
   bool can_ever_resize = widget_->widget_delegate()
@@ -113,10 +122,6 @@
   if (frame_component != HTNOWHERE)
     return frame_component;
 
-  int client_component = widget_->client_view()->NonClientHitTest(point);
-  if (client_component != HTNOWHERE)
-    return client_component;
-
   // Caption is a safe default.
   return HTCAPTION;
 }
diff -r -u --color up/chromium/chrome/browser/ui/views/autofill/autofill_popup_base_view.cc nw/chromium/chrome/browser/ui/views/autofill/autofill_popup_base_view.cc
--- up/chromium/chrome/browser/ui/views/autofill/autofill_popup_base_view.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/autofill/autofill_popup_base_view.cc	2023-01-28 02:49:23.895572000 +0000
@@ -8,6 +8,10 @@
 #include <memory>
 #include <utility>
 
+#include "chrome/browser/apps/platform_apps/app_window_registry_util.h"
+#include "extensions/browser/app_window/app_window.h"
+#include "extensions/browser/app_window/native_app_window.h"
+
 #include "base/bind.h"
 #include "base/dcheck_is_on.h"
 #include "base/location.h"
diff -r -u --color up/chromium/chrome/browser/ui/views/chrome_views_delegate.cc nw/chromium/chrome/browser/ui/views/chrome_views_delegate.cc
--- up/chromium/chrome/browser/ui/views/chrome_views_delegate.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/chrome_views_delegate.cc	2023-01-28 02:49:23.911572169 +0000
@@ -7,6 +7,8 @@
 #include <memory>
 
 #include "base/check_op.h"
+#include "content/nw/src/nw_content.h"
+
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
 #include "chrome/browser/browser_process.h"
@@ -97,6 +99,7 @@
   window_preferences.Set("right", bounds.right());
   window_preferences.Set("bottom", bounds.bottom());
   window_preferences.Set("maximized", show_state == ui::SHOW_STATE_MAXIMIZED);
+  window_preferences.Set("fullscreen", show_state == ui::SHOW_STATE_FULLSCREEN);
 
   gfx::Rect work_area(display::Screen::GetScreen()
                           ->GetDisplayNearestView(window->GetNativeView())
@@ -127,8 +130,11 @@
 
   bounds->SetRect(*left, *top, *right - *left, *bottom - *top);
 
-  const bool maximized = dictionary.FindBool("maximized").value_or(false);
+  bool maximized = dictionary.FindBool("maximized").value_or(false);
+  bool fullscreen = dictionary.FindBool("fullscreen").value_or(false);
   *show_state = maximized ? ui::SHOW_STATE_MAXIMIZED : ui::SHOW_STATE_NORMAL;
+  if (fullscreen)
+    *show_state = ui::SHOW_STATE_FULLSCREEN;
 
 #if BUILDFLAG(IS_CHROMEOS_ASH)
   AdjustSavedWindowPlacementChromeOS(widget, bounds);
diff -r -u --color up/chromium/chrome/browser/ui/views/chrome_views_delegate_linux.cc nw/chromium/chrome/browser/ui/views/chrome_views_delegate_linux.cc
--- up/chromium/chrome/browser/ui/views/chrome_views_delegate_linux.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/chrome_views_delegate_linux.cc	2023-01-28 02:49:23.911572169 +0000
@@ -7,6 +7,8 @@
 #include "base/environment.h"
 #include "base/nix/xdg_util.h"
 #include "build/branding_buildflags.h"
+#include "content/nw/src/nw_content.h"
+
 #include "chrome/browser/ui/views/native_widget_factory.h"
 #include "chrome/common/channel_info.h"
 #include "chrome/grit/chrome_unscaled_resources.h"
@@ -69,6 +71,9 @@
 
 #if BUILDFLAG(IS_LINUX)
 gfx::ImageSkia* ChromeViewsDelegate::GetDefaultWindowIcon() const {
+  gfx::ImageSkia* ret = nw::GetAppIcon();
+  if (ret)
+    return ret;
   ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
   return rb.GetImageSkiaNamed(GetWindowIconResourceId());
 }
diff -r -u --color up/chromium/chrome/browser/ui/views/constrained_web_dialog_delegate_views.cc nw/chromium/chrome/browser/ui/views/constrained_web_dialog_delegate_views.cc
--- up/chromium/chrome/browser/ui/views/constrained_web_dialog_delegate_views.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/constrained_web_dialog_delegate_views.cc	2023-01-28 02:49:23.911572169 +0000
@@ -209,6 +209,7 @@
 
   // ui::WebDialogWebContentsDelegate:
   void CloseContents(content::WebContents* source) override {
+    if (view_->GetWidget())
     view_->GetWidget()->Close();
   }
 
diff -r -u --color up/chromium/chrome/browser/ui/views/download/download_item_view.cc nw/chromium/chrome/browser/ui/views/download/download_item_view.cc
--- up/chromium/chrome/browser/ui/views/download/download_item_view.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/download/download_item_view.cc	2023-01-28 02:49:23.923572296 +0000
@@ -818,6 +818,7 @@
     StyleFilename(*warning_label_, filename_offset, filename.length());
     warning_label_->SizeToFit(GetLabelWidth(*warning_label_));
   }
+#if 0
 
   deep_scanning_label_->SetVisible(mode_ ==
                                    download::DownloadItemMode::kDeepScanning);
@@ -834,6 +835,7 @@
     StyleFilename(*deep_scanning_label_, filename_offset, filename.length());
     deep_scanning_label_->SizeToFit(GetLabelWidth(*deep_scanning_label_));
   }
+#endif
 }
 
 void DownloadItemView::UpdateButtons() {
@@ -1284,6 +1286,9 @@
 }
 
 void DownloadItemView::ShowOpenDialog(content::WebContents* web_contents) {
+#if 1
+  ExecuteCommand(DownloadCommands::BYPASS_DEEP_SCANNING);
+#else
   if (mode_ == download::DownloadItemMode::kDeepScanning) {
     TabModalConfirmDialog::Create(
         std::make_unique<safe_browsing::DeepScanningModalDialog>(
@@ -1301,6 +1306,7 @@
                        weak_ptr_factory_.GetWeakPtr(),
                        DownloadCommands::BYPASS_DEEP_SCANNING));
   }
+#endif
 }
 
 void DownloadItemView::ShowContextMenuImpl(const gfx::Rect& rect,
@@ -1337,7 +1343,7 @@
 }
 
 void DownloadItemView::OpenDownloadDuringAsyncScanning() {
-  model_->CompleteSafeBrowsingScan();
+  //model_->CompleteSafeBrowsingScan();
   model_->SetOpenWhenComplete(true);
 }
 
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_linux.cc nw/chromium/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_linux.cc
--- up/chromium/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_linux.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_linux.cc	2023-01-28 02:49:23.935572423 +0000
@@ -258,7 +258,7 @@
     const views::Widget::InitParams& params) {
   DesktopWindowTreeHostLinux::Init(std::move(params));
 
-#if defined(USE_DBUS_MENU)
+#if 0 //defined(USE_DBUS_MENU)
   // We have now created our backing X11 window.  We now need to (possibly)
   // alert the desktop environment that there's a menu bar attached to it.
   if (CreateGlobalMenuBar()) {
@@ -275,7 +275,7 @@
 }
 
 void BrowserDesktopWindowTreeHostLinux::CloseNow() {
-#if defined(USE_DBUS_MENU)
+#if 0//defined(USE_DBUS_MENU)
   dbus_appmenu_.reset();
 #endif
   DesktopWindowTreeHostLinux::CloseNow();
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.cc nw/chromium/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.cc
--- up/chromium/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.cc	2023-01-28 02:49:23.935572423 +0000
@@ -314,6 +314,11 @@
 bool BrowserDesktopWindowTreeHostWin::GetClientAreaInsets(
     gfx::Insets* insets,
     HMONITOR monitor) const {
+  //NWJS#7221, this is called during NCCALCSIZE handler
+  //without this, it will lead to a window with white bg shown
+  //initially during first ShowWindow call.
+  if (browser_view_->browser()->is_transparent())
+    return false;
   // Always use default insets for opaque frame.
   if (!ShouldUseNativeFrame())
     return false;
@@ -327,7 +332,7 @@
     // In fullscreen mode there is no frame.
     *insets = gfx::Insets();
   } else {
-    const int frame_thickness = ui::GetFrameThickness(monitor);
+    const int frame_thickness = browser_view_->CanResize() ? ui::GetFrameThickness(monitor) : 1;
     // Reduce the non-client border size; UpdateDWMFrame() will instead extend
     // the border into the window client area. For maximized windows, Windows
     // outdents the window rect from the screen's client rect by
@@ -408,7 +413,8 @@
 void BrowserDesktopWindowTreeHostWin::HandleFrameChanged() {
   // Reinitialize the status bubble, since it needs to be initialized
   // differently depending on whether or not DWM composition is enabled
-  browser_view_->InitStatusBubble();
+  //browser_view_->InitStatusBubble();
+
   DesktopWindowTreeHostWin::HandleFrameChanged();
 }
 
@@ -510,7 +516,10 @@
   // context of the BrowserView destructor.
   if (!browser_view_->browser())
     return false;
-
+  if (browser_view_->browser()->is_transparent())
+    return true;
+  if (browser_view_->browser()->is_frameless())
+    return false;
   if (IsOpaqueHostedAppFrame())
     return false;
 
@@ -526,8 +535,8 @@
 
 bool BrowserDesktopWindowTreeHostWin::ShouldWindowContentsBeTransparent()
     const {
-  return !ShouldCustomDrawSystemTitlebar() &&
-         views::DesktopWindowTreeHostWin::ShouldWindowContentsBeTransparent();
+  return browser_view_->browser()->is_transparent() || (!ShouldCustomDrawSystemTitlebar() &&
+         views::DesktopWindowTreeHostWin::ShouldWindowContentsBeTransparent());
 }
 
 ////////////////////////////////////////////////////////////////////////////////
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_frame.cc nw/chromium/chrome/browser/ui/views/frame/browser_frame.cc
--- up/chromium/chrome/browser/ui/views/frame/browser_frame.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_frame.cc	2023-01-28 02:49:23.935572423 +0000
@@ -5,6 +5,15 @@
 #include "chrome/browser/ui/views/frame/browser_frame.h"
 
 #include <memory>
+
+#if defined(USE_AURA)
+#if defined(OS_WIN)
+#include "ui/views/win/hwnd_util.h"
+#endif
+#include "ui/aura/window.h"
+#include "chrome/browser/ui/views/apps/app_window_easy_resize_window_targeter.h"
+#endif
+
 #include <utility>
 
 #include "base/bind.h"
@@ -66,8 +75,8 @@
 ////////////////////////////////////////////////////////////////////////////////
 // BrowserFrame, public:
 
-BrowserFrame::BrowserFrame(BrowserView* browser_view)
-    : native_browser_frame_(nullptr),
+BrowserFrame::BrowserFrame(BrowserView* browser_view, bool frameless)
+    : frameless_(frameless), native_browser_frame_(nullptr),
       root_view_(nullptr),
       browser_frame_view_(nullptr),
       browser_view_(browser_view) {
@@ -79,11 +88,20 @@
 
 BrowserFrame::~BrowserFrame() {}
 
-void BrowserFrame::InitBrowserFrame() {
+bool BrowserFrame::InitBrowserFrame() {
+  bool got_saved_bounds = false;
   native_browser_frame_ =
       NativeBrowserFrameFactory::CreateNativeBrowserFrame(this, browser_view_);
   views::Widget::InitParams params = native_browser_frame_->GetWidgetParams();
   params.name = "BrowserFrame";
+  if (frameless_)
+    params.remove_standard_frame = true;
+  if (browser_view_->browser()->is_transparent())
+    params.opacity = views::Widget::InitParams::WindowOpacity::kTranslucent;
+  if (browser_view_->browser()->initial_ontop())
+    params.z_order = ui::ZOrderLevel::kFloatingWindow;
+  if (browser_view_->browser()->initial_allvisible())
+    params.visible_on_all_workspaces = true;
   params.delegate = browser_view_;
   params.headless_mode = headless::IsHeadlessMode();
 
@@ -99,14 +117,14 @@
 
   if (native_browser_frame_->ShouldRestorePreviousBrowserWidgetState()) {
     if (browser->is_type_normal() || browser->is_type_devtools() ||
-        browser->is_type_app()) {
+        browser->is_type_app() || browser->is_type_popup()) {
       // Typed panel/popup can only return a size once the widget has been
       // created.
       // DevTools counts as a popup, but DevToolsWindow::CreateDevToolsBrowser
       // ensures there is always a size available. Without this, the tools
       // launch on the wrong display and can have sizing issues when
       // repositioned to the saved bounds in Widget::SetInitialBounds.
-      chrome::GetSavedWindowBoundsAndShowState(browser, &params.bounds,
+      got_saved_bounds = chrome::GetSavedWindowBoundsAndShowState(browser, &params.bounds,
                                                &params.show_state);
 
       params.workspace = browser->initial_workspace();
@@ -127,10 +145,23 @@
   Init(std::move(params));
   SelectNativeTheme();
 
+#if defined(USE_AURA)
+  if (frameless_) {
+#if 0
+    HWND hwnd = views::HWNDForWidget(GetTopLevelWidget());
+    int current_style = ::GetWindowLong(hwnd, GWL_STYLE);
+    ::SetWindowLong(hwnd, GWL_STYLE, current_style | WS_CAPTION);
+#endif
+    aura::Window* window = browser_view_->GetWidget()->GetNativeWindow();
+    window->SetEventTargeter(std::make_unique<AppWindowEasyResizeWindowTargeter>(
+      gfx::Insets(5), browser_view_));
+  }
+#endif
   if (!native_browser_frame_->UsesNativeSystemMenu()) {
     DCHECK(non_client_view());
     non_client_view()->set_context_menu_controller(this);
   }
+  return got_saved_bounds;
 }
 
 int BrowserFrame::GetMinimizeButtonOffset() const {
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_frame.h nw/chromium/chrome/browser/ui/views/frame/browser_frame.h
--- up/chromium/chrome/browser/ui/views/frame/browser_frame.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_frame.h	2023-01-28 02:49:23.935572423 +0000
@@ -56,7 +56,7 @@
 // This is a virtual interface that allows system specific browser frames.
 class BrowserFrame : public views::Widget, public views::ContextMenuController {
  public:
-  explicit BrowserFrame(BrowserView* browser_view);
+  explicit BrowserFrame(BrowserView* browser_view, bool frameless = false);
 
   BrowserFrame(const BrowserFrame&) = delete;
   BrowserFrame& operator=(const BrowserFrame&) = delete;
@@ -72,7 +72,7 @@
 #endif
 
   // Initialize the frame (creates the underlying native window).
-  void InitBrowserFrame();
+  bool InitBrowserFrame();
 
   // Determine the distance of the left edge of the minimize button from the
   // left edge of the window. Used in our Non-Client View's Layout.
@@ -157,6 +157,7 @@
   void SetTabDragKind(TabDragKind tab_drag_kind);
   TabDragKind tab_drag_kind() const { return tab_drag_kind_; }
 
+  bool frameless() { return frameless_; }
  protected:
   // views::Widget:
   ui::ColorProviderManager::Key GetColorProviderKey() const override;
@@ -173,6 +174,7 @@
   // Regenerate the frame on theme change if necessary. Returns true if
   // regenerated.
   bool RegenerateFrameOnThemeChange(BrowserThemeChangeType theme_change_type);
+  bool frameless_;
 
   // Returns whether the browser should always use the dark theme no matter user
   // makes any selection.
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_frame_mac.mm nw/chromium/chrome/browser/ui/views/frame/browser_frame_mac.mm
--- up/chromium/chrome/browser/ui/views/frame/browser_frame_mac.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_frame_mac.mm	2023-01-28 02:49:23.935572423 +0000
@@ -6,6 +6,8 @@
 
 #import "chrome/browser/ui/views/frame/browser_frame_mac.h"
 
+#include "ui/display/display.h"
+
 #import "base/mac/foundation_util.h"
 #include "chrome/app/chrome_command_ids.h"
 #include "chrome/browser/apps/app_shim/app_shim_host_mac.h"
@@ -133,6 +135,7 @@
 // BrowserFrameMac, views::NativeWidgetMac implementation:
 
 int32_t BrowserFrameMac::SheetOffsetY() {
+  return 0; //NWJS#7349
   // ModalDialogHost::GetDialogPosition() is relative to the host view. In
   // practice, this ends up being the widget's content view.
   web_modal::WebContentsModalDialogHost* dialog_host =
@@ -365,8 +368,16 @@
     params->window_class = remote_cocoa::mojom::WindowClass::kDefault;
     params->style_mask = NSWindowStyleMaskBorderless;
     params->window_title_hidden = true;
+  } else if (browser_view_->browser()->is_frameless()) {
+    params->window_class = remote_cocoa::mojom::WindowClass::kFrameless;
+    params->style_mask = NSWindowStyleMaskTitled | NSWindowStyleMaskClosable |
+                         NSWindowStyleMaskMiniaturizable |
+                         NSWindowStyleMaskResizable |
+                         NSWindowStyleMaskFullSizeContentView;
   } else {
     params->window_class = remote_cocoa::mojom::WindowClass::kDefault;
+    if (widget_params.remove_standard_frame)
+      params->style_mask = NSWindowStyleMaskBorderless;
   }
   params->animation_enabled = true;
 }
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_non_client_frame_view_factory_views.cc nw/chromium/chrome/browser/ui/views/frame/browser_non_client_frame_view_factory_views.cc
--- up/chromium/chrome/browser/ui/views/frame/browser_non_client_frame_view_factory_views.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_non_client_frame_view_factory_views.cc	2023-01-28 02:49:23.935572423 +0000
@@ -92,7 +92,7 @@
 #endif
 
 #if BUILDFLAG(IS_WIN)
-  if (frame->ShouldUseNativeFrame())
+  if (frame->ShouldUseNativeFrame() && !browser_view->browser()->is_transparent())
     return std::make_unique<GlassBrowserFrameView>(frame, browser_view);
 #endif
   auto view = CreateOpaqueBrowserFrameView(frame, browser_view);
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_non_client_frame_view_mac.h nw/chromium/chrome/browser/ui/views/frame/browser_non_client_frame_view_mac.h
--- up/chromium/chrome/browser/ui/views/frame/browser_non_client_frame_view_mac.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_non_client_frame_view_mac.h	2023-01-28 02:49:23.935572423 +0000
@@ -67,6 +67,7 @@
   gfx::Size GetMinimumSize() const override;
   void AddedToWidget() override;
   void PaintChildren(const views::PaintInfo& info) override;
+  gfx::Size GetMaximumSize() const override;
 
   // web_app::AppRegistrarObserver
   void OnAlwaysShowToolbarInFullscreenChanged(const web_app::AppId& app_id,
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_non_client_frame_view_mac.mm nw/chromium/chrome/browser/ui/views/frame/browser_non_client_frame_view_mac.mm
--- up/chromium/chrome/browser/ui/views/frame/browser_non_client_frame_view_mac.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_non_client_frame_view_mac.mm	2023-01-28 02:49:23.935572423 +0000
@@ -329,6 +329,9 @@
   // BrowserView::NonClientHitTest will return HTNOWHERE for points that hit
   // the native title bar. On Mac, we need to explicitly return HTCAPTION for
   // those points.
+  SkRegion* draggable_region = browser_view()->GetDraggableRegion();
+  if (draggable_region && draggable_region->contains(point.x(), point.y()))
+    return HTCAPTION;
   const int component = frame()->client_view()->NonClientHitTest(point);
   return (component == HTNOWHERE && bounds().Contains(point)) ? HTCAPTION
                                                               : component;
@@ -392,7 +395,7 @@
   // certain height, which empirically seems to be related to their *minimum*
   // width rather than their current width. This 4:3 ratio was chosen
   // empirically because it looks decent for both tabbed and untabbed browsers.
-  client_size.SetToMax(gfx::Size(0, (client_size.width() * 3) / 4));
+  //client_size.SetToMax(gfx::Size(0, (client_size.width() * 3) / 4));
 
   return client_size;
 }
@@ -416,6 +419,11 @@
     BrowserNonClientFrameView::PaintChildren(info);
 }
 
+gfx::Size BrowserNonClientFrameViewMac::GetMaximumSize() const {
+  gfx::Size client_size = frame()->client_view()->GetMaximumSize();
+  return client_size;
+}
+
 ///////////////////////////////////////////////////////////////////////////////
 // BrowserNonClientFrameViewMac, protected:
 
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_view.cc nw/chromium/chrome/browser/ui/views/frame/browser_view.cc
--- up/chromium/chrome/browser/ui/views/frame/browser_view.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_view.cc	2023-01-28 02:49:23.939572465 +0000
@@ -1,9 +1,34 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wunreachable-code"
 
 #include "chrome/browser/ui/views/frame/browser_view.h"
 
+#include "chrome/browser/extensions/api/tabs/tabs_windows_api.h"
+#include "chrome/browser/extensions/api/tabs/windows_event_router.h"
+#include "chrome/browser/extensions/browser_extension_window_controller.h"
+#include "components/favicon/content/content_favicon_driver.h"
+#include "content/public/browser/render_widget_host.h"
+
+#if defined(OS_MAC)
+#include "content/nw/src/nw_content_mac.h"
+#endif
+
+#if defined(OS_WIN)
+#include <shobjidl.h>
+#include <dwmapi.h>
+
+#include "base/win/windows_version.h"
+#include "ui/base/win/hidden_window.h"
+#include "ui/gfx/canvas.h"
+#include "ui/gfx/icon_util.h"
+#include "ui/gfx/font_list.h"
+#include "ui/gfx/platform_font.h"
+#include "ui/display/win/dpi.h"
+#include "ui/views/win/hwnd_util.h"
+#endif
+
 #include <stdint.h>
 
 #include <memory>
@@ -275,6 +300,9 @@
 #include "components/remote_cocoa/browser/application_host.h"
 #endif
 
+#include "extensions/browser/app_window/app_window.h"
+#include "extensions/browser/app_window/app_window_registry.h"
+
 #if defined(USE_AURA)
 #include "chrome/browser/ui/views/theme_profile_key.h"
 #include "ui/aura/client/window_parenting_client.h"
@@ -304,6 +332,8 @@
 #include "chrome/browser/ui/views/lens/lens_side_panel_controller.h"
 #endif
 
+using extensions::DraggableRegion;
+
 using base::UserMetricsAction;
 using content::NativeWebKeyboardEvent;
 using content::WebContents;
@@ -369,6 +399,20 @@
 
 #endif  // DCHECK_IS_ON()
 
+SkRegion* RawDraggableRegionsToSkRegion(
+    const std::vector<DraggableRegion>& regions) {
+  SkRegion* sk_region = new SkRegion;
+  for (std::vector<DraggableRegion>::const_iterator iter = regions.begin();
+       iter != regions.end(); ++iter) {
+    const DraggableRegion& region = *iter;
+    sk_region->op(
+                  SkIRect::MakeLTRB(region.bounds.x(), region.bounds.y(), region.bounds.right(),
+                                    region.bounds.bottom()),
+        region.draggable ? SkRegion::kUnion_Op : SkRegion::kDifference_Op);
+  }
+  return sk_region;
+}
+
 bool GetGestureCommand(ui::GestureEvent* event, int* command) {
   DCHECK(command);
   *command = 0;
@@ -839,6 +883,7 @@
       browser_(std::move(browser)),
       accessibility_mode_observer_(
           std::make_unique<AccessibilityModeObserver>(this)) {
+  CHECK(browser_->is_type_popup() || browser_->is_type_devtools()) << "opening browser window.";
   SetShowIcon(
       ::ShouldShowWindowIcon(browser_.get(), AppUsesWindowControlsOverlay()));
 
@@ -880,6 +925,14 @@
   }
 
   browser_->tab_strip_model()->AddObserver(this);
+  resizable_ = browser_->initial_resizable();
+#if defined(OS_LINUX) || defined(OS_WIN)
+  if (!resizable_) {
+    gfx::Size size = browser_->override_bounds().size();
+    size_constraints_.set_minimum_size(size);
+    size_constraints_.set_maximum_size(size);
+  }
+#endif
   immersive_mode_controller_ = chrome::CreateImmersiveModeController(this);
 
   // Top container holds tab strip region and toolbar and lives at the front of
@@ -914,10 +967,12 @@
   devtools_web_view->SetVisible(false);
 
   auto contents_web_view =
-      std::make_unique<ContentsWebView>(browser_->profile());
+    std::make_unique<ContentsWebView>(browser_->profile(), browser_->is_transparent());
   contents_web_view->SetID(VIEW_ID_TAB_CONTAINER);
 
   auto contents_container = std::make_unique<views::View>();
+  if (browser_->is_transparent())
+    contents_container->SetBackground(views::CreateSolidBackground(SK_ColorTRANSPARENT));
   devtools_web_view_ =
       contents_container->AddChildView(std::move(devtools_web_view));
   contents_web_view_ =
@@ -982,7 +1037,7 @@
   infobar_container_ =
       AddChildView(std::make_unique<InfoBarContainerView>(this));
 
-  InitStatusBubble();
+  //InitStatusBubble();
 
   // Create do-nothing view for the sake of controlling the z-order of the find
   // bar widget.
@@ -1010,6 +1065,90 @@
   }
 }
 
+void BrowserView::ForceClose() {
+  GetWidget()->Close(true);
+}
+bool BrowserView::NWCanClose(bool user_force) const {
+  return browser_->NWCanClose(user_force);
+}
+
+void BrowserView::UpdateDraggableRegions(
+    const std::vector<extensions::DraggableRegion>& regions) {
+  // Draggable region is not supported for non-frameless window.
+  if (!browser_->is_frameless())
+    return;
+
+  draggable_region_.reset(RawDraggableRegionsToSkRegion(regions));
+  //OnViewWasResized();
+}
+
+
+void BrowserView::SetShowInTaskbar(bool show) {
+#if defined(OS_WIN)
+  views::Widget* widget = GetWidget()->GetTopLevelWidget();
+
+  if (show == false && base::win::GetVersion() < base::win::Version::VISTA) {
+    // Change the owner of native window. Only needed on Windows XP.
+    ::SetParent(views::HWNDForWidget(widget),
+                ui::GetHiddenWindow());
+  }
+
+  Microsoft::WRL::ComPtr<ITaskbarList3> taskbar;
+  HRESULT result = ::CoCreateInstance(CLSID_TaskbarList, nullptr,
+                                      CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&taskbar));
+  if (FAILED(result)) {
+    VLOG(1) << "Failed creating a TaskbarList object: " << result;
+    return;
+  }
+
+  result = taskbar->HrInit();
+  if (FAILED(result)) {
+    LOG(ERROR) << "Failed initializing an ITaskbarList interface.";
+    return;
+  }
+
+  if (show)
+    result = taskbar->AddTab(views::HWNDForWidget(widget));
+  else
+    result = taskbar->DeleteTab(views::HWNDForWidget(widget));
+
+  if (FAILED(result)) {
+    LOG(ERROR) << "Failed to change the show in taskbar attribute";
+    return;
+  }
+#elif defined(OS_MAC)
+  NWSetNSWindowShowInTaskbar(browser()->window()->GetNativeWindow(), show);
+#endif
+}
+
+SkRegion* BrowserView::GetDraggableRegion() {
+  return draggable_region_.get();
+}
+
+void BrowserView::SetAllVisible(bool visible) {
+  frame_->SetVisibleOnAllWorkspaces(visible);
+}
+
+void BrowserView::SetResizable(bool resizable) {
+  resizable_ = resizable;
+  SetCanResize(resizable_);
+#if defined(OS_LINUX) || defined(OS_WIN)
+  if (!resizable) {
+    size_constraints_.set_minimum_size(GetContentsSize());
+    size_constraints_.set_maximum_size(GetContentsSize());
+  } else {
+    size_constraints_ = saved_size_constraints_;
+#if defined(OS_LINUX) //NWJS#6609
+    if (size_constraints_.HasFixedSize())
+      size_constraints_ = extensions::SizeConstraints();
+#endif
+  }
+#endif
+  GetWidget()->OnSizeConstraintsChanged();
+  frame_->non_client_view()->ResetWindowControls();
+  frame_->non_client_view()->Layout();
+}
+
 BrowserView::~BrowserView() {
   // Destroy the top controls slide controller first as it depends on the
   // tabstrip model and the browser frame.
@@ -1319,7 +1458,7 @@
 }
 
 void BrowserView::Hide() {
-  // Not implemented.
+  frame_->Hide();
 }
 
 bool BrowserView::IsVisible() const {
@@ -1334,6 +1473,13 @@
   frame_->SetBounds(bounds);
 }
 
+#if defined(OS_WIN)
+void BrowserView::SetPosition(const gfx::Point& pos) {
+  ExitFullscreen();
+  GetWidget()->SetPosition(pos);
+}
+#endif
+
 void BrowserView::Close() {
   frame_->Close();
 }
@@ -1359,8 +1505,7 @@
 }
 
 void BrowserView::SetZOrderLevel(ui::ZOrderLevel level) {
-  // Not implemented for browser windows.
-  NOTIMPLEMENTED();
+  frame_->SetZOrderLevel(level);
 }
 
 gfx::NativeWindow BrowserView::GetNativeWindow() const {
@@ -1670,6 +1815,7 @@
   // Update all the UI bits.
   UpdateTitleBar();
 
+#if 0
   if (old_contents) {
     TranslateBubbleController* translate_bubble_controller =
         TranslateBubbleController::FromWebContents(old_contents);
@@ -1677,6 +1823,7 @@
     if (translate_bubble_controller)
       translate_bubble_controller->CloseBubble();
   }
+#endif
 
   // This is only done once when the app is first opened so that there is only
   // one subscriber per web contents.
@@ -1870,7 +2017,7 @@
   // top that gives the user a hover target. In a public session we show the
   // bubble.
   // TODO(jamescook): Figure out what to do with mouse-lock.
-  if (is_trusted_pinned ||
+  if (true || is_trusted_pinned ||
       (!notify_download && bubble_type == EXCLUSIVE_ACCESS_BUBBLE_TYPE_NONE) ||
       (ShouldUseImmersiveFullscreenForUrl(url) &&
        !profiles::IsPublicSession())) {
@@ -1940,9 +2087,9 @@
   bool fullscreen = IsFullscreen();
   ProcessFullscreen(
       fullscreen, GURL(),
-      fullscreen
+      /*fullscreen
           ? GetExclusiveAccessManager()->GetExclusiveAccessExitBubbleType()
-          : EXCLUSIVE_ACCESS_BUBBLE_TYPE_NONE,
+          : */EXCLUSIVE_ACCESS_BUBBLE_TYPE_NONE,
       display::kInvalidDisplayId);
 }
 
@@ -2701,6 +2848,7 @@
     return ShowTranslateBubbleResult::EDITABLE_FIELD_IS_ACTIVE;
   }
 
+#if 0
   ChromeTranslateClient::FromWebContents(web_contents)
       ->GetTranslateManager()
       ->GetLanguageState()
@@ -2720,12 +2868,14 @@
                             is_user_gesture ? TranslateBubbleView::USER_GESTURE
                                             : TranslateBubbleView::AUTOMATIC);
 
+#endif
   return ShowTranslateBubbleResult::SUCCESS;
 }
 
 void BrowserView::StartPartialTranslate(const std::string& source_language,
                                         const std::string& target_language,
                                         const std::u16string& text_selection) {
+#if 0
   // Show the Translate icon and enabled the associated command to show the
   // Translate UI.
   ChromeTranslateClient::FromWebContents(GetActiveWebContents())
@@ -2739,6 +2889,7 @@
                               toolbar_button_provider()->GetPageActionIconView(
                                   PageActionIconType::kTranslate),
                               source_language, target_language, text_selection);
+#endif
 }
 
 void BrowserView::ShowOneClickSigninConfirmation(
@@ -3062,6 +3213,18 @@
 ///////////////////////////////////////////////////////////////////////////////
 // BrowserView, views::WidgetDelegate implementation:
 
+bool BrowserView::CanResize() const {
+#if defined(OS_MAC)
+  return resizable_;
+#else
+  return true;
+#endif
+}
+
+bool BrowserView::CanMaximize() const {
+  return resizable_ && size_constraints_.GetMaximumSize().IsEmpty() && !WidgetHasHitTestMask();
+}
+
 bool BrowserView::CanActivate() const {
   javascript_dialogs::AppModalDialogQueue* queue =
       javascript_dialogs::AppModalDialogQueue::GetInstance();
@@ -3347,17 +3510,82 @@
 }
 
 ui::ImageModel BrowserView::GetWindowAppIcon() {
+#if 1
+  if (browser_->is_type_devtools()) {
+    WebContents* contents = browser_->tab_strip_model()->GetActiveWebContents();
+    DevToolsWindow* devtools_window =
+        DevToolsWindow::AsDevToolsWindow(contents);
+    if (devtools_window) {
+      WebContents* inspected_contents =
+          devtools_window->GetInspectedWebContents();
+      if (!inspected_contents)
+        return ui::ImageModel();
+      Browser* browser = chrome::FindBrowserWithWebContents(inspected_contents);
+      if (browser && !browser->icon_override().IsEmpty())
+        return ui::ImageModel::FromImage(browser->icon_override());
+      favicon::FaviconDriver* favicon_driver =
+          favicon::ContentFaviconDriver::FromWebContents(inspected_contents);
+      gfx::Image app_icon;
+      if (favicon_driver)
+        app_icon = favicon_driver->GetFavicon();
+      if (!app_icon.IsEmpty())
+        return ui::ImageModel::FromImage(app_icon);
+      Profile* profile =
+          Profile::FromBrowserContext(contents->GetBrowserContext());
+      extensions::AppWindowRegistry* registry =
+          extensions::AppWindowRegistry::Get(profile);
+      if (registry) {
+        extensions::AppWindow* app_window =
+            registry->GetAppWindowForWebContents(inspected_contents);
+        if (app_window)
+          return ui::ImageModel::FromImageSkia(app_window->custom_app_icon().AsImageSkia());
+      }
+    }
+  }
+#endif
   web_app::AppBrowserController* app_controller = browser()->app_controller();
   return app_controller ? app_controller->GetWindowAppIcon() : GetWindowIcon();
 }
 
 ui::ImageModel BrowserView::GetWindowIcon() {
+  gfx::Image icon_override = browser()->icon_override();
+  if (!icon_override.IsEmpty())
+    return ui::ImageModel::FromImageSkia(*icon_override.ToImageSkia());
   // Use the default icon for devtools.
-  if (browser_->is_type_devtools())
+  if (browser_->is_type_devtools()) {
+    WebContents* active_content = browser_->tab_strip_model()->GetActiveWebContents();
+    DevToolsWindow* devtools_window =
+        DevToolsWindow::AsDevToolsWindow(active_content);
+    if (devtools_window) {
+      WebContents* inspected_contents =
+          devtools_window->GetInspectedWebContents();
+      Browser* browser = chrome::FindBrowserWithWebContents(inspected_contents);
+      if (browser && !browser->icon_override().IsEmpty())
+        return ui::ImageModel::FromImageSkia(*browser->icon_override().ToImageSkia());
+      favicon::FaviconDriver* favicon_driver = nullptr;
+      if (inspected_contents)
+          favicon_driver = favicon::ContentFaviconDriver::FromWebContents(inspected_contents);
+      gfx::Image app_icon;
+      if (favicon_driver)
+        app_icon = favicon_driver->GetFavicon();
+      if (!app_icon.IsEmpty())
+        return ui::ImageModel::FromImageSkia(*app_icon.ToImageSkia());
+      Profile* profile =
+          Profile::FromBrowserContext(active_content->GetBrowserContext());
+      extensions::AppWindowRegistry* registry =
+          extensions::AppWindowRegistry::Get(profile);
+      if (registry) {
+        extensions::AppWindow* app_window =
+            registry->GetAppWindowForWebContents(inspected_contents);
+        if (app_window)
+          return ui::ImageModel::FromImageSkia(app_window->custom_app_icon().AsImageSkia());
+      }
+    }
     return ui::ImageModel();
+  }
 
   // Hosted apps always show their app icon.
-  web_app::AppBrowserController* app_controller = browser()->app_controller();
+  web_app::AppBrowserController* app_controller = browser_->app_controller();
   if (app_controller)
     return app_controller->GetWindowIcon();
 
@@ -3402,7 +3630,7 @@
   // If IsFullscreen() is true, we've just changed into fullscreen mode, and
   // we're catching the going-into-fullscreen sizing and positioning calls,
   // which we want to ignore.
-  return !IsFullscreen() && frame_->ShouldSaveWindowPlacement() &&
+  return /* !IsFullscreen() && */ frame_->ShouldSaveWindowPlacement() &&
          chrome::ShouldSaveWindowPlacement(browser_.get());
 }
 
@@ -3410,17 +3638,26 @@
                                       ui::WindowShowState show_state) {
   DCHECK(ShouldSaveWindowPlacement());
 
-  WidgetDelegate::SaveWindowPlacement(bounds, show_state);
   gfx::Rect saved_bounds = bounds;
   if (chrome::SavedBoundsAreContentBounds(browser_.get())) {
+#if 0
     // Invert the transformation done in GetSavedWindowPlacement().
     gfx::Size client_size =
         frame_->GetFrameView()->GetBoundsForClientView().size();
     if (IsToolbarVisible())
       client_size.Enlarge(0, -toolbar_->GetPreferredSize().height());
     saved_bounds.set_size(client_size);
+#endif
+    gfx::Rect client_bounds = gfx::Rect(1000, 1000);
+    gfx::Rect window_bounds =
+          frame_->non_client_view()->GetWindowBoundsForClientBounds(client_bounds);
+    gfx::Insets insets = window_bounds.InsetsFrom(client_bounds);
+    saved_bounds.Inset(insets);
+    saved_bounds.set_origin(bounds.origin());
   }
+  WidgetDelegate::SaveWindowPlacement(bounds, show_state);
   chrome::SaveWindowPlacement(browser_.get(), saved_bounds, show_state);
+  NativeWindowChanged();
 }
 
 bool BrowserView::GetSavedWindowPlacement(
@@ -3462,7 +3699,7 @@
     rect.AdjustToFit(display.work_area());
 
     *bounds = rect;
-    *show_state = ui::SHOW_STATE_NORMAL;
+    //*show_state = ui::SHOW_STATE_NORMAL;
   }
 
   // We return true because we can _always_ locate reasonable bounds using the
@@ -3517,6 +3754,13 @@
 }
 #endif  // IS_MAC
 
+void BrowserView::NativeWindowChanged() {
+  extensions::TabsWindowsAPI* tabs_window_api =
+    extensions::TabsWindowsAPI::Get(browser_->profile());
+  tabs_window_api->windows_event_router()->
+    OnWindowChanged(browser_ ? browser_->extension_window_controller() : nullptr);
+}
+
 void BrowserView::OnWidgetDestroying(views::Widget* widget) {
   DCHECK(widget_observation_.IsObservingSource(widget));
   widget_observation_.Reset();
@@ -3613,6 +3857,10 @@
   LocationBarView* location_bar_view = GetLocationBarView();
   if (location_bar_view)
     location_bar_view->GetOmniboxView()->CloseOmniboxPopup();
+  extensions::TabsWindowsAPI* tabs_window_api =
+    extensions::TabsWindowsAPI::Get(browser_->profile());
+  tabs_window_api->windows_event_router()->
+    OnWindowMove(browser_ ? browser_->extension_window_controller() : nullptr);
 }
 
 views::Widget* BrowserView::GetWidget() {
@@ -3765,6 +4013,18 @@
         point_in_contents_web_view_coords.y());
   }
 
+#if defined(USE_AURA)
+  WebContents* web_contents = GetActiveWebContents();
+  if (!web_contents)
+    return true;
+  if (child->Contains(web_contents->GetNativeView())) {
+    // App window should claim mouse events that fall within the draggable
+    // region.
+    return !draggable_region_.get() ||
+           !draggable_region_->contains(location.x(), location.y());
+  }
+#endif
+
   return true;
 }
 
@@ -3808,10 +4068,27 @@
   return GetBrowserViewLayout()->NonClientHitTest(point);
 }
 
+void BrowserView::SetMinimumSize(gfx::Size size) {
+  size_constraints_.set_minimum_size(size);
+  saved_size_constraints_ = size_constraints_;
+  GetWidget()->OnSizeConstraintsChanged();
+}
+
+void BrowserView::SetMaximumSize(gfx::Size size) {
+  size_constraints_.set_maximum_size(size);
+  saved_size_constraints_ = size_constraints_;
+  GetWidget()->OnSizeConstraintsChanged();
+}
+
 gfx::Size BrowserView::GetMinimumSize() const {
+  if (size_constraints_.HasMinimumSize())
+    return size_constraints_.GetMinimumSize();
   return GetBrowserViewLayout()->GetMinimumSize(this);
 }
 
+gfx::Size BrowserView::GetMaximumSize() const {
+  return size_constraints_.GetMaximumSize();
+}
 ///////////////////////////////////////////////////////////////////////////////
 // BrowserView, views::View overrides:
 
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_view.h nw/chromium/chrome/browser/ui/views/frame/browser_view.h
--- up/chromium/chrome/browser/ui/views/frame/browser_view.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_view.h	2023-01-28 02:49:23.939572465 +0000
@@ -10,6 +10,8 @@
 #include <string>
 #include <vector>
 
+#include "extensions/browser/app_window/size_constraints.h"
+
 #include "base/callback_list.h"
 #include "base/gtest_prod_util.h"
 #include "base/memory/raw_ptr.h"
@@ -139,6 +141,8 @@
   void set_frame(BrowserFrame* frame) { frame_ = frame; }
   BrowserFrame* frame() const { return frame_; }
 
+  const extensions::SizeConstraints& size_constraints() const { return size_constraints_; }
+
   // Returns a pointer to the BrowserView* interface implementation (an
   // instance of this object, typically) for a given native window, or null if
   // there is no such association.
@@ -434,11 +438,24 @@
   void UpdateSidePanelHorizontalAlignment();
 
   // BrowserWindow:
+  void ForceClose() override;
+  void SetShowInTaskbar(bool) override;
+  void NativeWindowChanged() override;
+  void SetMinimumSize(gfx::Size) override;
+  void SetMaximumSize(gfx::Size) override;
+  void SetResizable(bool) override;
+  void SetAllVisible(bool) override;
+  void UpdateDraggableRegions(
+      const std::vector<extensions::DraggableRegion>& regions) override;
+  SkRegion* GetDraggableRegion() override;
   void Show() override;
   void ShowInactive() override;
   void Hide() override;
   bool IsVisible() const override;
   void SetBounds(const gfx::Rect& bounds) override;
+#if defined(OS_WIN)
+  void SetPosition(const gfx::Point& pos) override;
+#endif
   void Close() override;
   void Activate() override;
   void Deactivate() override;
@@ -654,6 +671,9 @@
                                   ui::Accelerator* accelerator) const override;
 
   // views::WidgetDelegate:
+  bool NWCanClose(bool user_force = false) const override;
+  bool CanResize() const override;
+  bool CanMaximize() const override;
   bool CanActivate() const override;
   std::u16string GetWindowTitle() const override;
   std::u16string GetAccessibleWindowTitle() const override;
@@ -696,6 +716,7 @@
   views::CloseRequestResult OnWindowCloseRequested() override;
   int NonClientHitTest(const gfx::Point& point) override;
   gfx::Size GetMinimumSize() const override;
+  gfx::Size GetMaximumSize() const override;
 
   // infobars::InfoBarContainer::Delegate:
   void InfoBarContainerStateChanged(bool is_animating) override;
@@ -826,12 +847,13 @@
   void CreateJumpList();
 #endif
 
+public:
   // Returns the BrowserViewLayout.
   BrowserViewLayout* GetBrowserViewLayout() const;
 
   // Returns the ContentsLayoutManager.
   ContentsLayoutManager* GetContentsLayoutManager() const;
-
+private:
   // Prepare to show the Bookmark Bar for the specified WebContents.
   // Returns true if the Bookmark Bar can be shown (i.e. it's supported for this
   // Browser type) and there should be a subsequent re-layout to show it.
@@ -936,6 +958,7 @@
   // and activates them. It returns true if it succeeded activating a bubble or
   // false otherwise.
   bool ActivateFirstInactiveBubbleForAccessibility();
+  std::unique_ptr<SkRegion> draggable_region_;
 
   // Notifies that window bounds changed to extensions if needed.
   void TryNotifyWindowBoundsChanged(const gfx::Rect& widget_bounds);
@@ -952,6 +975,9 @@
   // side panel. Should be called when the IPH backend is initialized or
   // whenever the touch mode changes.
   void MaybeShowReadingListInSidePanelIPH();
+  bool resizable_ = true;
+
+  extensions::SizeConstraints size_constraints_, saved_size_constraints_;
 
   void UpdateWindowControlsOverlayEnabled();
 
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_view_layout.cc nw/chromium/chrome/browser/ui/views/frame/browser_view_layout.cc
--- up/chromium/chrome/browser/ui/views/frame/browser_view_layout.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_view_layout.cc	2023-01-28 02:49:23.939572465 +0000
@@ -58,6 +58,8 @@
 // of the omnibox.
 const int kConstrainedWindowOverlap = 3;
 
+const int kMenuHeight = 25;
+
 // Combines View::ConvertPointToTarget and View::HitTest for a given |point|.
 // Converts |point| from |src| to |dst| and hit tests it against |dst|. The
 // converted |point| can then be retrieved and used for additional tests.
@@ -103,7 +105,7 @@
     views::View* view = browser_view_layout_->contents_container_;
     gfx::Rect content_area = view->ConvertRectToWidget(view->GetLocalBounds());
     const int middle_x = content_area.x() + content_area.width() / 2;
-    const int top = browser_view_layout_->web_contents_modal_dialog_top_y_;
+    const int top = content_area.y() + content_area.height() / 2 - size.height() / 2; //browser_view_layout_->web_contents_modal_dialog_top_y_;
     return gfx::Point(middle_x - size.width() / 2, top);
   }
 
@@ -163,6 +165,7 @@
     : delegate_(std::move(delegate)),
       host_view_(host_view),
       browser_view_(browser_view),
+      menu_bar_(nullptr),
       top_container_(top_container),
       tab_strip_region_view_(tab_strip_region_view),
       toolbar_(toolbar),
@@ -226,11 +229,14 @@
                       kMainBrowserContentsMinimumHeight)
           : kContentsMinimumSize);
 
-  const int min_height =
+  int min_height =
       delegate_->GetTopInsetInBrowserView() + tabstrip_size.height() +
       toolbar_size.height() + bookmark_bar_size.height() +
       infobar_container_size.height() + contents_size.height();
 
+  if (menu_bar_)
+    min_height += kMenuHeight;
+
   const int min_width = std::max(
       {tabstrip_size.width(), toolbar_size.width(), bookmark_bar_size.width(),
        infobar_container_size.width(), contents_size.width()});
@@ -377,6 +383,11 @@
   top = LayoutWebUITabStrip(top);
   top = LayoutToolbar(top);
 
+  if (menu_bar_) {
+    menu_bar_->SetBounds(0, top, browser_view_->width(), kMenuHeight);
+    top += kMenuHeight;
+  }
+
   top = LayoutBookmarkAndInfoBars(top, browser_view->y());
 
   // Top container requires updated toolbar and bookmark bar to compute bounds.
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_view_layout.h nw/chromium/chrome/browser/ui/views/frame/browser_view_layout.h
--- up/chromium/chrome/browser/ui/views/frame/browser_view_layout.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_view_layout.h	2023-01-28 02:49:23.939572465 +0000
@@ -97,6 +97,8 @@
   // this function only controls where it's drawn when it is in fact drawn.
   void SetContentBorderBounds(
       const absl::optional<gfx::Rect>& region_capture_rect);
+  void set_menu_bar(views::View* menu_bar) { menu_bar_ = menu_bar; }
+  views::View* menu_bar() { return menu_bar_; }
 
   web_modal::WebContentsModalDialogHost* GetWebContentsModalDialogHost();
 
@@ -174,6 +176,7 @@
   // Child views that the layout manager manages.
   // NOTE: If you add a view, try to add it as a views::View, which makes
   // testing much easier.
+  views::View* menu_bar_;
   const raw_ptr<views::View, DanglingUntriaged> top_container_;
   const raw_ptr<TabStripRegionView, DanglingUntriaged> tab_strip_region_view_;
   const raw_ptr<views::View, DanglingUntriaged> toolbar_;
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_window_factory.cc nw/chromium/chrome/browser/ui/views/frame/browser_window_factory.cc
--- up/chromium/chrome/browser/ui/views/frame/browser_window_factory.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_window_factory.cc	2023-01-28 02:49:23.939572465 +0000
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 #include <memory>
+#include "ui/display/screen.h"
 
 #include "build/chromeos_buildflags.h"
 #include "chrome/browser/profiles/profiles_state.h"
@@ -46,6 +47,8 @@
 #endif
   // Create the view and the frame. The frame will attach itself via the view
   // so we don't need to do anything with the pointer.
+  bool frameless = browser->is_frameless();
+  std::string position = browser->initial_position();
   BrowserView* view = new BrowserView(std::move(browser));
   BrowserFrame* browser_frame = nullptr;
 #if BUILDFLAG(IS_CHROMEOS_ASH)
@@ -56,10 +59,21 @@
   browser_frame = new BrowserFrameLacros(view);
 #endif
   if (!browser_frame)
-    browser_frame = new BrowserFrame(view);
+    browser_frame = new BrowserFrame(view, frameless);
   if (in_tab_dragging)
     browser_frame->SetTabDragKind(TabDragKind::kAllTabs);
-  browser_frame->InitBrowserFrame();
+  bool got_saved_bounds = browser_frame->InitBrowserFrame();
+
+  if (position == "mouse" && !got_saved_bounds) {
+      gfx::Point cursor_pos(display::Screen::GetScreen()->GetCursorScreenPoint());
+      gfx::Rect bounds = browser_frame->GetWindowBoundsInScreen();
+      bounds.set_origin(cursor_pos);
+      browser_frame->SetBounds(bounds);
+  }
+  if (position == "center" && !got_saved_bounds) {
+    gfx::Rect bounds = browser_frame->GetWindowBoundsInScreen();
+    browser_frame->CenterWindow(bounds.size());
+  }
 
 #if BUILDFLAG(IS_MAC)
   if (view->UsesImmersiveFullscreenMode()) {
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_window_property_manager_win.cc nw/chromium/chrome/browser/ui/views/frame/browser_window_property_manager_win.cc
--- up/chromium/chrome/browser/ui/views/frame/browser_window_property_manager_win.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_window_property_manager_win.cc	2023-01-28 02:49:23.939572465 +0000
@@ -54,12 +54,13 @@
   std::wstring app_id =
       browser->is_type_app() || browser->is_type_app_popup() ||
               browser->is_type_devtools()
+       || true
           ? shell_integration::win::GetAppUserModelIdForApp(
                 base::UTF8ToWide(browser->app_name()), profile->GetPath())
           : shell_integration::win::GetAppUserModelIdForBrowser(
                 profile->GetPath());
   // Apps set their relaunch details based on app's details.
-  if (browser->is_type_app() || browser->is_type_app_popup()) {
+  if (browser->is_type_app() || browser->is_type_app_popup() || true) {
     ExtensionRegistry* registry = ExtensionRegistry::Get(profile);
     const extensions::Extension* extension = registry->GetExtensionById(
         web_app::GetAppIdFromApplicationName(browser->app_name()),
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/contents_web_view.cc nw/chromium/chrome/browser/ui/views/frame/contents_web_view.cc
--- up/chromium/chrome/browser/ui/views/frame/contents_web_view.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/contents_web_view.cc	2023-01-28 02:49:23.939572465 +0000
@@ -23,10 +23,11 @@
 #include "ui/wm/core/window_util.h"
 #endif
 
-ContentsWebView::ContentsWebView(content::BrowserContext* browser_context)
+ContentsWebView::ContentsWebView(content::BrowserContext* browser_context,
+                                 bool transparent)
     : views::WebView(browser_context),
-      status_bubble_(nullptr) {
-}
+      status_bubble_(nullptr),
+      transparent_(transparent) {}
 
 ContentsWebView::~ContentsWebView() {
 }
@@ -72,14 +73,16 @@
   SkColor color = GetColorProvider()->GetColor(
       is_letterboxing() ? kColorWebContentsBackgroundLetterboxing
                         : kColorWebContentsBackground);
+  if (transparent_)
+    SetBackground(views::CreateSolidBackground(SK_ColorTRANSPARENT));
+  else
   SetBackground(background_visible_ ? views::CreateSolidBackground(color)
                                     : nullptr);
-
   if (web_contents()) {
     content::RenderWidgetHostView* rwhv =
         web_contents()->GetRenderWidgetHostView();
     if (rwhv) {
-      rwhv->SetBackgroundColor(background_visible_ ? color
+      rwhv->SetBackgroundColor(background_visible_ && !transparent_ ? color
                                                    : SK_ColorTRANSPARENT);
     }
   }
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/contents_web_view.h nw/chromium/chrome/browser/ui/views/frame/contents_web_view.h
--- up/chromium/chrome/browser/ui/views/frame/contents_web_view.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/contents_web_view.h	2023-01-28 02:49:23.939572465 +0000
@@ -25,7 +25,7 @@
       public WebContentsCloseHandlerDelegate {
  public:
   METADATA_HEADER(ContentsWebView);
-  explicit ContentsWebView(content::BrowserContext* browser_context);
+  explicit ContentsWebView(content::BrowserContext* browser_context, bool transparent);
   ContentsWebView(const ContentsWebView&) = delete;
   ContentsWebView& operator=(const ContentsWebView&) = delete;
   ~ContentsWebView() override;
@@ -55,6 +55,7 @@
  private:
   void UpdateBackgroundColor();
   StatusBubbleViews* status_bubble_;
+  bool transparent_;
 
   bool background_visible_ = true;
 
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/glass_browser_caption_button_container.cc nw/chromium/chrome/browser/ui/views/frame/glass_browser_caption_button_container.cc
--- up/chromium/chrome/browser/ui/views/frame/glass_browser_caption_button_container.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/glass_browser_caption_button_container.cc	2023-01-28 02:49:23.939572465 +0000
@@ -61,7 +61,7 @@
       close_button_(AddChildView(CreateCaptionButton(
           base::BindRepeating(&BrowserFrame::CloseWithReason,
                               base::Unretained(frame_view_->frame()),
-                              views::Widget::ClosedReason::kCloseButtonClicked),
+                              views::Widget::ClosedReason::kCloseButtonClicked, false),
           frame_view_,
           VIEW_ID_CLOSE_BUTTON,
           IDS_APP_ACCNAME_CLOSE))) {
@@ -154,8 +154,13 @@
   if (tab_search_button_)
     tab_search_button_->SetState(views::Button::STATE_NORMAL);
   minimize_button_->SetState(views::Button::STATE_NORMAL);
-  maximize_button_->SetState(views::Button::STATE_NORMAL);
-  restore_button_->SetState(views::Button::STATE_NORMAL);
+  if (frame_view_->browser_view()->CanMaximize()) {
+    maximize_button_->SetState(views::Button::STATE_NORMAL);
+    restore_button_->SetState(views::Button::STATE_NORMAL);
+  } else {
+    maximize_button_->SetState(views::Button::STATE_DISABLED);
+    restore_button_->SetState(views::Button::STATE_DISABLED);
+  }
   close_button_->SetState(views::Button::STATE_NORMAL);
   InvalidateLayout();
 }
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/glass_browser_frame_view.cc nw/chromium/chrome/browser/ui/views/frame/glass_browser_frame_view.cc
--- up/chromium/chrome/browser/ui/views/frame/glass_browser_frame_view.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/glass_browser_frame_view.cc	2023-01-28 02:49:23.939572465 +0000
@@ -232,6 +232,14 @@
     caption_button_container_->SchedulePaint();
 }
 
+gfx::Size GlassBrowserFrameView::GetMaximumSize() const {
+  gfx::Size max_size(browser_view()->GetMaximumSize());
+  if (max_size.height() > 0 || max_size.width() > 0)
+    max_size.Enlarge(0, GetTopInset(false));
+
+  return max_size;
+}
+
 ///////////////////////////////////////////////////////////////////////////////
 // GlassBrowserFrameView, views::NonClientFrameView implementation:
 
@@ -243,14 +251,21 @@
     const gfx::Rect& client_bounds) const {
   HWND hwnd = views::HWNDForWidget(frame());
   if (!browser_view()->GetTabStripVisible() && hwnd) {
-    // If we don't have a tabstrip, we're either a popup or an app window, in
-    // which case we have a standard size non-client area and can just use
-    // AdjustWindowRectEx to obtain it. We check for a non-null window handle in
-    // case this gets called before the window is actually created.
-    RECT rect = client_bounds.ToRECT();
-    AdjustWindowRectEx(&rect, GetWindowLong(hwnd, GWL_STYLE), FALSE,
-                       GetWindowLong(hwnd, GWL_EXSTYLE));
-    return gfx::Rect(rect);
+    if (ShouldCustomDrawSystemTitlebar()) {
+      const int top_inset = GetTopInset(false);
+      const int thickness = std::floor(
+        FrameTopBorderThicknessPx(false) /
+        display::win::ScreenWin::GetScaleFactorForHWND(hwnd));
+      return gfx::Rect(std::max(0, client_bounds.x()),
+        std::max(0, client_bounds.y() - top_inset),
+        client_bounds.width() + 2 * thickness, client_bounds.height() + top_inset + thickness);
+    }
+    else {
+      RECT rect = client_bounds.ToRECT();
+      AdjustWindowRectEx(&rect, GetWindowLong(hwnd, GWL_STYLE), FALSE,
+        GetWindowLong(hwnd, GWL_EXSTYLE));
+      return gfx::Rect(rect);
+    }
   }
 
   const int top_inset = GetTopInset(false);
@@ -271,8 +286,11 @@
 
   // If the point isn't within our bounds, then it's in the native portion of
   // the frame so again Windows can figure it out.
-  if (!bounds().Contains(point))
+  if (!bounds().Contains(point)) {
+    if (browser_view()->size_constraints().HasFixedSize())
+      return HTCAPTION;
     return HTNOWHERE;
+  }
 
   int frame_component = frame()->client_view()->NonClientHitTest(point);
 
@@ -461,7 +479,10 @@
       frame()->IsFullscreen();
   if (needs_no_border && !restored)
     return 0;
-
+#if 0
+  if (!browser_view()->CanResize() && !restored)
+    return 0;
+#endif
   // Note that this method assumes an equal resize handle thickness on all
   // sides of the window.
   // TODO(dfried): Consider having it return a gfx::Insets object instead.
@@ -532,6 +553,8 @@
   // FrameTopBorderThickness()) and floor(system dsf) pixels when restored.
   // Unfortunately we can't represent either of those at hidpi without using
   // non-integral dips, so we return the closest reasonable values instead.
+  if (!browser_view()->CanResize() && IsMaximized())
+    return 1;
   if (IsMaximized())
     return FrameTopBorderThickness(false);
   return IsWebUITabStrip() ? FrameTopBorderThickness(true) : 1;
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/glass_browser_frame_view.h nw/chromium/chrome/browser/ui/views/frame/glass_browser_frame_view.h
--- up/chromium/chrome/browser/ui/views/frame/glass_browser_frame_view.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/glass_browser_frame_view.h	2023-01-28 02:49:23.939572465 +0000
@@ -43,6 +43,7 @@
   gfx::Size GetMinimumSize() const override;
   void WindowControlsOverlayEnabledChanged() override;
   TabSearchBubbleHost* GetTabSearchBubbleHost() override;
+  gfx::Size GetMaximumSize() const override;
 
   // views::NonClientFrameView:
   gfx::Rect GetBoundsForClientView() const override;
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view.cc nw/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view.cc
--- up/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view.cc	2023-01-28 02:49:23.943572508 +0000
@@ -128,6 +128,7 @@
     BrowserView* browser_view,
     OpaqueBrowserFrameViewLayout* layout)
     : BrowserNonClientFrameView(frame, browser_view),
+      frameless_(frame->frameless()),
       layout_(layout),
       window_icon_(nullptr),
       window_title_(nullptr),
@@ -143,6 +144,8 @@
     layout_->SetBorderlessModeEnabled(browser_view->IsBorderlessModeEnabled(),
                                       this);
   }
+  if (frameless_)
+    return;
   SetLayoutManager(std::unique_ptr<views::LayoutManager>(layout_));
 }
 
@@ -200,7 +203,7 @@
       close_button_,
       base::BindRepeating(&BrowserFrame::CloseWithReason,
                           base::Unretained(frame()),
-                          views::Widget::ClosedReason::kCloseButtonClicked),
+                          views::Widget::ClosedReason::kCloseButtonClicked, false),
       IDS_ACCNAME_CLOSE, VIEW_ID_CLOSE_BUTTON);
 
   // Initializing the TabIconView is expensive, so only do it if we need to.
@@ -297,19 +300,45 @@
   UpdateCaptionButtonPlaceholderContainerBackground();
   BrowserNonClientFrameView::OnThemeChanged();
 }
+
+gfx::Size OpaqueBrowserFrameView::GetMaximumSize() const {
+  return layout_->GetMaximumSize(this);
+}
+
 ///////////////////////////////////////////////////////////////////////////////
 // OpaqueBrowserFrameView, views::NonClientFrameView implementation:
 
 gfx::Rect OpaqueBrowserFrameView::GetBoundsForClientView() const {
+  if (frameless_)
+    return bounds();
   return layout_->client_view_bounds();
 }
 
 gfx::Rect OpaqueBrowserFrameView::GetWindowBoundsForClientBounds(
     const gfx::Rect& client_bounds) const {
+  if (frameless_) {
+    gfx::Rect window_bounds = client_bounds;
+    if (window_bounds.IsEmpty()) {
+      window_bounds.set_width(1);
+      window_bounds.set_height(1);
+    }
+    return window_bounds;
+  }
   return layout_->GetWindowBoundsForClientBounds(client_bounds);
 }
 
 int OpaqueBrowserFrameView::NonClientHitTest(const gfx::Point& point) {
+  if (frameless_) {
+    constexpr int kResizeAreaCornerSize = 16;
+    views::WidgetDelegate* delegate = frame()->widget_delegate();
+    if (!delegate)
+      return HTCAPTION;
+    int window_component = GetHTComponentForFrame(
+      point, gfx::Insets(5),
+      kResizeAreaCornerSize, kResizeAreaCornerSize, delegate->CanResize());
+    if (window_component != HTNOWHERE)
+      return window_component;
+  }
   int super_component = BrowserNonClientFrameView::NonClientHitTest(point);
   if (super_component != HTNOWHERE)
     return super_component;
@@ -317,6 +346,10 @@
   if (!bounds().Contains(point))
     return HTNOWHERE;
 
+  SkRegion* draggable_region = browser_view()->GetDraggableRegion();
+  if (draggable_region && draggable_region->contains(point.x(), point.y()))
+    return HTCAPTION;
+
   int frame_component = frame()->client_view()->NonClientHitTest(point);
 
   // See if we're in the sysmenu region.  We still have to check the tabstrip
@@ -398,10 +431,17 @@
 }
 
 void OpaqueBrowserFrameView::ResetWindowControls() {
+  if (frameless_)
+    return;
   BrowserNonClientFrameView::ResetWindowControls();
-  restore_button_->SetState(views::Button::STATE_NORMAL);
   minimize_button_->SetState(views::Button::STATE_NORMAL);
-  maximize_button_->SetState(views::Button::STATE_NORMAL);
+  if (browser_view()->CanMaximize()) {
+    restore_button_->SetState(views::Button::STATE_NORMAL);
+    maximize_button_->SetState(views::Button::STATE_NORMAL);
+  } else {
+    restore_button_->SetState(views::Button::STATE_DISABLED);
+    maximize_button_->SetState(views::Button::STATE_DISABLED);
+  }
   // The close button isn't affected by this constraint.
 }
 
@@ -411,6 +451,8 @@
 }
 
 void OpaqueBrowserFrameView::UpdateWindowTitle() {
+  if (frameless_)
+    return;
   if (!frame()->IsFullscreen() && ShouldShowWindowTitle()) {
     Layout();
     window_title_->SchedulePaint();
@@ -485,6 +527,10 @@
   return browser_view()->GetMinimumSize();
 }
 
+gfx::Size OpaqueBrowserFrameView::GetBrowserViewMaximumSize() const {
+  return browser_view()->GetMaximumSize();
+}
+
 bool OpaqueBrowserFrameView::ShouldShowCaptionButtons() const {
   return GetShowWindowTitleBar();
 }
@@ -592,7 +638,7 @@
 // views::View:
 void OpaqueBrowserFrameView::OnPaint(gfx::Canvas* canvas) {
   TRACE_EVENT0("views.frame", "OpaqueBrowserFrameView::OnPaint");
-  if (frame()->IsFullscreen())
+  if (frame()->IsFullscreen() || frameless_)
     return;  // Nothing is visible, so don't bother to paint.
 
   const bool active = ShouldPaintAsActive();
@@ -796,6 +842,8 @@
   if (frame()->IsFullscreen())
     return false;
 
+  if (frameless_)
+    return false;
   // Do not show caption buttons if the window manager is forcefully providing a
   // title bar (e.g., in Ubuntu Unity, if the window is maximized).
   return !views::ViewsDelegate::GetInstance()->WindowManagerProvidesTitleBar(
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view.h nw/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view.h
--- up/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view.h	2023-01-28 02:49:23.943572508 +0000
@@ -68,6 +68,7 @@
   void PaintAsActiveChanged() override;
   void UpdateFrameColor() override;
   void OnThemeChanged() override;
+  gfx::Size GetMaximumSize() const override;
 
   // views::NonClientFrameView:
   gfx::Rect GetBoundsForClientView() const override;
@@ -93,6 +94,7 @@
   std::u16string GetWindowTitle() const override;
   int GetIconSize() const override;
   gfx::Size GetBrowserViewMinimumSize() const override;
+  gfx::Size GetBrowserViewMaximumSize() const override;
   bool ShouldShowCaptionButtons() const override;
   bool IsRegularOrGuestSession() const override;
   bool CanMaximize() const override;
@@ -213,6 +215,7 @@
   void UpdateCaptionButtonToolTipsForWindowControlsOverlay();
 #endif
 
+  bool frameless_;
   // Our layout manager also calculates various bounds.
   raw_ptr<OpaqueBrowserFrameViewLayout> layout_;
 
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.cc nw/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.cc
--- up/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.cc	2023-01-28 02:49:23.943572508 +0000
@@ -105,10 +105,19 @@
                    tabstrip_minimum_size.height());
 }
 
+gfx::Size OpaqueBrowserFrameViewLayout::GetMaximumSize(
+         const views::View* host) const {
+  return GetMinimumSizeHelper(host, true);
+}
 gfx::Size OpaqueBrowserFrameViewLayout::GetMinimumSize(
-    const views::View* host) const {
-  // Ensure that we can fit the main browser view.
-  gfx::Size min_size = delegate_->GetBrowserViewMinimumSize();
+         const views::View* host) const {
+  return GetMinimumSizeHelper(host, false);
+}
+gfx::Size OpaqueBrowserFrameViewLayout::GetMinimumSizeHelper(
+         const views::View* host, bool max) const {
+  gfx::Size min_size = max? delegate_->GetBrowserViewMaximumSize() : delegate_->GetBrowserViewMinimumSize();
+  if (max && min_size.IsEmpty())
+    return min_size;
 
   // Ensure that we can, at minimum, hold our window controls and a tab strip.
   int top_width = minimum_size_for_buttons_;
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.h nw/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.h
--- up/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.h	2023-01-28 02:49:23.943572508 +0000
@@ -131,6 +131,8 @@
   // Called explicitly from OpaqueBrowserFrameView so we can't group it with
   // the other overrides.
   gfx::Size GetMinimumSize(const views::View* host) const override;
+  gfx::Size GetMaximumSize(const views::View* host) const;
+  gfx::Size GetMinimumSizeHelper(const views::View* host, bool max) const;
 
 
  protected:
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout_delegate.h nw/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout_delegate.h
--- up/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout_delegate.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/opaque_browser_frame_view_layout_delegate.h	2023-01-28 02:49:23.943572508 +0000
@@ -44,6 +44,7 @@
   // Returns the browser's minimum view size. Used because we need to calculate
   // the minimum size for the entire non-client area.
   virtual gfx::Size GetBrowserViewMinimumSize() const = 0;
+  virtual gfx::Size GetBrowserViewMaximumSize() const = 0;
 
   // Whether we should show the (minimize,maximize,close) buttons. This can
   // depend on the current state of the window (e.g., whether it is maximized).
diff -r -u --color up/chromium/chrome/browser/ui/views/frame/system_menu_model_builder.cc nw/chromium/chrome/browser/ui/views/frame/system_menu_model_builder.cc
--- up/chromium/chrome/browser/ui/views/frame/system_menu_model_builder.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/system_menu_model_builder.cc	2023-01-28 02:49:23.943572508 +0000
@@ -118,6 +118,7 @@
 
 void SystemMenuModelBuilder::BuildSystemMenuForAppOrPopupWindow(
     ui::SimpleMenuModel* model) {
+#if 0
   model->AddItemWithStringId(IDC_BACK, IDS_CONTENT_CONTEXT_BACK);
   model->AddItemWithStringId(IDC_FORWARD, IDS_CONTENT_CONTEXT_FORWARD);
   model->AddItemWithStringId(IDC_RELOAD, IDS_APP_MENU_RELOAD);
@@ -152,6 +153,7 @@
   AppendMoveToDesksMenu(model);
 #endif
   AppendTeleportMenu(model);
+#endif
 }
 
 void SystemMenuModelBuilder::AddFrameToggleItems(ui::SimpleMenuModel* model) {
diff -r -u --color up/chromium/chrome/browser/ui/views/fullscreen_control/fullscreen_control_host.cc nw/chromium/chrome/browser/ui/views/fullscreen_control/fullscreen_control_host.cc
--- up/chromium/chrome/browser/ui/views/fullscreen_control/fullscreen_control_host.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/fullscreen_control/fullscreen_control_host.cc	2023-01-28 02:49:23.947572550 +0000
@@ -289,9 +289,13 @@
 }
 
 bool FullscreenControlHost::IsExitUiNeeded() {
+#if 1
+  return false;
+#else
   return browser_view_->IsFullscreen() &&
          browser_view_->CanUserExitFullscreen() &&
          browser_view_->ShouldHideUIForFullscreen();
+#endif
 }
 
 float FullscreenControlHost::CalculateCursorBufferHeight() const {
diff -r -u --color up/chromium/chrome/browser/ui/views/location_bar/zoom_bubble_view.cc nw/chromium/chrome/browser/ui/views/location_bar/zoom_bubble_view.cc
--- up/chromium/chrome/browser/ui/views/location_bar/zoom_bubble_view.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/location_bar/zoom_bubble_view.cc	2023-01-28 02:49:23.955572634 +0000
@@ -148,6 +148,7 @@
   return nullptr;
 }
 
+#if 0
 ImmersiveModeController* GetImmersiveModeControllerForBrowser(
     Browser* browser) {
   BrowserView* browser_view = BrowserView::GetBrowserViewForBrowser(browser);
@@ -173,6 +174,7 @@
 
   views::BubbleDialogDelegateView::CreateBubble(zoom_bubble);
 }
+#endif
 
 // Find the extension that initiated the zoom change, if any.
 const extensions::ExtensionZoomRequestClient* GetExtensionZoomRequestClient(
@@ -191,6 +193,7 @@
 // static
 void ZoomBubbleView::ShowBubble(content::WebContents* web_contents,
                                 DisplayReason reason) {
+#if 0
   Browser* browser = chrome::FindBrowserWithWebContents(web_contents);
   // |web_contents| could have been unloaded if a tab gets closed and a mouse
   // event arrives before the zoom icon gets hidden.
@@ -228,6 +231,7 @@
   // disappears after a short timeout.
   zoom_bubble_->ShowForReason(reason, /* allow_refocus_alert */ false);
   zoom_bubble_->UpdateZoomIconVisibility();
+#endif
 }
 
 // static
diff -r -u --color up/chromium/chrome/browser/ui/views/media_router/presentation_receiver_window_view.cc nw/chromium/chrome/browser/ui/views/media_router/presentation_receiver_window_view.cc
--- up/chromium/chrome/browser/ui/views/media_router/presentation_receiver_window_view.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/media_router/presentation_receiver_window_view.cc	2023-01-28 02:49:23.955572634 +0000
@@ -166,7 +166,7 @@
   infobars::ContentInfoBarManager::CreateForWebContents(web_contents);
 
   SecurityStateTabHelper::CreateForWebContents(web_contents);
-  ChromeTranslateClient::CreateForWebContents(web_contents);
+  //ChromeTranslateClient::CreateForWebContents(web_contents);
   autofill::ChromeAutofillClient::CreateForWebContents(web_contents);
   autofill::ContentAutofillDriverFactory::CreateForWebContentsAndDelegate(
       web_contents,
diff -r -u --color up/chromium/chrome/browser/ui/views/omnibox/omnibox_popup_contents_view.cc nw/chromium/chrome/browser/ui/views/omnibox/omnibox_popup_contents_view.cc
--- up/chromium/chrome/browser/ui/views/omnibox/omnibox_popup_contents_view.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/omnibox/omnibox_popup_contents_view.cc	2023-01-28 02:49:23.959572677 +0000
@@ -97,7 +97,7 @@
 
     // Destroy the popup when done. The observer deletes itself on completion.
     scoped_settings->AddObserver(new ui::ClosureAnimationObserver(
-        base::BindOnce(&AutocompletePopupWidget::Close, AsWeakPtr())));
+                                                                  base::BindOnce(&AutocompletePopupWidget::Close, AsWeakPtr(), false)));
   }
 
   void OnNativeWidgetDestroying() override {
diff -r -u --color up/chromium/chrome/browser/ui/views/overlay/overlay_window_views.h nw/chromium/chrome/browser/ui/views/overlay/overlay_window_views.h
--- up/chromium/chrome/browser/ui/views/overlay/overlay_window_views.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/overlay/overlay_window_views.h	2023-01-28 02:49:23.963572719 +0000
@@ -16,6 +16,8 @@
 #include "ui/gfx/geometry/size.h"
 #include "ui/views/widget/widget.h"
 
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Woverloaded-virtual"
 // Base class for the Chrome desktop implementation of VideoOverlayWindow.
 // This will only be implemented in views, which will support all desktop
 // platforms.
@@ -186,4 +188,6 @@
   absl::optional<bool> force_controls_visible_;
 };
 
+#pragma clang diagnostic pop
+
 #endif  // CHROME_BROWSER_UI_VIEWS_OVERLAY_OVERLAY_WINDOW_VIEWS_H_
diff -r -u --color up/chromium/chrome/browser/ui/views/page_action/page_action_icon_controller.cc nw/chromium/chrome/browser/ui/views/page_action/page_action_icon_controller.cc
--- up/chromium/chrome/browser/ui/views/page_action/page_action_icon_controller.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/page_action/page_action_icon_controller.cc	2023-01-28 02:49:23.963572719 +0000
@@ -229,11 +229,13 @@
                       params.page_action_icon_delegate, params.browser));
         break;
       case PageActionIconType::kTranslate:
+#if 0
         DCHECK(params.command_updater);
         add_page_action_icon(
             type, std::make_unique<TranslateIconView>(
                       params.command_updater, params.icon_label_bubble_delegate,
                       params.page_action_icon_delegate));
+#endif
         break;
       case PageActionIconType::kVirtualCardEnroll:
         add_page_action_icon(
diff -r -u --color up/chromium/chrome/browser/ui/views/profiles/profile_picker_signed_in_flow_controller.cc nw/chromium/chrome/browser/ui/views/profiles/profile_picker_signed_in_flow_controller.cc
--- up/chromium/chrome/browser/ui/views/profiles/profile_picker_signed_in_flow_controller.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/profiles/profile_picker_signed_in_flow_controller.cc	2023-01-28 02:49:23.983572930 +0000
@@ -150,12 +150,14 @@
 }
 
 void ProfilePickerSignedInFlowController::SwitchToSyncConfirmationFinished() {
+#if 0
   DCHECK(IsInitialized());
   // Initialize the WebUI page once we know it's committed.
   SyncConfirmationUI* sync_confirmation_ui =
       static_cast<SyncConfirmationUI*>(contents()->GetWebUI()->GetController());
 
   sync_confirmation_ui->InitializeMessageHandlerWithBrowser(nullptr);
+#endif
 }
 
 void ProfilePickerSignedInFlowController::
diff -r -u --color up/chromium/chrome/browser/ui/views/sad_tab_view.cc nw/chromium/chrome/browser/ui/views/sad_tab_view.cc
--- up/chromium/chrome/browser/ui/views/sad_tab_view.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/sad_tab_view.cc	2023-01-28 02:49:23.987572973 +0000
@@ -4,6 +4,7 @@
 
 #include "chrome/browser/ui/views/sad_tab_view.h"
 
+#include "components/strings/grit/components_strings.h"
 #include <string>
 
 #include "base/metrics/histogram_macros.h"
@@ -564,7 +565,7 @@
       actions_container->AddChildView(std::make_unique<views::MdTextButton>(
           base::BindRepeating(&SadTabView::PerformAction,
                               base::Unretained(this), Action::BUTTON),
-          l10n_util::GetStringUTF16(GetButtonTitle())));
+          l10n_util::GetStringUTF16(IDS_CLOSE)));
   action_button_->SetProminent(true);
   action_button_->SetProperty(
       views::kFlexBehaviorKey,
diff -r -u --color up/chromium/chrome/browser/ui/views/safe_browsing/password_reuse_modal_warning_dialog.h nw/chromium/chrome/browser/ui/views/safe_browsing/password_reuse_modal_warning_dialog.h
--- up/chromium/chrome/browser/ui/views/safe_browsing/password_reuse_modal_warning_dialog.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/safe_browsing/password_reuse_modal_warning_dialog.h	2023-01-28 02:49:23.987572973 +0000
@@ -8,7 +8,7 @@
 #include "base/callback.h"
 #include "base/memory/raw_ptr.h"
 #include "base/time/time.h"
-#include "chrome/browser/safe_browsing/chrome_password_protection_service.h"
+//#include "chrome/browser/safe_browsing/chrome_password_protection_service.h"
 #include "components/password_manager/core/browser/password_manager_metrics_util.h"
 #include "content/public/browser/web_contents_observer.h"
 #include "ui/base/metadata/metadata_header_macros.h"
diff -r -u --color up/chromium/chrome/browser/ui/views/status_icons/status_icon_linux_wrapper.cc nw/chromium/chrome/browser/ui/views/status_icons/status_icon_linux_wrapper.cc
--- up/chromium/chrome/browser/ui/views/status_icons/status_icon_linux_wrapper.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/status_icons/status_icon_linux_wrapper.cc	2023-01-28 02:49:23.995573057 +0000
@@ -43,8 +43,7 @@
     : status_icon_(status_icon),
       status_icon_type_(status_icon_type),
       image_(GetBestImageRep(image)),
-      tool_tip_(tool_tip),
-      menu_model_(nullptr) {
+      tool_tip_(tool_tip) {
   status_icon_->SetDelegate(this);
 }
 
@@ -71,8 +70,6 @@
 }
 
 StatusIconLinuxWrapper::~StatusIconLinuxWrapper() {
-  if (menu_model_)
-    menu_model_->RemoveObserver(this);
 }
 
 void StatusIconLinuxWrapper::SetImage(const gfx::ImageSkia& image) {
@@ -160,17 +157,9 @@
 }
 
 void StatusIconLinuxWrapper::UpdatePlatformContextMenu(
-    StatusIconMenuModel* model) {
+    ui::MenuModel* model) {
   if (!status_icon_)
     return;
 
-  // If a menu already exists, remove ourself from its observer list.
-  if (menu_model_)
-    menu_model_->RemoveObserver(this);
-
   status_icon_->UpdatePlatformContextMenu(model);
-  menu_model_ = model;
-
-  if (model)
-    model->AddObserver(this);
 }
diff -r -u --color up/chromium/chrome/browser/ui/views/status_icons/status_icon_linux_wrapper.h nw/chromium/chrome/browser/ui/views/status_icons/status_icon_linux_wrapper.h
--- up/chromium/chrome/browser/ui/views/status_icons/status_icon_linux_wrapper.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/status_icons/status_icon_linux_wrapper.h	2023-01-28 02:49:23.995573057 +0000
@@ -55,7 +55,7 @@
   // Invoked after a call to SetContextMenu() to let the platform-specific
   // subclass update the native context menu based on the new model. If NULL is
   // passed, subclass should destroy the native context menu.
-  void UpdatePlatformContextMenu(StatusIconMenuModel* model) override;
+  void UpdatePlatformContextMenu(ui::MenuModel* model) override;
 
  private:
   enum StatusIconType {
diff -r -u --color up/chromium/chrome/browser/ui/views/status_icons/status_icon_win.cc nw/chromium/chrome/browser/ui/views/status_icons/status_icon_win.cc
--- up/chromium/chrome/browser/ui/views/status_icons/status_icon_win.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/status_icons/status_icon_win.cc	2023-01-28 02:49:23.995573057 +0000
@@ -42,6 +42,8 @@
   NOTIFYICONDATA icon_data;
   InitIconData(&icon_data);
   Shell_NotifyIcon(NIM_DELETE, &icon_data);
+  if (tray_ && tray_->key_handler() == this)
+    tray_->set_key_handler(nullptr);
 }
 
 void StatusIconWin::HandleClickEvent(const gfx::Point& cursor_pos,
@@ -65,6 +67,8 @@
   menu_runner_->RunMenuAt(nullptr, nullptr, gfx::Rect(cursor_pos, gfx::Size()),
                           views::MenuAnchorPosition::kTopLeft,
                           ui::MENU_SOURCE_MOUSE);
+  if (tray_)
+    tray_->set_key_handler(this);
 }
 
 void StatusIconWin::HandleBalloonClickEvent() {
@@ -145,7 +149,7 @@
 ////////////////////////////////////////////////////////////////////////////////
 // StatusIconWin, private:
 
-void StatusIconWin::UpdatePlatformContextMenu(StatusIconMenuModel* menu) {
+void StatusIconWin::UpdatePlatformContextMenu(ui::MenuModel* menu) {
   // |menu_model_| is about to be destroyed. Destroy the menu (which closes it)
   // so that it doesn't attempt to continue using |menu_model_|.
   menu_runner_.reset();
diff -r -u --color up/chromium/chrome/browser/ui/views/status_icons/status_icon_win.h nw/chromium/chrome/browser/ui/views/status_icons/status_icon_win.h
--- up/chromium/chrome/browser/ui/views/status_icons/status_icon_win.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/status_icons/status_icon_win.h	2023-01-28 02:49:23.995573057 +0000
@@ -60,7 +60,7 @@
 
  protected:
   // Overridden from StatusIcon:
-  void UpdatePlatformContextMenu(StatusIconMenuModel* menu) override;
+  void UpdatePlatformContextMenu(ui::MenuModel* menu) override;
 
  private:
   void InitIconData(NOTIFYICONDATA* icon_data);
diff -r -u --color up/chromium/chrome/browser/ui/views/status_icons/status_tray_win.cc nw/chromium/chrome/browser/ui/views/status_icons/status_tray_win.cc
--- up/chromium/chrome/browser/ui/views/status_icons/status_tray_win.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/status_icons/status_tray_win.cc	2023-01-28 02:49:23.999573099 +0000
@@ -4,6 +4,7 @@
 
 #include "chrome/browser/ui/views/status_icons/status_tray_win.h"
 
+#include "ui/views/controls/menu/menu_controller.h"
 #include <commctrl.h>
 #include <wrl/client.h>
 
@@ -100,7 +101,7 @@
 };
 
 StatusTrayWin::StatusTrayWin()
-    : next_icon_id_(1),
+    : key_handler_(nullptr), next_icon_id_(1),
       atom_(0),
       instance_(NULL),
       window_(NULL) {
@@ -210,6 +211,13 @@
     // it gets that Windows is exiting. Make sure we shutdown in an orderly
     // fashion.
     chrome::SessionEnding();
+  } else if (message == WM_KEYDOWN || message == WM_KEYUP) {
+    CHROME_MSG msg = {hwnd, message, wparam, lparam,
+               static_cast<DWORD>(GetMessageTime())};
+    ui::KeyEvent key(msg);
+    views::MenuController* controller = views::MenuController::GetActiveInstance();
+    if (controller)
+      controller->OnWillDispatchKeyEvent(&key);
   }
   return ::DefWindowProc(hwnd, message, wparam, lparam);
 }
diff -r -u --color up/chromium/chrome/browser/ui/views/status_icons/status_tray_win.h nw/chromium/chrome/browser/ui/views/status_icons/status_tray_win.h
--- up/chromium/chrome/browser/ui/views/status_icons/status_tray_win.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/status_icons/status_tray_win.h	2023-01-28 02:49:23.999573099 +0000
@@ -41,6 +41,9 @@
   LRESULT CALLBACK
       WndProc(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam);
 
+  StatusIconWin* key_handler() { return key_handler_; }
+  void set_key_handler(StatusIconWin* win) { key_handler_ = win; }
+
  protected:
   // Overriden from StatusTray:
   std::unique_ptr<StatusIcon> CreatePlatformStatusIcon(
@@ -50,7 +53,7 @@
 
  private:
   FRIEND_TEST_ALL_PREFIXES(StatusTrayWinTest, EnsureVisibleTest);
-
+  StatusIconWin* key_handler_;
   // Static callback invoked when a message comes in to our messaging window.
   static LRESULT CALLBACK
       WndProcStatic(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam);
diff -r -u --color up/chromium/chrome/browser/ui/views/tab_icon_view.cc nw/chromium/chrome/browser/ui/views/tab_icon_view.cc
--- up/chromium/chrome/browser/ui/views/tab_icon_view.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/tab_icon_view.cc	2023-01-28 02:49:23.999573099 +0000
@@ -3,6 +3,9 @@
 // found in the LICENSE file.
 
 #include "chrome/browser/ui/views/tab_icon_view.h"
+#include "ui/gfx/scoped_canvas.h"
+#include "ui/gfx/image/image_skia_operations.h"
+#include "ui/gfx/favicon_size.h"
 
 #include <memory>
 
@@ -102,6 +105,17 @@
 
 void TabIconView::PaintFavicon(gfx::Canvas* canvas,
                                const gfx::ImageSkia& image) {
+#if 1
+  {
+    gfx::ScopedCanvas scoped_canvas(canvas);
+    const float scale = canvas->UndoDeviceScaleFactor();
+    const gfx::ImageSkia resized(gfx::ImageSkiaOperations::CreateResizedImage(
+      image, skia::ImageOperations::RESIZE_BEST, gfx::Size(gfx::kFaviconSize * scale, gfx::kFaviconSize * scale)));
+    const gfx::ImageSkiaRep& rep = resized.GetRepresentation(1);
+    canvas->DrawImageIntInPixel(rep, 0, 0, gfx::kFaviconSize * scale, gfx::kFaviconSize * scale, true, cc::PaintFlags());
+    return;
+  }
+#endif
   // For source images smaller than the favicon square, scale them as if they
   // were padded to fit the favicon square, so we don't blow up tiny favicons
   // into larger or nonproportional results.
diff -r -u --color up/chromium/chrome/browser/ui/views/toolbar/toolbar_actions_bar_bubble_views.cc nw/chromium/chrome/browser/ui/views/toolbar/toolbar_actions_bar_bubble_views.cc
--- up/chromium/chrome/browser/ui/views/toolbar/toolbar_actions_bar_bubble_views.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/toolbar/toolbar_actions_bar_bubble_views.cc	2023-01-28 02:49:24.011573226 +0000
@@ -209,7 +209,7 @@
   // an ExtensionMessageBubbleBridge, which owns the
   // ExtensionMessageBubbleController.
   delegate_->OnBubbleShown(
-      base::BindOnce(&views::Widget::Close, base::Unretained(GetWidget())));
+             base::BindOnce(&views::Widget::Close, base::Unretained(GetWidget()), false));
 }
 
 BEGIN_METADATA(ToolbarActionsBarBubbleViews, views::BubbleDialogDelegateView)
diff -r -u --color up/chromium/chrome/browser/ui/views/window_sizer_linux.cc nw/chromium/chrome/browser/ui/views/window_sizer_linux.cc
--- up/chromium/chrome/browser/ui/views/window_sizer_linux.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/window_sizer_linux.cc	2023-01-28 02:49:24.027573395 +0000
@@ -13,7 +13,7 @@
 #include "ui/ozone/public/ozone_platform.h"
 
 // static
-void WindowSizer::GetBrowserWindowBoundsAndShowState(
+bool WindowSizer::GetBrowserWindowBoundsAndShowState(
     std::unique_ptr<StateProvider> state_provider,
     const gfx::Rect& specified_bounds,
     const Browser* browser,
@@ -26,6 +26,7 @@
   *show_state = GetWindowDefaultShowState(browser);
   *bounds = specified_bounds;
   sizer.DetermineWindowBoundsAndShowState(specified_bounds, bounds, show_state);
+  return true;
 }
 
 WindowSizerLinux::WindowSizerLinux(
diff -r -u --color up/chromium/chrome/browser/ui/webui/app_settings/web_app_settings_ui.cc nw/chromium/chrome/browser/ui/webui/app_settings/web_app_settings_ui.cc
--- up/chromium/chrome/browser/ui/webui/app_settings/web_app_settings_ui.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/webui/app_settings/web_app_settings_ui.cc	2023-01-28 02:49:24.035573480 +0000
@@ -99,6 +99,7 @@
 
 void WebAppSettingsUI::BindInterface(
     mojo::PendingReceiver<app_management::mojom::PageHandlerFactory> receiver) {
+#if 0
   if (!app_management_page_handler_factory_) {
     auto window_delegate = std::make_unique<WebAppSettingsWindowDelegate>(
         Profile::FromWebUI(web_ui()));
@@ -108,6 +109,7 @@
             Profile::FromWebUI(web_ui()), std::move(window_delegate));
   }
   app_management_page_handler_factory_->Bind(std::move(receiver));
+#endif
 }
 
 void WebAppSettingsUI::OnWebAppUninstalled(const web_app::AppId& app_id) {
diff -r -u --color up/chromium/chrome/browser/ui/webui/chrome_web_contents_handler.cc nw/chromium/chrome/browser/ui/webui/chrome_web_contents_handler.cc
--- up/chromium/chrome/browser/ui/webui/chrome_web_contents_handler.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/webui/chrome_web_contents_handler.cc	2023-01-28 02:49:24.059573734 +0000
@@ -103,7 +103,7 @@
       return;
     }
     browser = Browser::Create(
-        Browser::CreateParams(Browser::TYPE_NORMAL, profile, user_gesture));
+        Browser::CreateParams(Browser::TYPE_POPUP, profile, user_gesture));
   }
   NavigateParams params(browser, std::move(new_contents));
   params.source_contents = source;
diff -r -u --color up/chromium/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc nw/chromium/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
--- up/chromium/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc	2023-01-28 02:49:24.059573734 +0000
@@ -442,7 +442,7 @@
   return new WEB_UI_CONTROLLER(web_ui, std::move(delegate));
 }
 
-#if !BUILDFLAG(IS_ANDROID)
+#if 0 //!BUILDFLAG(IS_ANDROID)
 template <>
 WebUIController* NewWebUI<PageNotAvailableForGuestUI>(WebUI* web_ui,
                                                       const GURL& url) {
@@ -450,11 +450,13 @@
 }
 #endif
 
+#if defined(NWJS_SDK)
 // Special case for older about: handlers.
 template <>
 WebUIController* NewWebUI<AboutUI>(WebUI* web_ui, const GURL& url) {
   return new AboutUI(web_ui, url.host());
 }
+#endif
 
 template <>
 WebUIController* NewWebUI<OptimizationGuideInternalsUI>(WebUI* web_ui,
@@ -703,13 +705,16 @@
 
 #endif  // BUILDFLAG(IS_CHROMEOS_ASH)
 
-#if BUILDFLAG(ENABLE_DICE_SUPPORT)
+//#if BUILDFLAG(ENABLE_DICE_SUPPORT)
+
+#if 0
 template <>
 WebUIController* NewWebUI<WelcomeUI>(WebUI* web_ui, const GURL& url) {
   return new WelcomeUI(web_ui, url);
 }
 #endif  // !BUILDFLAG(IS_ANDROID) && !BUILDFLAG(IS_CHROMEOS_ASH)
 
+#if defined(NWJS_SDK)
 bool IsAboutUI(const GURL& url) {
   return (url.host_piece() == chrome::kChromeUIChromeURLsHost ||
           url.host_piece() == chrome::kChromeUICreditsHost
@@ -726,6 +731,7 @@
 #endif
   );  // NOLINT
 }
+#endif
 
 // Returns a function that can be used to create the right type of WebUI for a
 // tab, based on its URL. Returns nullptr if the URL doesn't have WebUI
@@ -750,6 +756,7 @@
   // All platform builds of Chrome will need to have a cloud printing
   // dialog as backup.  It's just that on Chrome OS, it's the only
   // print dialog.
+#if 0
   if (url.host_piece() == chrome::kChromeUIAccessibilityHost)
     return &NewWebUI<AccessibilityUI>;
   if (url.host_piece() == chrome::kChromeUIAPCInternalsHost)
@@ -771,6 +778,7 @@
     return &NewWebUI<BrowsingTopicsInternalsUI>;
   if (url.host_piece() == chrome::kChromeUIComponentsHost)
     return &NewWebUI<ComponentsUI>;
+#endif
   if (url.spec() == chrome::kChromeUIConstrainedHTMLTestURL)
     return &NewWebUI<ConstrainedWebDialogUI>;
   if (url.host_piece() == chrome::kChromeUICrashesHost)
@@ -788,6 +796,7 @@
     return &NewWebUI<GCMInternalsUI>;
   if (url.host_piece() == chrome::kChromeUIInternalsHost)
     return &NewWebUI<InternalsUI>;
+#if 0
   if (url.host_piece() == chrome::kChromeUIInterstitialHost)
     return &NewWebUI<InterstitialUI>;
   if (url.host_piece() == chrome::kChromeUIInvalidationsHost)
@@ -836,13 +845,13 @@
   }
   if (url.host_piece() == chrome::kChromeUIUsbInternalsHost)
     return &NewWebUI<UsbInternalsUI>;
+#endif
   if (url.host_piece() == chrome::kChromeUIUserActionsHost)
     return &NewWebUI<UserActionsUI>;
   if (url.host_piece() == chrome::kChromeUIVersionHost)
     return &NewWebUI<VersionUI>;
 
-#if !BUILDFLAG(IS_ANDROID)
-#if !BUILDFLAG(IS_CHROMEOS)
+#if 0 //!BUILDFLAG(IS_CHROMEOS)
   // AppLauncherPage is not needed on Android or ChromeOS.
   if (url.host_piece() == chrome::kChromeUIAppLauncherPageHost && profile &&
       extensions::ExtensionSystem::Get(profile)->extension_service() &&
@@ -854,6 +863,8 @@
     }
   }
 #endif  // !BUILDFLAG(IS_CHROMEOS)
+
+#if 0
   if (profile->IsGuestSession() &&
       (url.host_piece() == chrome::kChromeUIAppLauncherPageHost ||
        url.host_piece() == chrome::kChromeUIBookmarksHost ||
@@ -878,6 +889,7 @@
   // Downloads list on Android uses the built-in download manager.
   if (url.host_piece() == chrome::kChromeUIDownloadsHost)
     return &NewWebUI<DownloadsUI>;
+#endif
   // Identity API is not available on Android.
   if (url.host_piece() == chrome::kChromeUIIdentityInternalsHost)
     return &NewWebUI<IdentityInternalsUI>;
@@ -912,16 +924,22 @@
     return &NewWebUI<settings::SettingsUI>;
   if (url.host_piece() == chrome::kChromeUITabSearchHost)
     return &NewWebUI<TabSearchUI>;
+#if defined(NWJS_SDK)
   if (url.host_piece() == chrome::kChromeUIExtensionsHost)
     return &NewWebUI<extensions::ExtensionsUI>;
+#endif
+#if 0
   if (url.host_piece() == chrome::kChromeUIHistoryHost)
     return &NewWebUI<HistoryUI>;
   if (url.host_piece() == chrome::kChromeUIProfileInternalsHost)
     return &NewWebUI<ProfileInternalsUI>;
+#endif
   if (url.host_piece() == chrome::kChromeUISyncFileSystemInternalsHost)
     return &NewWebUI<SyncFileSystemInternalsUI>;
+#if 0
   if (url.host_piece() == chrome::kChromeUISystemInfoHost)
     return &NewWebUI<SystemInfoUI>;
+#endif
   if (url.host_piece() == chrome::kChromeUIAccessCodeCastHost) {
     if (!base::FeatureList::IsEnabled(features::kAccessCodeCastUI)) {
       return nullptr;
@@ -935,8 +953,8 @@
       url.host_piece() == chrome::kChromeUISupportToolHost &&
       SupportToolUI::IsEnabled(profile))
     return &NewWebUI<SupportToolUI>;
-#endif  // !BUILDFLAG(IS_ANDROID)
-#if BUILDFLAG(IS_WIN)
+
+#if 0
   if (url.host_piece() == chrome::kChromeUIConflictsHost)
     return &NewWebUI<ConflictsUI>;
 #endif
@@ -1055,6 +1073,7 @@
   // extensions aren't supported.
   if (url.host_piece() == chrome::kChromeUIInspectHost)
     return &NewWebUI<InspectUI>;
+#if 0
   if (url.host_piece() == chrome::kChromeUISyncConfirmationHost &&
       !profile->IsOffTheRecord()) {
     return &NewWebUI<SyncConfirmationUI>;
@@ -1062,6 +1081,8 @@
   if (url.host_piece() == chrome::kChromeUIImageEditorHost) {
     return &NewWebUI<image_editor::ImageEditorUI>;
   }
+#endif
+
 #endif  // BUILDFLAG(IS_ANDROID)
 #if !BUILDFLAG(IS_CHROMEOS_ASH) && !BUILDFLAG(IS_ANDROID)
   if (url.host_piece() == chrome::kChromeUIEnterpriseProfileWelcomeHost)
@@ -1073,6 +1094,9 @@
     return &NewWebUI<ProfileCustomizationUI>;
   if (url.host_piece() == chrome::kChromeUIProfilePickerHost)
     return &NewWebUI<ProfilePickerUI>;
+#endif
+
+#if 0
   if (url.host_piece() == chrome::kChromeUISigninErrorHost &&
       (!profile->IsOffTheRecord() || profile->IsSystemProfile()))
     return &NewWebUI<SigninErrorUI>;
@@ -1150,6 +1174,7 @@
     return &NewWebUI<SandboxInternalsUI>;
   }
 #endif
+#if 0
 #if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_MAC) || BUILDFLAG(IS_LINUX) || \
     BUILDFLAG(IS_CHROMEOS_ASH)
   if (url.host_piece() == chrome::kChromeUIConnectorsInternalsHost)
@@ -1169,17 +1194,23 @@
   if (url.host_piece() == chrome::kChromeUIWebAppSettingsHost)
     return &NewWebUI<WebAppSettingsUI>;
 #endif
+#endif
+
+#if defined(NWJS_SDK)
   if (IsAboutUI(url))
     return &NewWebUI<AboutUI>;
+#endif
 
   if (url.host_piece() == security_interstitials::kChromeUIConnectionHelpHost) {
     return &NewWebUI<security_interstitials::ConnectionHelpUI>;
   }
 
+#if 0
   if (site_engagement::SiteEngagementService::IsEnabled() &&
       url.host_piece() == chrome::kChromeUISiteEngagementHost) {
     return &NewWebUI<SiteEngagementUI>;
   }
+#endif
 
   if (MediaEngagementService::IsEnabled() &&
       url.host_piece() == chrome::kChromeUIMediaEngagementHost) {
@@ -1203,10 +1234,12 @@
 #endif
 
 #if BUILDFLAG(ENABLE_DICE_SUPPORT)
+#if 0
   if (url.host_piece() == chrome::kChromeUIWelcomeHost &&
       welcome::IsEnabled(profile)) {
     return &NewWebUI<WelcomeUI>;
   }
+#endif
   if (url.host_piece() == chrome::kChromeUIDiceWebSigninInterceptHost)
     return &NewWebUI<DiceWebSigninInterceptUI>;
   if (url.host_piece() == chrome::kChromeUISigninReauthHost &&
@@ -1375,8 +1408,10 @@
   if (!content::HasWebUIScheme(page_url))
     return nullptr;
 
+#if 0
   if (page_url.host_piece() == chrome::kChromeUIComponentsHost)
     return ComponentsUI::GetFaviconResourceBytes(scale_factor);
+#endif
 
 #if BUILDFLAG(IS_WIN)
   if (page_url.host_piece() == chrome::kChromeUIConflictsHost)
@@ -1402,12 +1437,15 @@
   if (page_url.host_piece() == chrome::kChromeUIWhatsNewHost)
     return WhatsNewUI::GetFaviconResourceBytes(scale_factor);
 
+#if 0
   // Bookmarks are part of NTP on Android.
   if (page_url.host_piece() == chrome::kChromeUIBookmarksHost)
     return BookmarksUI::GetFaviconResourceBytes(scale_factor);
 
+#if 0
   if (page_url.host_piece() == chrome::kChromeUIHistoryHost)
     return HistoryUI::GetFaviconResourceBytes(scale_factor);
+#endif
 
   if (page_url.host_piece() == chrome::kChromeUIPasswordManagerHost)
     return PasswordManagerUI::GetFaviconResourceBytes(scale_factor);
@@ -1424,16 +1462,18 @@
     }
     return settings_utils::GetFaviconResourceBytes(scale_factor);
   }
+#endif  // !defined(OS_ANDROID)
 
   if (page_url.host_piece() == chrome::kChromeUIManagementHost)
     return ManagementUI::GetFaviconResourceBytes(scale_factor);
 
-#if BUILDFLAG(ENABLE_EXTENSIONS)
+#if BUILDFLAG(ENABLE_EXTENSIONS) && defined(NWJS_SDK)
   if (page_url.host_piece() == chrome::kChromeUIExtensionsHost) {
     return extensions::ExtensionsUI::GetFaviconResourceBytes(scale_factor);
   }
 #endif  // BUILDFLAG(ENABLE_EXTENSIONS)
-#endif  // !BUILDFLAG(IS_ANDROID)
+
+#endif
 
 #if BUILDFLAG(IS_CHROMEOS_ASH)
   if (page_url.host_piece() == chrome::kChromeUIOSSettingsHost)
diff -r -u --color up/chromium/chrome/browser/ui/webui/downloads/downloads_dom_handler.cc nw/chromium/chrome/browser/ui/webui/downloads/downloads_dom_handler.cc
--- up/chromium/chrome/browser/ui/webui/downloads/downloads_dom_handler.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/webui/downloads/downloads_dom_handler.cc	2023-01-28 02:49:24.067573818 +0000
@@ -182,6 +182,7 @@
 
 void DownloadsDOMHandler::DiscardDangerous(const std::string& id) {
   CountDownloadsDOMEvents(DOWNLOADS_DOM_EVENT_DISCARD_DANGEROUS);
+#if 0
   download::DownloadItem* download = GetDownloadByStringId(id);
   if (download) {
     // If this download is no longer dangerous, is already canceled or
@@ -208,6 +209,7 @@
       }
     }
   }
+#endif
   RemoveDownloadInArgs(id);
 }
 
@@ -401,7 +403,7 @@
   if (download) {
     DownloadItemModel model(download);
     model.SetOpenWhenComplete(true);
-#if BUILDFLAG(FULL_SAFE_BROWSING)
+#if 0 //BUILDFLAG(FULL_SAFE_BROWSING)
     model.CompleteSafeBrowsingScan();
 #endif
   }
@@ -415,11 +417,13 @@
   }
 
   CountDownloadsDOMEvents(DOWNLOADS_DOM_EVENT_REVIEW_DANGEROUS);
+#if 0
   download::DownloadItem* download = GetDownloadByStringId(id);
   if (download) {
     DownloadItemModel model(download);
     model.ReviewScanningVerdict(GetWebUIWebContents());
   }
+#endif
 }
 
 // DownloadsDOMHandler, private: --------------------------------------------
@@ -448,12 +452,14 @@
 
 void DownloadsDOMHandler::ShowDangerPrompt(
     download::DownloadItem* dangerous_item) {
+#if 0
   DownloadDangerPrompt* danger_prompt = DownloadDangerPrompt::Create(
       dangerous_item, GetWebUIWebContents(), false,
       base::BindOnce(&DownloadsDOMHandler::DangerPromptDone,
                      weak_ptr_factory_.GetWeakPtr(), dangerous_item->GetId()));
   // danger_prompt will delete itself.
   DCHECK(danger_prompt);
+#endif
 }
 
 void DownloadsDOMHandler::DangerPromptDone(
diff -r -u --color up/chromium/chrome/browser/ui/webui/extensions/extensions_internals_source.cc nw/chromium/chrome/browser/ui/webui/extensions/extensions_internals_source.cc
--- up/chromium/chrome/browser/ui/webui/extensions/extensions_internals_source.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/webui/extensions/extensions_internals_source.cc	2023-01-28 02:49:24.067573818 +0000
@@ -51,6 +51,8 @@
       return "TYPE_LEGACY_PACKAGED_APP";
     case extensions::Manifest::TYPE_PLATFORM_APP:
       return "TYPE_PLATFORM_APP";
+    case extensions::Manifest::TYPE_NWJS_APP:
+      return "TYPE_NWJS_APP";
     case extensions::Manifest::TYPE_SHARED_MODULE:
       return "TYPE_SHARED_MODULE";
     case extensions::Manifest::TYPE_LOGIN_SCREEN_EXTENSION:
diff -r -u --color up/chromium/chrome/browser/ui/webui/print_preview/pdf_printer_handler.cc nw/chromium/chrome/browser/ui/webui/print_preview/pdf_printer_handler.cc
--- up/chromium/chrome/browser/ui/webui/print_preview/pdf_printer_handler.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/webui/print_preview/pdf_printer_handler.cc	2023-01-28 02:49:24.083573987 +0000
@@ -61,6 +61,8 @@
 #include "chromeos/lacros/lacros_service.h"
 #endif
 
+#include "chrome/browser/ui/webui/print_preview/print_preview_handler.h"
+
 namespace printing {
 
 namespace {
@@ -264,6 +266,10 @@
     scoped_refptr<base::RefCountedMemory> print_data,
     PrintCallback callback) {
   print_data_ = print_data;
+  if (!chrome::NWPrintGetPDFPath().empty() && chrome::NWPrintGetCustomPrinting()) {
+    print_to_pdf_path_ = chrome::NWPrintGetPDFPath();
+    print_callback_ = std::move(callback);
+  }
   if (!print_to_pdf_path_.empty()) {
     // User has already selected a path, no need to show the dialog again.
     PostPrintToPdfTask();
diff -r -u --color up/chromium/chrome/browser/ui/webui/print_preview/print_preview_handler.cc nw/chromium/chrome/browser/ui/webui/print_preview/print_preview_handler.cc
--- up/chromium/chrome/browser/ui/webui/print_preview/print_preview_handler.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/webui/print_preview/print_preview_handler.cc	2023-01-28 02:49:24.087574030 +0000
@@ -4,6 +4,8 @@
 
 #include "chrome/browser/ui/webui/print_preview/print_preview_handler.h"
 
+#include "base/no_destructor.h"
+#include "base/json/json_writer.h"
 #include <ctype.h>
 #include <stddef.h>
 
@@ -86,6 +88,15 @@
 using content::RenderFrameHost;
 using content::WebContents;
 
+namespace {
+static base::NoDestructor<std::string> g_nw_printer_name;
+static base::NoDestructor<base::FilePath> g_nw_print_to_pdf_path;
+static base::NoDestructor<base::Value> g_nw_print_options;
+
+bool g_nw_custom_printing = false;
+
+}
+
 namespace printing {
 
 namespace {
@@ -390,7 +401,38 @@
 #endif  // BUILDFLAG(IS_CHROMEOS)
 
 }  // namespace
+} // namespace printing
+
+namespace chrome {
+void NWPrintSetCustomPrinting(bool value) {
+  g_nw_custom_printing = value;
+}
 
+bool NWPrintGetCustomPrinting() {
+  return g_nw_custom_printing;
+}
+
+void NWPrintSetOptions(const base::DictionaryValue* dict, WebContents* web_contents) {
+  *g_nw_print_options = dict->Clone();
+  absl::optional<bool> silent_printing = (*g_nw_print_options).FindBoolKey("silent");
+  if (silent_printing && web_contents)
+    web_contents->set_silent_printing(*silent_printing);
+}
+
+void NWPrintSetPDFPath(const base::FilePath& path) {
+  *g_nw_print_to_pdf_path = path;
+}
+
+const base::FilePath& NWPrintGetPDFPath() {
+  return *g_nw_print_to_pdf_path;
+}
+
+void NWPrintSetDefaultPrinter(const std::string& printer_name) {
+  *g_nw_printer_name = printer_name;
+}
+}
+
+namespace printing {
 PrintPreviewHandler::PrintPreviewHandler() {
 #if BUILDFLAG(IS_CHROMEOS_ASH)
   DCHECK(crosapi::CrosapiManager::IsInitialized());
@@ -684,6 +726,40 @@
   absl::optional<bool> display_header_footer_opt =
       settings.FindBool(kSettingHeaderFooterEnabled);
   DCHECK(display_header_footer_opt);
+  std::string footer_string, header_string;
+  base::Value::Dict* dict = (*g_nw_print_options).GetIfDict();
+  if (dict) {
+    base::Value::Dict* media_size_value = dict->FindDict(printing::kSettingMediaSize);
+    base::Value::Dict* custom_margins = dict->FindDict(printing::kSettingMarginsCustom);
+    absl::optional<bool> display_header_footer;
+
+    if (media_size_value && media_size_value->empty())
+      settings.Set(printing::kSettingMediaSize, media_size_value->Clone());
+    display_header_footer = (*g_nw_print_options).FindBoolKey(printing::kSettingHeaderFooterEnabled);
+    if (display_header_footer)
+      settings.Set(printing::kSettingHeaderFooterEnabled, *display_header_footer);
+    absl::optional<bool> landscape = (*g_nw_print_options).FindBoolKey(printing::kSettingLandscape);
+    if (landscape)
+      settings.Set(printing::kSettingLandscape, *landscape);
+    absl::optional<bool> backgrounds = (*g_nw_print_options).FindBoolKey(printing::kSettingShouldPrintBackgrounds);
+    if (backgrounds)
+      settings.Set(printing::kSettingShouldPrintBackgrounds, *backgrounds);
+    absl::optional<int> margins_type = dict->FindInt(printing::kSettingMarginsType);
+    if (margins_type)
+      settings.Set(printing::kSettingMarginsType, *margins_type);
+    if (custom_margins && !custom_margins->empty())
+      settings.Set(printing::kSettingMarginsCustom, custom_margins->Clone());
+    absl::optional<int> scale = dict->FindInt(printing::kSettingScaleFactor);
+    if (scale)
+      settings.Set(printing::kSettingScaleFactor, *scale);
+    std::string* str = dict->FindString("footerString");
+    if (str)
+      footer_string = *str;
+    str = dict->FindString("headerString");
+    if (str)
+      header_string = *str;
+  }
+
   if (display_header_footer_opt.value_or(false)) {
     settings.Set(kSettingHeaderFooterTitle, initiator->GetTitle());
 
@@ -691,9 +767,14 @@
     url_sanitizer.ClearUsername();
     url_sanitizer.ClearPassword();
     const GURL& initiator_url = initiator->GetLastCommittedURL();
+    if (footer_string.empty())
     settings.Set(kSettingHeaderFooterURL,
                  url_formatter::FormatUrl(
                      initiator_url.ReplaceComponents(url_sanitizer)));
+    else
+      settings.Set(printing::kSettingHeaderFooterURL, footer_string);
+    if (!header_string.empty())
+      settings.Set(printing::kSettingHeaderFooterTitle, header_string);
   }
 
   VLOG(1) << "Print preview request start";
@@ -716,10 +797,27 @@
   const std::string& callback_id = args[0].GetString();
   CHECK(!callback_id.empty());
   CHECK(args[1].is_string());
-  const std::string& json_str = args[1].GetString();
+  std::string json_str = args[1].GetString();
 
   base::Value::Dict settings = GetSettingsDictionary(json_str);
   const UserActionBuckets user_action = DetermineUserAction(settings);
+  base::Value::Dict* dict = (*g_nw_print_options).GetIfDict();
+  if (dict) {
+    base::Value::List* page_range_array = dict->FindList(printing::kSettingPageRange);
+    bool changed = false;
+
+    if (page_range_array && !page_range_array->empty()) {
+      changed = true;
+      settings.Set(printing::kSettingPageRange, page_range_array->Clone());
+    }
+    absl::optional<int> copies = dict->FindInt(printing::kSettingCopies);
+    if (copies) {
+      changed = true;
+      settings.Set(printing::kSettingCopies, *copies);
+    }
+    if (changed)
+      base::JSONWriter::Write(settings, &json_str);
+  }
 
   int page_count = settings.FindInt(kSettingPreviewPageCount).value_or(-1);
   if (page_count <= 0) {
@@ -757,6 +855,7 @@
                       std::move(settings), data,
                       base::BindOnce(&PrintPreviewHandler::OnPrintResult,
                                      weak_factory_.GetWeakPtr(), callback_id));
+  chrome::NWPrintSetCustomPrinting(false);
 }
 
 void PrintPreviewHandler::HandleHidePreview(const base::Value::List& /*args*/) {
@@ -888,7 +987,7 @@
   bool source_is_arc = false;
 #endif
   initial_settings.Set(kSettingPreviewIsFromArc, source_is_arc);
-  initial_settings.Set(kSettingPrinterName, default_printer);
+  initial_settings.Set(kSettingPrinterName, (*g_nw_printer_name).empty() ? default_printer : *g_nw_printer_name);
   initial_settings.Set(kDocumentHasSelection,
                        print_preview_ui()->source_has_selection());
   initial_settings.Set(kSettingShouldPrintSelectionOnly,
@@ -917,8 +1016,11 @@
 
   base::CommandLine* cmdline = base::CommandLine::ForCurrentProcess();
   initial_settings.Set(kIsInKioskAutoPrintMode,
-                       cmdline->HasSwitch(switches::kKioskModePrinting));
+                       cmdline->HasSwitch(switches::kKioskModePrinting) || g_nw_custom_printing);
   initial_settings.Set(kIsInAppKioskMode, chrome::IsRunningInForcedAppMode());
+  initial_settings.Set("nwPrintMode", g_nw_custom_printing);
+  if (g_nw_custom_printing || !(*g_nw_printer_name).empty())
+    initial_settings.Set(kAppState, base::Value());
   const std::string rules_str =
       prefs->GetString(prefs::kPrintPreviewDefaultDestinationSelectionRules);
   if (rules_str.empty()) {
diff -r -u --color up/chromium/chrome/browser/ui/webui/print_preview/print_preview_handler.h nw/chromium/chrome/browser/ui/webui/print_preview/print_preview_handler.h
--- up/chromium/chrome/browser/ui/webui/print_preview/print_preview_handler.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/webui/print_preview/print_preview_handler.h	2023-01-28 02:49:24.087574030 +0000
@@ -45,6 +45,16 @@
 class WebContents;
 }
 
+namespace chrome {
+  base::Value::List PrintersToValues(const printing::PrinterList& printer_list);
+  void NWPrintSetCustomPrinting(bool value);
+  bool NWPrintGetCustomPrinting();
+  void NWPrintSetDefaultPrinter(const std::string& printer_name);
+  void NWPrintSetPDFPath(const base::FilePath& path);
+  const base::FilePath& NWPrintGetPDFPath();
+void NWPrintSetOptions(const base::DictionaryValue* dict, content::WebContents*);
+}
+
 namespace printing {
 
 class PdfPrinterHandler;
diff -r -u --color up/chromium/chrome/browser/ui/webui/print_preview/print_preview_utils.cc nw/chromium/chrome/browser/ui/webui/print_preview/print_preview_utils.cc
--- up/chromium/chrome/browser/ui/webui/print_preview/print_preview_utils.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/webui/print_preview/print_preview_utils.cc	2023-01-28 02:49:24.087574030 +0000
@@ -49,16 +49,17 @@
 // The dictionary key for the CDD item containing custom vendor capabilities.
 const char kVendorCapabilityKey[] = "vendor_capability";
 
-namespace {
+}
 
-base::Value::List PrintersToValues(const PrinterList& printer_list) {
+namespace chrome {
+base::Value::List PrintersToValues(const printing::PrinterList& printer_list) {
   base::Value::List results;
-  for (const PrinterBasicInfo& printer : printer_list) {
+  for (const printing::PrinterBasicInfo& printer : printer_list) {
     base::Value::Dict printer_info;
-    printer_info.Set(kSettingDeviceName, printer.printer_name);
+    printer_info.Set(printing::kSettingDeviceName, printer.printer_name);
 
-    printer_info.Set(kSettingPrinterName, printer.display_name);
-    printer_info.Set(kSettingPrinterDescription, printer.printer_description);
+    printer_info.Set(printing::kSettingPrinterName, printer.display_name);
+    printer_info.Set(printing::kSettingPrinterDescription, printer.printer_description);
 
     base::Value::Dict options;
     for (const auto& opt_it : printer.options)
@@ -71,7 +72,7 @@
             printer.options.at(kCUPSEnterprisePrinter) == kValueTrue);
 #endif  // BUILDFLAG(IS_CHROMEOS_ASH)
 
-    printer_info.Set(kSettingPrinterOptions, std::move(options));
+    printer_info.Set(printing::kSettingPrinterOptions, std::move(options));
 
     results.Append(std::move(printer_info));
 
@@ -81,6 +82,9 @@
   return results;
 }
 
+}  // namespace chrome
+
+namespace printing {
 template <typename Predicate>
 base::Value::List GetFilteredList(const base::Value::List& list,
                                   Predicate pred) {
@@ -130,7 +134,6 @@
   // intentional no-op
 }
 
-}  // namespace
 
 base::Value::Dict ValidateCddForPrintPreview(base::Value::Dict cdd) {
   base::Value::Dict* caps = cdd.FindDict(kPrinter);
@@ -221,7 +224,7 @@
     PrinterHandler::AddedPrintersCallback callback,
     PrinterHandler::GetPrintersDoneCallback done_callback,
     const PrinterList& printer_list) {
-  base::Value::List printers = PrintersToValues(printer_list);
+  base::Value::List printers = chrome::PrintersToValues(printer_list);
 
   VLOG(1) << "Enumerate printers finished, found " << printers.size()
           << " printers";
@@ -252,7 +255,7 @@
     // Run the callback early, or the modal dialogs will prevent the preview
     // from closing until they do.
     std::move(callback).Run(base::Value());
-    callback = base::BindOnce(&SystemDialogDone);
+    callback = base::BindOnce(&printing::SystemDialogDone);
   }
   print_view_manager->PrintForPrintPreview(
       std::move(job_settings), std::move(print_data),
diff -r -u --color up/chromium/chrome/browser/ui/webui/settings/people_handler.cc nw/chromium/chrome/browser/ui/webui/settings/people_handler.cc
--- up/chromium/chrome/browser/ui/webui/settings/people_handler.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/webui/settings/people_handler.cc	2023-01-28 02:49:24.103574199 +0000
@@ -649,6 +649,7 @@
 
 #if BUILDFLAG(ENABLE_DICE_SUPPORT) || BUILDFLAG(IS_CHROMEOS_LACROS)
 void PeopleHandler::HandleSignout(const base::Value::List& args) {
+#if 0
   bool delete_profile = false;
   if (args[0].is_bool())
     delete_profile = args[0].GetBool();
@@ -733,6 +734,7 @@
     webui::DeleteProfileAtPath(profile_path,
                                ProfileMetrics::DELETE_PROFILE_SETTINGS);
   }
+#endif
 }
 #endif  // BUILDFLAG(ENABLE_DICE_SUPPORT) || BUILDFLAG(IS_CHROMEOS_LACROS)
 
diff -r -u --color up/chromium/chrome/browser/ui/webui/settings/settings_ui.cc nw/chromium/chrome/browser/ui/webui/settings/settings_ui.cc
--- up/chromium/chrome/browser/ui/webui/settings/settings_ui.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/webui/settings/settings_ui.cc	2023-01-28 02:49:24.107574241 +0000
@@ -1,7 +1,7 @@
 // Copyright 2015 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
-
+#pragma clang diagnostic ignored "-Wunused-const-variable"
 #include "chrome/browser/ui/webui/settings/settings_ui.h"
 
 #include <stddef.h>
@@ -184,6 +184,7 @@
   Profile* profile = Profile::FromWebUI(web_ui);
   content::WebUIDataSource* html_source =
       content::WebUIDataSource::Create(chrome::kChromeUISettingsHost);
+#if 0
   html_source->OverrideContentSecurityPolicy(
       network::mojom::CSPDirectiveName::WorkerSrc, "worker-src blob: 'self';");
 
@@ -420,6 +421,7 @@
 
   content::WebUIDataSource::Add(web_ui->GetWebContents()->GetBrowserContext(),
                                 html_source);
+#endif
 
   content::URLDataSource::Add(
       profile, std::make_unique<FaviconSource>(
diff -r -u --color up/chromium/chrome/browser/ui/window_sizer/window_sizer.cc nw/chromium/chrome/browser/ui/window_sizer/window_sizer.cc
--- up/chromium/chrome/browser/ui/window_sizer/window_sizer.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/window_sizer/window_sizer.cc	2023-01-28 02:49:24.127574452 +0000
@@ -1,10 +1,11 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
-
+#pragma clang diagnostic ignored "-Wunreachable-code"
 #include "chrome/browser/ui/window_sizer/window_sizer.h"
 
 #include <algorithm>
+#include "content/nw/src/nw_base.h"
 #include <utility>
 
 #include "base/command_line.h"
@@ -69,6 +70,8 @@
     if (!browser_ || !browser_->profile()->GetPrefs())
       return false;
 
+    if (browser_->is_type_popup() && browser_->windows_key().empty())
+      return false;
     const base::Value::Dict* pref =
         chrome::GetWindowPlacementDictionaryReadOnly(
             chrome::GetWindowName(browser_), browser_->profile()->GetPrefs());
@@ -78,6 +81,8 @@
         RectFromPrefixedPref(pref, "work_area_");
     absl::optional<bool> maximized =
         pref ? pref->FindBool("maximized") : absl::nullopt;
+    absl::optional<bool> fullscreen =
+        pref ? pref->FindBool("fullscreen") : absl::nullopt;
 
     if (!pref_bounds || !maximized)
       return false;
@@ -87,6 +92,8 @@
       *work_area = pref_area.value();
     if (*show_state == ui::SHOW_STATE_DEFAULT && maximized.value())
       *show_state = ui::SHOW_STATE_MAXIMIZED;
+    if (*show_state == ui::SHOW_STATE_DEFAULT && fullscreen && fullscreen.value())
+      *show_state = ui::SHOW_STATE_FULLSCREEN;
 
     return true;
   }
@@ -195,7 +202,7 @@
 WindowSizer::~WindowSizer() = default;
 
 // static
-void WindowSizer::GetBrowserWindowBoundsAndShowState(
+bool WindowSizer::GetBrowserWindowBoundsAndShowState(
     const gfx::Rect& specified_bounds,
     const Browser* browser,
     gfx::Rect* window_bounds,
@@ -208,7 +215,7 @@
 #if !BUILDFLAG(IS_LINUX)
 // Linux has its own implementation, see WindowSizerLinux.
 // static
-void WindowSizer::GetBrowserWindowBoundsAndShowState(
+bool WindowSizer::GetBrowserWindowBoundsAndShowState(
     std::unique_ptr<StateProvider> state_provider,
     const gfx::Rect& specified_bounds,
     const Browser* browser,
@@ -224,26 +231,34 @@
   // Pre-populate the window state with our default.
   *show_state = GetWindowDefaultShowState(browser);
   *bounds = specified_bounds;
-  sizer.DetermineWindowBoundsAndShowState(specified_bounds, bounds, show_state);
+  return sizer.DetermineWindowBoundsAndShowState(specified_bounds, bounds, show_state);
 }
 #endif  // !BUILDFLAG(IS_LINUX)
 
-void WindowSizer::DetermineWindowBoundsAndShowState(
+bool WindowSizer::DetermineWindowBoundsAndShowState(
     const gfx::Rect& specified_bounds,
     gfx::Rect* bounds,
     ui::WindowShowState* show_state) {
-  if (bounds->IsEmpty()) {
+  // In upstream, non empty case is only used in chrome tests, so we ignore it.
+  // In NW, the non empty value is the API parameter passed by browser->override_bounds()
+  // Use this strategy as the central place to determine window size
+  // priority: saved > API parameter > default in manifest > default value
+  if (true || bounds->IsEmpty()) {
     // See if there's last active window's placement information.
     if (GetLastActiveWindowBounds(bounds, show_state))
-      return;
+      return false;
+    gfx::Rect saved;
     // See if there's saved placement information.
-    if (GetSavedWindowBounds(bounds, show_state))
-      return;
-
+    if (GetSavedWindowBounds(&saved, show_state)) {
+      *bounds = saved;
+      return true;
+    }
+    if (!bounds->IsEmpty())
+      return false;
     // No saved placement, figure out some sensible default size based on
     // the user's screen size.
     *bounds = GetDefaultWindowBounds(GetDisplayForNewWindow());
-    return;
+    return false;
   }
 
   // In case that there was a bound given we need to make sure that it is
@@ -259,6 +274,7 @@
 
   // Resize so that it fits.
   bounds->AdjustToFit(work_area);
+  return false;
 }
 
 void WindowSizer::AdjustWorkAreaForPlatform(gfx::Rect& work_area) {}
@@ -297,6 +313,15 @@
     const display::Display& display) const {
   gfx::Rect work_area = display.work_area();
 
+  int default_width = 800;
+  int default_height = 600;
+  nw::Package* package = nw::package();
+  if (package && package->window()) {
+    default_width = package->window()->FindInt("width").value_or(800);
+    default_height = package->window()->FindInt("height").value_or(600);
+  }
+
+#if 0
   // The default size is either some reasonably wide width, or if the work
   // area is narrower, then the work area width less some aesthetic padding.
   int default_width = std::min(work_area.width() - 2 * kWindowTilePixels,
@@ -324,9 +349,10 @@
         1.5 * kWindowTilePixels);
   }
 #endif  // !BUILDFLAG(IS_MAC)
+#endif
   return gfx::Rect(kWindowTilePixels + work_area.x(),
-                   kWindowTilePixels + work_area.y(), default_width,
-                   default_height);
+                   kWindowTilePixels + work_area.y(),
+                   default_width, default_height);
 }
 
 void WindowSizer::AdjustBoundsToBeVisibleOnDisplay(
diff -r -u --color up/chromium/chrome/browser/ui/window_sizer/window_sizer.h nw/chromium/chrome/browser/ui/window_sizer/window_sizer.h
--- up/chromium/chrome/browser/ui/window_sizer/window_sizer.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/ui/window_sizer/window_sizer.h	2023-01-28 02:49:24.127574452 +0000
@@ -72,14 +72,14 @@
   //
   // |show_state| will be overwritten and return the initial visual state of
   // the window to use.
-  static void GetBrowserWindowBoundsAndShowState(
+  static bool GetBrowserWindowBoundsAndShowState(
       const gfx::Rect& specified_bounds,
       const Browser* browser,
       gfx::Rect* window_bounds,
       ui::WindowShowState* show_state);
 
   // As above, but takes a state provider for testing.
-  static void GetBrowserWindowBoundsAndShowState(
+  static bool GetBrowserWindowBoundsAndShowState(
       std::unique_ptr<StateProvider> state_provider,
       const gfx::Rect& specified_bounds,
       const Browser* browser,
@@ -106,7 +106,7 @@
   virtual ~WindowSizer();
 
   // See GetBrowserWindowBoundsAndShowState() above.
-  virtual void DetermineWindowBoundsAndShowState(
+  virtual bool DetermineWindowBoundsAndShowState(
       const gfx::Rect& specified_bounds,
       gfx::Rect* bounds,
       ui::WindowShowState* show_state);
diff -r -u --color up/chromium/chrome/browser/upgrade_detector/upgrade_detector_impl.cc nw/chromium/chrome/browser/upgrade_detector/upgrade_detector_impl.cc
--- up/chromium/chrome/browser/upgrade_detector/upgrade_detector_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/upgrade_detector/upgrade_detector_impl.cc	2023-01-28 02:49:24.131574495 +0000
@@ -1,6 +1,7 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wunreachable-code"
 
 #include "chrome/browser/upgrade_detector/upgrade_detector_impl.h"
 
@@ -434,7 +435,7 @@
   //   switch from being taken into account.
   // - kSimulateOutdatedNoAU has precedence over kSimulateOutdated.
   // - kSimulateOutdated[NoAu] can work on its own, or with a specified date.
-  if (cmd_line.HasSwitch(switches::kDisableBackgroundNetworking))
+  if (true || cmd_line.HasSwitch(switches::kDisableBackgroundNetworking))
     return;
 
   if (simulating_outdated_) {
diff -r -u --color up/chromium/chrome/browser/web_applications/extensions/web_app_extension_shortcut.cc nw/chromium/chrome/browser/web_applications/extensions/web_app_extension_shortcut.cc
--- up/chromium/chrome/browser/web_applications/extensions/web_app_extension_shortcut.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/web_applications/extensions/web_app_extension_shortcut.cc	2023-01-28 02:49:24.171574918 +0000
@@ -221,6 +221,7 @@
   // cannot be shown in the launcher.
   if (extension->location() ==
           extensions::mojom::ManifestLocation::kComponent ||
+      extension->is_nwjs_app() ||
       !extensions::ui_util::CanDisplayInAppLauncher(extension, profile)) {
     return false;
   }
diff -r -u --color up/chromium/chrome/browser/web_applications/os_integration/web_app_shortcut_mac.mm nw/chromium/chrome/browser/web_applications/os_integration/web_app_shortcut_mac.mm
--- up/chromium/chrome/browser/web_applications/os_integration/web_app_shortcut_mac.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/web_applications/os_integration/web_app_shortcut_mac.mm	2023-01-28 02:49:24.179575002 +0000
@@ -209,11 +209,14 @@
 }
 
 bool AppShimCreationDisabledForTest() {
+  return true;
+#if 0
   // Disable app shims in tests if the shortcut folder is not set.
   // Because shims created in ~/Applications will not be cleaned up.
   return base::CommandLine::ForCurrentProcess()->HasSwitch(
              switches::kTestType) &&
          !GetShortcutOverrideForTesting();
+#endif
 }
 
 bool AppShimRevealDisabledForTest() {
diff -r -u --color up/chromium/chrome/browser/web_applications/os_integration/web_app_shortcut_win.cc nw/chromium/chrome/browser/web_applications/os_integration/web_app_shortcut_win.cc
--- up/chromium/chrome/browser/web_applications/os_integration/web_app_shortcut_win.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/web_applications/os_integration/web_app_shortcut_win.cc	2023-01-28 02:49:24.179575002 +0000
@@ -50,15 +50,15 @@
 constexpr base::FilePath::CharType kIconChecksumFileExt[] =
     FILE_PATH_LITERAL(".ico.md5");
 
-constexpr base::FilePath::CharType kChromeProxyExecutable[] =
-    FILE_PATH_LITERAL("chrome_proxy.exe");
+//constexpr base::FilePath::CharType kChromeProxyExecutable[] =
+//    FILE_PATH_LITERAL("nw.exe");
 
 }  // namespace
 
 base::FilePath GetChromeProxyPath() {
   base::FilePath chrome_dir;
-  CHECK(base::PathService::Get(base::DIR_EXE, &chrome_dir));
-  return chrome_dir.Append(kChromeProxyExecutable);
+  CHECK(base::PathService::Get(base::FILE_EXE, &chrome_dir));
+  return chrome_dir; //.Append(kChromeProxyExecutable);
 }
 
 namespace internals {
@@ -427,12 +427,19 @@
                                      const base::FilePath& icon_file,
                                      HWND hwnd,
                                      const ShortcutInfo& shortcut_info) {
+  base::CommandLine command_line(base::CommandLine::NO_PROGRAM);
+#if 0
   base::CommandLine command_line =
       shell_integration::CommandLineArgsForLauncher(
           shortcut_info.url, shortcut_info.extension_id,
           shortcut_info.profile_path, "");
 
+#endif
   command_line.SetProgram(GetChromeProxyPath());
+  const base::CommandLine::StringVector& args = base::CommandLine::ForCurrentProcess()->GetArgs();
+  if (args.size())
+	  command_line.AppendArgNative(args[0]);
+
   ui::win::SetRelaunchDetailsForWindow(command_line.GetCommandLineString(),
                                        base::AsWString(shortcut_info.title),
                                        hwnd);
diff -r -u --color up/chromium/chrome/browser/web_applications/web_app_helpers.cc nw/chromium/chrome/browser/web_applications/web_app_helpers.cc
--- up/chromium/chrome/browser/web_applications/web_app_helpers.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/web_applications/web_app_helpers.cc	2023-01-28 02:49:24.187575087 +0000
@@ -32,7 +32,7 @@
 // for the name of this directory.  Hosts can't include an underscore.
 // By starting this string with an underscore, we ensure that there
 // are no naming conflicts.
-const char kCrxAppPrefix[] = "_crx_";
+const char kCrxAppPrefix[] = "_nwjs_";
 
 std::string GenerateApplicationNameFromURL(const GURL& url) {
   return base::StrCat({url.host_piece(), "_", url.path_piece()});
diff -r -u --color up/chromium/chrome/browser/webshare/share_service_impl.cc nw/chromium/chrome/browser/webshare/share_service_impl.cc
--- up/chromium/chrome/browser/webshare/share_service_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/webshare/share_service_impl.cc	2023-01-28 02:49:24.203575256 +0000
@@ -198,14 +198,6 @@
       return;
     }
 
-    // Check if at least one file is marked by the download protection service
-    // to send a ping to check this file type.
-    if (!should_check_url &&
-        safe_browsing::FileTypePolicies::GetInstance()->IsCheckedBinaryFile(
-            path)) {
-      should_check_url = true;
-    }
-
     // In the case where the original blob handle was to a native file (of
     // unknown size), the serialized data does not contain an accurate file
     // size. To handle this, the comparison against kMaxSharedFileBytes should
diff -r -u --color up/chromium/chrome/browser/win/app_icon.cc nw/chromium/chrome/browser/win/app_icon.cc
--- up/chromium/chrome/browser/win/app_icon.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/win/app_icon.cc	2023-01-28 02:49:24.203575256 +0000
@@ -4,6 +4,8 @@
 
 #include "chrome/browser/win/app_icon.h"
 
+#include "content/nw/src/nw_content.h"
+
 #include "chrome/common/chrome_constants.h"
 #include "chrome/install_static/install_details.h"
 #include "third_party/skia/include/core/SkBitmap.h"
@@ -21,6 +23,11 @@
 }  // namespace
 
 HICON GetAppIcon() {
+#if 1
+  HICON ret = nw::GetWindowHIcon();
+  if (ret)
+    return ret;
+#endif
   // TODO(mgiuca): Use GetAppIconImageFamily/CreateExact instead of LoadIcon, to
   // get correct scaling. (See http://crbug.com/551256)
   const int icon_id = GetAppIconResourceId();
@@ -30,6 +37,11 @@
 }
 
 HICON GetSmallAppIcon() {
+#if 1
+  HICON ret = nw::GetAppHIcon();
+  if (ret)
+    return ret;
+#endif
   // TODO(mgiuca): Use GetAppIconImageFamily/CreateExact instead of LoadIcon, to
   // get correct scaling. (See http://crbug.com/551256)
   const int icon_id = GetAppIconResourceId();
diff -r -u --color up/chromium/chrome/browser/win/conflicts/BUILD.gn nw/chromium/chrome/browser/win/conflicts/BUILD.gn
--- up/chromium/chrome/browser/win/conflicts/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/browser/win/conflicts/BUILD.gn	2023-01-28 02:49:24.203575256 +0000
@@ -27,7 +27,10 @@
     "//content/public/common",
   ]
 
-  deps = [ "//base:i18n" ]
+  deps = [
+    "//base:i18n",
+    #"//chrome/common/safe_browsing:pe_image_reader",
+  ]
 
   libs = [ "crypt32.lib" ]
 }
diff -r -u --color up/chromium/chrome/chrome_elf/BUILD.gn nw/chromium/chrome/chrome_elf/BUILD.gn
--- up/chromium/chrome/chrome_elf/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/chrome_elf/BUILD.gn	2023-01-28 02:49:24.243575679 +0000
@@ -51,6 +51,7 @@
 # We should move chrome_result_codes.h to another target which does not bring
 # in the world.
 shared_library("chrome_elf") {
+  output_name = "nw_elf"
   sources = [
     "chrome_elf_main.cc",
     "chrome_elf_main.h",
diff -r -u --color up/chromium/chrome/chrome_elf/chrome_elf.ver nw/chromium/chrome/chrome_elf/chrome_elf.ver
--- up/chromium/chrome/chrome_elf/chrome_elf.ver	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/chrome_elf/chrome_elf.ver	2023-01-28 02:49:24.243575679 +0000
@@ -1,2 +1,2 @@
-INTERNAL_NAME=chrome_elf_dll
-ORIGINAL_FILENAME=chrome_elf.dll
+INTERNAL_NAME=nw_elf_dll
+ORIGINAL_FILENAME=nw_elf.dll
diff -r -u --color up/chromium/chrome/chrome_elf/chrome_elf_main.cc nw/chromium/chrome/chrome_elf/chrome_elf_main.cc
--- up/chromium/chrome/chrome_elf/chrome_elf_main.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/chrome_elf/chrome_elf_main.cc	2023-01-28 02:49:24.243575679 +0000
@@ -4,6 +4,7 @@
 
 #include "chrome/chrome_elf/chrome_elf_main.h"
 
+#include "components/crash/core/app/crash_reporter_client.h"
 #include <assert.h>
 #include <windows.h>
 
@@ -16,11 +17,15 @@
 #include "chrome/install_static/product_install_details.h"
 #include "chrome/install_static/user_data_dir.h"
 
+extern std::wstring g_nwjs_prod_name, g_nwjs_prod_version;
+
 // This function is exported from the DLL so that it can be called by WinMain
 // after startup has completed in the browser process. For non-browser processes
 // it will be called inside the DLL loader lock so it should do as little as
 // possible to prevent deadlocks.
-void SignalInitializeCrashReporting() {
+void SignalInitializeCrashReporting(void* prod_name, void* prod_version) {
+  if (prod_name) g_nwjs_prod_name = *(std::wstring*)prod_name;
+  if (prod_version) g_nwjs_prod_version = *(std::wstring*)prod_version;
   if (!elf_crash::InitializeCrashReporting()) {
 #ifdef _DEBUG
     assert(false);
@@ -58,6 +63,11 @@
 //         This can result in path expansion that triggers secondary DLL loads,
 //         that will blow up with the loader lock held.
 //         https://bugs.chromium.org/p/chromium/issues/detail?id=748949#c18
+
+void* ElfGetReporterClient() {
+  return crash_reporter::GetCrashReporterClient();
+}
+
 BOOL APIENTRY DllMain(HMODULE module, DWORD reason, LPVOID reserved) {
   if (reason == DLL_PROCESS_ATTACH) {
     install_static::InitializeProductDetailsForPrimaryModule();
@@ -75,10 +85,12 @@
       } __except (elf_crash::GenerateCrashDump(GetExceptionInformation())) {
       }
     } else if (!install_static::IsCrashpadHandlerProcess()) {
-      SignalInitializeCrashReporting();
+      //SignalInitializeCrashReporting(nullptr, nullptr);
       // CRT on initialization installs an exception filter which calls
       // TerminateProcess. We need to hook CRT's attempt to set an exception.
+#if 0 ////disable this or NW will fail with Enigma VB
       elf_crash::DisableSetUnhandledExceptionFilter();
+#endif
     }
 
   } else if (reason == DLL_PROCESS_DETACH) {
diff -r -u --color up/chromium/chrome/chrome_elf/chrome_elf_main.h nw/chromium/chrome/chrome_elf/chrome_elf_main.h
--- up/chromium/chrome/chrome_elf/chrome_elf_main.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/chrome_elf/chrome_elf_main.h	2023-01-28 02:49:24.243575679 +0000
@@ -22,7 +22,7 @@
 // This function is a temporary workaround for https://crbug.com/655788. We
 // need to come up with a better way to initialize crash reporting that can
 // happen inside DllMain().
-void SignalInitializeCrashReporting();
+  void SignalInitializeCrashReporting(void*, void*);
 void SignalChromeElf();
 
 // Sets the metrics client ID in crash keys.
@@ -37,5 +37,5 @@
 bool IsExtensionPointDisableSet();
 
 }  // extern "C"
-
+extern "C" void* ElfGetReporterClient();
 #endif  // CHROME_CHROME_ELF_CHROME_ELF_MAIN_H_
diff -r -u --color up/chromium/chrome/chrome_elf/chrome_elf_x64.def nw/chromium/chrome/chrome_elf/chrome_elf_x64.def
--- up/chromium/chrome/chrome_elf/chrome_elf_x64.def	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/chrome_elf/chrome_elf_x64.def	2023-01-28 02:49:24.243575679 +0000
@@ -1,9 +1,10 @@
 ; Copyright 2013 The Chromium Authors
 ; Use of this source code is governed by a BSD-style license that can be
 ; found in the LICENSE file.
-LIBRARY  "chrome_elf.dll"
+LIBRARY  "nw_elf.dll"
 
 EXPORTS
+  ElfGetReporterClient
   ; When functions are added to this file, they must also be added to
   ; chrome_elf_x86.def and chrome_elf_arm64.def
 
diff -r -u --color up/chromium/chrome/chrome_elf/chrome_elf_x86.def nw/chromium/chrome/chrome_elf/chrome_elf_x86.def
--- up/chromium/chrome/chrome_elf/chrome_elf_x86.def	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/chrome_elf/chrome_elf_x86.def	2023-01-28 02:49:24.243575679 +0000
@@ -1,7 +1,8 @@
 ; Copyright 2013 The Chromium Authors
 ; Use of this source code is governed by a BSD-style license that can be
 ; found in the LICENSE file.
-LIBRARY  "chrome_elf.dll"
+
+LIBRARY  "nw_elf.dll"
 
 EXPORTS
   ; When functions are added to this file, they must also be added to
@@ -43,3 +44,4 @@
 
   ; From chrome/chrome_elf/third_party_dlls/main.cc
   IsThirdPartyInitialized
+  ElfGetReporterClient
diff -r -u --color up/chromium/chrome/chrome_paks.gni nw/chromium/chrome/chrome_paks.gni
--- up/chromium/chrome/chrome_paks.gni	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/chrome_paks.gni	2023-01-28 02:49:24.247575721 +0000
@@ -77,7 +77,7 @@
       deps += [ "//extensions:extensions_browser_resources" ]
     }
 
-    output = "${invoker.output_dir}/chrome_${percent}_percent.pak"
+    output = "${invoker.output_dir}/nw_${percent}_percent.pak"
   }
 }
 
@@ -136,6 +136,12 @@
     if (defined(invoker.additional_paks)) {
       sources += invoker.additional_paks
     }
+    if (nwjs_sdk) {
+      sources += [
+        "$root_gen_dir/content/browser/tracing/tracing_resources.pak",
+        "$root_gen_dir/content/browser/devtools/devtools_resources.pak",
+      ]
+    }
 
     if (!is_android) {
       # New paks should be added here by default.
@@ -170,8 +176,6 @@
         "$root_gen_dir/chrome/tab_search_resources.pak",
         "$root_gen_dir/chrome/webui_gallery_resources.pak",
         "$root_gen_dir/chrome/whats_new_resources.pak",
-        "$root_gen_dir/content/browser/devtools/devtools_resources.pak",
-        "$root_gen_dir/content/browser/tracing/tracing_resources.pak",
       ]
       deps += [
         "//chrome/browser/resources:component_extension_resources",
diff -r -u --color up/chromium/chrome/common/BUILD.gn nw/chromium/chrome/common/BUILD.gn
--- up/chromium/chrome/common/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/common/BUILD.gn	2023-01-28 02:49:24.247575721 +0000
@@ -221,8 +221,8 @@
     "//components/services/app_service/public/cpp:app_types",
     "//components/services/heap_profiling/public/cpp",
     "//components/strings",
-    "//components/translate/content/common",
-    "//components/translate/core/common",
+    #"//components/translate/content/common",
+    #"//components/translate/core/common",
     "//components/url_formatter",
     "//components/variations",
     "//components/variations/net",
@@ -332,6 +332,7 @@
       "//components/services/app_service/public/mojom",
     ]
     public_deps += [
+      "//content/nw/src/api:nw_api",
       "//chrome/common/extensions/api",
       "//chrome/common/extensions/api:extensions_features",
       "//extensions:extensions_resources",
diff -r -u --color up/chromium/chrome/common/apps/platform_apps/api/_api_features.json nw/chromium/chrome/common/apps/platform_apps/api/_api_features.json
--- up/chromium/chrome/common/apps/platform_apps/api/_api_features.json	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/common/apps/platform_apps/api/_api_features.json	2023-01-28 02:49:24.247575721 +0000
@@ -7,10 +7,6 @@
 // well as feature.h, simple_feature.h, and feature_provider.h.
 
 {
-  "arcAppsPrivate": {
-    "dependencies": ["permission:arcAppsPrivate"],
-    "contexts": ["blessed_extension"]
-  },
   "browser": {
     "dependencies": ["permission:browser"],
     "contexts": ["blessed_extension"]
diff -r -u --color up/chromium/chrome/common/child_process_logging_win.cc nw/chromium/chrome/common/child_process_logging_win.cc
--- up/chromium/chrome/common/child_process_logging_win.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/common/child_process_logging_win.cc	2023-01-28 02:49:24.247575721 +0000
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 #include "chrome/common/child_process_logging.h"
+#include "chrome/chrome_elf/chrome_elf_main.h"
 
 #include <windows.h>
 
diff -r -u --color up/chromium/chrome/common/chrome_constants.cc nw/chromium/chrome/common/chrome_constants.cc
--- up/chromium/chrome/common/chrome_constants.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/common/chrome_constants.cc	2023-01-28 02:49:24.247575721 +0000
@@ -15,7 +15,7 @@
 #if BUILDFLAG(GOOGLE_CHROME_BRANDING)
 #define PRODUCT_STRING "Google Chrome"
 #elif BUILDFLAG(CHROMIUM_BRANDING)
-#define PRODUCT_STRING "Chromium"
+#define PRODUCT_STRING "nwjs"
 #else
 #error Unknown branding
 #endif
@@ -44,9 +44,9 @@
 
 #if BUILDFLAG(IS_WIN)
 const base::FilePath::CharType kBrowserProcessExecutableName[] =
-    FPL("chrome.exe");
+    FPL("nw.exe");
 const base::FilePath::CharType kHelperProcessExecutableName[] =
-    FPL("chrome.exe");
+    FPL("nw.exe");
 #elif BUILDFLAG(IS_MAC)
 const base::FilePath::CharType kBrowserProcessExecutableName[] =
     FPL(PRODUCT_STRING);
@@ -58,7 +58,7 @@
 const base::FilePath::CharType kHelperProcessExecutableName[] =
     FPL("sandboxed_process");
 #elif BUILDFLAG(IS_POSIX)
-const base::FilePath::CharType kBrowserProcessExecutableName[] = FPL("chrome");
+const base::FilePath::CharType kBrowserProcessExecutableName[] = FPL("nw");
 // Helper processes end up with a name of "exe" due to execing via
 // /proc/self/exe.  See bug 22703.
 const base::FilePath::CharType kHelperProcessExecutableName[] = FPL("exe");
@@ -66,9 +66,9 @@
 
 #if BUILDFLAG(IS_WIN)
 const base::FilePath::CharType kBrowserProcessExecutablePath[] =
-    FPL("chrome.exe");
+    FPL("nw.exe");
 const base::FilePath::CharType kHelperProcessExecutablePath[] =
-    FPL("chrome.exe");
+    FPL("nw.exe");
 #elif BUILDFLAG(IS_MAC)
 const base::FilePath::CharType kBrowserProcessExecutablePath[] =
     FPL(PRODUCT_STRING ".app/Contents/MacOS/" PRODUCT_STRING);
@@ -78,8 +78,8 @@
 const base::FilePath::CharType kBrowserProcessExecutablePath[] = FPL("chrome");
 const base::FilePath::CharType kHelperProcessExecutablePath[] = FPL("chrome");
 #elif BUILDFLAG(IS_POSIX)
-const base::FilePath::CharType kBrowserProcessExecutablePath[] = FPL("chrome");
-const base::FilePath::CharType kHelperProcessExecutablePath[] = FPL("chrome");
+const base::FilePath::CharType kBrowserProcessExecutablePath[] = FPL("nw");
+const base::FilePath::CharType kHelperProcessExecutablePath[] = FPL("nw");
 #endif  // OS_*
 
 #if BUILDFLAG(IS_MAC)
@@ -91,11 +91,11 @@
 #endif  // BUILDFLAG(IS_MAC)
 
 #if BUILDFLAG(IS_WIN)
-const base::FilePath::CharType kBrowserResourcesDll[] = FPL("chrome.dll");
-const base::FilePath::CharType kElfDll[] = FPL("chrome_elf.dll");
+const base::FilePath::CharType kBrowserResourcesDll[] = FPL("nw.dll");
+const base::FilePath::CharType kElfDll[] = FPL("nw_elf.dll");
 const base::FilePath::CharType kStatusTrayWindowClass[] =
-    FPL("Chrome_StatusTrayWindow");
-#endif  // BUILDFLAG(IS_WIN)
+    FPL("NWJS_StatusTrayWindow");
+#endif  // defined(OS_WIN)
 
 const char kInitialProfile[] = "Default";
 const char kMultiProfileDirPrefix[] = "Profile ";
diff -r -u --color up/chromium/chrome/common/chrome_content_client.cc nw/chromium/chrome/common/chrome_content_client.cc
--- up/chromium/chrome/common/chrome_content_client.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/common/chrome_content_client.cc	2023-01-28 02:49:24.247575721 +0000
@@ -2,8 +2,10 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "content/nw/src/browser/nw_extensions_browser_hooks.h"
 #include "chrome/common/chrome_content_client.h"
 
+#include "components/crash/core/app/crash_reporter_client.h"
 #include <stdint.h>
 
 #include <memory>
@@ -95,6 +97,8 @@
 #include "chrome/common/media/chrome_media_drm_bridge_client.h"
 #endif
 
+#include "content/nw/src/common/nw_content_common_hooks.h"
+
 namespace {
 
 #if BUILDFLAG(ENABLE_NACL)
@@ -177,6 +181,17 @@
 #endif  // BUILDFLAG(ENABLE_NACL)
 }
 
+void ChromeContentClient::LoadNWAppAsExtension(base::DictionaryValue* manifest,
+                                               const base::FilePath& path,
+                                               std::string* error) {
+  nw::LoadNWAppAsExtensionHook(manifest, path, error);
+}
+
+void ChromeContentClient::SetNWReportURL(const GURL& url) {
+  static crash_reporter::CrashKeyString<1024> nwjs_url("url-nwjs");
+  nwjs_url.Set(url.possibly_invalid_spec());
+}
+
 void ChromeContentClient::AddContentDecryptionModules(
     std::vector<content::CdmInfo>* cdms,
     std::vector<media::CdmHostFilePath>* cdm_host_file_paths) {
diff -r -u --color up/chromium/chrome/common/chrome_content_client.h nw/chromium/chrome/common/chrome_content_client.h
--- up/chromium/chrome/common/chrome_content_client.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/common/chrome_content_client.h	2023-01-28 02:49:24.247575721 +0000
@@ -42,6 +42,9 @@
 
   ChromeContentClient();
   ~ChromeContentClient() override;
+  void LoadNWAppAsExtension(base::DictionaryValue* manifest,
+                            const base::FilePath& path,
+                            std::string* error) override;
 
   // The methods below are called by child processes to set the function
   // pointers for built-in plugins. We avoid linking these plugins into
@@ -55,6 +58,7 @@
 #endif
 
   void SetActiveURL(const GURL& url, std::string top_origin) override;
+  void SetNWReportURL(const GURL& url) override;
   void SetGpuInfo(const gpu::GPUInfo& gpu_info) override;
   void AddPlugins(std::vector<content::ContentPluginInfo>* plugins) override;
   void AddContentDecryptionModules(
diff -r -u --color up/chromium/chrome/common/chrome_features.cc nw/chromium/chrome/common/chrome_features.cc
--- up/chromium/chrome/common/chrome_features.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/common/chrome_features.cc	2023-01-28 02:49:24.247575721 +0000
@@ -1055,7 +1055,7 @@
 #if BUILDFLAG(IS_ANDROID)
              base::FEATURE_DISABLED_BY_DEFAULT
 #else
-             base::FEATURE_ENABLED_BY_DEFAULT
+      base::FEATURE_DISABLED_BY_DEFAULT
 #endif
 );
 
diff -r -u --color up/chromium/chrome/common/chrome_paths.cc nw/chromium/chrome/common/chrome_paths.cc
--- up/chromium/chrome/common/chrome_paths.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/common/chrome_paths.cc	2023-01-28 02:49:24.247575721 +0000
@@ -294,7 +294,7 @@
     // was shipped along with chrome.  The value can be overridden
     // if it is installed via component updater.
     case chrome::DIR_PNACL_COMPONENT:
-#if BUILDFLAG(IS_MAC)
+#if 0
       // PNaCl really belongs in the InternalPluginsDirectory but actually
       // copying it there would result in the files also being shipped, which
       // we don't want yet. So for now, just find them in the directory where
diff -r -u --color up/chromium/chrome/common/chrome_paths_linux.cc nw/chromium/chrome/common/chrome_paths_linux.cc
--- up/chromium/chrome/common/chrome_paths_linux.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/common/chrome_paths_linux.cc	2023-01-28 02:49:24.251575763 +0000
@@ -18,6 +18,8 @@
 #include "chrome/common/channel_info.h"
 #include "chrome/common/chrome_paths_internal.h"
 
+#include "content/nw/src/nw_base.h"
+
 namespace chrome {
 
 using base::nix::GetXDGDirectory;
@@ -89,12 +91,15 @@
         GetXDGDirectory(env.get(), kXdgConfigHomeEnvVar, kDotConfigDir);
   }
 
+#if 0
 #if BUILDFLAG(GOOGLE_CHROME_BRANDING)
   std::string data_dir_basename = "google-chrome";
 #else
-  std::string data_dir_basename = "chromium";
+  std::string data_dir_basename = nw::package()->GetName();
+#endif
 #endif
-  *result = config_dir.Append(data_dir_basename + GetChannelSuffixForDataDir());
+  *result = config_dir.Append(nw::package()->GetName());
+  //*result = config_dir.Append(data_dir_basename + GetChannelSuffixForDataDir());
   return true;
 }
 
diff -r -u --color up/chromium/chrome/common/chrome_paths_mac.mm nw/chromium/chrome/common/chrome_paths_mac.mm
--- up/chromium/chrome/common/chrome_paths_mac.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/common/chrome_paths_mac.mm	2023-01-28 02:49:24.251575763 +0000
@@ -19,6 +19,8 @@
 #include "chrome/common/chrome_constants.h"
 #include "chrome/common/chrome_paths_internal.h"
 
+#include "content/nw/src/nw_base.h"
+
 namespace {
 
 // Return a retained (NOT autoreleased) NSBundle* as the internal
@@ -59,7 +61,7 @@
 #if BUILDFLAG(GOOGLE_CHROME_BRANDING)
       product_dir_name = "Google/Chrome";
 #else
-      product_dir_name = "Chromium";
+    product_dir_name = "nwjs";
 #endif
     }
 
@@ -69,6 +71,7 @@
   }
 }
 
+#if 0
 // ProductDirName returns the name of the directory inside
 // ~/Library/Application Support that should hold the product application
 // data. This can be overridden by setting the CrProductDirName key in the
@@ -90,6 +93,7 @@
       ProductDirNameForBundle(chrome::OuterAppBundle());
   return std::string(product_dir_name);
 }
+#endif
 
 bool GetDefaultUserDataDirectoryForProduct(const std::string& product_dir,
                                            base::FilePath* result) {
@@ -106,7 +110,7 @@
 namespace chrome {
 
 bool GetDefaultUserDataDirectory(base::FilePath* result) {
-  return GetDefaultUserDataDirectoryForProduct(ProductDirName(), result);
+  return GetDefaultUserDataDirectoryForProduct(nw::package()->GetName(), result);
 }
 
 bool GetUserDocumentsDirectory(base::FilePath* result) {
diff -r -u --color up/chromium/chrome/common/chrome_paths_win.cc nw/chromium/chrome/common/chrome_paths_win.cc
--- up/chromium/chrome/common/chrome_paths_win.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/common/chrome_paths_win.cc	2023-01-28 02:49:24.251575763 +0000
@@ -19,6 +19,8 @@
 #include "chrome/install_static/install_util.h"
 #include "components/nacl/common/nacl_switches.h"
 
+#include "content/nw/src/nw_base.h"
+
 namespace chrome {
 
 namespace {
@@ -45,7 +47,8 @@
 bool GetDefaultUserDataDirectory(base::FilePath* result) {
   if (!base::PathService::Get(base::DIR_LOCAL_APP_DATA, result))
     return false;
-  *result = result->Append(install_static::GetChromeInstallSubDirectory());
+  if (nw::package()) //FIXME: crashpad initialized early in cr49
+    *result = result->Append(base::FilePath::FromUTF8Unsafe(nw::package()->GetName()));
   *result = result->Append(chrome::kUserDataDirname);
   return true;
 }
diff -r -u --color up/chromium/chrome/common/extensions/api/BUILD.gn nw/chromium/chrome/common/extensions/api/BUILD.gn
--- up/chromium/chrome/common/extensions/api/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/common/extensions/api/BUILD.gn	2023-01-28 02:49:24.251575763 +0000
@@ -89,7 +89,10 @@
 json_features("api_features") {
   feature_type = "APIFeature"
   method_name = "AddChromeAPIFeatures"
-  sources = [ "_api_features.json" ]
+  sources = [
+    "../../../../content/nw/src/api/_api_features.json",
+    "_api_features.json",
+  ]
   visibility = [ ":extensions_features" ]
 }
 
diff -r -u --color up/chromium/chrome/common/extensions/api/_api_features.json nw/chromium/chrome/common/extensions/api/_api_features.json
--- up/chromium/chrome/common/extensions/api/_api_features.json	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/common/extensions/api/_api_features.json	2023-01-28 02:49:24.251575763 +0000
@@ -58,26 +58,6 @@
        "A9A9FC0228ADF541F0334F22BEFB8F9C245B21D7"   // http://crbug.com/839189
     ]
   },
-  "action": {
-    "dependencies": ["manifest:action"],
-    "contexts": ["blessed_extension"]
-  },
-  "action.openPopup": {
-    // TODO(https://crbug.com/1245093): Upgrade to stable channel.
-    "channel": "dev"
-  },
-  "action.isEnabled": {
-    // TODO(https://crbug.com/1189295): Upgrade to stable channel.
-    "channel": "dev"
-  },
-  "action.getBadgeTextColor": {
-    // TODO(https://crbug.com/1337783): Upgrade to stable channel.
-    "channel": "dev"
-  },
-  "action.setBadgeTextColor": {
-    // TODO(https://crbug.com/1337783): Upgrade to stable channel.
-    "channel": "dev"
-  },
   "activityLogPrivate": [{
     "dependencies": ["permission:activityLogPrivate"],
     "contexts": ["blessed_extension"]
@@ -512,30 +492,6 @@
     "contexts": ["blessed_extension"],
     "disallow_for_service_workers": true
   },
-  "fileManagerPrivate": [{
-    "dependencies": ["permission:fileManagerPrivate"],
-    "contexts": ["blessed_extension"]
-  }, {
-    "channel": "stable",
-    "contexts": ["webui"],
-    "matches": [
-      "chrome://file-manager/*",
-      "chrome://webui-test/*"
-    ]
-  }],
-  "fileManagerPrivateInternal": [{
-    "internal": true,
-    "dependencies": ["permission:fileManagerPrivate"],
-    "contexts": ["blessed_extension"]
-  }, {
-    "internal": true,
-    "channel": "stable",
-    "contexts": ["webui"],
-    "matches": [
-      "chrome://file-manager/*",
-      "chrome://webui-test/*"
-    ]
-  }],
   "fileSystemProvider": [{
     "dependencies": ["permission:fileSystemProvider"],
     "contexts": ["blessed_extension"],
@@ -622,6 +578,8 @@
   }, {
     "channel": "stable",
     "contexts": ["webui"],
+    "dependencies": ["permission:usersPrivate"],
+    "platforms": ["chromeos"],
     "matches": [
       // TODO(maybelle): Audit and remove chrome://settings or
       // chrome://os-settings as appropriate
@@ -770,10 +728,6 @@
     "dependencies": ["permission:rtcPrivate"],
     "contexts": ["blessed_extension"]
   },
-  "safeBrowsingPrivate": {
-    "dependencies": ["permission:safeBrowsingPrivate"],
-    "contexts": ["blessed_extension"]
-  },
   "scripting": {
     "dependencies": ["permission:scripting"],
     "contexts": ["blessed_extension"]
@@ -924,31 +878,10 @@
     "dependencies": ["permission:ttsEngine"],
     "contexts": ["blessed_extension"]
   },
-  "usersPrivate": [{
-    "dependencies": ["permission:usersPrivate"],
-    "contexts": ["blessed_extension"],
-    "platforms": ["chromeos"]
-  }, {
-    "channel": "stable",
-    "contexts": ["webui"],
-    "matches": [
-      "chrome://os-settings/*"
-    ]
-  }],
   "virtualKeyboardPrivate": {
     "dependencies": ["permission:virtualKeyboardPrivate"],
     "contexts": ["blessed_extension"]
   },
-  "wallpaper": [{
-    "dependencies": ["permission:wallpaper"],
-    "contexts": ["blessed_extension"]
-  }, {
-    "channel": "stable",
-    "contexts": ["webui"],
-    "matches": [
-      "chrome://file-manager/*"
-    ]
-  }],
   "webAuthenticationProxy": {
     "dependencies": ["permission:webAuthenticationProxy"],
     "contexts": ["blessed_extension"]
diff -r -u --color up/chromium/chrome/common/extensions/api/_permission_features.json nw/chromium/chrome/common/extensions/api/_permission_features.json
--- up/chromium/chrome/common/extensions/api/_permission_features.json	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/common/extensions/api/_permission_features.json	2023-01-28 02:49:24.251575763 +0000
@@ -210,16 +210,7 @@
   ],
   "developerPrivate": {
     "channel": "stable",
-    "extension_types": ["platform_app"],
-    "allowlist": [
-        "AE27D69DBE571F4B1694F05C89B710C646792231", // Published ADT.
-        "FA0501B579070BB9CBD4FCAEC8CB0EDF22BA2F04", // Apps Editor published.
-        "4A4EA121622FCA3D78ED2AB534197F43D7189EE0", // Spark nightly build.
-        "9FDE6E7F06FCFA11D9A05041C7FF6D8AE662F5D1", // Spark release.
-        "50B4A905D522C06E27CA6D099E3E54BDA1F152C5", // Spark Beta channel.
-        "BA0C8BB92084C9741312D90D3EA882526853455F", // Spark dev channel.
-        "5F57A9AE8DFF5D6BB09DF8606270402612E871E5"  // http://crbug.com/422624
-    ]
+    "extension_types": ["platform_app"]
   },
   "devtools": {
     "channel": "stable",
@@ -554,6 +545,7 @@
   }],
   "webcamPrivate": {
     "channel": "stable",
+    "platforms": ["chromeos"],
     "extension_types": ["extension", "platform_app"],
     "allowlist": [
       "E703483CEF33DEC18B4B6DD84B5C776FB9182BDB",  // http://crbug.com/891460
@@ -574,25 +566,7 @@
     },
     {
       "channel": "stable",
-      "extension_types": ["platform_app"],
-      "allowlist": [
-        "AE27D69DBE571F4B1694F05C89B710C646792231", // Published ADT
-        // TODO(grv): clean up once Apps developer tool is published.
-        "5107DE9024C329EEA9C9A72D94C16723790C6422",  // Apps Developer Tool.
-        "8C0B1873FFFB65E4D0F4D772879F7304CEF125C2",  // Apps Editor old.
-        "FA0501B579070BB9CBD4FCAEC8CB0EDF22BA2F04",  // Apps Editor published.
-        "EE17C698905F7F2E6DDC87C9C30F11E164C829F4",  // Watchdog (Activity Log)
-        "90113DA9516526D24DAF156C629CC41C049E8882",  // Watchdog Test Version
-        "4A4EA121622FCA3D78ED2AB534197F43D7189EE0",  // Spark nightly build.
-        "9FDE6E7F06FCFA11D9A05041C7FF6D8AE662F5D1",  // Spark release.
-        "50B4A905D522C06E27CA6D099E3E54BDA1F152C5",  // Spark Beta channel.
-        "BA0C8BB92084C9741312D90D3EA882526853455F",  // Spark dev channel.
-        "5F57A9AE8DFF5D6BB09DF8606270402612E871E5",  // http://crbug.com/422624
-        "46578A13607D38F1DC8E280C4F499FB0A2F9565C",  // http://crbug.com/819404
-        "898FB5A39687D210766B8998BA4530B99C9E6586",  // http://crbug.com/819404
-        "82F30B65397BC3E4ADE627BBD857AB8A58210648",  // http://crbug.com/819404
-        "C74B2AF138F9EDECD04D0965AB36CA66C8290466"   // http://crbug.com/957772
-      ]
+      "extension_types": ["platform_app"]
     },
     {
       "channel": "stable",
@@ -766,6 +740,7 @@
   "rtcPrivate": {
     "channel": "stable",
     "extension_types": ["extension", "legacy_packaged_app"],
+    "platforms": ["chromeos"],
     "allowlist": [
       "53041A2FA309EECED01FFC751E7399186E860B2C",  // Google Talk prod
       "A74A4D44C7CFCD8844830E6140C8D763E12DD8F3",  // Google Talk beta
@@ -866,7 +841,7 @@
   ],
   "tabCapture": {
     "channel": "stable",
-    "extension_types": ["extension", "legacy_packaged_app"]
+    "extension_types": ["extension", "legacy_packaged_app", "platform_app"]
   },
   "terminalPrivate": {
     "channel": "stable",
diff -r -u --color up/chromium/chrome/common/extensions/api/api_sources.gni nw/chromium/chrome/common/extensions/api/api_sources.gni
--- up/chromium/chrome/common/extensions/api/api_sources.gni	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/common/extensions/api/api_sources.gni	2023-01-28 02:49:24.255575805 +0000
@@ -44,7 +44,6 @@
   "passwords_private.idl",
   "permissions.json",
   "resources_private.idl",
-  "safe_browsing_private.idl",
   "scripting.idl",
   "search.idl",
   "sessions.json",
diff -r -u --color up/chromium/chrome/common/extensions/api/tabs.json nw/chromium/chrome/common/extensions/api/tabs.json
--- up/chromium/chrome/common/extensions/api/tabs.json	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/common/extensions/api/tabs.json	2023-01-28 02:49:24.263575890 +0000
@@ -52,7 +52,8 @@
           // TODO(kalman): Investigate how this is ending up as -1 (based on window type? a bug?) and whether it should be optional instead.
           "index": {"type": "integer", "minimum": -1, "description": "The zero-based index of the tab within its window."},
           "groupId": {"type": "integer", "minimum": -1, "description": "The ID of the group that the tab belongs to."},
-          "windowId": {"type": "integer", "minimum": 0, "description": "The ID of the window that contains the tab."},
+          "windowId": {"type": "integer", "minimum": -1, "description": "The ID of the window that contains the tab."},
+          "mainFrameId": {"type": "integer", "minimum": 0, "description": "The ID of the main frame of the tab"},
           "openerTabId": {"type": "integer", "minimum": 0, "optional": true, "description": "The ID of the tab that opened this tab, if any. This property is only present if the opener tab still exists."},
           "selected": {"type": "boolean", "description": "Whether the tab is selected.", "deprecated": "Please use $(ref:tabs.Tab.highlighted)."},
           "highlighted": {"type": "boolean", "description": "Whether the tab is highlighted."},
@@ -71,6 +72,11 @@
             "optional": true,
             "description": "The tab's loading status."
           },
+          "nwstatus": {
+            "$ref": "TabStatus",
+            "optional": true,
+            "description": "The tab's loading status."
+          },
           "incognito": {"type": "boolean", "description": "Whether the tab is in an incognito window."},
           "width": {"type": "integer", "optional": true, "description": "The width of the tab in pixels."},
           "height": {"type": "integer", "optional": true, "description": "The height of the tab in pixels."},
@@ -1116,6 +1122,11 @@
             "name": "changeInfo",
             "description": "Lists the changes to the state of the tab that was updated.",
             "properties": {
+              "nwstatus": {
+                "type": "string",
+                "optional": true,
+                "description": "The status of the tab. Can be either <em>loading</em> or <em>complete</em>."
+              },
               "status": {
                 "$ref": "TabStatus",
                 "optional": true,
diff -r -u --color up/chromium/chrome/common/extensions/api/web_navigation.json nw/chromium/chrome/common/extensions/api/web_navigation.json
--- up/chromium/chrome/common/extensions/api/web_navigation.json	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/common/extensions/api/web_navigation.json	2023-01-28 02:49:24.263575890 +0000
@@ -244,6 +244,7 @@
               "processId": {"type": "integer", "description": "The ID of the process that runs the renderer for this frame."},
               "frameId": {"type": "integer", "description": "0 indicates the navigation happens in the tab content window; a positive value indicates navigation in a subframe. Frame IDs are unique within a tab."},
               "parentFrameId": {"type": "integer", "description": "The ID of the parent frame, or <code>-1</code> if this is the main frame."},
+              "routingId": {"type": "integer", "description": ""},
               "timeStamp": {"type": "number", "description": "The time when the page's DOM was fully constructed, in milliseconds since the epoch."},
               "documentId": {"type": "string", "description": "A UUID of the document loaded."},
               "parentDocumentId": {"type": "string", "optional": true, "description": "A UUID of the parent document owning this frame. This is not set if there is no parent."},
diff -r -u --color up/chromium/chrome/common/extensions/api/webview_tag.json nw/chromium/chrome/common/extensions/api/webview_tag.json
--- up/chromium/chrome/common/extensions/api/webview_tag.json	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/common/extensions/api/webview_tag.json	2023-01-28 02:49:24.263575890 +0000
@@ -905,6 +905,13 @@
         "parameters": []
       },
       {
+        "name": "getGuestId",
+        "type": "function",
+        "returns": { "type": "integer" },
+        "description": "",
+        "parameters": []
+      },
+      {
         "name": "getUserAgent",
         "type": "function",
         "returns": { "type": "string" },
@@ -1148,6 +1155,41 @@
           }
         ]
       },
+      {
+	"name": "showDevTools",
+	"type": "function",
+	"description": "Open or close devtools for this webview.",
+	"parameters": [
+          {
+            "type": "boolean",
+            "name": "show",
+            "description" : "show or close."
+          },
+          {
+            "type": "object",
+            "name": "container",
+            "description" : "where to show the devtools, should be a webview",
+            "optional": true
+          }
+        ]
+      },
+      {
+	"name": "inspectElementAt",
+	"type": "function",
+	"description": "inpsect element in this webview in devtools opened previously.",
+	"parameters": [
+          {
+            "type": "integer",
+            "name": "x",
+            "description" : "coordinate x of the element."
+          },
+          {
+            "type": "integer",
+            "name": "y",
+            "description" : "coordinate y of the element"
+          }
+        ]
+      },
       {
         "name": "terminate",
         "type": "function",
diff -r -u --color up/chromium/chrome/common/extensions/api/windows.json nw/chromium/chrome/common/extensions/api/windows.json
--- up/chromium/chrome/common/extensions/api/windows.json	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/common/extensions/api/windows.json	2023-01-28 02:49:24.263575890 +0000
@@ -50,6 +50,9 @@
           "name": "maximized",
           "description": "Maximized window state."
         }, {
+          "name": "hidden",
+          "description": "Hidden window state."
+        }, {
           "name": "fullscreen",
           "description": "Fullscreen window state."
         }, {
@@ -64,6 +67,10 @@
         "properties": {
           "id": {"type": "integer", "optional": true, "minimum": 0, "description": "The ID of the window. Window IDs are unique within a browser session. In some circumstances a window may not be assigned an <code>ID</code> property; for example, when querying windows using the $(ref:sessions) API, in which case a session ID may be present."},
           "focused": {"type": "boolean", "description": "Whether the window is currently the focused window."},
+          "maxWidth": {"type": "integer", "optional": true, "description": ""},  
+          "maxHeight": {"type": "integer", "optional": true, "description": ""},  
+          "minWidth": {"type": "integer", "optional": true, "description": ""},  
+          "minHeight": {"type": "integer", "optional": true, "description": ""},  
           "top": {"type": "integer", "optional": true, "description": "The offset of the window from the top edge of the screen in pixels. In some circumstances a window may not be assigned a <code>top</code> property; for example, when querying closed windows from the $(ref:sessions) API."},
           "left": {"type": "integer", "optional": true, "description": "The offset of the window from the left edge of the screen in pixels. In some circumstances a window may not be assigned a <code>left</code> property; for example, when querying closed windows from the $(ref:sessions) API."},
           "width": {"type": "integer", "optional": true, "description": "The width of the window, including the frame, in pixels. In some circumstances a window may not be assigned a <code>width</code> property; for example, when querying closed windows from the $(ref:sessions) API."},
@@ -81,6 +88,9 @@
             "description": "The state of this browser window."
           },
           "alwaysOnTop": {"type": "boolean", "description": "Whether the window is set to be always on top."},
+          "showInTaskbar": {"type": "boolean", "optional": true, "description": "Whether the window is set to be always on top."},
+          "resizable": {"type": "boolean", "optional": true, "description": "Whether the window is resizable"},
+          "allVisible": {"type": "boolean", "optional": true, "description": "Whether the window is set to be visible on all workspaces."},
           "sessionId": {"type": "string", "optional": true, "description": "The session ID used to uniquely identify a window, obtained from the $(ref:sessions) API."}
         }
       },
@@ -208,12 +218,33 @@
                   {"type": "array", "items": {"type": "string"}}
                 ]
               },
+              "id": {"type":"string", "optional": true, "description": ""},
               "tabId": {"type": "integer", "minimum": 0, "optional": true, "description": "The ID of the tab to add to the new window."},
+              "maxWidth": {"type": "integer", "optional": true, "description": ""},  
+              "maxHeight": {"type": "integer", "optional": true, "description": ""},  
+              "minWidth": {"type": "integer", "optional": true, "description": ""},  
+              "minHeight": {"type": "integer", "optional": true, "description": ""},  
               "left": {"type": "integer", "optional": true, "description": "The number of pixels to position the new window from the left edge of the screen. If not specified, the new window is offset naturally from the last focused window. This value is ignored for panels."},
               "top": {"type": "integer", "optional": true, "description": "The number of pixels to position the new window from the top edge of the screen. If not specified, the new window is offset naturally from the last focused window. This value is ignored for panels."},
               "width": {"type": "integer", "minimum": 0, "optional": true, "description": "The width in pixels of the new window, including the frame. If not specified, defaults to a natural width."},
               "height": {"type": "integer", "minimum": 0, "optional": true, "description": "The height in pixels of the new window, including the frame. If not specified, defaults to a natural height."},
               "focused": {"type": "boolean", "optional": true, "description": "If <code>true</code>, opens an active window. If <code>false</code>, opens an inactive window."},
+              "hidden": {"type": "boolean", "optional": true, "description": ""},
+              "frameless": {"type": "boolean", "optional": true, "description": ""},
+              "kiosk": {"type": "boolean", "optional": true, "description": ""},
+              "alphaEnabled": {"type": "boolean", "optional": true, "description": ""},
+              "new_instance": {"type": "boolean", "optional": true, "description": ""},
+              "mixed_context": {"type": "boolean", "optional": true, "description": ""},
+              "block_parser": {"type":"boolean", "optional": true, "description": ""},
+              "inject_js_start": {"type":"string", "optional": true, "description": ""},
+              "inject_js_end": {"type":"string", "optional": true, "description": ""},
+              "alwaysOnTop": {"type": "boolean", "optional": true, "description": "Whether the window is set to be always on top."},
+              "showInTaskbar": {"type": "boolean", "optional": true, "description": "Whether the window is set to be always on top."},
+              "allVisible": {"type": "boolean", "optional": true, "description": "Whether the window is visible on all workspaces"},
+              "resizable": {"type": "boolean", "optional": true, "description": "Whether the window is resizable"},
+              "title":{"type":"string", "optional": true, "description": ""},
+              "icon":{"type":"string", "optional": true, "description": ""},
+              "position":{"type":"string", "optional": true, "description": ""},
               "incognito": {"type": "boolean", "optional": true, "description": "Whether the new window should be an incognito window."},
               "type": {
                 "$ref": "CreateType",
@@ -255,11 +286,23 @@
             "type": "object",
             "name": "updateInfo",
             "properties": {
+              "show": {"type": "boolean", "optional": true, "description": ""},
+              "resizable": {"type": "boolean", "optional": true, "description": "Whether the window is resizable"},
+              "allVisible": {"type": "boolean", "optional": true, "description": "Whether the window is visible on all workspaces"},
+              "alwaysOnTop": {"type": "boolean", "optional": true, "description": "Whether the window is set to be always on top."},
+              "showInTaskbar": {"type": "boolean", "optional": true, "description": "Whether the window is set to be always on top."},
+              "maxWidth": {"type": "integer", "optional": true, "description": ""},  
+              "maxHeight": {"type": "integer", "optional": true, "description": ""},  
+              "minWidth": {"type": "integer", "optional": true, "description": ""},  
+              "minHeight": {"type": "integer", "optional": true, "description": ""},  
               "left": {"type": "integer", "optional": true, "description": "The offset from the left edge of the screen to move the window to in pixels. This value is ignored for panels."},
               "top": {"type": "integer", "optional": true, "description": "The offset from the top edge of the screen to move the window to in pixels. This value is ignored for panels."},
+              "innerWidth": {"type": "integer", "optional": true, "description": ""},  
+              "innerHeight": {"type": "integer", "optional": true, "description": ""},  
               "width": {"type": "integer", "minimum": 0, "optional": true, "description": "The width to resize the window to in pixels. This value is ignored for panels."},
               "height": {"type": "integer", "minimum": 0, "optional": true, "description": "The height to resize the window to in pixels. This value is ignored for panels."},
               "focused": {"type": "boolean", "optional": true, "description": "If <code>true</code>, brings the window to the front; cannot be combined with the state 'minimized'. If <code>false</code>, brings the next window in the z-order to the front; cannot be combined with the state 'fullscreen' or 'maximized'."},
+              "position": {"type":"string", "optional": true, "description": ""},  
               "drawAttention": {"type": "boolean", "optional": true, "description": "If <code>true</code>, causes the window to be displayed in a manner that draws the user's attention to the window, without changing the focused window. The effect lasts until the user changes focus to the window. This option has no effect if the window already has focus. Set to <code>false</code> to cancel a previous <code>drawAttention</code> request."},
               "state": {
                 "$ref": "WindowState",
@@ -291,6 +334,46 @@
     ],
     "events": [
       {
+        "name": "onMove",
+        "type": "function",
+        "description": "Fired when a window is moving.",
+        "filters": [
+          {
+            "name": "windowTypes",
+            "type": "array",
+            "items": { "$ref": "WindowType" },
+            "description": "Conditions that the window's type being created must satisfy. By default it satisfies <code>['normal', 'popup']</code>."
+          }
+        ],
+        "parameters": [
+          {
+            "$ref": "Window",
+            "name": "window",
+            "description": "Details of the created window."
+          }
+        ]
+      },
+      {
+        "name": "onWindowChanged",
+        "type": "function",
+        "description": "Fired when a window is changed.",
+        "filters": [
+          {
+            "name": "windowTypes",
+            "type": "array",
+            "items": { "$ref": "WindowType" },
+            "description": "Conditions that the window's type being created must satisfy. By default it satisfies <code>['normal', 'popup']</code>."
+          }
+        ],
+        "parameters": [
+          {
+            "$ref": "Window",
+            "name": "window",
+            "description": "Details of the created window."
+          }
+        ]
+      },
+      {
         "name": "onCreated",
         "type": "function",
         "description": "Fired when a window is created.",
@@ -311,6 +394,23 @@
         ]
       },
       {
+        "name": "onRemoving",
+        "type": "function",
+        "description": "Fired when a window wants to be closed.",
+        "filters": [
+          {
+            "name": "windowTypes",
+            "type": "array",
+            "items": { "$ref": "WindowType" },
+            "description": "Conditions that the window's type being removed must satisfy. By default it satisfies <code>['normal', 'popup']</code>."
+          }
+        ],
+        "parameters": [
+          {"type": "integer", "name": "windowId", "minimum": 0, "description": "ID of the removed window."},
+          {"type": "string", "optional": true, "name": "flag", "description": ""}
+        ]
+      },
+      {
         "name": "onRemoved",
         "type": "function",
         "description": "Fired when a window is removed (closed).",
diff -r -u --color up/chromium/chrome/common/extensions/chrome_extensions_api_provider.cc nw/chromium/chrome/common/extensions/chrome_extensions_api_provider.cc
--- up/chromium/chrome/common/extensions/chrome_extensions_api_provider.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/common/extensions/chrome_extensions_api_provider.cc	2023-01-28 02:49:24.263575890 +0000
@@ -4,6 +4,8 @@
 
 #include "chrome/common/extensions/chrome_extensions_api_provider.h"
 
+#include "content/nw/src/api/generated_schemas.h"
+
 #include "chrome/common/extensions/api/api_features.h"
 #include "chrome/common/extensions/api/generated_schemas.h"
 #include "chrome/common/extensions/api/manifest_features.h"
@@ -11,6 +13,7 @@
 #include "chrome/common/extensions/chrome_manifest_handlers.h"
 #include "chrome/common/extensions/permissions/chrome_api_permissions.h"
 #include "chrome/grit/common_resources.h"
+#include "extensions/grit/extensions_resources.h"
 #include "extensions/common/features/json_feature_provider_source.h"
 #include "extensions/common/permissions/permissions_info.h"
 
@@ -41,16 +44,20 @@
 void ChromeExtensionsAPIProvider::AddAPIJSONSources(
     JSONFeatureProviderSource* json_source) {
   json_source->LoadJSON(IDR_CHROME_EXTENSION_API_FEATURES);
+  json_source->LoadJSON(IDR_NW_EXTENSION_API_FEATURES);
 }
 
 bool ChromeExtensionsAPIProvider::IsAPISchemaGenerated(
     const std::string& name) {
-  return api::ChromeGeneratedSchemas::IsGenerated(name);
+  return api::ChromeGeneratedSchemas::IsGenerated(name) || nwapi::nwjsGeneratedSchemas::IsGenerated(name);
 }
 
 base::StringPiece ChromeExtensionsAPIProvider::GetAPISchema(
     const std::string& name) {
-  return api::ChromeGeneratedSchemas::Get(name);
+  base::StringPiece chrome_schema = api::ChromeGeneratedSchemas::Get(name);
+  if (!chrome_schema.empty())
+    return chrome_schema;
+  return nwapi::nwjsGeneratedSchemas::Get(name);
 }
 
 void ChromeExtensionsAPIProvider::RegisterPermissions(
diff -r -u --color up/chromium/chrome/common/extensions/chrome_extensions_client.cc nw/chromium/chrome/common/extensions/chrome_extensions_client.cc
--- up/chromium/chrome/common/extensions/chrome_extensions_client.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/common/extensions/chrome_extensions_client.cc	2023-01-28 02:49:24.263575890 +0000
@@ -39,6 +39,8 @@
 #include "ui/base/l10n/l10n_util.h"
 #include "url/gurl.h"
 
+#include "content/nw/src/api/generated_schemas.h"
+
 namespace extensions {
 
 namespace {
diff -r -u --color up/chromium/chrome/common/extensions/sync_helper.cc nw/chromium/chrome/common/extensions/sync_helper.cc
--- up/chromium/chrome/common/extensions/sync_helper.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/common/extensions/sync_helper.cc	2023-01-28 02:49:24.267575932 +0000
@@ -49,6 +49,7 @@
     case Manifest::TYPE_HOSTED_APP:
     case Manifest::TYPE_LEGACY_PACKAGED_APP:
     case Manifest::TYPE_PLATFORM_APP:
+    case Manifest::TYPE_NWJS_APP:
     case Manifest::TYPE_THEME:
       return true;
 
diff -r -u --color up/chromium/chrome/common/features.gni nw/chromium/chrome/common/features.gni
--- up/chromium/chrome/common/features.gni	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/common/features.gni	2023-01-28 02:49:24.267575932 +0000
@@ -91,6 +91,7 @@
 # Every grit target in //chrome should apply these defines so that the
 # proper build flags can be set.
 chrome_grit_defines = [
+  "nwjs_sdk=$nwjs_sdk",
   "chrome_root_store_supported=$chrome_root_store_supported",
   "enable_arcore=$enable_arcore",
   "enable_background_mode=$enable_background_mode",
diff -r -u --color up/chromium/chrome/common/logging_chrome.cc nw/chromium/chrome/common/logging_chrome.cc
--- up/chromium/chrome/common/logging_chrome.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/common/logging_chrome.cc	2023-01-28 02:49:24.271575975 +0000
@@ -20,6 +20,7 @@
 #define IPC_LOG_TABLE_ADD_ENTRY(msg_id, logger) \
   content::RegisterIPCLogger(msg_id, logger)
 #include "chrome/common/all_messages.h"
+#include "extensions/common/extension_messages.h"
 #endif
 
 #if BUILDFLAG(IS_WIN)
diff -r -u --color up/chromium/chrome/install_static/chromium_install_modes.cc nw/chromium/chrome/install_static/chromium_install_modes.cc
--- up/chromium/chrome/install_static/chromium_install_modes.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/install_static/chromium_install_modes.cc	2023-01-28 02:49:24.299576270 +0000
@@ -16,7 +16,7 @@
 
 const wchar_t kCompanyPathName[] = L"";
 
-const wchar_t kProductPathName[] = L"Chromium";
+const wchar_t kProductPathName[] = L"nwjs";
 
 const size_t kProductPathNameLength = _countof(kProductPathName) - 1;
 
@@ -34,8 +34,8 @@
         .logo_suffix = L"",  // No logo suffix for the primary install mode.
         .app_guid =
             L"",  // Empty app_guid since no integraion with Google Update.
-        .base_app_name = L"Chromium",      // A distinct base_app_name.
-        .base_app_id = L"Chromium",        // A distinct base_app_id.
+        .base_app_name = L"nwjs",      // A distinct base_app_name.
+        .base_app_id = L"nwjs",        // A distinct base_app_id.
         .prog_id_prefix = L"ChromiumHTM",  // ProgID prefix.
         .prog_id_description =
             L"Chromium HTML Document",  // ProgID description.
diff -r -u --color up/chromium/chrome/install_static/install_util.cc nw/chromium/chrome/install_static/install_util.cc
--- up/chromium/chrome/install_static/install_util.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/install_static/install_util.cc	2023-01-28 02:49:24.299576270 +0000
@@ -25,6 +25,8 @@
 #include "components/nacl/common/buildflags.h"
 #include "components/version_info/channel.h"
 
+std::wstring g_nwjs_prod_name, g_nwjs_prod_version;
+
 namespace install_static {
 
 enum class ProcessType {
@@ -97,6 +99,7 @@
   va_end(args);
 }
 
+#if 0
 bool GetLanguageAndCodePageFromVersionResource(const char* version_resource,
                                                WORD* language,
                                                WORD* code_page) {
@@ -174,6 +177,7 @@
   }
   return false;
 }
+#endif
 
 bool DirectoryExists(const std::wstring& path) {
   DWORD file_attributes = ::GetFileAttributes(path.c_str());
@@ -474,7 +478,10 @@
     path->append(kCompanyPathName);
     path->push_back(L'\\');
   }
-  path->append(kProductPathName, kProductPathNameLength);
+  if (!g_nwjs_prod_name.empty())
+    path->append(g_nwjs_prod_name);
+  else
+    path->append(kProductPathName, kProductPathNameLength);
   if (!include_suffix)
     return *path;
   return path->append(mode.install_suffix);
@@ -585,10 +592,10 @@
   assert(channel_name);
 
   // Default values in case we don't find a version resource.
-  *product_name = L"Chrome";
-  *version = L"0.0.0.0-devel";
+  *product_name = g_nwjs_prod_name;
+  *version = g_nwjs_prod_version;
   special_build->clear();
-
+#if 0
   DWORD dummy = 0;
   DWORD length = ::GetFileVersionInfoSize(exe_path.c_str(), &dummy);
   if (length) {
@@ -607,6 +614,7 @@
     }
   }
   *channel_name = GetChromeChannelName(/*with_extended_stable=*/true);
+#endif
 }
 
 version_info::Channel GetChromeChannel() {
diff -r -u --color up/chromium/chrome/installer/linux/BUILD.gn nw/chromium/chrome/installer/linux/BUILD.gn
--- up/chromium/chrome/installer/linux/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/installer/linux/BUILD.gn	2023-01-28 02:49:24.303576313 +0000
@@ -35,7 +35,7 @@
 assert(is_linux || is_chromeos)
 
 packaging_files_executables = [
-  "$root_out_dir/chrome",
+  "$root_out_dir/nw",
   "$root_out_dir/chrome_crashpad_handler",
   "$root_out_dir/chrome_management_service",
   "$root_out_dir/chrome_sandbox",
@@ -71,16 +71,16 @@
 
 if (use_egl) {
   packaging_files_shlibs += [
-    "$root_out_dir/libEGL.so",
-    "$root_out_dir/libGLESv2.so",
+    "$root_out_dir/lib/libEGL.so",
+    "$root_out_dir/lib/libGLESv2.so",
   ]
   if (angle_shared_libvulkan && !is_chromeos) {
-    packaging_files_shlibs += [ "$root_out_dir/libvulkan.so.1" ]
+    packaging_files_shlibs += [ "$root_out_dir/lib/libvulkan.so.1" ]
   }
 }
 
 if (enable_swiftshader) {
-  packaging_files_shlibs += [ "$root_out_dir/libvk_swiftshader.so" ]
+  packaging_files_shlibs += [ "$root_out_dir/lib/libvk_swiftshader.so" ]
 }
 
 if (build_with_internal_optimization_guide) {
@@ -183,7 +183,7 @@
 }
 
 strip_binary("strip_chrome_binary") {
-  binary_input = "$root_out_dir/chrome"
+  binary_input = "$root_out_dir/nw"
   deps = [ "//chrome" ]
 }
 
@@ -203,22 +203,22 @@
 }
 
 strip_binary("strip_libEGL_shlib") {
-  binary_input = "$root_out_dir/libEGL.so"
+  binary_input = "$root_out_dir/lib/libEGL.so"
   deps = [ "//third_party/angle:libEGL" ]
 }
 
 strip_binary("strip_libGLESv2_shlib") {
-  binary_input = "$root_out_dir/libGLESv2.so"
+  binary_input = "$root_out_dir/lib/libGLESv2.so"
   deps = [ "//third_party/angle:libGLESv2" ]
 }
 
 strip_binary("strip_libvulkan_shlib") {
-  binary_input = "$root_out_dir/libvulkan.so.1"
+  binary_input = "$root_out_dir/lib/libvulkan.so.1"
   deps = [ "//third_party/vulkan-deps/vulkan-loader/src:libvulkan" ]
 }
 
 strip_binary("strip_libvk_swiftshader.shlib") {
-  binary_input = "$root_out_dir/libvk_swiftshader.so"
+  binary_input = "$root_out_dir/lib/libvk_swiftshader.so"
   deps = [ "//third_party/swiftshader/src/Vulkan:swiftshader_libvulkan" ]
 }
 
@@ -396,6 +396,9 @@
     "//components/crash/core/app:chrome_crashpad_handler",
     "//sandbox/linux:chrome_sandbox",
   ]
+  if (is_linux) {
+    public_deps += [ "//chrome:xdg_mime" ]
+  }
   if (package_nacl) {
     public_deps += [
       ":strip_nacl_helper",
diff -r -u --color up/chromium/chrome/installer/linux/common/installer.include nw/chromium/chrome/installer/linux/common/installer.include
--- up/chromium/chrome/installer/linux/common/installer.include	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/installer/linux/common/installer.include	2023-01-28 02:49:24.303576313 +0000
@@ -157,9 +157,9 @@
   # we should flag all installer files in FILES.cfg and get them from there, so
   # there's only one place people need to keep track of such things (and in
   # only the public repository).
-  if [ -r "${OUTPUTDIR}/chrome_100_percent.pak" ]; then
-    install -m 644 "${OUTPUTDIR}/chrome_100_percent.pak" "${STAGEDIR}/${INSTALLDIR}/"
-    install -m 644 "${OUTPUTDIR}/chrome_200_percent.pak" "${STAGEDIR}/${INSTALLDIR}/"
+  if [ -r "${OUTPUTDIR}/nw_100_percent.pak" ]; then
+    install -m 644 "${OUTPUTDIR}/nw_100_percent.pak" "${STAGEDIR}/${INSTALLDIR}/"
+    install -m 644 "${OUTPUTDIR}/nw_200_percent.pak" "${STAGEDIR}/${INSTALLDIR}/"
   else
     install -m 644 "${OUTPUTDIR}/theme_resources_100_percent.pak" "${STAGEDIR}/${INSTALLDIR}/"
     install -m 644 "${OUTPUTDIR}/ui_resources_100_percent.pak" "${STAGEDIR}/${INSTALLDIR}/"
diff -r -u --color up/chromium/chrome/installer/mini_installer/BUILD.gn nw/chromium/chrome/installer/mini_installer/BUILD.gn
--- up/chromium/chrome/installer/mini_installer/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/installer/mini_installer/BUILD.gn	2023-01-28 02:49:24.307576355 +0000
@@ -119,8 +119,8 @@
   release_file = "chrome.release"
 
   inputs = [
-    "$root_out_dir/chrome.dll",
-    "$root_out_dir/chrome.exe",
+    "$root_out_dir/nw.dll",
+    "$root_out_dir/nw.exe",
     "$root_out_dir/locales/en-US.pak",
     "$root_out_dir/setup.exe",
     "//chrome/tools/build/win/makecab.py",
diff -r -u --color up/chromium/chrome/installer/mini_installer/chrome.release nw/chromium/chrome/installer/mini_installer/chrome.release
--- up/chromium/chrome/installer/mini_installer/chrome.release	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/installer/mini_installer/chrome.release	2023-01-28 02:49:24.311576397 +0000
@@ -6,45 +6,46 @@
 #
 # Chrome Application dir entries, sorted alphabetically.
 #
-chrome.exe: %(ChromeDir)s\
-chrome_proxy.exe: %(ChromeDir)s\
+nw.exe: %(ChromeDir)s\
+nw_proxy.exe: %(ChromeDir)s\
 #
 # Chrome version dir assembly manifest.
 # The name of this file must match the name of the version dir, so we cannot
 # hard-code it.
 # // TODO(caitkp): Find a way to do this without wildcards.
 #
-*.*.*.*.manifest: %(VersionDir)s\
+*.*.*.*.manifest: %(ChromeDir)s\
 #
 # Chrome version dir entries, sorted alphabetically.
 #
-chrome.dll: %(VersionDir)s\
-chrome_100_percent.pak: %(VersionDir)s\
-chrome_child.dll: %(VersionDir)s\
-chrome_elf.dll: %(VersionDir)s\
-chrome_pwa_launcher.exe: %(VersionDir)s\
-chrome_wer.dll: %(VersionDir)s\
-d3dcompiler_47.dll: %(VersionDir)s\
-eventlog_provider.dll: %(VersionDir)s\
-icudtl.dat: %(VersionDir)s\
-libEGL.dll: %(VersionDir)s\
-libGLESv2.dll: %(VersionDir)s\
-mojo_core.dll: %(VersionDir)s\
-nacl64.exe: %(VersionDir)s\
-nacl_irt_x86_32.nexe: %(VersionDir)s\
-nacl_irt_x86_64.nexe: %(VersionDir)s\
-notification_helper.exe: %(VersionDir)s\
-optimization_guide_internal.dll: %(VersionDir)s\
-resources.pak: %(VersionDir)s\
-vk_swiftshader.dll: %(VersionDir)s\
-vk_swiftshader_icd.json: %(VersionDir)s\
-vulkan-1.dll: %(VersionDir)s\
-v8_context_snapshot.bin: %(VersionDir)s\
+nw.dll: %(ChromeDir)s\
+nw_100_percent.pak: %(ChromeDir)s\
+nw_child.dll: %(ChromeDir)s\
+nw_elf.dll: %(ChromeDir)s\
+chrome_pwa_launcher.exe: %(ChromeDir)s\
+chrome_wer.dll: %(ChromeDir)s\
+d3dcompiler_47.dll: %(ChromeDir)s\
+eventlog_provider.dll: %(ChromeDir)s\
+icudtl.dat: %(ChromeDir)s\
+libEGL.dll: %(ChromeDir)s\
+libGLESv2.dll: %(ChromeDir)s\
+mojo_core.dll: %(ChromeDir)s\
+nacl64.exe: %(ChromeDir)s\
+nacl_irt_x86_32.nexe: %(ChromeDir)s\
+nacl_irt_x86_64.nexe: %(ChromeDir)s\
+notification_helper.exe: %(ChromeDir)s\
+resources.pak: %(ChromeDir)s\
+node.dll: %(ChromeDir)s\
+vk_swiftshader.dll: %(ChromeDir)s\
+vk_swiftshader_icd.json: %(ChromeDir)s\
+vulkan-1.dll: %(ChromeDir)s\
+v8_context_snapshot.bin: %(ChromeDir)s\
+
 #
 # Sub directories living in the version dir
 #
-Extensions\*.*: %(VersionDir)s\Extensions\
-locales\*.pak: %(VersionDir)s\Locales
+Extensions\*.*: %(ChromeDir)s\Extensions\
+locales\*.pak: %(ChromeDir)s\Locales
 
 #
 # VisualElements sub-dir.
@@ -52,8 +53,9 @@
 # All or none of the *Logo*.png files need to be present as the creation of
 # VisualElementsManifest.xml is based on the existence of
 # %(VersionDir)\VisualElements.
-Logo.png: %(VersionDir)s\VisualElements\
-SmallLogo.png: %(VersionDir)s\VisualElements\
+
+Logo.png: %(ChromeDir)s\VisualElements\
+SmallLogo.png: %(ChromeDir)s\VisualElements\
 
 #
 # MEI Preload sub dir
@@ -62,7 +64,7 @@
 MEIPreload\preloaded_data.pb: %(VersionDir)s\MEIPreload\
 
 [HIDPI]
-chrome_200_percent.pak: %(VersionDir)s\
+nw_200_percent.pak: %(ChromeDir)s\
 
 [FFMPEG]
 ffmpeg.dll: %(VersionDir)s\
@@ -92,15 +94,15 @@
 #
 # Widevine CDM sub-dir
 #
-WidevineCdm\manifest.json: %(VersionDir)s\WidevineCdm\
-WidevineCdm\LICENSE: %(VersionDir)s\WidevineCdm\
-WidevineCdm\_platform_specific\win_x86\widevinecdm.dll: %(VersionDir)s\WidevineCdm\_platform_specific\win_x86\
-WidevineCdm\_platform_specific\win_x86\widevinecdm.dll.sig: %(VersionDir)s\WidevineCdm\_platform_specific\win_x86\
-WidevineCdm\_platform_specific\win_x64\widevinecdm.dll: %(VersionDir)s\WidevineCdm\_platform_specific\win_x64\
-WidevineCdm\_platform_specific\win_x64\widevinecdm.dll.sig: %(VersionDir)s\WidevineCdm\_platform_specific\win_x64\
+WidevineCdm\manifest.json: %(ChromeDir)s\WidevineCdm\
+WidevineCdm\LICENSE: %(ChromeDir)s\WidevineCdm\
+WidevineCdm\_platform_specific\win_x86\widevinecdm.dll: %(ChromeDir)s\WidevineCdm\_platform_specific\win_x86\
+WidevineCdm\_platform_specific\win_x86\widevinecdm.dll.sig: %(ChromeDir)s\WidevineCdm\_platform_specific\win_x86\
+WidevineCdm\_platform_specific\win_x64\widevinecdm.dll: %(ChromeDir)s\WidevineCdm\_platform_specific\win_x64\
+WidevineCdm\_platform_specific\win_x64\widevinecdm.dll.sig: %(ChromeDir)s\WidevineCdm\_platform_specific\win_x64\
 
 [SNAPSHOTBLOB]
 # The snapshot_blob.bin V8 snapshot is needed in builds that don't use
 # v8_context_snapshot.bin, such as Linux-Windows cross-builds.
 # It has its own section here so that it's only included when necessary.
-snapshot_blob.bin: %(VersionDir)s\
+snapshot_blob.bin: %(ChromeDir)s\
diff -r -u --color up/chromium/chrome/installer/util/google_update_settings.cc nw/chromium/chrome/installer/util/google_update_settings.cc
--- up/chromium/chrome/installer/util/google_update_settings.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/installer/util/google_update_settings.cc	2023-01-28 02:49:24.323576524 +0000
@@ -1,6 +1,7 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wunused-function"
 
 #include "chrome/installer/util/google_update_settings.h"
 
@@ -213,10 +214,14 @@
 }
 
 bool GoogleUpdateSettings::GetCollectStatsConsent() {
+#if 1
+  return false;
+#else
   return GetCollectStatsConsentImpl(
              &install_static::GetClientStateKeyPath,
              &install_static::GetClientStateMediumKeyPath) ==
          google_update::TRISTATE_TRUE;
+#endif
 }
 
 bool GoogleUpdateSettings::SetCollectStatsConsent(bool consented) {
diff -r -u --color up/chromium/chrome/installer/util/util_constants.cc nw/chromium/chrome/installer/util/util_constants.cc
--- up/chromium/chrome/installer/util/util_constants.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/installer/util/util_constants.cc	2023-01-28 02:49:24.327576566 +0000
@@ -216,8 +216,8 @@
 // TODO(gab): Rename setup.exe itself altogether and use the same binary for
 // Active Setup.
 const wchar_t kActiveSetupExe[] = L"chrmstp.exe";
-const wchar_t kChromeDll[] = L"chrome.dll";
-const wchar_t kChromeExe[] = L"chrome.exe";
+const wchar_t kChromeDll[] = L"nw.dll";
+const wchar_t kChromeExe[] = L"nw.exe";
 const wchar_t kChromeNewExe[] = L"new_chrome.exe";
 const wchar_t kChromeOldExe[] = L"old_chrome.exe";
 const wchar_t kChromeProxyExe[] = L"chrome_proxy.exe";
diff -r -u --color up/chromium/chrome/renderer/BUILD.gn nw/chromium/chrome/renderer/BUILD.gn
--- up/chromium/chrome/renderer/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/renderer/BUILD.gn	2023-01-28 02:49:24.331576609 +0000
@@ -122,6 +122,7 @@
   deps = [
     "//base/allocator:buildflags",
     "//build:chromeos_buildflags",
+    "//content/nw:nw_renderer",
     "//chrome:resources",
     "//chrome:strings",
     "//chrome/common",
@@ -178,9 +179,9 @@
     "//components/subresource_filter/content/renderer",
     "//components/subresource_filter/core/common",
     "//components/sync/driver",
-    "//components/translate/content/renderer",
+    #"//components/translate/content/renderer",
     "//components/translate/core/common",
-    "//components/translate/core/language_detection",
+    #"//components/translate/core/language_detection",
     "//components/visitedlink/renderer",
     "//components/web_cache/public:features",
     "//components/web_cache/renderer",
diff -r -u --color up/chromium/chrome/renderer/chrome_content_renderer_client.cc nw/chromium/chrome/renderer/chrome_content_renderer_client.cc
--- up/chromium/chrome/renderer/chrome_content_renderer_client.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/renderer/chrome_content_renderer_client.cc	2023-01-28 02:49:24.335576651 +0000
@@ -247,6 +247,9 @@
 #include "chrome/renderer/supervised_user/supervised_user_error_page_controller_delegate_impl.h"
 #endif
 
+#include "content/nw/src/nw_content.h"
+#include "content/nw/src/common/shell_switches.h"
+
 using autofill::AutofillAgent;
 using autofill::PasswordAutofillAgent;
 using autofill::PasswordGenerationAgent;
@@ -384,6 +387,15 @@
 
 ChromeContentRendererClient::~ChromeContentRendererClient() {}
 
+void ChromeContentRendererClient::willHandleNavigationPolicy(content::RenderFrame* rv,
+                                                             blink::WebFrame* frame,
+                                                             const blink::WebURLRequest& request,
+                                                             blink::WebNavigationPolicy* policy,
+                                                             blink::WebString* manifest,
+                                                             bool new_win) {
+  nw::willHandleNavigationPolicy(rv, frame, request, policy, manifest, new_win);
+}
+
 void ChromeContentRendererClient::RenderThreadStarted() {
   RenderThread* thread = RenderThread::Get();
 
@@ -428,25 +440,28 @@
       WebString::FromASCII(extensions::kExtensionScheme));
 #endif
 
+  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
 #if BUILDFLAG(ENABLE_SPELLCHECK)
-  if (!spellcheck_)
+  if (!spellcheck_ && command_line->HasSwitch(switches::kEnableSpellChecking)) {
     InitSpellCheck();
+  }
 #endif
 
   subresource_filter_ruleset_dealer_ =
       std::make_unique<subresource_filter::UnverifiedRulesetDealer>();
 
+#if 0
   phishing_model_setter_ =
       std::make_unique<safe_browsing::PhishingModelSetterImpl>();
+#endif
 
   thread->AddObserver(chrome_observer_.get());
   thread->AddObserver(subresource_filter_ruleset_dealer_.get());
-  thread->AddObserver(phishing_model_setter_.get());
+  //thread->AddObserver(phishing_model_setter_.get());
 
   blink::WebScriptController::RegisterExtension(
       extensions_v8::LoadTimesExtension::Get());
 
-  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
   if (command_line->HasSwitch(variations::switches::kEnableBenchmarking)) {
     blink::WebScriptController::RegisterExtension(
         extensions_v8::BenchmarkingExtension::Get());
@@ -714,10 +729,12 @@
     subresource_filter_agent->Initialize();
   }
 
+#if 0
   if (translate::IsSubFrameTranslationEnabled()) {
     new translate::PerFrameTranslateAgent(
         render_frame, ISOLATED_WORLD_ID_TRANSLATE, associated_interfaces);
   }
+#endif
 
 #if !BUILDFLAG(IS_ANDROID)
   base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
@@ -740,6 +757,7 @@
   }
 
 #if BUILDFLAG(ENABLE_SPELLCHECK)
+  if (command_line->HasSwitch(switches::kEnableSpellChecking))
   new SpellCheckProvider(render_frame, spellcheck_.get(), this);
 
 #if BUILDFLAG(HAS_SPELLCHECK_PANEL)
@@ -1551,6 +1569,10 @@
   return false;
 }
 
+base::FilePath ChromeContentRendererClient::GetRootPath() {
+  return nw::GetRootPathRenderer();
+}
+
 void ChromeContentRendererClient::RunScriptsAtDocumentStart(
     content::RenderFrame* render_frame) {
 #if BUILDFLAG(ENABLE_EXTENSIONS)
diff -r -u --color up/chromium/chrome/renderer/chrome_content_renderer_client.h nw/chromium/chrome/renderer/chrome_content_renderer_client.h
--- up/chromium/chrome/renderer/chrome_content_renderer_client.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/renderer/chrome_content_renderer_client.h	2023-01-28 02:49:24.335576651 +0000
@@ -19,7 +19,7 @@
 #include "chrome/common/media/webrtc_logging.mojom.h"
 #include "chrome/services/speech/buildflags/buildflags.h"
 #include "components/nacl/common/buildflags.h"
-#include "components/safe_browsing/content/renderer/phishing_classifier/phishing_model_setter_impl.h"
+//#include "components/safe_browsing/content/renderer/phishing_classifier/phishing_model_setter_impl.h"
 #include "components/spellcheck/spellcheck_buildflags.h"
 #include "content/public/renderer/content_renderer_client.h"
 #include "content/public/renderer/render_thread.h"
@@ -87,6 +87,13 @@
 
   ~ChromeContentRendererClient() override;
 
+  base::FilePath GetRootPath() override;
+  void willHandleNavigationPolicy(content::RenderFrame* rv,
+                                  blink::WebFrame* frame,
+                                  const blink::WebURLRequest& request,
+                                  blink::WebNavigationPolicy* policy,
+                                  blink::WebString* manifest,
+                                  bool new_win) override;
   void RenderThreadStarted() override;
   void ExposeInterfacesToBrowser(mojo::BinderMap* binders) override;
   void RenderFrameCreated(content::RenderFrame* render_frame) override;
@@ -278,8 +285,10 @@
 #if BUILDFLAG(ENABLE_PLUGINS)
   std::set<std::string> allowed_camera_device_origins_;
 #endif
+#if 0
   std::unique_ptr<safe_browsing::PhishingModelSetterImpl>
       phishing_model_setter_;
+#endif
 
   scoped_refptr<blink::ThreadSafeBrowserInterfaceBrokerProxy>
       browser_interface_broker_;
diff -r -u --color up/chromium/chrome/renderer/chrome_content_settings_agent_delegate.cc nw/chromium/chrome/renderer/chrome_content_settings_agent_delegate.cc
--- up/chromium/chrome/renderer/chrome_content_settings_agent_delegate.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/renderer/chrome_content_settings_agent_delegate.cc	2023-01-28 02:49:24.335576651 +0000
@@ -115,8 +115,10 @@
 }
 
 absl::optional<bool> ChromeContentSettingsAgentDelegate::AllowMutationEvents() {
+#if 0
   if (IsPlatformApp())
     return false;
+#endif
   return absl::nullopt;
 }
 
diff -r -u --color up/chromium/chrome/renderer/chrome_render_frame_observer.cc nw/chromium/chrome/renderer/chrome_render_frame_observer.cc
--- up/chromium/chrome/renderer/chrome_render_frame_observer.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/renderer/chrome_render_frame_observer.cc	2023-01-28 02:49:24.335576651 +0000
@@ -195,11 +195,12 @@
 #if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   SetClientSidePhishingDetection();
 #endif
-
+#if 0
   if (!translate::IsSubFrameTranslationEnabled()) {
     translate_agent_ = new translate::TranslateAgent(
         render_frame, ISOLATED_WORLD_ID_TRANSLATE);
   }
+#endif
 }
 
 ChromeRenderFrameObserver::~ChromeRenderFrameObserver() {
@@ -240,9 +241,10 @@
   // Let translate_agent do any preparatory work for loading a URL.
   if (!translate_agent_)
     return;
-
+#if 0
   translate_agent_->PrepareForUrl(
       render_frame()->GetWebFrame()->GetDocument().Url());
+#endif
 }
 
 void ChromeRenderFrameObserver::DidFinishLoad() {
@@ -539,7 +541,7 @@
 }
 
 void ChromeRenderFrameObserver::SetClientSidePhishingDetection() {
-#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
+#if 0 //BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   phishing_classifier_ = safe_browsing::PhishingClassifierDelegate::Create(
       render_frame(), nullptr);
 #endif
@@ -637,12 +639,14 @@
                    .Utf16();
   }
 
+#if 0
   // Language detection should run only once. Parsing finishes before the page
   // loads, so let's pick that timing.
   if (translate_agent_ &&
       layout_type == blink::WebMeaningfulLayout::kFinishedParsing) {
     translate_agent_->PageCaptured(contents);
   }
+#endif
 
   if (text_callback) {
     std::move(text_callback).Run(contents);
diff -r -u --color up/chromium/chrome/renderer/chrome_render_frame_observer.h nw/chromium/chrome/renderer/chrome_render_frame_observer.h
--- up/chromium/chrome/renderer/chrome_render_frame_observer.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/renderer/chrome_render_frame_observer.h	2023-01-28 02:49:24.335576651 +0000
@@ -5,6 +5,7 @@
 #ifndef CHROME_RENDERER_CHROME_RENDER_FRAME_OBSERVER_H_
 #define CHROME_RENDERER_CHROME_RENDER_FRAME_OBSERVER_H_
 
+#pragma clang diagnostic ignored "-Wunused-private-field"
 #include <string>
 #include <vector>
 
diff -r -u --color up/chromium/chrome/renderer/extensions/chrome_extensions_renderer_client.cc nw/chromium/chrome/renderer/extensions/chrome_extensions_renderer_client.cc
--- up/chromium/chrome/renderer/extensions/chrome_extensions_renderer_client.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/renderer/extensions/chrome_extensions_renderer_client.cc	2023-01-28 02:49:24.335576651 +0000
@@ -8,6 +8,8 @@
 #include <utility>
 
 #include "base/bind.h"
+#include "content/nw/src/nw_content.h"
+
 #include "base/command_line.h"
 #include "base/features.h"
 #include "base/lazy_instance.h"
@@ -139,6 +141,7 @@
   if (!extension_dispatcher_) {
     extension_dispatcher_ = std::make_unique<extensions::Dispatcher>(
         std::make_unique<ChromeExtensionsDispatcherDelegate>());
+    nw::ExtensionDispatcherCreated(extension_dispatcher_.get());
   }
   extension_dispatcher_->OnRenderThreadStarted(thread);
   permissions_policy_delegate_ =
diff -r -u --color up/chromium/chrome/renderer/extensions/resource_request_policy.cc nw/chromium/chrome/renderer/extensions/resource_request_policy.cc
--- up/chromium/chrome/renderer/extensions/resource_request_policy.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/renderer/extensions/resource_request_policy.cc	2023-01-28 02:49:24.335576651 +0000
@@ -99,7 +99,10 @@
   // resources:
 
   // Empty urls (needed for some edge cases when we have empty urls).
-  if (frame_url.is_empty())
+  // NWJS: about:blank here when load iframe in document-start-end
+  // case starting from cr53
+    bool is_empty_origin = frame_url.is_empty() || frame_url == GURL(url::kAboutBlankURL);
+  if (is_empty_origin)
     return true;
 
   // Extensions requesting their own resources (frame_url check is for images,
diff -r -u --color up/chromium/chrome/renderer/url_loader_throttle_provider_impl.cc nw/chromium/chrome/renderer/url_loader_throttle_provider_impl.cc
--- up/chromium/chrome/renderer/url_loader_throttle_provider_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/renderer/url_loader_throttle_provider_impl.cc	2023-01-28 02:49:24.343576736 +0000
@@ -140,6 +140,7 @@
   DCHECK(!is_frame_resource ||
          type_ == blink::URLLoaderThrottleProviderType::kFrame);
 
+#if 0
   if (!is_frame_resource) {
     if (safe_browsing_remote_)
       safe_browsing_.Bind(std::move(safe_browsing_remote_));
@@ -147,6 +148,7 @@
         std::make_unique<safe_browsing::RendererURLLoaderThrottle>(
             safe_browsing_.get(), render_frame_id));
   }
+#endif
 
   if (type_ == blink::URLLoaderThrottleProviderType::kFrame &&
       !is_frame_resource) {
diff -r -u --color up/chromium/chrome/services/file_util/BUILD.gn nw/chromium/chrome/services/file_util/BUILD.gn
--- up/chromium/chrome/services/file_util/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/services/file_util/BUILD.gn	2023-01-28 02:49:24.347576778 +0000
@@ -38,11 +38,11 @@
     deps += ["//components/services/filesystem/public/mojom"]
   }
 
-  if (is_mac) {
+  if (false && is_mac) {
     deps += ["//chrome/utility/safe_browsing/mac"]
   }
 
-  if (safe_browsing_mode == 1) {
+  if (false && safe_browsing_mode == 1) {
     sources += [
       "safe_archive_analyzer.cc",
       "safe_archive_analyzer.h",
diff -r -u --color up/chromium/chrome/test/BUILD.gn nw/chromium/chrome/test/BUILD.gn
--- up/chromium/chrome/test/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/test/BUILD.gn	2023-01-28 02:49:24.367576989 +0000
@@ -232,7 +232,7 @@
     "//chrome:strings",
     "//chrome/browser:browser_process",
     "//chrome/browser:test_support",
-    "//chrome/browser/safe_browsing",
+    #"//chrome/browser/safe_browsing",
     "//chrome/child",
     "//chrome/common:non_code_constants",
     "//chrome/common:test_support",
@@ -1292,8 +1292,8 @@
       "//chrome/browser/sharing/proto",
       "//chrome/browser/ui/color:color_headers",
       "//chrome/browser/ui/tabs:tab_enums",
-      "//chrome/browser/ui/web_applications:browser_tests",
-      "//chrome/browser/web_applications:browser_tests",
+      #"//chrome/browser/ui/web_applications:browser_tests",
+      #"//chrome/browser/web_applications:browser_tests",
       "//chrome/browser/web_applications:web_applications_test_support",
       "//chrome/browser/web_applications/extensions",
       "//chrome/browser/webaudio:browser_tests",
@@ -1429,10 +1429,10 @@
       "//components/resources",
       "//components/safe_browsing:buildflags",
       "//components/safe_browsing/content/browser",
-      "//components/safe_browsing/content/browser:client_side_detection",
-      "//components/safe_browsing/content/browser:safe_browsing_service",
-      "//components/safe_browsing/content/browser/password_protection",
-      "//components/safe_browsing/content/browser/password_protection:test_support",
+      #"//components/safe_browsing/content/browser:client_side_detection",
+      #"//components/safe_browsing/content/browser:safe_browsing_service",
+      #"//components/safe_browsing/content/browser/password_protection",
+      #"//components/safe_browsing/content/browser/password_protection:test_support",
       "//components/safe_browsing/content/browser/web_ui",
       "//components/safe_browsing/content/common:interfaces",
       "//components/safe_browsing/content/common:interfaces_shared_cpp_sources",
@@ -1517,7 +1517,7 @@
       "//courgette:courgette_lib",
       "//crypto:test_support",
       "//device/bluetooth:mocks",
-      "//device/fido:cablev2_test_util",
+      #"//device/fido:cablev2_test_util",
       "//device/fido:test_support",
       "//google_apis:test_support",
       "//media:media_buildflags",
@@ -2435,8 +2435,8 @@
       ]
 
       deps += [
-        "//chrome/browser/ui/web_applications:app_service_browser_tests",
-        "//chrome/browser/web_applications:app_service_browser_tests",
+        #"//chrome/browser/ui/web_applications:app_service_browser_tests",
+        #"//chrome/browser/web_applications:app_service_browser_tests",
       ]
     }
 
@@ -3308,7 +3308,7 @@
         # TODO(rockot) bug 505926: The chrome_extensions_browsertests_sources
         # target should be deleted and this line removed. See the
         # chrome_extensions_browsertests_sources target for more.
-        "//extensions:chrome_extensions_browsertests_sources",
+        #"//extensions:chrome_extensions_browsertests_sources",
         "//extensions/browser:test_support",
         "//extensions/common:mojom",
         "//extensions/common/api",
@@ -4716,6 +4716,26 @@
     }
 
     sources += metric_integration_sources
+
+    sources = []
+    sources = [ 
+      "../../content/nw/src/nwjs_browsertest.cc",
+      "../browser/ui/test/test_browser_dialog.cc",
+      "../browser/ui/test/test_browser_dialog.h",
+      "../browser/ui/test/test_browser_ui.cc",
+      "../browser/ui/test/test_browser_ui.h",
+      "../browser/extensions/extension_apitest.cc",
+      "../browser/extensions/extension_browsertest.cc",
+      "../browser/extensions/extension_function_test_utils.cc",
+      "../browser/extensions/extension_function_test_utils.h",
+      "../browser/apps/platform_apps/app_browsertest_util.cc",
+      "../browser/apps/platform_apps/app_browsertest_util.h",
+      "../browser/pdf/pdf_extension_test.cc",
+      "../browser/renderer_context_menu/render_view_context_menu_browsertest_util.cc",
+      "../browser/renderer_context_menu/render_view_context_menu_browsertest_util.h",
+      "../browser/extensions/browsertest_util.cc",
+      "../browser/extensions/browsertest_util.h",
+    ]
   }
 }
 
@@ -4891,8 +4911,8 @@
       "//chrome/app:command_ids",
       "//chrome/browser/chromeos/extensions/vpn_provider",
       "//chrome/browser/metrics/structured",
-      "//chrome/browser/ui/web_applications:app_service_browser_tests",
-      "//chrome/browser/web_applications:app_service_browser_tests",
+      #"//chrome/browser/ui/web_applications:app_service_browser_tests",
+      #"//chrome/browser/web_applications:app_service_browser_tests",
       "//chrome/browser/web_applications:web_applications_test_support",
       "//chromeos/crosapi/cpp:cpp",
       "//chromeos/crosapi/mojom",
@@ -5990,7 +6010,7 @@
     "//components/resources",
     "//components/safe_browsing:buildflags",
     "//components/safe_browsing/content/browser",
-    "//components/safe_browsing/content/browser:client_side_detection",
+    #"//components/safe_browsing/content/browser:client_side_detection",
     "//components/safe_browsing/content/browser/password_protection",
     "//components/safe_browsing/content/browser/password_protection:mock_password_protection",
     "//components/safe_browsing/content/browser/web_ui",
@@ -6301,13 +6321,13 @@
       "//chrome/browser/renderer_host:history_swiper",
       "//chrome/browser/updater:browser_updater_client",
       "//chrome/common/notifications",
-      "//chrome/common/safe_browsing:archive_analyzer_results",
-      "//chrome/common/safe_browsing:disk_image_type_sniffer_mac",
+      #"//chrome/common/safe_browsing:archive_analyzer_results",
+      #"//chrome/common/safe_browsing:disk_image_type_sniffer_mac",
       "//chrome/services/mac_notifications:unit_tests",
       "//chrome/services/mac_notifications/public/mojom",
       "//chrome/updater:browser_sources",
-      "//chrome/utility/safe_browsing/mac",
-      "//chrome/utility/safe_browsing/mac:dmg_common",
+      #"//chrome/utility/safe_browsing/mac",
+      #"//chrome/utility/safe_browsing/mac:dmg_common",
       "//components/power_metrics",
 
       # The test fetches resources which means Mac need the app bundle to exist
@@ -9121,10 +9141,10 @@
       "../browser/ui/views/autofill/payments/offer_notification_bubble_views_test_base.h",
       "../browser/ui/views/tabs/tab_hover_card_test_util.cc",
       "../browser/ui/views/tabs/tab_hover_card_test_util.h",
-      "../browser/ui/views/web_apps/web_app_integration_test_driver.cc",
-      "../browser/ui/views/web_apps/web_app_integration_test_driver.h",
-      "../browser/ui/web_applications/test/web_app_navigation_browsertest.cc",
-      "../browser/ui/web_applications/test/web_app_navigation_browsertest.h",
+      #"../browser/ui/views/web_apps/web_app_integration_test_driver.cc",
+      #"../browser/ui/views/web_apps/web_app_integration_test_driver.h",
+      #"../browser/ui/web_applications/test/web_app_navigation_browsertest.cc",
+      #"../browser/ui/web_applications/test/web_app_navigation_browsertest.h",
       "../browser/ui/webui/signin/login_ui_test_utils.cc",
       "../browser/ui/webui/signin/login_ui_test_utils.h",
       "../browser/web_applications/test/profile_test_helper.cc",
diff -r -u --color up/chromium/chrome/test/base/test_browser_window.cc nw/chromium/chrome/test/base/test_browser_window.cc
--- up/chromium/chrome/test/base/test_browser_window.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/test/base/test_browser_window.cc	2023-01-28 02:49:24.383577158 +0000
@@ -75,6 +75,13 @@
 
 // TestBrowserWindow ----------------------------------------------------------
 
+void TestBrowserWindow::UpdateDraggableRegions(
+                                               const std::vector<extensions::DraggableRegion>& regions) {
+}
+SkRegion* TestBrowserWindow::GetDraggableRegion() {
+  return nullptr;
+}
+
 TestBrowserWindow::TestBrowserWindow() {}
 
 TestBrowserWindow::~TestBrowserWindow() {}
diff -r -u --color up/chromium/chrome/test/base/test_browser_window.h nw/chromium/chrome/test/base/test_browser_window.h
--- up/chromium/chrome/test/base/test_browser_window.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/test/base/test_browser_window.h	2023-01-28 02:49:24.383577158 +0000
@@ -56,7 +56,16 @@
   TestBrowserWindow& operator=(const TestBrowserWindow&) = delete;
   ~TestBrowserWindow() override;
 
+  void SetShowInTaskbar(bool) override {}
+  void SetResizable(bool) override {}
+  void SetAllVisible(bool) override {}
+  void SetMinimumSize(gfx::Size) override {}
+  void SetMaximumSize(gfx::Size) override {}
+  void NativeWindowChanged() override {}
   // BrowserWindow:
+  void UpdateDraggableRegions(
+         const std::vector<extensions::DraggableRegion>& regions) override;
+  SkRegion* GetDraggableRegion() override;
   void Show() override {}
   void ShowInactive() override {}
   void Hide() override {}
diff -r -u --color up/chromium/chrome/test/base/test_browser_window_aura.cc nw/chromium/chrome/test/base/test_browser_window_aura.cc
--- up/chromium/chrome/test/base/test_browser_window_aura.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/test/base/test_browser_window_aura.cc	2023-01-28 02:49:24.383577158 +0000
@@ -51,6 +51,14 @@
   return native_window_.get();
 }
 
+void TestBrowserWindowAura::UpdateDraggableRegions(
+    const std::vector<extensions::DraggableRegion>& regions) {
+}
+
+SkRegion* TestBrowserWindowAura::GetDraggableRegion() {
+  return nullptr;
+}
+
 void TestBrowserWindowAura::Show() {
   native_window_->Show();
 }
diff -r -u --color up/chromium/chrome/test/base/test_browser_window_aura.h nw/chromium/chrome/test/base/test_browser_window_aura.h
--- up/chromium/chrome/test/base/test_browser_window_aura.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/test/base/test_browser_window_aura.h	2023-01-28 02:49:24.383577158 +0000
@@ -27,6 +27,9 @@
   ~TestBrowserWindowAura() override;
 
   // TestBrowserWindow overrides:
+  void UpdateDraggableRegions(
+         const std::vector<extensions::DraggableRegion>& regions) override;
+  SkRegion* GetDraggableRegion() override;
   gfx::NativeWindow GetNativeWindow() const override;
   void Show() override;
   void Hide() override;
diff -r -u --color up/chromium/chrome/test/base/testing_browser_process.h nw/chromium/chrome/test/base/testing_browser_process.h
--- up/chromium/chrome/test/base/testing_browser_process.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/test/base/testing_browser_process.h	2023-01-28 02:49:24.383577158 +0000
@@ -129,6 +129,7 @@
   void StartAutoupdateTimer() override {}
 #endif
 
+
   component_updater::ComponentUpdateService* component_updater() override;
   MediaFileSystemRegistry* media_file_system_registry() override;
 
diff -r -u --color up/chromium/chrome/test/chromedriver/capabilities.cc nw/chromium/chrome/test/chromedriver/capabilities.cc
--- up/chromium/chrome/test/chromedriver/capabilities.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/test/chromedriver/capabilities.cc	2023-01-28 02:49:24.383577158 +0000
@@ -281,6 +281,20 @@
   return Status(kOk);
 }
 
+Status ParseArguments(const base::Value& option,
+                     Capabilities* capabilities) {
+  if (!option.is_list())
+    return Status(kUnknownError, "must be a list");
+  for (auto& val: option.GetList()) {
+    std::string arg_string;
+    if (!val.is_string())
+      return Status(kUnknownError, "each argument must be a string");
+    arg_string = val.GetString();
+    capabilities->arguments.push_back(arg_string);
+  }
+  return Status(kOk);
+}
+
 Status ParseExtensions(const base::Value& option, Capabilities* capabilities) {
   if (!option.is_list())
     return Status(kInvalidArgument, "must be a list");
@@ -598,6 +612,7 @@
         base::BindRepeating(&ParseNetAddress, &capabilities->debugger_address);
   } else {
     parser_map["args"] = base::BindRepeating(&ParseSwitches);
+    parser_map["nwargs"] = base::BindRepeating(&ParseArguments);
     parser_map["binary"] =
         base::BindRepeating(&ParseFilePath, &capabilities->binary);
     parser_map["detach"] =
diff -r -u --color up/chromium/chrome/test/chromedriver/capabilities.h nw/chromium/chrome/test/chromedriver/capabilities.h
--- up/chromium/chrome/test/chromedriver/capabilities.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/test/chromedriver/capabilities.h	2023-01-28 02:49:24.383577158 +0000
@@ -168,6 +168,8 @@
   // Time to wait for extension background page to appear. If 0, no waiting.
   base::TimeDelta extension_load_timeout;
 
+  std::vector<std::string> arguments;
+
   std::unique_ptr<base::DictionaryValue> local_state;
 
   std::string log_path;
diff -r -u --color up/chromium/chrome/test/chromedriver/chrome/chrome_finder.cc nw/chromium/chrome/test/chromedriver/chrome/chrome_finder.cc
--- up/chromium/chrome/test/chromedriver/chrome/chrome_finder.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/test/chromedriver/chrome/chrome_finder.cc	2023-01-28 02:49:24.387577201 +0000
@@ -30,7 +30,7 @@
 
 namespace {
 
-#if BUILDFLAG(IS_WIN)
+#if 0
 void GetApplicationDirs(std::vector<base::FilePath>* locations) {
   std::vector<base::FilePath> installation_locations;
   base::FilePath local_app_data, program_files, program_files_x86,
@@ -53,7 +53,7 @@
         installation_locations[i].Append(L"Chromium\\Application"));
   }
 }
-#elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
+#elif 0
 void GetApplicationDirs(std::vector<base::FilePath>* locations) {
   // TODO: Respect users' PATH variables.
   // Until then, we use an approximation of the most common defaults.
@@ -130,7 +130,7 @@
 
 }  // namespace internal
 
-#if BUILDFLAG(IS_MAC)
+#if 0
 void GetApplicationDirs(std::vector<base::FilePath>* locations);
 #endif
 
@@ -139,10 +139,8 @@
 #if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_MAC)
     base::FilePath(chrome::kBrowserProcessExecutablePath),
 #elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
-    base::FilePath("google-chrome"),
     base::FilePath(chrome::kBrowserProcessExecutablePath),
-    base::FilePath("chromium"),
-    base::FilePath("chromium-browser")
+    base::FilePath("nw")
 #else
     // it will compile but won't work on other OSes
     base::FilePath()
@@ -172,8 +170,11 @@
   }
 
   std::vector<base::FilePath> locations;
-  GetApplicationDirs(&locations);
   GetPathsFromEnvironment(&locations);
+  base::FilePath exe_path;
+  base::PathService::Get(base::DIR_EXE, &exe_path);
+  locations.push_back(exe_path);
+
   return internal::FindExe(base::BindRepeating(&base::PathExists), browser_exes,
                            locations, browser_exe);
 }
diff -r -u --color up/chromium/chrome/test/chromedriver/chrome/chrome_impl.cc nw/chromium/chrome/test/chromedriver/chrome/chrome_impl.cc
--- up/chromium/chrome/test/chromedriver/chrome/chrome_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/test/chromedriver/chrome/chrome_impl.cc	2023-01-28 02:49:24.387577201 +0000
@@ -19,6 +19,7 @@
 #include "base/values.h"
 #include "chrome/test/chromedriver/chrome/chrome.h"
 #include "chrome/test/chromedriver/chrome/device_metrics.h"
+#include "base/strings/string_util.h"
 #include "chrome/test/chromedriver/chrome/devtools_client.h"
 #include "chrome/test/chromedriver/chrome/devtools_client_impl.h"
 #include "chrome/test/chromedriver/chrome/devtools_event_listener.h"
@@ -66,13 +67,25 @@
   status = UpdateWebViews(views_info, w3c_compliant);
   if (status.IsError())
     return status;
+  std::string ret;
   for (int i = views_info.GetSize() - 1; i >= 0; --i) {
     const WebViewInfo& view = views_info.Get(i);
-    if (view.type == WebViewInfo::kPage) {
-      *web_view_id = view.id;
-      return Status(kOk);
+    if (view.type == WebViewInfo::kPage ||
+        view.type == WebViewInfo::kApp ||
+        (view.type == WebViewInfo::kOther &&
+         !base::StartsWith(view.url, "chrome-extension://", base::CompareCase::SENSITIVE) &&
+         !base::StartsWith(view.url, "about:blank", base::CompareCase::SENSITIVE))) {
+      ret = view.id;
+      if (view.type != WebViewInfo::kOther) {
+        *web_view_id = view.id;
+        return Status(kOk);
+      }
     }
   }
+  if (!ret.empty()) {
+    *web_view_id = ret;
+    return Status(kOk);
+  }
   return Status(kUnknownError, "unable to discover open window in chrome");
 }
 
diff -r -u --color up/chromium/chrome/test/chromedriver/chrome/console_logger.cc nw/chromium/chrome/test/chromedriver/chrome/console_logger.cc
--- up/chromium/chrome/test/chromedriver/chrome/console_logger.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/test/chromedriver/chrome/console_logger.cc	2023-01-28 02:49:24.387577201 +0000
@@ -123,11 +123,11 @@
       if (!url.empty())
         origin = url;
       int line = call_frame.FindIntKey("lineNumber").value_or(-1);
-      if (line < 0)
-        return Status(kUnknownError, "missing or invalid lineNumber");
+      //if (line < 0)
+      //  return Status(kUnknownError, "missing or invalid lineNumber");
       int column = call_frame.FindIntKey("columnNumber").value_or(-1);
-      if (column < 0)
-        return Status(kUnknownError, "missing or invalid columnNumber");
+      //if (column < 0)
+      //  return Status(kUnknownError, "missing or invalid columnNumber");
       line_column = base::StringPrintf("%d:%d", line, column);
     }
   }
diff -r -u --color up/chromium/chrome/test/chromedriver/chrome/devtools_http_client.cc nw/chromium/chrome/test/chromedriver/chrome/devtools_http_client.cc
--- up/chromium/chrome/test/chromedriver/chrome/devtools_http_client.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/test/chromedriver/chrome/devtools_http_client.cc	2023-01-28 02:49:24.387577201 +0000
@@ -109,7 +109,17 @@
 
 bool DevToolsHttpClient::IsBrowserWindow(const WebViewInfo& view) const {
   return base::Contains(*window_types_, view.type) ||
-         (view.type == WebViewInfo::kOther && view.url == "chrome://print/");
+         (view.type == WebViewInfo::kOther &&
+          (view.url == "chrome://print/" ||
+           view.url == "" || view.url == "about:blank" ||
+           //          base::StartsWith(view.url, "chrome-extension://",
+           //                 base::CompareCase::SENSITIVE) ||
+           base::StartsWith(view.url, "file://",
+                            base::CompareCase::SENSITIVE) ||
+           base::StartsWith(view.url, "http://",
+                            base::CompareCase::SENSITIVE) ||
+           base::StartsWith(view.url, "https://",
+                            base::CompareCase::SENSITIVE)));
 }
 
 const DevToolsEndpoint& DevToolsHttpClient::endpoint() const {
diff -r -u --color up/chromium/chrome/test/chromedriver/chrome_launcher.cc nw/chromium/chrome/test/chromedriver/chrome_launcher.cc
--- up/chromium/chrome/test/chromedriver/chrome_launcher.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/test/chromedriver/chrome_launcher.cc	2023-01-28 02:49:24.391577243 +0000
@@ -72,6 +72,8 @@
 #include <windows.h>
 #endif
 
+#include "base/strings/string_number_conversions.h"
+
 namespace {
 
 const char* const kCommonSwitches[] = {
@@ -80,6 +82,7 @@
     "allow-pre-commit-input",
 };
 
+#if 0
 const char* const kDesktopSwitches[] = {
     "disable-hang-monitor",
     "disable-prompt-on-repost",
@@ -99,6 +102,7 @@
     "enable-blink-features=ShadowDOMV0",
     "no-service-autorun",
 };
+#endif
 
 #if BUILDFLAG(IS_WIN)
 
@@ -149,12 +153,14 @@
 
   for (auto* common_switch : kCommonSwitches)
     switches.SetUnparsedSwitch(common_switch);
+#if 0 //FIXME if enabled, chromedriver cannot find chrome on windows
   for (auto* desktop_switch : kDesktopSwitches)
     switches.SetUnparsedSwitch(desktop_switch);
 #if BUILDFLAG(IS_WIN)
   for (auto* win_desktop_switch : kWindowsDesktopSwitches)
     switches.SetUnparsedSwitch(win_desktop_switch);
 #endif
+#endif
 
   // Chrome logs are normally sent to a file (whose location can be controlled
   // via the logPath capability). We expose a flag, --enable-chrome-logs, that
@@ -197,7 +203,7 @@
       return Status(kInvalidArgument, "user data dir can not be empty");
     *user_data_dir = base::FilePath(user_data_dir_value);
   } else {
-    command.AppendArg("data:,");
+    //command.AppendArg("data:,");
     if (!user_data_dir_temp_dir->CreateUniqueTempDir())
       return Status(kUnknownError, "cannot create temp dir for user data dir");
     switches.SetSwitch("user-data-dir",
@@ -227,6 +233,10 @@
       return status;
   }
   switches.AppendToCommandLine(&command);
+
+  for (size_t i = 0; i < capabilities.arguments.size(); i++)
+    command.AppendArg(capabilities.arguments[i]);
+
   *prepared_command = command;
   return Status(kOk);
 }
@@ -248,8 +258,13 @@
     window_types = std::make_unique<std::set<WebViewInfo::Type>>();
   }
 
-  std::unique_ptr<DevToolsHttpClient> client;
   base::CommandLine* cmd_line = base::CommandLine::ForCurrentProcess();
+  if (cmd_line->HasSwitch("launch-timeout")) {
+    std::string s_timeout = cmd_line->GetSwitchValueASCII("launch-timeout");
+    base::StringToInt(s_timeout, &wait_time);
+  }
+
+  std::unique_ptr<DevToolsHttpClient> client;
   if (cmd_line->HasSwitch("devtools-replay")) {
     base::CommandLine::StringType log_path =
         cmd_line->GetSwitchValueNative("devtools-replay");
@@ -319,7 +334,10 @@
     if (status.IsError())
       return status;
     for (size_t i = 0; i < views_info.GetSize(); ++i) {
-      if (views_info.Get(i).type == WebViewInfo::kPage) {
+      if (views_info.Get(i).type == WebViewInfo::kPage ||
+          views_info.Get(i).type == WebViewInfo::kApp
+          || (views_info.Get(i).type == WebViewInfo::kOther &&
+              !base::StartsWith(views_info.Get(i).url, "chrome-extension://", base::CompareCase::SENSITIVE))) { //node-remote page
         *user_client = std::move(client);
         return Status(kOk);
       }
diff -r -u --color up/chromium/chrome/test/chromedriver/element_commands.cc nw/chromium/chrome/test/chromedriver/element_commands.cc
--- up/chromium/chrome/test/chromedriver/element_commands.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/test/chromedriver/element_commands.cc	2023-01-28 02:49:24.391577243 +0000
@@ -45,54 +45,6 @@
 
 const std::set<std::string> kNontypeableControlTypes = {"color"};
 
-const std::unordered_set<std::string> kBooleanAttributes = {
-    "allowfullscreen",
-    "allowpaymentrequest",
-    "allowusermedia",
-    "async",
-    "autofocus",
-    "autoplay",
-    "checked",
-    "compact",
-    "complete",
-    "controls",
-    "declare",
-    "default",
-    "defaultchecked",
-    "defaultselected",
-    "defer",
-    "disabled",
-    "ended",
-    "formnovalidate",
-    "hidden",
-    "indeterminate",
-    "iscontenteditable",
-    "ismap",
-    "itemscope",
-    "loop",
-    "multiple",
-    "muted",
-    "nohref",
-    "nomodule",
-    "noresize",
-    "noshade",
-    "novalidate",
-    "nowrap",
-    "open",
-    "paused",
-    "playsinline",
-    "pubdate",
-    "readonly",
-    "required",
-    "reversed",
-    "scoped",
-    "seamless",
-    "seeking",
-    "selected",
-    "truespeed",
-    "typemustmatch",
-    "willvalidate"};
-
 namespace {
 
 Status FocusToElement(
@@ -1046,11 +998,11 @@
     return Status(kInvalidArgument, "missing 'name'");
 
   // In legacy mode, use old behavior for backward compatibility.
-  if (!session->w3c_compliant) {
-    return GetElementAttribute(session, web_view, element_id, *attribute_name,
+  //if (!session->w3c_compliant) {
+  return GetElementAttribute(session, web_view, element_id, *attribute_name,
                                value);
-  }
-
+    //}
+#if 0
   Status status = CheckElement(element_id);
   if (status.IsError())
     return status;
@@ -1063,6 +1015,7 @@
           ? "(elem, attribute) => elem.hasAttribute(attribute) ? 'true' : null"
           : "(elem, attribute) => elem.getAttribute(attribute)",
       args, value);
+#endif
 }
 
 Status ExecuteGetElementValueOfCSSProperty(
diff -r -u --color up/chromium/chrome/test/data/webui/print_preview/destination_dialog_test.ts nw/chromium/chrome/test/data/webui/print_preview/destination_dialog_test.ts
--- up/chromium/chrome/test/data/webui/print_preview/destination_dialog_test.ts	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/test/data/webui/print_preview/destination_dialog_test.ts	2023-01-28 02:49:25.251586333 +0000
@@ -114,7 +114,7 @@
         false /* pdfPrinterDisabled */, true /* isDriveMounted */,
         'FooDevice' /* printerName */,
         '' /* serializedDefaultDestinationSelectionRulesStr */,
-        [makeRecentDestination(destinations[4]!)] /* recentDestinations */);
+        [makeRecentDestination(destinations[4]!)] /* recentDestinations */, false);
     await whenPrinterListReady;
     whenPrinterListReady = nativeLayer.waitForGetPrinters(1);
     // This should trigger 1 new getPrinters() call, for extension printers.
@@ -139,7 +139,7 @@
             '' /* serializedDefaultDestinationSelectionRulesStr */, [
               makeRecentDestination(destinations[4]!),
               makeRecentDestination(extensionDestinations[0]!),
-            ] /* recentDestinations */);
+            ] /* recentDestinations */, false);
         await whenAllPreloaded;
         finishSetup();
         flush();
diff -r -u --color up/chromium/chrome/test/data/webui/print_preview/destination_search_test.ts nw/chromium/chrome/test/data/webui/print_preview/destination_search_test.ts
--- up/chromium/chrome/test/data/webui/print_preview/destination_search_test.ts	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/test/data/webui/print_preview/destination_search_test.ts	2023-01-28 02:49:25.251586333 +0000
@@ -44,7 +44,7 @@
         false /* pdfPrinterDisabled */, false /* isDriveMounted */,
         'FooDevice' /* printerName */,
         '' /* serializedDefaultDestinationSelectionRulesStr */,
-        [] /* recentDestinations */);
+        [] /* recentDestinations */, false);
 
     dialog = document.createElement('print-preview-destination-dialog');
     dialog.destinationStore = destinationStore;
diff -r -u --color up/chromium/chrome/test/data/webui/print_preview/destination_store_test.ts nw/chromium/chrome/test/data/webui/print_preview/destination_store_test.ts
--- up/chromium/chrome/test/data/webui/print_preview/destination_store_test.ts	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/test/data/webui/print_preview/destination_store_test.ts	2023-01-28 02:49:25.251586333 +0000
@@ -108,7 +108,7 @@
         initialSettings.pdfPrinterDisabled, !!initialSettings.isDriveMounted,
         initialSettings.printerName,
         initialSettings.serializedDefaultDestinationSelectionRulesStr,
-        recentDestinations);
+        recentDestinations, false);
     return expectPrinterFailure ? Promise.resolve() : Promise.race([
       nativeLayer.whenCalled('getPrinterCapabilities'),
       whenCapabilitiesReady,
diff -r -u --color up/chromium/chrome/test/data/webui/print_preview/invalid_settings_browsertest.ts nw/chromium/chrome/test/data/webui/print_preview/invalid_settings_browsertest.ts
--- up/chromium/chrome/test/data/webui/print_preview/invalid_settings_browsertest.ts	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/test/data/webui/print_preview/invalid_settings_browsertest.ts	2023-01-28 02:49:25.251586333 +0000
@@ -30,6 +30,7 @@
   let nativeLayer: NativeLayerStub;
 
   const initialSettings: NativeInitialSettings = {
+    nwPrintMode: false,
     isInKioskAutoPrintMode: false,
     isInAppKioskMode: false,
     thousandsDelimiter: ',',
diff -r -u --color up/chromium/chrome/test/data/webui/print_preview/print_preview_app_test.ts nw/chromium/chrome/test/data/webui/print_preview/print_preview_app_test.ts
--- up/chromium/chrome/test/data/webui/print_preview/print_preview_app_test.ts	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/test/data/webui/print_preview/print_preview_app_test.ts	2023-01-28 02:49:25.255586375 +0000
@@ -37,6 +37,7 @@
   let pluginProxy: TestPluginProxy;
 
   const initialSettings: NativeInitialSettings = {
+    nwPrintMode: false,
     isInKioskAutoPrintMode: false,
     isInAppKioskMode: false,
     thousandsDelimiter: ',',
diff -r -u --color up/chromium/chrome/test/data/webui/print_preview/print_preview_test_utils.ts nw/chromium/chrome/test/data/webui/print_preview/print_preview_test_utils.ts
--- up/chromium/chrome/test/data/webui/print_preview/print_preview_test_utils.ts	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/test/data/webui/print_preview/print_preview_test_utils.ts	2023-01-28 02:49:25.255586375 +0000
@@ -15,6 +15,7 @@
     NativeInitialSettings {
   return {
     isInKioskAutoPrintMode: false,
+    nwPrintMode: false,
     isInAppKioskMode: false,
     pdfPrinterDisabled: false,
     thousandsDelimiter: ',',
diff -r -u --color up/chromium/chrome/test/include_js_tests.gni nw/chromium/chrome/test/include_js_tests.gni
--- up/chromium/chrome/test/include_js_tests.gni	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/test/include_js_tests.gni	2023-01-28 02:49:25.331587179 +0000
@@ -2,6 +2,6 @@
 
 if (!is_android) {
   # js_tests don't work in cross builds, https://crbug.com/1010561
-  include_js_tests =
-      !(is_asan || is_msan || is_tsan || is_cfi || (is_win && host_os != "win"))
+  include_js_tests = false
+  #    !(is_asan || is_msan || is_tsan || is_cfi || (is_win && host_os != "win"))
 }
diff -r -u --color up/chromium/chrome/utility/BUILD.gn nw/chromium/chrome/utility/BUILD.gn
--- up/chromium/chrome/utility/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/utility/BUILD.gn	2023-01-28 02:49:25.383587728 +0000
@@ -46,7 +46,7 @@
     "//components/password_manager/services/csv_password:lib",
     "//components/safe_browsing:buildflags",
     "//components/search_engines",
-    "//components/services/language_detection",
+    #"//components/services/language_detection",
     "//components/services/paint_preview_compositor",
     "//components/services/patch:lib",
     "//components/services/screen_ai/buildflags",
@@ -245,7 +245,7 @@
 
   if (safe_browsing_mode == 1) {
     deps += [ "//chrome/services/file_util" ]
-    if (is_mac) {
+    if (false && is_mac) {
       deps += [ "//chrome/utility/safe_browsing/mac" ]
     }
   }
diff -r -u --color up/chromium/chrome/utility/chrome_content_utility_client.cc nw/chromium/chrome/utility/chrome_content_utility_client.cc
--- up/chromium/chrome/utility/chrome_content_utility_client.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/utility/chrome_content_utility_client.cc	2023-01-28 02:49:25.383587728 +0000
@@ -25,6 +25,10 @@
 #include "sandbox/policy/mojom/sandbox.mojom.h"
 #include "sandbox/policy/sandbox_type.h"
 
+#if defined(OS_WIN)
+#pragma warning(disable:4065)
+#endif
+
 namespace {
 
 base::LazyInstance<ChromeContentUtilityClient::NetworkBinderCreationCallback>::
diff -r -u --color up/chromium/chrome/utility/services.cc nw/chromium/chrome/utility/services.cc
--- up/chromium/chrome/utility/services.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/chrome/utility/services.cc	2023-01-28 02:49:25.387587770 +0000
@@ -153,12 +153,14 @@
   return std::make_unique<unzip::UnzipperImpl>(std::move(receiver));
 }
 
+#if 0
 auto RunLanguageDetectionService(
     mojo::PendingReceiver<language_detection::mojom::LanguageDetectionService>
         receiver) {
   return std::make_unique<language_detection::LanguageDetectionServiceImpl>(
       std::move(receiver));
 }
+#endif
 
 auto RunQRCodeGeneratorService(
     mojo::PendingReceiver<qrcode_generator::mojom::QRCodeGeneratorService>
@@ -439,7 +441,7 @@
 void RegisterMainThreadServices(mojo::ServiceFactory& services) {
   services.Add(RunFilePatcher);
   services.Add(RunUnzipper);
-  services.Add(RunLanguageDetectionService);
+  //services.Add(RunLanguageDetectionService);
   services.Add(RunQRCodeGeneratorService);
   services.Add(RunWebAppOriginAssociationParser);
 
diff -r -u --color up/chromium/components/about_ui/resources/about_credits.css nw/chromium/components/about_ui/resources/about_credits.css
--- up/chromium/components/about_ui/resources/about_credits.css	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/about_ui/resources/about_credits.css	2023-01-28 02:49:25.747591576 +0000
@@ -77,7 +77,6 @@
 .licence {
   border-radius: 3px;
   clear: both;
-  display: none;
   padding: 16px;
 }
 .licence h3 {
diff -r -u --color up/chromium/components/autofill/core/browser/data_model/phone_number.cc nw/chromium/components/autofill/core/browser/data_model/phone_number.cc
--- up/chromium/components/autofill/core/browser/data_model/phone_number.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/autofill/core/browser/data_model/phone_number.cc	2023-01-28 02:49:25.791592041 +0000
@@ -5,6 +5,7 @@
 #include "components/autofill/core/browser/data_model/phone_number.h"
 
 #include <algorithm>
+#include <cctype>
 
 #include "base/check_op.h"
 #include "base/notreached.h"
diff -r -u --color up/chromium/components/component_updater/component_updater_service.h nw/chromium/components/component_updater/component_updater_service.h
--- up/chromium/components/component_updater/component_updater_service.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/component_updater/component_updater_service.h	2023-01-28 02:49:26.063594916 +0000
@@ -24,6 +24,10 @@
 class ComponentsHandler;
 class PluginObserver;
 
+namespace extensions {
+class NwAppUpdateComponentFunction;
+}
+
 namespace policy {
 class ComponentUpdaterPolicyTest;
 }
@@ -199,6 +203,7 @@
   virtual ~OnDemandUpdater() = default;
 
  private:
+  friend class extensions::NwAppUpdateComponentFunction;
   friend class OnDemandTester;
   friend class policy::ComponentUpdaterPolicyTest;
   friend class ::ComponentsHandler;
diff -r -u --color up/chromium/components/content_settings/core/browser/content_settings_registry.cc nw/chromium/components/content_settings/core/browser/content_settings_registry.cc
--- up/chromium/components/content_settings/core/browser/content_settings_registry.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/content_settings/core/browser/content_settings_registry.cc	2023-01-28 02:49:26.079595085 +0000
@@ -150,7 +150,7 @@
            ContentSettingsInfo::EXCEPTIONS_ON_SECURE_ORIGINS_ONLY);
 
   Register(ContentSettingsType::NOTIFICATIONS, "notifications",
-           CONTENT_SETTING_ASK, WebsiteSettingsInfo::UNSYNCABLE,
+           CONTENT_SETTING_ALLOW, WebsiteSettingsInfo::UNSYNCABLE,
            /*allowlisted_schemes=*/{},
            /*valid_settings=*/
            {CONTENT_SETTING_ALLOW, CONTENT_SETTING_BLOCK, CONTENT_SETTING_ASK},
diff -r -u --color up/chromium/components/cookie_config/cookie_store_util.cc nw/chromium/components/cookie_config/cookie_store_util.cc
--- up/chromium/components/cookie_config/cookie_store_util.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/cookie_config/cookie_store_util.cc	2023-01-28 02:49:26.083595127 +0000
@@ -15,6 +15,8 @@
     BUILDFLAG(IS_CHROMEOS)
 namespace {
 
+bool g_should_encrypt = true;
+
 // Use the operating system's mechanisms to encrypt cookies before writing
 // them to persistent store.  Currently this only is done with desktop OS's
 // because ChromeOS and Android already protect the entire profile contents.
@@ -40,7 +42,7 @@
   // rewritten.
   return false;
 #else
-  return true;
+  return g_should_encrypt;
 #endif
 }
 
@@ -66,6 +68,11 @@
 }
 #else   // BUILDFLAG(IS_WIN) || BUILDFLAG(IS_APPLE) || BUILDFLAG(IS_LINUX) ||
         // BUILDFLAG(IS_CHROMEOS)
+
+void SetEnableCookieCrypto(bool enable) {
+  g_should_encrypt = enable;
+}
+
 net::CookieCryptoDelegate* GetCookieCryptoDelegate() {
   return NULL;
 }
diff -r -u --color up/chromium/components/cookie_config/cookie_store_util.h nw/chromium/components/cookie_config/cookie_store_util.h
--- up/chromium/components/cookie_config/cookie_store_util.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/cookie_config/cookie_store_util.h	2023-01-28 02:49:26.083595127 +0000
@@ -15,7 +15,7 @@
 // this platform. The object returned is a LazyInstance. Ownership is not
 // transferred.
 net::CookieCryptoDelegate* GetCookieCryptoDelegate();
-
+void SetEnableCookieCrypto(bool enable);
 }  // namespace cookie_config
 
 #endif  // COMPONENTS_COOKIE_CONFIG_COOKIE_STORE_UTIL_H_
diff -r -u --color up/chromium/components/crash/core/app/breakpad_linux.cc nw/chromium/components/crash/core/app/breakpad_linux.cc
--- up/chromium/components/crash/core/app/breakpad_linux.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/crash/core/app/breakpad_linux.cc	2023-01-28 02:49:26.091595212 +0000
@@ -832,7 +832,6 @@
     minidump_descriptor.set_size_limit(kMaxMinidumpFileSize);
   }
 #if BUILDFLAG(IS_ANDROID)
-  unattended = true;  // Android never uploads directly.
   SetMinidumpSanitizationFields(&minidump_descriptor, sanitization_info);
 #endif
   if (unattended) {
@@ -1392,17 +1391,33 @@
       StringFromPrefixAndUint("/dev/fd/", upload_status_fd, allocator);
 
   static const char kWgetBinary[] = "/usr/bin/wget";
+  char* const upload_url = reinterpret_cast<char*>(allocator->Alloc(1024));
+  *upload_url='\0';
+  int i = 1;
+  do {
+    char key_name[17];
+    my_strlcpy(key_name, "url-nwjs__", sizeof(key_name));
+    my_uitos(key_name + 10, i, my_uint_len(i));
+    key_name[10 + my_uint_len(i)] = '\0';
+    const char* chunk = crash_reporter::internal::GetCrashKeyStorage()->GetValueForKey(key_name);
+    if (!chunk)
+      break;
+    my_strlcat(upload_url, chunk, 1024);
+    i++;
+  } while(true);
+  //WriteLog("UPLOAD_URL", 10);
+  //WriteLog(upload_url, my_strlen(upload_url));
   const char* args[] = {
-      kWgetBinary,
-      header_content_encoding,
-      header_content_type,
-      post_file,
-      g_upload_url,
-      "--timeout=10",  // Set a timeout so we don't hang forever.
-      "--tries=1",     // Don't retry if the upload fails.
-      "-O",            // Output reply to the file descriptor path.
-      status_fd_path,
-      nullptr,
+    kWgetBinary,
+    header_content_encoding,
+    header_content_type,
+    post_file,
+    upload_url,
+    "--timeout=10",  // Set a timeout so we don't hang forever.
+    "--tries=1",     // Don't retry if the upload fails.
+    "-O",  // Output reply to the file descriptor path.
+    status_fd_path,
+    nullptr,
   };
   static const char msg[] = "Cannot upload crash dump: cannot exec "
                             "/usr/bin/wget\n";
diff -r -u --color up/chromium/components/crash/core/app/crash_reporter_client.cc nw/chromium/components/crash/core/app/crash_reporter_client.cc
--- up/chromium/components/crash/core/app/crash_reporter_client.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/crash/core/app/crash_reporter_client.cc	2023-01-28 02:49:26.091595212 +0000
@@ -46,6 +46,10 @@
     const std::string& client_guid) {}
 #endif
 
+void CrashReporterClient::SetUploadDump(bool upload) {
+  enable_upload_ = upload;
+}
+
 #if BUILDFLAG(IS_WIN)
 bool CrashReporterClient::ShouldCreatePipeName(
     const std::wstring& process_type) {
@@ -93,7 +97,7 @@
 }
 #endif
 
-#if BUILDFLAG(IS_POSIX) && !BUILDFLAG(IS_MAC)
+#if BUILDFLAG(IS_POSIX)
 void CrashReporterClient::GetProductNameAndVersion(const char** product_name,
                                                    const char** version) {
 }
diff -r -u --color up/chromium/components/crash/core/app/crash_reporter_client.h nw/chromium/components/crash/core/app/crash_reporter_client.h
--- up/chromium/components/crash/core/app/crash_reporter_client.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/crash/core/app/crash_reporter_client.h	2023-01-28 02:49:26.091595212 +0000
@@ -24,7 +24,7 @@
 // runtime.
 void SetCrashReporterClient(CrashReporterClient* client);
 
-#if defined(CRASH_IMPLEMENTATION)
+#if 1
 // The components's embedder API should only be used by the component.
 CrashReporterClient* GetCrashReporterClient();
 #endif
@@ -46,6 +46,7 @@
   virtual void SetCrashReporterClientIdFromGUID(const std::string& client_guid);
 #endif
 
+  virtual void SetUploadDump(bool);
 #if BUILDFLAG(IS_WIN)
   // Returns true if the pipe name to connect to breakpad should be computed and
   // stored in the process's environment block. By default, returns true for the
@@ -94,7 +95,7 @@
   virtual bool GetShouldDumpLargerDumps();
 #endif
 
-#if BUILDFLAG(IS_POSIX) && !BUILDFLAG(IS_MAC)
+#if BUILDFLAG(IS_POSIX)
   // Returns a textual description of the product type and version to include
   // in the crash report. Neither out parameter should be set to NULL.
   // TODO(jperaza): Remove the 2-parameter overload of this method once all
@@ -211,6 +212,10 @@
 
   // Returns true if breakpad should run in the given process type.
   virtual bool EnableBreakpadForProcess(const std::string& process_type);
+
+  bool enable_upload_;
+  std::string product_name_;
+  std::string product_version_;
 };
 
 }  // namespace crash_reporter
diff -r -u --color up/chromium/components/crash/core/app/crashpad_mac.mm nw/chromium/components/crash/core/app/crashpad_mac.mm
--- up/chromium/components/crash/core/app/crashpad_mac.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/crash/core/app/crashpad_mac.mm	2023-01-28 02:49:26.091595212 +0000
@@ -148,11 +148,20 @@
 
       // Is there a way to recover if this fails?
       CrashReporterClient* crash_reporter_client = GetCrashReporterClient();
+      const char* product_name = "";
+      const char* version = "";
+
+      crash_reporter_client->GetProductNameAndVersion(&product_name, &version);
       crash_reporter_client->GetCrashDumpLocation(database_path);
       crash_reporter_client->GetCrashMetricsLocation(&metrics_path);
 
       std::string url = crash_reporter_client->GetUploadUrl();
 
+      std::map<std::string, std::string> process_annotations;
+      process_annotations["prod"] = product_name;
+      process_annotations["ver"] = version;
+      process_annotations["plat"] = std::string("OS X");
+
       std::vector<std::string> arguments;
 
       if (crash_reporter_client->ShouldMonitorCrashHandlerExpensively()) {
@@ -173,9 +182,10 @@
             "--reset-own-crash-exception-port-to-system-default");
       }
 
+      
       bool result = GetCrashpadClient().StartHandler(
           handler_path, *database_path, metrics_path, url,
-          GetProcessSimpleAnnotations(), arguments, true, false);
+          process_annotations, arguments, true, false);
 
       // If this is an initial client that's not the browser process, it's
       // important to sever the connection to any existing handler. If
diff -r -u --color up/chromium/components/crx_file/id_util.cc nw/chromium/components/crx_file/id_util.cc
--- up/chromium/components/crx_file/id_util.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/crx_file/id_util.cc	2023-01-28 02:49:26.119595508 +0000
@@ -87,6 +87,7 @@
 }
 
 bool IdIsValid(base::StringPiece id) {
+#if 0
   // Verify that the id is legal.
   if (id.size() != (crx_file::id_util::kIdSize * 2))
     return false;
@@ -97,6 +98,7 @@
       return false;
   }
 
+#endif
   return true;
 }
 
diff -r -u --color up/chromium/components/embedder_support/user_agent_utils.cc nw/chromium/components/embedder_support/user_agent_utils.cc
--- up/chromium/components/embedder_support/user_agent_utils.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/embedder_support/user_agent_utils.cc	2023-01-28 02:49:26.179596142 +0000
@@ -4,6 +4,8 @@
 
 #include "components/embedder_support/user_agent_utils.h"
 
+#include "content/nw/src/common/nw_content_common_hooks.h"
+
 #include "base/command_line.h"
 #include "base/debug/stack_trace.h"
 #include "base/feature_list.h"
@@ -419,6 +421,11 @@
     LOG(WARNING) << "Ignored invalid value for flag --" << kUserAgent;
   }
 
+  std::string user_agent;
+  if (nw::GetUserAgentFromManifest(&user_agent)) {
+    return user_agent;
+  }
+
   if (base::FeatureList::IsEnabled(blink::features::kFullUserAgent))
     return GetFullUserAgent(force_major_to_minor);
 
diff -r -u --color up/chromium/components/favicon/core/favicon_driver_impl.cc nw/chromium/components/favicon/core/favicon_driver_impl.cc
--- up/chromium/components/favicon/core/favicon_driver_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/favicon/core/favicon_driver_impl.cc	2023-01-28 02:49:26.243596818 +0000
@@ -33,7 +33,7 @@
         favicon_service_, this, FaviconDriverObserver::TOUCH_LARGEST));
   } else {
     handlers_.push_back(std::make_unique<FaviconHandler>(
-        favicon_service_, this, FaviconDriverObserver::NON_TOUCH_16_DIP));
+        favicon_service_, this, FaviconDriverObserver::NON_TOUCH_LARGEST));
   }
 }
 
diff -r -u --color up/chromium/components/gcm_driver/gcm_driver_desktop.cc nw/chromium/components/gcm_driver/gcm_driver_desktop.cc
--- up/chromium/components/gcm_driver/gcm_driver_desktop.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/gcm_driver/gcm_driver_desktop.cc	2023-01-28 02:49:26.283597241 +0000
@@ -30,6 +30,8 @@
 #include "net/base/ip_endpoint.h"
 #include "services/network/public/cpp/shared_url_loader_factory.h"
 
+#include "content/nw/src/nw_base.h"
+
 namespace gcm {
 
 class GCMDriverDesktop::IOWorker : public GCMClient::Delegate {
@@ -1170,6 +1172,9 @@
   if (gcm_started_)
     return GCMClient::SUCCESS;
 
+  if (!nw::gcm_enabled())
+    return GCMClient::GCM_DISABLED;
+
   // Have any app requested the service?
   if (app_handlers().empty())
     return GCMClient::UNKNOWN_ERROR;
diff -r -u --color up/chromium/components/gcm_driver/gcm_internals_helper.cc nw/chromium/components/gcm_driver/gcm_internals_helper.cc
--- up/chromium/components/gcm_driver/gcm_internals_helper.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/gcm_driver/gcm_internals_helper.cc	2023-01-28 02:49:26.283597241 +0000
@@ -4,6 +4,7 @@
 
 #include "components/gcm_driver/gcm_internals_helper.h"
 
+#include "content/nw/src/nw_base.h"
 #include <memory>
 #include <utility>
 
@@ -121,7 +122,7 @@
 
     base::Value::Dict device_info;
     device_info.Set(kProfileServiceCreated, profile_service != nullptr);
-    device_info.Set(kGcmEnabled, true);
+    device_info.Set(kGcmEnabled, nw::gcm_enabled());
     device_info.Set(kGcmClientCreated, stats->gcm_client_created);
     device_info.Set(kGcmClientState, stats->gcm_client_state);
     device_info.Set(kConnectionClientCreated, stats->connection_client_created);
diff -r -u --color up/chromium/components/gcm_driver/instance_id/instance_id_driver.cc nw/chromium/components/gcm_driver/instance_id/instance_id_driver.cc
--- up/chromium/components/gcm_driver/instance_id/instance_id_driver.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/gcm_driver/instance_id/instance_id_driver.cc	2023-01-28 02:49:26.283597241 +0000
@@ -4,12 +4,27 @@
 
 #include "components/gcm_driver/instance_id/instance_id_driver.h"
 
+#include "base/metrics/field_trial.h"
+#include "base/strings/string_util.h"
 #include "build/build_config.h"
 #include "components/gcm_driver/gcm_driver.h"
 #include "components/gcm_driver/instance_id/instance_id.h"
 
 namespace instance_id {
 
+namespace {
+const char kInstanceIDFieldTrialName[] = "InstanceID";
+const char kInstanceIDFieldTrialDisabledGroupPrefix[] = "Disabled";
+}  // namespace
+
+// static
+bool InstanceIDDriver::IsInstanceIDEnabled() {
+  std::string group_name =
+      base::FieldTrialList::FindFullName(kInstanceIDFieldTrialName);
+  return !base::StartsWith(group_name, kInstanceIDFieldTrialDisabledGroupPrefix,
+                           base::CompareCase::INSENSITIVE_ASCII);
+}
+
 InstanceIDDriver::InstanceIDDriver(gcm::GCMDriver* gcm_driver)
     : gcm_driver_(gcm_driver) {
 }
diff -r -u --color up/chromium/components/gcm_driver/instance_id/instance_id_driver.h nw/chromium/components/gcm_driver/instance_id/instance_id_driver.h
--- up/chromium/components/gcm_driver/instance_id/instance_id_driver.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/gcm_driver/instance_id/instance_id_driver.h	2023-01-28 02:49:26.283597241 +0000
@@ -25,6 +25,9 @@
 // Create instances of this class with |InstanceIDProfileServiceFactory|.
 class InstanceIDDriver {
  public:
+  // Returns whether InstanceID is enabled.
+  static bool IsInstanceIDEnabled();
+
   explicit InstanceIDDriver(gcm::GCMDriver* gcm_driver);
 
   InstanceIDDriver(const InstanceIDDriver&) = delete;
diff -r -u --color up/chromium/components/gcm_driver/instance_id/instance_id_profile_service.cc nw/chromium/components/gcm_driver/instance_id/instance_id_profile_service.cc
--- up/chromium/components/gcm_driver/instance_id/instance_id_profile_service.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/gcm_driver/instance_id/instance_id_profile_service.cc	2023-01-28 02:49:26.283597241 +0000
@@ -6,12 +6,18 @@
 
 #include "base/check.h"
 #include "base/memory/ptr_util.h"
+#include "content/nw/src/nw_base.h"
 #include "components/gcm_driver/gcm_driver.h"
 #include "components/gcm_driver/gcm_profile_service.h"
 #include "components/gcm_driver/instance_id/instance_id_driver.h"
 
 namespace instance_id {
 
+// static
+bool InstanceIDProfileService::IsInstanceIDEnabled() {
+  return nw::gcm_enabled() && InstanceIDDriver::IsInstanceIDEnabled();
+}
+
 InstanceIDProfileService::InstanceIDProfileService(gcm::GCMDriver* driver,
                                                    bool is_off_the_record) {
   DCHECK(!is_off_the_record);
diff -r -u --color up/chromium/components/gcm_driver/instance_id/instance_id_profile_service.h nw/chromium/components/gcm_driver/instance_id/instance_id_profile_service.h
--- up/chromium/components/gcm_driver/instance_id/instance_id_profile_service.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/gcm_driver/instance_id/instance_id_profile_service.h	2023-01-28 02:49:26.283597241 +0000
@@ -20,6 +20,9 @@
 // Providing Instance ID support, via InstanceIDDriver, to a profile.
 class InstanceIDProfileService : public KeyedService {
  public:
+  // Returns whether InstanceID is enabled for |profile|.
+  static bool IsInstanceIDEnabled();
+
   InstanceIDProfileService(gcm::GCMDriver* driver, bool is_off_the_record);
 
   InstanceIDProfileService(const InstanceIDProfileService&) = delete;
diff -r -u --color up/chromium/components/guest_view/browser/guest_view_manager.cc nw/chromium/components/guest_view/browser/guest_view_manager.cc
--- up/chromium/components/guest_view/browser/guest_view_manager.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/guest_view/browser/guest_view_manager.cc	2023-01-28 02:49:26.291597326 +0000
@@ -513,10 +513,9 @@
 
   // The embedder is trying to access a guest with a negative or zero
   // instance ID.
-  if (guest_instance_id <= kInstanceIDNone) {
-    bad_access_key.Set("Nonpositive");
-    return false;
-  }
+  if (guest_instance_id <= kInstanceIDNone)
+    return true; // the 'alert' case will fail when keeps clicking
+                 // 'detach' otherwise
 
   // The embedder is trying to access an instance ID that has not yet been
   // allocated by GuestViewManager. This could cause instance ID
@@ -541,6 +540,7 @@
 
   // MimeHandlerViewGuests (PDF) may be embedded in a cross-process frame.
   // Other than MimeHandlerViewGuest, all other guest types are only permitted
+#if 0
   // to run in the main frame or its local subframes.
   const int allowed_embedder_render_process_id =
       guest_view->CanBeEmbeddedInsideCrossProcessFrames()
@@ -554,7 +554,7 @@
     bad_access_key.Set("Bad embedder process");
     return false;
   }
-
+#endif
   return true;
 }
 
diff -r -u --color up/chromium/components/guest_view/browser/guest_view_manager.h nw/chromium/components/guest_view/browser/guest_view_manager.h
--- up/chromium/components/guest_view/browser/guest_view_manager.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/guest_view/browser/guest_view_manager.h	2023-01-28 02:49:26.291597326 +0000
@@ -207,9 +207,12 @@
                                      content::WebContents* guest_web_contents);
 
   // Contains guests' WebContents, mapping from their instance ids.
+ public:
   using GuestInstanceMap = std::map<int, content::WebContents*>;
+  const GuestInstanceMap& guest_web_contents_by_instance_id() { return guest_web_contents_by_instance_id_; }
+ protected:
   GuestInstanceMap guest_web_contents_by_instance_id_;
-
+  
   struct ElementInstanceKey {
     int embedder_process_id;
     int element_instance_id;
diff -r -u --color up/chromium/components/javascript_dialogs/app_modal_dialog_manager.cc nw/chromium/components/javascript_dialogs/app_modal_dialog_manager.cc
--- up/chromium/components/javascript_dialogs/app_modal_dialog_manager.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/javascript_dialogs/app_modal_dialog_manager.cc	2023-01-28 02:49:26.331597748 +0000
@@ -77,6 +77,8 @@
 std::u16string AppModalDialogManager::GetTitle(
     content::WebContents* web_contents,
     const url::Origin& alerting_frame_origin) {
+  return std::u16string();
+#if 0
   // For extensions, show the extension name, but only if the origin of
   // the alert matches the top-level WebContents.
   std::string name;
@@ -142,6 +144,7 @@
       is_same_origin_as_main_frame
           ? IDS_JAVASCRIPT_MESSAGEBOX_TITLE_NONSTANDARD_URL
           : IDS_JAVASCRIPT_MESSAGEBOX_TITLE_NONSTANDARD_URL_IFRAME);
+#endif
 }
 
 void AppModalDialogManager::RunJavaScriptDialog(
@@ -170,7 +173,7 @@
   AppModalDialogQueue::GetInstance()->AddDialog(new AppModalDialogController(
       web_contents, &javascript_dialog_extra_data_, dialog_title, dialog_type,
       message_text, default_prompt_text,
-      ShouldDisplaySuppressCheckbox(extra_data),
+      false, //ShouldDisplaySuppressCheckbox(extra_data),
       false,  // is_before_unload_dialog
       false,  // is_reload
       base::BindOnce(&AppModalDialogManager::OnDialogClosed,
diff -r -u --color up/chromium/components/keep_alive_registry/keep_alive_registry.cc nw/chromium/components/keep_alive_registry/keep_alive_registry.cc
--- up/chromium/components/keep_alive_registry/keep_alive_registry.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/keep_alive_registry/keep_alive_registry.cc	2023-01-28 02:49:26.335597791 +0000
@@ -118,7 +118,8 @@
 
 void KeepAliveRegistry::Register(KeepAliveOrigin origin,
                                  KeepAliveRestartOption restart) {
-  CHECK(!is_shutting_down_);
+  //nw1 crash when quit from dock
+//  CHECK(!is_shutting_down_);
 
   bool old_keeping_alive = IsKeepingAlive();
   bool old_restart_allowed = IsRestartAllowed();
diff -r -u --color up/chromium/components/keep_alive_registry/keep_alive_registry.h nw/chromium/components/keep_alive_registry/keep_alive_registry.h
--- up/chromium/components/keep_alive_registry/keep_alive_registry.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/keep_alive_registry/keep_alive_registry.h	2023-01-28 02:49:26.335597791 +0000
@@ -76,10 +76,12 @@
   KeepAliveRegistry();
   ~KeepAliveRegistry();
 
+ public:
   // Add/Remove entries. Do not use directly, use ScopedKeepAlive instead.
   void Register(KeepAliveOrigin origin, KeepAliveRestartOption restart);
   void Unregister(KeepAliveOrigin origin, KeepAliveRestartOption restart);
 
+ private:
   // Methods called when a specific aspect of the state of the registry changes.
   void OnKeepAliveStateChanged(bool new_keeping_alive);
   void OnRestartAllowedChanged(bool new_restart_allowed);
diff -r -u --color up/chromium/components/media_router/browser/presentation/presentation_service_delegate_impl.cc nw/chromium/components/media_router/browser/presentation/presentation_service_delegate_impl.cc
--- up/chromium/components/media_router/browser/presentation/presentation_service_delegate_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/media_router/browser/presentation/presentation_service_delegate_impl.cc	2023-01-28 02:49:26.363598087 +0000
@@ -468,7 +468,9 @@
     const content::PresentationRequest& request,
     content::PresentationConnectionCallback success_cb,
     content::PresentationConnectionErrorCallback error_cb) {
+#if defined(NWJS_SDK)
   const auto& render_frame_host_id = request.render_frame_host_id;
+#endif
   const auto& presentation_urls = request.presentation_urls;
   if (presentation_urls.empty()) {
     std::move(error_cb).Run(PresentationError(
@@ -481,6 +483,8 @@
                           "Invalid presentation URL."));
     return;
   }
+
+#if defined(NWJS_SDK)
   auto presentation_context = std::make_unique<StartPresentationContext>(
       request,
       base::BindOnce(
@@ -496,6 +500,7 @@
       MediaRouterDialogController::GetOrCreateForWebContents(&GetWebContents());
   controller->ShowMediaRouterDialogForPresentation(
       std::move(presentation_context));
+#endif
 }
 
 void PresentationServiceDelegateImpl::ReconnectPresentation(
diff -r -u --color up/chromium/components/metrics/metrics_service.cc nw/chromium/components/metrics/metrics_service.cc
--- up/chromium/components/metrics/metrics_service.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/metrics/metrics_service.cc	2023-01-28 02:49:26.387598340 +0000
@@ -260,7 +260,7 @@
       client_(client),
       local_state_(local_state),
       recording_state_(UNSET),
-      test_mode_active_(false),
+      test_mode_active_(true),
       state_(CONSTRUCTED),
       idle_since_last_transmission_(false),
       session_id_(-1) {
@@ -309,9 +309,9 @@
 }
 
 void MetricsService::Start() {
-  HandleIdleSinceLastTransmission(false);
+  test_mode_active_ = true;
   EnableRecording();
-  EnableReporting();
+  DisableReporting();
 }
 
 void MetricsService::StartRecordingForTests() {
diff -r -u --color up/chromium/components/metrics/metrics_state_manager.cc nw/chromium/components/metrics/metrics_state_manager.cc
--- up/chromium/components/metrics/metrics_state_manager.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/metrics/metrics_state_manager.cc	2023-01-28 02:49:26.387598340 +0000
@@ -411,6 +411,7 @@
   // so the command-line checks wouldn't be needed here.
   // Currently, kForceEnableMetricsReporting is used by Java UkmTest and
   // kMetricsRecordingOnly is used by Chromedriver tests.
+#if 0
   DCHECK(enabled_state_provider_->IsConsentGiven() ||
          IsMetricsReportingForceEnabled() || IsMetricsRecordingOnlyEnabled());
   if (!external_client_id_.empty()) {
@@ -423,6 +424,7 @@
 #if BUILDFLAG(IS_CHROMEOS_ASH)
   std::string previous_client_id = client_id_;
 #endif  // BUILDFLAG(IS_CHROMEOS_ASH)
+#endif
   {
     std::string client_id_from_prefs = ReadClientId(local_state_);
     // If client id in prefs matches the cached copy, return early.
diff -r -u --color up/chromium/components/metrics_services_manager/metrics_services_manager.cc nw/chromium/components/metrics_services_manager/metrics_services_manager.cc
--- up/chromium/components/metrics_services_manager/metrics_services_manager.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/metrics_services_manager/metrics_services_manager.cc	2023-01-28 02:49:26.395598425 +0000
@@ -1,6 +1,7 @@
 // Copyright 2014 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wunreachable-code"
 
 #include "components/metrics_services_manager/metrics_services_manager.h"
 
@@ -137,7 +138,7 @@
   DCHECK(thread_checker_.CalledOnValidThread());
   metrics::MetricsService* metrics = GetMetricsService();
 
-  if (metrics::IsMetricsRecordingOnlyEnabled()) {
+  if (true) { //metrics::IsMetricsRecordingOnlyEnabled()) {
     metrics->StartRecordingForTests();
     return;
   }
diff -r -u --color up/chromium/components/nacl/features.gni nw/chromium/components/nacl/features.gni
--- up/chromium/components/nacl/features.gni	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/nacl/features.gni	2023-01-28 02:49:26.407598552 +0000
@@ -24,10 +24,8 @@
   # Enables Native Client support.
   #
   # Intentionally and permanently disable nacl on arm64 mac.
-  enable_nacl =
-      checkout_nacl && _cpu_is_supported && target_os != "ios" && !is_android &&
-      !is_fuchsia && !is_castos && !(is_win && host_os != "win") &&
-      !(is_mac && (host_os != "mac" || target_cpu != "x64"))
+  enable_nacl = false
+
 }
 
 assert(!(is_win && host_os != "win") || !enable_nacl,
diff -r -u --color up/chromium/components/nacl/loader/BUILD.gn nw/chromium/components/nacl/loader/BUILD.gn
--- up/chromium/components/nacl/loader/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/nacl/loader/BUILD.gn	2023-01-28 02:49:26.407598552 +0000
@@ -152,6 +152,12 @@
     if (!export_libcxxabi_from_executables) {
       configs -= [ "//build/config/compiler:export_dynamic" ]
     }
+    if (is_linux) {
+      if (!is_component_build) {
+        # Set rpath to find our own libfreetype even in a non-component build.
+        configs += [ "//build/config/gcc:rpath_for_built_shared_libraries" ]
+      }
+    }
 
     data_deps =
         [ "//native_client/src/trusted/service_runtime/linux:bootstrap" ]
diff -r -u --color up/chromium/components/nacl/loader/nacl_helper_linux.cc nw/chromium/components/nacl/loader/nacl_helper_linux.cc
--- up/chromium/components/nacl/loader/nacl_helper_linux.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/nacl/loader/nacl_helper_linux.cc	2023-01-28 02:49:26.407598552 +0000
@@ -331,7 +331,7 @@
   }
   if (!have_to_reply)
     return false;
-  const std::vector<int> empty;  // We never send file descriptors back.
+  const std::vector<int> empty = std::vector<int>();  // We never send file descriptors back.
   if (!base::UnixDomainSocket::SendMsg(reply_fd, write_pickle.data(),
                                        write_pickle.size(), empty)) {
     LOG(ERROR) << "*** send() to zygote failed";
@@ -351,11 +351,13 @@
       &buf, sizeof(buf), &fds);
   // If the Zygote has started handling requests, we should be sandboxed via
   // the setuid sandbox.
+#if 0
   if (!nacl_sandbox->layer_one_enabled()) {
     LOG(ERROR) << "NaCl helper process running without a sandbox!\n"
       << "Most likely you need to configure your SUID sandbox "
       << "correctly";
   }
+#endif
   if (msglen == 0 || (msglen == -1 && errno == ECONNRESET)) {
     // EOF from the browser. Goodbye!
     _exit(0);
@@ -484,7 +486,7 @@
   nacl_sandbox->InitializeLayerOneSandbox();
   CHECK_EQ(is_init_process, nacl_sandbox->layer_one_enabled());
 
-  const std::vector<int> empty;
+  const std::vector<int> empty = std::vector<int>();
   // Send the zygote a message to let it know we are ready to help
   if (!base::UnixDomainSocket::SendMsg(kNaClZygoteDescriptor,
                                        kNaClHelperStartupAck,
diff -r -u --color up/chromium/components/nacl/loader/sandbox_linux/nacl_sandbox_linux.cc nw/chromium/components/nacl/loader/sandbox_linux/nacl_sandbox_linux.cc
--- up/chromium/components/nacl/loader/sandbox_linux/nacl_sandbox_linux.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/nacl/loader/sandbox_linux/nacl_sandbox_linux.cc	2023-01-28 02:49:26.411598594 +0000
@@ -183,7 +183,7 @@
   // have a single thread running here.
   DCHECK(!layer_one_sealed_);
   CHECK(IsSingleThreaded());
-  CheckForExpectedNumberOfOpenFds();
+  //CheckForExpectedNumberOfOpenFds();
 
   RestrictAddressSpaceUsage();
 
diff -r -u --color up/chromium/components/nacl/zygote/nacl_fork_delegate_linux.cc nw/chromium/components/nacl/zygote/nacl_fork_delegate_linux.cc
--- up/chromium/components/nacl/zygote/nacl_fork_delegate_linux.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/nacl/zygote/nacl_fork_delegate_linux.cc	2023-01-28 02:49:26.411598594 +0000
@@ -403,7 +403,7 @@
   write_pickle.WriteInt(pid);
   write_pickle.WriteBool(known_dead);
 
-  const std::vector<int> empty_fds;
+  const std::vector<int> empty_fds = std::vector<int>();
   char reply_buf[kNaClMaxIPCMessageLength];
   ssize_t reply_size = 0;
   bool got_reply =
diff -r -u --color up/chromium/components/network_time/network_time_tracker.cc nw/chromium/components/network_time/network_time_tracker.cc
--- up/chromium/components/network_time/network_time_tracker.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/network_time/network_time_tracker.cc	2023-01-28 02:49:26.419598679 +0000
@@ -66,7 +66,7 @@
 #else
 BASE_FEATURE(kNetworkTimeServiceQuerying,
              "NetworkTimeServiceQuerying",
-             base::FEATURE_ENABLED_BY_DEFAULT);
+             base::FEATURE_DISABLED_BY_DEFAULT);
 #endif
 
 namespace {
diff -r -u --color up/chromium/components/omnibox/browser/search_provider.cc nw/chromium/components/omnibox/browser/search_provider.cc
--- up/chromium/components/omnibox/browser/search_provider.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/omnibox/browser/search_provider.cc	2023-01-28 02:49:26.475599271 +0000
@@ -1,7 +1,7 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
-
+#pragma clang diagnostic ignored "-Wunreachable-code"
 #include "components/omnibox/browser/search_provider.h"
 
 #include <stddef.h>
@@ -931,7 +931,7 @@
 std::unique_ptr<network::SimpleURLLoader> SearchProvider::CreateSuggestLoader(
     const TemplateURL* template_url,
     const AutocompleteInput& input) {
-  if (!template_url || template_url->suggestions_url().empty())
+  if (true || !template_url || template_url->suggestions_url().empty())
     return nullptr;
 
   // Setting SuggestUrl the same as SearchUrl is a typical misconfiguration.
diff -r -u --color up/chromium/components/os_crypt/keychain_password_mac.mm nw/chromium/components/os_crypt/keychain_password_mac.mm
--- up/chromium/components/os_crypt/keychain_password_mac.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/os_crypt/keychain_password_mac.mm	2023-01-28 02:49:26.511599651 +0000
@@ -31,8 +31,8 @@
 const char kDefaultServiceName[] = "Chrome Safe Storage";
 const char kDefaultAccountName[] = "Chrome";
 #else
-const char kDefaultServiceName[] = "Chromium Safe Storage";
-const char kDefaultAccountName[] = "Chromium";
+const char kDefaultServiceName[] = "NWJS Safe Storage";
+const char kDefaultAccountName[] = "nwjs";
 #endif
 
 // Generates a random password and adds it to the Keychain.  The added password
diff -r -u --color up/chromium/components/os_crypt/os_crypt.h nw/chromium/components/os_crypt/os_crypt.h
--- up/chromium/components/os_crypt/os_crypt.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/os_crypt/os_crypt.h	2023-01-28 02:49:26.511599651 +0000
@@ -278,7 +278,7 @@
   // The cached AES encryption key.
   std::unique_ptr<crypto::SymmetricKey> cached_encryption_key_;
   // TODO(dhollowa): Refactor to allow dependency injection of Keychain.
-  bool use_mock_keychain_ = false;
+  bool use_mock_keychain_ = true;
   // This flag is used to make the GetEncryptionKey method return NULL if used
   // along with mock Keychain.
   bool use_locked_mock_keychain_ = false;
diff -r -u --color up/chromium/components/os_crypt/os_crypt_mac.mm nw/chromium/components/os_crypt/os_crypt_mac.mm
--- up/chromium/components/os_crypt/os_crypt_mac.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/os_crypt/os_crypt_mac.mm	2023-01-28 02:49:26.511599651 +0000
@@ -135,7 +135,7 @@
 
 void OSCryptImpl::SetRawEncryptionKey(const std::string& raw_key) {
   base::AutoLock auto_lock(OSCryptImpl::GetLock());
-  DCHECK(!cached_encryption_key_) << "Encryption key already set.";
+  //DCHECK(!cached_encryption_key_) << "Encryption key already set.";
   cached_encryption_key_ =
       crypto::SymmetricKey::Import(crypto::SymmetricKey::AES, raw_key);
   key_is_cached_ = true;
diff -r -u --color up/chromium/components/password_manager/core/browser/credential_manager_impl.cc nw/chromium/components/password_manager/core/browser/credential_manager_impl.cc
--- up/chromium/components/password_manager/core/browser/credential_manager_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/password_manager/core/browser/credential_manager_impl.cc	2023-01-28 02:49:26.543599989 +0000
@@ -241,7 +241,8 @@
   const PasswordForm& form = form_manager_->GetPendingCredentials();
   DCHECK(client_->IsSavingAndFillingEnabled(form.url));
 
-  if (form_manager_->IsPendingCredentialsPublicSuffixMatch()) {
+  if (form_manager_->IsPendingCredentialsPublicSuffixMatch() ||
+      form_manager_->IsPendingCredentialsOriginExtension()) {
     // Having a credential with a PSL match implies there is no credential with
     // an exactly matching origin and username. In order to avoid showing a save
     // bubble to the user Save() is called directly.
diff -r -u --color up/chromium/components/password_manager/core/browser/password_bubble_experiment.cc nw/chromium/components/password_manager/core/browser/password_bubble_experiment.cc
--- up/chromium/components/password_manager/core/browser/password_bubble_experiment.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/password_manager/core/browser/password_bubble_experiment.cc	2023-01-28 02:49:26.559600158 +0000
@@ -36,8 +36,11 @@
 }
 
 bool ShouldShowAutoSignInPromptFirstRunExperience(PrefService* prefs) {
+  return false; //NWJS#6809
+#if 0
   return !prefs->GetBoolean(
       password_manager::prefs::kWasAutoSignInFirstRunExperienceShown);
+#endif
 }
 
 void RecordAutoSignInPromptFirstRunExperienceWasShown(PrefService* prefs) {
diff -r -u --color up/chromium/components/password_manager/core/browser/password_form_manager.cc nw/chromium/components/password_manager/core/browser/password_form_manager.cc
--- up/chromium/components/password_manager/core/browser/password_form_manager.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/password_manager/core/browser/password_form_manager.cc	2023-01-28 02:49:26.559600158 +0000
@@ -271,6 +271,12 @@
   return metrics_recorder_.get();
 }
 
+bool PasswordFormManager::IsPendingCredentialsOriginExtension() const {
+  if (GetPendingCredentials().url.SchemeIs("chrome-extension"))
+    return true;
+  return false;
+}
+
 base::span<const InteractionsStats> PasswordFormManager::GetInteractionsStats()
     const {
   return base::make_span(form_fetcher_->GetInteractionsStats());
diff -r -u --color up/chromium/components/password_manager/core/browser/password_form_manager.h nw/chromium/components/password_manager/core/browser/password_form_manager.h
--- up/chromium/components/password_manager/core/browser/password_form_manager.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/password_manager/core/browser/password_form_manager.h	2023-01-28 02:49:26.559600158 +0000
@@ -174,6 +174,7 @@
   bool IsNewLogin() const;
   FormFetcher* GetFormFetcher();
   bool IsPendingCredentialsPublicSuffixMatch() const;
+  bool IsPendingCredentialsOriginExtension() const;
   void PresaveGeneratedPassword(const autofill::FormData& form_data,
                                 const std::u16string& generated_password);
   void PasswordNoLongerGenerated();
diff -r -u --color up/chromium/components/payments/content/payment_request.cc nw/chromium/components/payments/content/payment_request.cc
--- up/chromium/components/payments/content/payment_request.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/payments/content/payment_request.cc	2023-01-28 02:49:26.591600497 +0000
@@ -133,8 +133,9 @@
     return;
   }
 
-  bool allowed_origin =
+  bool allowed_origin = last_committed_url.SchemeIs("chrome-extension") ||
       UrlUtil::IsOriginAllowedToUseWebPaymentApis(last_committed_url);
+
   if (!allowed_origin) {
     reject_show_error_message_ = errors::kProhibitedOrigin;
   }
@@ -296,6 +297,7 @@
     return;
   }
 
+#if 0
   if (!delegate_->IsBrowserWindowActive()) {
     log_.Error(errors::kCannotShowInBackgroundTab);
     DCHECK(!has_recorded_completion_);
@@ -306,6 +308,7 @@
     ResetAndDeleteThis();
     return;
   }
+#endif
 
   if (wait_for_updated_details) {
     // Put |spec_| into uninitialized state, so the UI knows to show a spinner.
diff -r -u --color up/chromium/components/pdf/renderer/internal_plugin_renderer_helpers.cc nw/chromium/components/pdf/renderer/internal_plugin_renderer_helpers.cc
--- up/chromium/components/pdf/renderer/internal_plugin_renderer_helpers.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/pdf/renderer/internal_plugin_renderer_helpers.cc	2023-01-28 02:49:26.607600666 +0000
@@ -57,7 +57,7 @@
   }
 
   // Only create the in-process plugin within a PDF renderer.
-  CHECK(IsPdfRenderer());
+  //CHECK(IsPdfRenderer());
 
   // Origins allowed to embed the internal plugin are trusted (the PDF viewer
   // and Print Preview), and should never directly create the in-process plugin.
@@ -65,7 +65,7 @@
   //
   // See crbug.com/1259635 and crbug.com/1261758 for examples of previous bugs.
   CHECK(!delegate->IsAllowedOrigin(frame->GetSecurityOrigin()));
-  CHECK(parent_frame->IsWebRemoteFrame());
+  //CHECK(parent_frame->IsWebRemoteFrame());
 
   mojo::AssociatedRemote<pdf::mojom::PdfService> pdf_service;
   render_frame->GetRemoteAssociatedInterfaces()->GetInterface(
diff -r -u --color up/chromium/components/permissions/permission_context_base.cc nw/chromium/components/permissions/permission_context_base.cc
--- up/chromium/components/permissions/permission_context_base.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/permissions/permission_context_base.cc	2023-01-28 02:49:26.639601004 +0000
@@ -4,6 +4,9 @@
 
 #include "components/permissions/permission_context_base.h"
 
+#include "chrome/browser/chrome_content_browser_client.h"
+#include "extensions/browser/extension_registry.h"
+
 #include <stddef.h>
 
 #include <string>
@@ -151,6 +154,18 @@
   PermissionResult result =
       GetPermissionStatus(rfh, requesting_origin, embedding_origin);
 
+  content::WebContents* web_contents =
+    content::WebContents::FromRenderFrameHost(rfh);
+  extensions::ExtensionRegistry* extension_registry =
+    extensions::ExtensionRegistry::Get(web_contents->GetBrowserContext());
+  const extensions::Extension* extension =
+    extension_registry->enabled_extensions().GetByID(requesting_origin.host());
+  bool is_nw_origin = ChromeContentBrowserClient::IsNWURL(requesting_origin,
+                                                          web_contents->GetBrowserContext());
+  if (is_nw_origin || (extension && extension->is_nwjs_app())) {
+    result.content_setting = CONTENT_SETTING_ALLOW;
+  }
+
   if (result.content_setting == CONTENT_SETTING_ALLOW ||
       result.content_setting == CONTENT_SETTING_BLOCK) {
     switch (result.source) {
diff -r -u --color up/chromium/components/permissions/permission_manager.cc nw/chromium/components/permissions/permission_manager.cc
--- up/chromium/components/permissions/permission_manager.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/permissions/permission_manager.cc	2023-01-28 02:49:26.643601046 +0000
@@ -4,6 +4,8 @@
 
 #include "components/permissions/permission_manager.h"
 
+#include "extensions/browser/extension_registry.h"
+
 #include <memory>
 #include <utility>
 
diff -r -u --color up/chromium/components/remote_cocoa/app_shim/bridged_content_view.h nw/chromium/components/remote_cocoa/app_shim/bridged_content_view.h
--- up/chromium/components/remote_cocoa/app_shim/bridged_content_view.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/remote_cocoa/app_shim/bridged_content_view.h	2023-01-28 02:49:26.947604260 +0000
@@ -55,6 +55,9 @@
 @property(assign, nonatomic) BOOL drawMenuBackgroundForBlur;
 @property(assign, nonatomic) NSEvent* keyDownEventForTesting;
 
+// Used by g_force_cpu_draw
+@property(assign, nonatomic) CALayer* forceCPUDrawLayer;
+
 // Initialize the NSView -> views::View bridge. |viewToHost| must be non-NULL.
 - (instancetype)initWithBridge:(remote_cocoa::NativeWidgetNSWindowBridge*)bridge
                         bounds:(gfx::Rect)rect;
diff -r -u --color up/chromium/components/remote_cocoa/app_shim/bridged_content_view.mm nw/chromium/components/remote_cocoa/app_shim/bridged_content_view.mm
--- up/chromium/components/remote_cocoa/app_shim/bridged_content_view.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/remote_cocoa/app_shim/bridged_content_view.mm	2023-01-28 02:49:26.947604260 +0000
@@ -181,6 +181,7 @@
 @synthesize bridge = _bridge;
 @synthesize drawMenuBackgroundForBlur = _drawMenuBackgroundForBlur;
 @synthesize keyDownEventForTesting = _keyDownEvent;
+@synthesize forceCPUDrawLayer = forceCPUDrawLayer_;
 
 - (instancetype)initWithBridge:(remote_cocoa::NativeWidgetNSWindowBridge*)bridge
                         bounds:(gfx::Rect)bounds {
@@ -281,6 +282,17 @@
   return [super hitTest:point];
 }
 
+- (void)drawRect:(NSRect)dirty {
+  if (content::g_force_cpu_draw) {
+    CGContextRef ctx = (CGContextRef)[[NSGraphicsContext currentContext] graphicsPort];
+    CGContextClipToRect(ctx, NSRectToCGRect(dirty));
+    //get the flipped layer from forceCPUDrawLayer_ and do renderInContext
+    [forceCPUDrawLayer_ renderInContext:ctx];
+  } else {
+    [super drawRect:dirty];
+  }
+}
+
 - (void)processCapturedMouseEvent:(NSEvent*)theEvent {
   if (!_bridge)
     return;
diff -r -u --color up/chromium/components/remote_cocoa/app_shim/native_widget_ns_window_bridge.h nw/chromium/components/remote_cocoa/app_shim/native_widget_ns_window_bridge.h
--- up/chromium/components/remote_cocoa/app_shim/native_widget_ns_window_bridge.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/remote_cocoa/app_shim/native_widget_ns_window_bridge.h	2023-01-28 02:49:26.951604302 +0000
@@ -142,6 +142,8 @@
   // being reordered in (or out of) the screen list.
   void OnVisibilityChanged();
 
+  void OnWindowWillStartLiveResize();
+
   // Called by the NSWindowDelegate when the system control tint changes.
   void OnSystemControlTintChanged();
 
@@ -256,6 +258,12 @@
   void SetCanAppearInExistingFullscreenSpaces(
       bool can_appear_in_existing_fullscreen_spaces) override;
   void SetMiniaturized(bool miniaturized) override;
+  void SetMaximized(bool maximized) override;
+  bool IsMaximized(bool* maximized) override;
+  void IsMaximized(IsMaximizedCallback callback) override;
+  void GetRestoredBounds(GetRestoredBoundsCallback callback) override;
+  bool GetRestoredBounds(gfx::Rect* bounds) override;
+  void SetRestoredBounds(const gfx::Rect& bounds) override;
   void SetSizeConstraints(const gfx::Size& min_size,
                           const gfx::Size& max_size,
                           bool is_resizable,
@@ -383,6 +391,8 @@
   // (and its compositor).
   gfx::Size content_dip_size_;
 
+  NSRect bounds_before_maximize_;
+
   // The size of the frame most recently *received from* the compositor. Note
   // that during resize (and showing new windows), this will lag behind
   // |content_dip_size_|, which is the frame size most recently *sent to* the
diff -r -u --color up/chromium/components/remote_cocoa/app_shim/native_widget_ns_window_bridge.mm nw/chromium/components/remote_cocoa/app_shim/native_widget_ns_window_bridge.mm
--- up/chromium/components/remote_cocoa/app_shim/native_widget_ns_window_bridge.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/remote_cocoa/app_shim/native_widget_ns_window_bridge.mm	2023-01-28 02:49:26.951604302 +0000
@@ -56,6 +56,10 @@
 using remote_cocoa::mojom::VisibilityTransition;
 using remote_cocoa::mojom::WindowVisibilityState;
 
+namespace content {
+  extern bool g_force_cpu_draw;
+}
+
 namespace {
 constexpr auto kUIPaintTimeout = base::Seconds(5);
 
@@ -166,6 +170,17 @@
 
 using RankMap = std::map<NSView*, int>;
 
+bool NSWindowIsMaximized(NSWindow* window) {
+  // -[NSWindow isZoomed] only works if the zoom button is enabled.
+  if ([[window standardWindowButton:NSWindowZoomButton] isEnabled])
+    return [window isZoomed];
+
+  // We don't attempt to distinguish between a window that has been explicitly
+  // maximized versus one that has just been dragged by the user to fill the
+  // screen. This is the same behavior as -[NSWindow isZoomed] above.
+  return NSEqualRects([window frame], [[window screen] visibleFrame]);
+}
+
 // Return the content size for a minimum or maximum widget size.
 gfx::Size GetClientSizeForWindowSize(NSWindow* window,
                                      const gfx::Size& window_size) {
@@ -443,6 +458,12 @@
 
   [[NSNotificationCenter defaultCenter]
       addObserver:window_delegate_
+         selector:@selector(onWindowWillStartLiveResize:)
+             name:NSWindowWillStartLiveResizeNotification
+           object:nil];
+
+  [[NSNotificationCenter defaultCenter]
+      addObserver:window_delegate_
          selector:@selector(onSystemControlTintChanged:)
              name:NSControlTintDidChangeNotification
            object:nil];
@@ -502,8 +523,8 @@
 
   // A contentRect with zero width or height is a banned practice in ChromeMac,
   // due to unpredictable OSX treatment.
-  DCHECK(!clamped_content_size.IsEmpty())
-      << "Zero-sized windows not supported on Mac";
+  //DCHECK(!clamped_content_size.IsEmpty())
+  //    << "Zero-sized windows not supported on Mac";
 
   if (!window_visible_ && IsWindowModalSheet()) {
     // Window-Modal dialogs (i.e. sheets) are positioned by Cocoa when shown for
@@ -535,7 +556,7 @@
     const gfx::Size& content_size,
     const gfx::Size& minimum_content_size) {
   gfx::Rect new_window_bounds = gfx::ScreenRectFromNSRect([window_ frame]);
-  new_window_bounds.set_size(GetWindowSizeForClientSize(window_, content_size));
+  new_window_bounds.set_size(content_size); //GetWindowSizeForClientSize(window_, content_size));
   SetBounds(new_window_bounds, minimum_content_size);
 
   // Note that this is not the precise center of screen, but it is the standard
@@ -586,7 +607,16 @@
   [compositor_view setWantsLayer:YES];
   [bridged_view_ addSubview:compositor_view];
 
-  [bridged_view_ setWantsLayer:YES];
+  if (content::g_force_cpu_draw) {
+    [compositor_view setLayer:nil];
+    [compositor_view setWantsLayer:NO];
+    //DisplayCALayerTree flipped_layer_
+    CALayer* flipped_layer = background_layer.sublayers[0];
+    [bridged_view_ setForceCPUDrawLayer:flipped_layer];
+    [flipped_layer setGeometryFlipped:NO];
+  } else {
+    [bridged_view_ setWantsLayer:YES];
+  }
   [window_ setContentView:bridged_view_];
 }
 
@@ -992,6 +1022,12 @@
   UpdateWindowGeometry();
 }
 
+void NativeWidgetNSWindowBridge::OnWindowWillStartLiveResize() {
+  if (!NSWindowIsMaximized(window_) && !fullscreen_controller_.IsInFullscreenTransition()) {
+    bounds_before_maximize_ = [window_ frame];
+  }
+}
+
 void NativeWidgetNSWindowBridge::OnVisibilityChanged() {
   const bool window_visible = [window_ isVisible];
   if (window_visible_ == window_visible)
@@ -1412,6 +1448,44 @@
   window.collectionBehavior = collectionBehavior;
 }
 
+bool NativeWidgetNSWindowBridge::IsMaximized(bool* maximized) {
+  *maximized = NSWindowIsMaximized(window_);
+  return true;
+}
+
+void NativeWidgetNSWindowBridge::IsMaximized(IsMaximizedCallback callback) {
+  bool maximized = false;
+  IsMaximized(&maximized);
+  std::move(callback).Run(maximized);
+}
+
+void NativeWidgetNSWindowBridge::SetRestoredBounds(const gfx::Rect& bounds) {
+  bounds_before_maximize_ = gfx::ScreenRectToNSRect(bounds);
+}
+
+bool NativeWidgetNSWindowBridge::GetRestoredBounds(gfx::Rect* bounds) {
+  *bounds = gfx::ScreenRectFromNSRect(bounds_before_maximize_);
+  return true;
+}
+
+void NativeWidgetNSWindowBridge::GetRestoredBounds(GetRestoredBoundsCallback callback) {
+  std::move(callback).Run(gfx::ScreenRectFromNSRect(bounds_before_maximize_));
+}
+
+void NativeWidgetNSWindowBridge::SetMaximized(bool maximized) {
+  if (!maximized) {
+    if (NSWindowIsMaximized(window_))
+      [window_ setFrame:bounds_before_maximize_ display:YES animate:YES];
+    return;
+  }
+  if (!NSWindowIsMaximized(window_))
+    [window_ setFrame:[[window_ screen] visibleFrame] display:YES animate:YES];
+
+  if ([window_ isMiniaturized])
+    [window_ deminiaturize:nil];
+}
+
+
 void NativeWidgetNSWindowBridge::SetMiniaturized(bool miniaturized) {
   // In headless mode the platform window is always hidden and WebKit
   // will not deminiaturize hidden windows. So instead of changing the window
@@ -1473,6 +1547,11 @@
   // the content display on-screen.
   display_ca_layer_tree_->UpdateCALayerTree(ca_layer_params);
 
+  if (content::g_force_cpu_draw) {
+    // this is to tell the NSView that the CALayer content has been updated
+    [bridged_view_ setNeedsDisplay:YES];
+  }
+
   if (ca_transaction_sync_suppressed_)
     ca_transaction_sync_suppressed_ = false;
 
@@ -1484,7 +1563,9 @@
 
 void NativeWidgetNSWindowBridge::SetIgnoresMouseEvents(
     bool ignores_mouse_events) {
-  [window_ setIgnoresMouseEvents:ignores_mouse_events];
+  if (!content::g_force_cpu_draw) {
+    [window_ setIgnoresMouseEvents:ignores_mouse_events];
+  }
 }
 
 void NativeWidgetNSWindowBridge::MakeFirstResponder() {
diff -r -u --color up/chromium/components/remote_cocoa/app_shim/select_file_dialog_bridge.mm nw/chromium/components/remote_cocoa/app_shim/select_file_dialog_bridge.mm
--- up/chromium/components/remote_cocoa/app_shim/select_file_dialog_bridge.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/remote_cocoa/app_shim/select_file_dialog_bridge.mm	2023-01-28 02:49:26.951604302 +0000
@@ -1,7 +1,8 @@
 // Copyright 2019 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
-
+#pragma clang diagnostic ignored "-Wunreachable-code"
+#pragma clang diagnostic ignored "-Wunused-variable"
 #include "components/remote_cocoa/app_shim/select_file_dialog_bridge.h"
 
 #include <AppKit/AppKit.h>
@@ -282,9 +283,10 @@
           base::SysUTF8ToNSString(default_path.BaseName().value());
     }
   }
-
+#if 0
   const bool keep_extension_visible =
       file_types ? file_types->keep_extension_visible : false;
+#endif
   if (type_ != SelectFileDialogType::kFolder &&
       type_ != SelectFileDialogType::kUploadFolder &&
       type_ != SelectFileDialogType::kExistingFolder) {
@@ -299,6 +301,9 @@
   }
 
   if (type_ == SelectFileDialogType::kSaveAsFile) {
+#if 1 //NWJS#6091: extension was hidden
+    [dialog setExtensionHidden:NO];
+#else
     // When file extensions are hidden and removing the extension from
     // the default filename gives one which still has an extension
     // that OS X recognizes, it will get confused and think the user
@@ -313,6 +318,7 @@
       [dialog setExtensionHidden:YES];
       [dialog setCanSelectHiddenExtension:YES];
     }
+#endif
   } else {
     // This does not use ObjCCast because the underlying object could be a
     // non-exported AppKit type (https://crbug.com/995476).
@@ -335,7 +341,7 @@
         [open_dialog setCanCreateDirectories:NO];
 
       NSString* prompt =
-          (type_ == SelectFileDialogType::kUploadFolder)
+          (false && type_ == SelectFileDialogType::kUploadFolder)
               ? l10n_util::GetNSString(IDS_SELECT_UPLOAD_FOLDER_BUTTON_TITLE)
               : l10n_util::GetNSString(IDS_SELECT_FOLDER_BUTTON_TITLE);
       [open_dialog setPrompt:prompt];
diff -r -u --color up/chromium/components/remote_cocoa/app_shim/views_nswindow_delegate.h nw/chromium/components/remote_cocoa/app_shim/views_nswindow_delegate.h
--- up/chromium/components/remote_cocoa/app_shim/views_nswindow_delegate.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/remote_cocoa/app_shim/views_nswindow_delegate.h	2023-01-28 02:49:26.951604302 +0000
@@ -54,10 +54,10 @@
 // a backing store). |notification| is optional and can be set when redirecting
 // a notification such as NSApplicationDidHideNotification.
 - (void)onWindowOrderChanged:(NSNotification*)notification;
-
 // Notify that the system control tint changed.
 - (void)onSystemControlTintChanged:(NSNotification*)notification;
 
+- (void)onWindowWillStartLiveResize:(NSNotification*)notification;
 // Called on the delegate of a modal sheet when its modal session ends.
 - (void)sheetDidEnd:(NSWindow*)sheet
          returnCode:(NSInteger)returnCode
diff -r -u --color up/chromium/components/remote_cocoa/app_shim/views_nswindow_delegate.mm nw/chromium/components/remote_cocoa/app_shim/views_nswindow_delegate.mm
--- up/chromium/components/remote_cocoa/app_shim/views_nswindow_delegate.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/remote_cocoa/app_shim/views_nswindow_delegate.mm	2023-01-28 02:49:26.951604302 +0000
@@ -75,6 +75,10 @@
   _parent->OnVisibilityChanged();
 }
 
+- (void)onWindowWillStartLiveResize:(NSNotification*)notification {
+  _parent->OnWindowWillStartLiveResize();
+}
+
 - (void)onSystemControlTintChanged:(NSNotification*)notification {
   _parent->OnSystemControlTintChanged();
 }
diff -r -u --color up/chromium/components/remote_cocoa/common/native_widget_ns_window.mojom nw/chromium/components/remote_cocoa/common/native_widget_ns_window.mojom
--- up/chromium/components/remote_cocoa/common/native_widget_ns_window.mojom	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/remote_cocoa/common/native_widget_ns_window.mojom	2023-01-28 02:49:26.951604302 +0000
@@ -193,6 +193,10 @@
 
   // Zoom or un-zoom the window.
   SetZoomed(bool zoomed);
+  SetMaximized(bool maximized);
+  [Sync] IsMaximized() => (bool maximized);
+  [Sync] GetRestoredBounds() => (gfx.mojom.Rect bounds);
+  SetRestoredBounds(gfx.mojom.Rect bounds);
 
   // Called by NativeWidgetMac when the window size constraints change.
   SetSizeConstraints(gfx.mojom.Size min_size,
diff -r -u --color up/chromium/components/renderer_context_menu/context_menu_content_type.cc nw/chromium/components/renderer_context_menu/context_menu_content_type.cc
--- up/chromium/components/renderer_context_menu/context_menu_content_type.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/renderer_context_menu/context_menu_content_type.cc	2023-01-28 02:49:26.951604302 +0000
@@ -146,7 +146,7 @@
       return true;
 
     case ITEM_GROUP_DEVTOOLS_UNPACKED_EXT:
-      return false;
+      return true;
 
     case ITEM_GROUP_PRINT_PREVIEW:
 #if BUILDFLAG(ENABLE_PRINT_PREVIEW)
diff -r -u --color up/chromium/components/resources/BUILD.gn nw/chromium/components/resources/BUILD.gn
--- up/chromium/components/resources/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/resources/BUILD.gn	2023-01-28 02:49:26.963604429 +0000
@@ -131,3 +131,9 @@
     public_deps = [ "//device/vr/buildflags" ]
   }
 }
+
+copy("about_credits_nw") {
+  sources = [ about_credits_file ]
+  outputs = [ "$root_build_dir/credits.html" ]
+  deps = [ ":about_credits" ]
+}
diff -r -u --color up/chromium/components/safe_browsing/buildflags.gni nw/chromium/components/safe_browsing/buildflags.gni
--- up/chromium/components/safe_browsing/buildflags.gni	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/safe_browsing/buildflags.gni	2023-01-28 02:49:26.971604513 +0000
@@ -17,6 +17,6 @@
   } else if (is_android) {
     safe_browsing_mode = 2
   } else {
-    safe_browsing_mode = 1
+    safe_browsing_mode = 0
   }
 }
diff -r -u --color up/chromium/components/safe_browsing/content/browser/BUILD.gn nw/chromium/components/safe_browsing/content/browser/BUILD.gn
--- up/chromium/components/safe_browsing/content/browser/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/safe_browsing/content/browser/BUILD.gn	2023-01-28 02:49:26.971604513 +0000
@@ -141,7 +141,7 @@
   ]
 
   deps = [
-    ":client_side_detection",
+    #":client_side_detection",
     "//base:base",
     "//base/test:test_support",
     "//components/safe_browsing:buildflags",
diff -r -u --color up/chromium/components/safe_browsing/content/common/proto/BUILD.gn nw/chromium/components/safe_browsing/content/common/proto/BUILD.gn
--- up/chromium/components/safe_browsing/content/common/proto/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/safe_browsing/content/common/proto/BUILD.gn	2023-01-28 02:49:26.979604598 +0000
@@ -5,7 +5,7 @@
 import("//components/safe_browsing/buildflags.gni")
 import("//third_party/protobuf/proto_library.gni")
 
-if (safe_browsing_mode != 0) {
+if (true) {
   proto_library("download_file_types_proto") {
     sources = [ "download_file_types.proto" ]
   }
diff -r -u --color up/chromium/components/safe_browsing/core/browser/db/v4_update_protocol_manager.cc nw/chromium/components/safe_browsing/core/browser/db/v4_update_protocol_manager.cc
--- up/chromium/components/safe_browsing/core/browser/db/v4_update_protocol_manager.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/safe_browsing/core/browser/db/v4_update_protocol_manager.cc	2023-01-28 02:49:26.987604682 +0000
@@ -315,6 +315,7 @@
     return;
   }
 
+#if 0
   net::NetworkTrafficAnnotationTag traffic_annotation =
       net::DefineNetworkTrafficAnnotation("safe_browsing_v4_update", R"(
         semantics {
@@ -358,7 +359,7 @@
                      base::Unretained(this)));
 
   request_ = std::move(loader);
-
+#endif
   // Begin the update request timeout.
   timeout_timer_.Start(FROM_HERE, base::Seconds(kV4TimerUpdateWaitSecMax), this,
                        &V4UpdateProtocolManager::HandleTimeout);
diff -r -u --color up/chromium/components/search_provider_logos/logo_service_impl.cc nw/chromium/components/search_provider_logos/logo_service_impl.cc
--- up/chromium/components/search_provider_logos/logo_service_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/search_provider_logos/logo_service_impl.cc	2023-01-28 02:49:27.003604851 +0000
@@ -1,6 +1,7 @@
 // Copyright 2017 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wunreachable-code"
 
 #include "components/search_provider_logos/logo_service_impl.h"
 
@@ -267,7 +268,7 @@
     base_url = doodle_url.DeprecatedGetOriginAsURL();
   }
 
-  if (!logo_url.is_valid() && !doodle_url.is_valid()) {
+  if (true) { //!logo_url.is_valid() && !doodle_url.is_valid()) {
     RunCallbacksWithDisabled(std::move(callbacks));
     return;
   }
diff -r -u --color up/chromium/components/services/storage/dom_storage/local_storage_impl.cc nw/chromium/components/services/storage/dom_storage/local_storage_impl.cc
--- up/chromium/components/services/storage/dom_storage/local_storage_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/services/storage/dom_storage/local_storage_impl.cc	2023-01-28 02:49:27.115606035 +0000
@@ -155,13 +155,13 @@
 
   // To avoid excessive IO we apply limits to the amount of data being written
   // and the frequency of writes.
-  static const size_t kMaxBytesPerHour = kPerStorageAreaQuota;
-  static constexpr int kMaxCommitsPerHour = 60;
+  //static const size_t kMaxBytesPerHour = std::numeric_limits<size_t>::max();
+  static constexpr int kMaxCommitsPerHour = std::numeric_limits<int32_t>::max();
 
   StorageAreaImpl::Options options;
-  options.max_size = kPerStorageAreaQuota + kPerStorageAreaOverQuotaAllowance;
+  options.max_size = std::numeric_limits<size_t>::max();
   options.default_commit_delay = kCommitDefaultDelaySecs;
-  options.max_bytes_per_hour = kMaxBytesPerHour;
+  options.max_bytes_per_hour = std::numeric_limits<int>::max();
   options.max_commits_per_hour = kMaxCommitsPerHour;
 #if BUILDFLAG(IS_ANDROID)
     options.cache_mode = StorageAreaImpl::CacheMode::KEYS_ONLY_WHEN_POSSIBLE;
diff -r -u --color up/chromium/components/sessions/core/session_service_commands.cc nw/chromium/components/sessions/core/session_service_commands.cc
--- up/chromium/components/sessions/core/session_service_commands.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/sessions/core/session_service_commands.cc	2023-01-28 02:49:27.135606247 +0000
@@ -165,9 +165,10 @@
   PERSISTED_SHOW_STATE_MAXIMIZED = 3,
   // SHOW_STATE_INACTIVE (4) never persisted.
   PERSISTED_SHOW_STATE_FULLSCREEN = 5,
-  PERSISTED_SHOW_STATE_DETACHED_DEPRECATED = 6,
-  PERSISTED_SHOW_STATE_DOCKED_DEPRECATED = 7,
-  PERSISTED_SHOW_STATE_END = 8,
+  // hidden not persisted
+  PERSISTED_SHOW_STATE_DETACHED_DEPRECATED = 7,
+  PERSISTED_SHOW_STATE_DOCKED_DEPRECATED = 8,
+  PERSISTED_SHOW_STATE_END = 9,
 };
 
 // Assert to ensure PersistedWindowShowState is updated if ui::WindowShowState
@@ -191,6 +192,7 @@
       return PERSISTED_SHOW_STATE_FULLSCREEN;
     case ui::SHOW_STATE_DEFAULT:
     case ui::SHOW_STATE_INACTIVE:
+    case ui::SHOW_STATE_HIDDEN:
       return PERSISTED_SHOW_STATE_NORMAL;
 
     case ui::SHOW_STATE_END:
diff -r -u --color up/chromium/components/sessions/core/tab_restore_service_impl.cc nw/chromium/components/sessions/core/tab_restore_service_impl.cc
--- up/chromium/components/sessions/core/tab_restore_service_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/sessions/core/tab_restore_service_impl.cc	2023-01-28 02:49:27.135606247 +0000
@@ -181,6 +181,7 @@
   kSerializedShowStateMaximized = 3,
   kSerializedShowStateInactive = 4,
   kSerializedShowStateFullscreen = 5,
+  kSerializedShowStateHidden = 6,
 };
 
 // Converts a window show state to an integer. This function needs to be kept
@@ -199,6 +200,8 @@
       return kSerializedShowStateInactive;
     case ui::SHOW_STATE_FULLSCREEN:
       return kSerializedShowStateFullscreen;
+    case ui::SHOW_STATE_HIDDEN:
+      return kSerializedShowStateHidden;
     case ui::SHOW_STATE_END:
       // This should never happen.
       NOTREACHED();
@@ -230,6 +233,9 @@
     case kSerializedShowStateFullscreen:
       *show_state = ui::SHOW_STATE_FULLSCREEN;
       return true;
+    case kSerializedShowStateHidden:
+      *show_state = ui::SHOW_STATE_HIDDEN;
+      return true;
     case kSerializedShowStateInvalid:
     default:
       // Ignore unknown values. This could happen if the data is corrupt.
diff -r -u --color up/chromium/components/storage_monitor/portable_device_watcher_win.cc nw/chromium/components/storage_monitor/portable_device_watcher_win.cc
--- up/chromium/components/storage_monitor/portable_device_watcher_win.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/storage_monitor/portable_device_watcher_win.cc	2023-01-28 02:49:27.167606585 +0000
@@ -33,7 +33,7 @@
 namespace {
 
 // Name of the client application that communicates with the MTP device.
-const wchar_t kClientName[] = L"Chromium";
+const wchar_t kClientName[] = L"nwjs";
 
 // Returns true if |data| represents a class of portable devices.
 bool IsPortableDeviceStructure(LPARAM data) {
diff -r -u --color up/chromium/components/translate/content/browser/BUILD.gn nw/chromium/components/translate/content/browser/BUILD.gn
--- up/chromium/components/translate/content/browser/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/translate/content/browser/BUILD.gn	2023-01-28 02:49:27.659611785 +0000
@@ -36,7 +36,7 @@
     "//components/services/language_detection/public/cpp",
     "//components/services/language_detection/public/mojom",
     "//components/translate/core/browser:translate_model_service",
-    "//components/translate/core/language_detection:language_detection",
+    #"//components/translate/core/language_detection:language_detection",
     "//components/ukm/content",
     "//content/public/browser",
     "//content/public/common",
diff -r -u --color up/chromium/components/translate/core/language_detection/BUILD.gn nw/chromium/components/translate/core/language_detection/BUILD.gn
--- up/chromium/components/translate/core/language_detection/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/translate/core/language_detection/BUILD.gn	2023-01-28 02:49:27.667611870 +0000
@@ -40,7 +40,7 @@
     "//components/language/core/common",
     "//components/optimization_guide/core:features",
     "//components/translate/core/common",
-    "//third_party/cld_3/src/src:cld_3",
+    #"//third_party/cld_3/src/src:cld_3",
     "//third_party/flatbuffers",
     "//third_party/icu",
     "//third_party/smhasher:murmurhash2",
diff -r -u --color up/chromium/components/translate/translate_internals/translate_internals_handler.cc nw/chromium/components/translate/translate_internals/translate_internals_handler.cc
--- up/chromium/components/translate/translate_internals/translate_internals_handler.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/translate/translate_internals/translate_internals_handler.cc	2023-01-28 02:49:27.667611870 +0000
@@ -160,6 +160,7 @@
 
 void TranslateInternalsHandler::OnRemovePrefItem(
     const base::Value::List& args) {
+#if 0
   std::unique_ptr<translate::TranslatePrefs> translate_prefs =
       GetTranslateClient()->GetTranslatePrefs();
 
@@ -190,6 +191,7 @@
   }
 
   SendPrefsToJs();
+#endif
 }
 
 void TranslateInternalsHandler::OnSetRecentTargetLanguage(
diff -r -u --color up/chromium/components/viz/service/display/skia_renderer.cc nw/chromium/components/viz/service/display/skia_renderer.cc
--- up/chromium/components/viz/service/display/skia_renderer.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/viz/service/display/skia_renderer.cc	2023-01-28 02:49:27.751612758 +0000
@@ -1,7 +1,7 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
-
+#pragma clang diagnostic ignored "-Wunused-variable"
 #include "components/viz/service/display/skia_renderer.h"
 
 #include <limits>
diff -r -u --color up/chromium/components/viz/service/display_embedder/software_output_device_win.cc nw/chromium/components/viz/service/display_embedder/software_output_device_win.cc
--- up/chromium/components/viz/service/display_embedder/software_output_device_win.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/viz/service/display_embedder/software_output_device_win.cc	2023-01-28 02:49:27.759612842 +0000
@@ -17,6 +17,7 @@
 #include "services/viz/privileged/mojom/compositing/layered_window_updater.mojom.h"
 #include "skia/ext/platform_canvas.h"
 #include "skia/ext/skia_utils_win.h"
+#include "ui/display/display.h"
 #include "ui/gfx/gdi_util.h"
 #include "ui/gfx/geometry/skia_conversions.h"
 #include "ui/gfx/win/hwnd_util.h"
diff -r -u --color up/chromium/components/web_modal/web_contents_modal_dialog_manager.cc nw/chromium/components/web_modal/web_contents_modal_dialog_manager.cc
--- up/chromium/components/web_modal/web_contents_modal_dialog_manager.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/web_modal/web_contents_modal_dialog_manager.cc	2023-01-28 02:49:27.899614322 +0000
@@ -44,7 +44,7 @@
 
   if (child_dialogs_.size() == 1) {
     BlockWebContentsInteraction(true);
-    if (delegate_ && delegate_->IsWebContentsVisible(web_contents()))
+    if (!web_contents()->is_silent_printing() && delegate_ && delegate_->IsWebContentsVisible(web_contents()))
       child_dialogs_.back().manager->Show();
   }
 }
@@ -109,7 +109,8 @@
     // The WebContents has already disconnected.
     return;
   }
-
+  if (!blocked && contents->is_silent_printing())
+    contents->set_silent_printing(false);
   contents->SetIgnoreInputEvents(blocked);
   if (delegate_)
     delegate_->SetWebContentsBlocked(contents, blocked);
diff -r -u --color up/chromium/components/webdata_services/web_data_service_wrapper.cc nw/chromium/components/webdata_services/web_data_service_wrapper.cc
--- up/chromium/components/webdata_services/web_data_service_wrapper.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/components/webdata_services/web_data_service_wrapper.cc	2023-01-28 02:49:27.923614576 +0000
@@ -47,6 +47,7 @@
     autofill::AutofillWebDataBackend* autofill_backend) {
   DCHECK(db_task_runner->RunsTasksInCurrentSequence());
 
+#if 0
   autofill::AutocompleteSyncBridge::CreateForWebDataServiceAndBackend(
       autofill_web_data.get(), autofill_backend);
   autofill::AutofillProfileSyncBridge::CreateForWebDataServiceAndBackend(
@@ -55,6 +56,7 @@
     autofill::ContactInfoSyncBridge::CreateForWebDataServiceAndBackend(
         autofill_backend, autofill_web_data.get());
   }
+#endif
 }
 
 void InitWalletSyncBridgesOnDBSequence(
diff -r -u --color up/chromium/content/BUILD.gn nw/chromium/content/BUILD.gn
--- up/chromium/content/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/BUILD.gn	2023-01-28 02:49:27.939614745 +0000
@@ -60,6 +60,7 @@
 # linking problems) for when check is enabled.
 
 content_shared_components = [
+  "//content/nw:nw_base",
   "//content/gpu:gpu_sources",
   "//content/public/browser:browser_sources",
   "//content/public/child:child_sources",
@@ -77,6 +78,9 @@
   component("content") {
     public_deps =
         content_shared_components + [ "//content/public/app:app_sources" ]
+    deps = [
+      "//content/nw:nw_content",
+    ]
   }
 } else {
   group("content") {
diff -r -u --color up/chromium/content/app/content_main.cc nw/chromium/content/app/content_main.cc
--- up/chromium/content/app/content_main.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/app/content_main.cc	2023-01-28 02:49:27.939614745 +0000
@@ -4,6 +4,8 @@
 
 #include "content/public/app/content_main.h"
 
+#include "content/nw/src/nw_base.h"
+
 #include "base/allocator/buildflags.h"
 #include "base/allocator/partition_alloc_support.h"
 #include "base/at_exit.h"
@@ -154,7 +156,7 @@
   }
 #endif
 
-#if !defined(OFFICIAL_BUILD) && BUILDFLAG(IS_WIN)
+#if 0
   base::RouteStdioToConsole(false);
   LoadLibraryA("dbghelp.dll");
 #endif
@@ -264,7 +266,7 @@
 
     base::EnableTerminationOnHeapCorruption();
 
-    SetProcessTitleFromCommandLine(argv);
+    //SetProcessTitleFromCommandLine(argv);
 #endif  // !BUILDFLAG(IS_ANDROID)
 
     InitTimeTicksAtUnixEpoch();
@@ -320,7 +322,7 @@
       return exit_code;
     }
 
-#if BUILDFLAG(IS_WIN)
+#if 0 //BUILDFLAG(IS_WIN)
     // Route stdio to parent console (if any) or create one.
     if (base::CommandLine::ForCurrentProcess()->HasSwitch(
             switches::kEnableLogging)) {
@@ -341,6 +343,11 @@
     CommonSubprocessInit();
   exit_code = content_main_runner->Run();
 
+  std::string type_switch =
+    base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII(switches::kProcessType);
+  if (type_switch == "renderer")
+    exit_code = nw::ExitCodeHook();
+
   if (tracker) {
     if (exit_code == 0) {
       tracker->SetProcessPhaseIfEnabled(
diff -r -u --color up/chromium/content/app/content_main_runner_impl.cc nw/chromium/content/app/content_main_runner_impl.cc
--- up/chromium/content/app/content_main_runner_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/app/content_main_runner_impl.cc	2023-01-28 02:49:27.939614745 +0000
@@ -1019,11 +1019,10 @@
   DCHECK(is_initialized_);
   DCHECK(content_main_params_);
   DCHECK(!is_shutdown_);
-  const base::CommandLine* command_line =
-      base::CommandLine::ForCurrentProcess();
+  base::CommandLine& command_line =
+      *base::CommandLine::ForCurrentProcess();
   std::string process_type =
-      command_line->GetSwitchValueASCII(switches::kProcessType);
-
+      command_line.GetSwitchValueASCII(switches::kProcessType);
   // Run this logic on all child processes.
   if (!process_type.empty()) {
     if (process_type != switches::kZygoteProcess) {
@@ -1058,7 +1057,11 @@
 #endif  // BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
   }
 
-  MainFunctionParams main_params(command_line);
+  if (process_type.empty()) {
+    command_line.AppendSwitch(sandbox::policy::switches::kNoSandbox);
+    command_line.AppendSwitch(switches::kNoZygote);
+  }
+  MainFunctionParams main_params(&command_line);
   main_params.ui_task = std::move(content_main_params_->ui_task);
   main_params.created_main_parts_closure =
       std::move(content_main_params_->created_main_parts_closure);
diff -r -u --color up/chromium/content/app_shim_remote_cocoa/ns_view_bridge_factory_impl.mm nw/chromium/content/app_shim_remote_cocoa/ns_view_bridge_factory_impl.mm
--- up/chromium/content/app_shim_remote_cocoa/ns_view_bridge_factory_impl.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/app_shim_remote_cocoa/ns_view_bridge_factory_impl.mm	2023-01-28 02:49:27.939614745 +0000
@@ -67,6 +67,8 @@
  private:
   void OnMojoDisconnect() { delete this; }
 
+  content::RenderWidgetHostViewMac* GetRenderWidgetHostViewMac() override { return nullptr; }
+
   std::unique_ptr<blink::WebCoalescedInputEvent> TranslateEvent(
       const blink::WebInputEvent& web_event) {
     return std::make_unique<blink::WebCoalescedInputEvent>(
diff -r -u --color up/chromium/content/app_shim_remote_cocoa/render_widget_host_ns_view_bridge.h nw/chromium/content/app_shim_remote_cocoa/render_widget_host_ns_view_bridge.h
--- up/chromium/content/app_shim_remote_cocoa/render_widget_host_ns_view_bridge.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/app_shim_remote_cocoa/render_widget_host_ns_view_bridge.h	2023-01-28 02:49:27.939614745 +0000
@@ -20,6 +20,8 @@
 #include "ui/base/mojom/attributed_string.mojom-forward.h"
 #include "ui/display/display_observer.h"
 
+@class CALayer;
+
 namespace remote_cocoa {
 
 // Mojo bridge for a RenderWidgetHostViewMac's NSView. This class may be
@@ -90,6 +92,7 @@
       bool consumed) override;
   void DidOverscroll(blink::mojom::DidOverscrollParamsPtr params) override;
 
+  CALayer* GetBackgroundLayer();
  private:
   bool IsPopup() const { return !!popup_window_; }
 
diff -r -u --color up/chromium/content/app_shim_remote_cocoa/render_widget_host_ns_view_bridge.mm nw/chromium/content/app_shim_remote_cocoa/render_widget_host_ns_view_bridge.mm
--- up/chromium/content/app_shim_remote_cocoa/render_widget_host_ns_view_bridge.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/app_shim_remote_cocoa/render_widget_host_ns_view_bridge.mm	2023-01-28 02:49:27.939614745 +0000
@@ -22,6 +22,11 @@
 
 using blink::WebGestureEvent;
 
+namespace content {
+  extern bool g_support_transparency;
+  extern bool g_force_cpu_draw;
+}
+
 namespace remote_cocoa {
 
 RenderWidgetHostNSViewBridge::RenderWidgetHostNSViewBridge(
@@ -35,13 +40,21 @@
       withHostHelper:host_helper]);
 
   background_layer_.reset([[CALayer alloc] init]);
+
   display_ca_layer_tree_ =
       std::make_unique<ui::DisplayCALayerTree>(background_layer_.get());
+
+  bool isOpaque = [cocoa_view_ isOpaque];
+  if (content::g_support_transparency) {
+    [background_layer_ setBackgroundColor: (isOpaque || !content::g_support_transparency) ?
+      CGColorGetConstantColor(kCGColorWhite) : CGColorGetConstantColor(kCGColorClear)];
+  }
+
   [cocoa_view_ setLayer:background_layer_];
-  [cocoa_view_ setWantsLayer:YES];
+  [cocoa_view_ setWantsLayer:!content::g_force_cpu_draw];
 
   view_id_ = std::make_unique<remote_cocoa::ScopedNSViewIdMapping>(ns_view_id,
-                                                                   cocoa_view_);
+        cocoa_view_);
 }
 
 RenderWidgetHostNSViewBridge::~RenderWidgetHostNSViewBridge() {
@@ -151,6 +164,10 @@
   if (display_disabled_)
     return;
   display_ca_layer_tree_->UpdateCALayerTree(ca_layer_params);
+  if (content::g_force_cpu_draw) {
+    // this is to tell parent window, that the window content has been updated
+    [[cocoa_view_ superview] setNeedsDisplay:YES];
+  }
 }
 
 void RenderWidgetHostNSViewBridge::SetBackgroundColor(SkColor color) {
@@ -241,6 +258,11 @@
   [cocoa_view_ updateScreenProperties];
 }
 
+CALayer* RenderWidgetHostNSViewBridge::GetBackgroundLayer() {
+  assert(content::g_force_cpu_draw);
+  return background_layer_;
+}
+
 void RenderWidgetHostNSViewBridge::DisplayCursor(const ui::Cursor& cursor) {
   [cocoa_view_ updateCursor:content::WebCursor(cursor).GetNativeCursor()];
 }
diff -r -u --color up/chromium/content/app_shim_remote_cocoa/render_widget_host_ns_view_host_helper.h nw/chromium/content/app_shim_remote_cocoa/render_widget_host_ns_view_host_helper.h
--- up/chromium/content/app_shim_remote_cocoa/render_widget_host_ns_view_host_helper.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/app_shim_remote_cocoa/render_widget_host_ns_view_host_helper.h	2023-01-28 02:49:27.939614745 +0000
@@ -22,6 +22,7 @@
 
 namespace content {
 struct NativeWebKeyboardEvent;
+class RenderWidgetHostViewMac;
 }  // namespace content
 
 namespace remote_cocoa {
@@ -30,6 +31,7 @@
 class RenderWidgetHostNSViewHost;
 }  // namespace mojom
 
+
 // An interface through which the NSView for a RenderWidgetHostViewMac is to
 // communicate with the RenderWidgetHostViewMac (potentially in another
 // process). Unlike mojom::RenderWidgetHostNSViewHost, this object is always
@@ -56,6 +58,8 @@
 
   // Return the currently focused accessibility element.
   virtual id GetFocusedBrowserAccessibilityElement() = 0;
+  virtual content::RenderWidgetHostViewMac* GetRenderWidgetHostViewMac() = 0;
+
 
   // Set the NSWindow that will be the accessibility parent of the NSView.
   virtual void SetAccessibilityWindow(NSWindow* window) = 0;
diff -r -u --color up/chromium/content/app_shim_remote_cocoa/render_widget_host_view_cocoa.mm nw/chromium/content/app_shim_remote_cocoa/render_widget_host_view_cocoa.mm
--- up/chromium/content/app_shim_remote_cocoa/render_widget_host_view_cocoa.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/app_shim_remote_cocoa/render_widget_host_view_cocoa.mm	2023-01-28 02:49:27.939614745 +0000
@@ -59,6 +59,10 @@
 using remote_cocoa::mojom::RenderWidgetHostNSViewHost;
 using remote_cocoa::RenderWidgetHostNSViewHostHelper;
 
+namespace content {
+  extern bool g_force_cpu_draw;
+}
+
 namespace {
 
 constexpr NSString* WebAutomaticQuoteSubstitutionEnabled =
@@ -78,6 +82,7 @@
   DummyHostHelper& operator=(const DummyHostHelper&) = delete;
 
  private:
+  content::RenderWidgetHostViewMac* GetRenderWidgetHostViewMac() override { return nullptr; }
   // RenderWidgetHostNSViewHostHelper implementation.
   id GetAccessibilityElement() override { return nil; }
   id GetRootBrowserAccessibilityElement() override { return nil; }
@@ -585,6 +590,19 @@
   return [super forwardingTargetForSelector:selector];
 }
 
+- (void)drawRect:(NSRect)dirty {
+  if (content::g_force_cpu_draw) {
+    CGContextRef ctx = (CGContextRef)[[NSGraphicsContext currentContext] graphicsPort];
+    CGContextClipToRect(ctx, NSRectToCGRect(dirty));
+    //High Sierra 10.13 fix, previously we use [self layer],
+    //since we have set the layer to nil in AcceleratedWidgetMac::GotSoftwareFrame,
+    //we access the layer "directly" which is the "background_layer()" (see RenderWidgetHostViewMac constructor)
+    [_hostHelper->GetRenderWidgetHostViewMac()->background_layer() renderInContext:ctx];
+  } else {
+    [super drawRect:dirty];
+  }
+}
+
 - (void)setCanBeKeyView:(BOOL)can {
   _canBeKeyView = can;
 }
@@ -1499,8 +1517,17 @@
 }
 
 - (void)setFrameSize:(NSSize)newSize {
+  //High Sierra 10.13 fix, RenderWidgetHostViewCocoa CALayer must be nil
+  //so we can do drawRect "manually"
+  //here, we temporarily assign back the layer during resize, so the background_layer() can be resized properly
+  if (content::g_force_cpu_draw)
+    [self setLayer:_hostHelper->GetRenderWidgetHostViewMac()->background_layer()];
+
   [super setFrameSize:newSize];
   [self sendViewBoundsInWindowToHost];
+
+  if (content::g_force_cpu_draw)
+    [self setLayer:nil];
 }
 
 - (BOOL)canBecomeKeyView {
diff -r -u --color up/chromium/content/browser/BUILD.gn nw/chromium/content/browser/BUILD.gn
--- up/chromium/content/browser/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/BUILD.gn	2023-01-28 02:49:27.943614787 +0000
@@ -1855,6 +1855,8 @@
     "renderer_host/view_transition_commit_deferring_condition.h",
     "renderer_host/visible_time_request_trigger.cc",
     "renderer_host/visible_time_request_trigger.h",
+    "resolve_proxy_helper.cc",
+    "resolve_proxy_helper.h",
     "resource_context_impl.cc",
     "resource_context_impl.h",
     "resource_coordinator_service.cc",
diff -r -u --color up/chromium/content/browser/browser_main_loop.cc nw/chromium/content/browser/browser_main_loop.cc
--- up/chromium/content/browser/browser_main_loop.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/browser_main_loop.cc	2023-01-28 02:49:27.987615252 +0000
@@ -435,6 +435,8 @@
 // The currently-running BrowserMainLoop.  There can be one or zero.
 BrowserMainLoop* g_current_browser_main_loop = nullptr;
 
+bool g_browser_main_loop_shutting_down = false;
+
 #if BUILDFLAG(IS_ANDROID)
 
 namespace {
@@ -951,6 +953,7 @@
   if (parts_)
     result_code_ = parts_->PreMainMessageLoopRun();
 
+#if 1
   // ShellBrowserMainParts initializes a ShellBrowserContext with user data
   // directory only in PreMainMessageLoopRun(). First-Party Sets handler needs
   // to access this directory, hence triggering after this stage has run.
@@ -961,6 +964,7 @@
             base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
                 network::switches::kUseFirstPartySet)));
   }
+#endif
 
   variations::MaybeScheduleFakeCrash();
 
@@ -1098,8 +1102,9 @@
       base::BindOnce(base::IgnoreResult(
           &base::PermanentThreadAllowance::AllowBaseSyncPrimitives)));
 
-  if (RenderProcessHost::run_renderer_in_process())
-    RenderProcessHostImpl::ShutDownInProcessRenderer();
+#if 1 //defined(OS_ANDROID)
+  g_browser_main_loop_shutting_down = true;
+#endif
 
   if (parts_) {
     TRACE_EVENT0("shutdown",
@@ -1107,6 +1112,9 @@
     parts_->PostMainMessageLoopRun();
   }
 
+  if (RenderProcessHost::run_renderer_in_process())
+    RenderProcessHostImpl::ShutDownInProcessRenderer();
+
   // Request shutdown to clean up allocated resources on the IO thread.
   if (midi_service_) {
     TRACE_EVENT0("shutdown", "BrowserMainLoop::Subsystem:MidiService");
diff -r -u --color up/chromium/content/browser/browser_plugin/browser_plugin_guest.cc nw/chromium/content/browser/browser_plugin/browser_plugin_guest.cc
--- up/chromium/content/browser/browser_plugin/browser_plugin_guest.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/browser_plugin/browser_plugin_guest.cc	2023-01-28 02:49:27.987615252 +0000
@@ -4,6 +4,10 @@
 
 #include "content/browser/browser_plugin/browser_plugin_guest.h"
 
+#include "content/nw/src/nw_base.h"
+#include "content/nw/src/common/shell_switches.h"
+#include "base/files/file_util.h"
+
 #include <stddef.h>
 
 #include <utility>
@@ -78,6 +82,24 @@
   // navigations still continue to function inside the app.
   renderer_prefs->browser_handles_all_top_level_requests = false;
 
+  base::ScopedAllowBlocking allow_io;
+  nw::Package* package = nw::package();
+  std::string js_doc_start, js_doc_end;
+  std::string* str = package->root()->FindString(::switches::kmInjectJSDocStart);
+  if (str)
+    js_doc_start = *str;
+  if (!js_doc_start.empty()) {
+    std::string fpath = base::MakeAbsoluteFilePath(package->path()).AppendASCII(js_doc_start).AsUTF8Unsafe();
+    renderer_prefs->nw_inject_js_doc_start = fpath;
+  }
+  str = package->root()->FindString(::switches::kmInjectJSDocEnd);
+  if (str)
+    js_doc_end = *str;
+  if (!js_doc_end.empty()) {
+    std::string fpath = base::MakeAbsoluteFilePath(package->path()).AppendASCII(js_doc_end).AsUTF8Unsafe();
+    renderer_prefs->nw_inject_js_doc_end = fpath;
+  }
+
   // TODO(chrishtr): this code is wrong. The navigate_on_drag_drop field will
   // be reset again the next time preferences are updated.
   blink::web_pref::WebPreferences prefs =
diff -r -u --color up/chromium/content/browser/child_process_security_policy_impl.cc nw/chromium/content/browser/child_process_security_policy_impl.cc
--- up/chromium/content/browser/child_process_security_policy_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/child_process_security_policy_impl.cc	2023-01-28 02:49:27.999615379 +0000
@@ -306,7 +306,7 @@
 class ChildProcessSecurityPolicyImpl::SecurityState {
  public:
   explicit SecurityState(BrowserContext* browser_context)
-      : enabled_bindings_(0),
+    : grant_all_(false), enabled_bindings_(0),
         can_read_raw_cookies_(false),
         can_send_midi_sysex_(false),
         browser_context_(browser_context),
@@ -346,6 +346,10 @@
     scheme_map_[scheme] = CommitRequestPolicy::kCommitAndRequest;
   }
 
+  void GrantAll() {
+    grant_all_ = true;
+  }
+
   void GrantRequestScheme(const std::string& scheme) {
     // Anything already in |scheme_map_| must have at least request permission
     // already. In that case, the emplace() below will be a no-op.
@@ -423,6 +427,8 @@
   bool CanCommitURL(const GURL& url) {
     DCHECK(!url.SchemeIsBlob() && !url.SchemeIsFileSystem())
         << "inner_url extraction should be done already.";
+    if (grant_all_)
+      return true;
     // Having permission to a scheme implies permission to all of its URLs.
     auto scheme_judgment = scheme_map_.find(url.scheme());
     if (scheme_judgment != scheme_map_.end() &&
@@ -469,6 +475,8 @@
     if (file.IsContentUri())
       return HasPermissionsForContentUri(file, permissions);
 #endif
+    if (grant_all_)
+      return true;
     if (!permissions || file.empty() || !file.IsAbsolute())
       return false;
     base::FilePath current_path = file.StripTrailingSeparators();
@@ -611,6 +619,8 @@
   // granted. There is no provision for revoking.
   SchemeMap scheme_map_;
 
+  bool grant_all_;
+
   // The map of URL origins to commit/request policies the child process has
   // been granted. There is no provision for revoking.
   OriginMap origin_map_;
@@ -750,7 +760,7 @@
   // IsWebSafeScheme(), and then eliminate the next two lines.
   RegisterWebSafeScheme(url::kBlobScheme);
   RegisterWebSafeScheme(url::kFileSystemScheme);
-
+  //RegisterWebSafeScheme("chrome-devtools");
   // We know about the following pseudo schemes and treat them specially.
   RegisterPseudoScheme(url::kAboutScheme);
   RegisterPseudoScheme(url::kJavaScriptScheme);
@@ -941,6 +951,15 @@
   }
 }
 
+void ChildProcessSecurityPolicyImpl::GrantAll(int child_id) {
+  base::AutoLock lock(lock_);
+  SecurityStateMap::iterator state = security_state_.find(child_id);
+  if (state == security_state_.end())
+    return;
+
+  state->second->GrantAll();
+}
+
 void ChildProcessSecurityPolicyImpl::GrantReadFile(int child_id,
                                                    const base::FilePath& file) {
   GrantPermissionsForFile(child_id, file, READ_FILE_GRANT);
diff -r -u --color up/chromium/content/browser/child_process_security_policy_impl.h nw/chromium/content/browser/child_process_security_policy_impl.h
--- up/chromium/content/browser/child_process_security_policy_impl.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/child_process_security_policy_impl.h	2023-01-28 02:49:27.999615379 +0000
@@ -143,6 +143,7 @@
   static ChildProcessSecurityPolicyImpl* GetInstance();
 
   // ChildProcessSecurityPolicy implementation.
+  void GrantAll(int child_id) override;
   void RegisterWebSafeScheme(const std::string& scheme) override;
   void RegisterWebSafeIsolatedScheme(
       const std::string& scheme,
diff -r -u --color up/chromium/content/browser/devtools/devtools_http_handler.cc nw/chromium/content/browser/devtools/devtools_http_handler.cc
--- up/chromium/content/browser/devtools/devtools_http_handler.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/devtools/devtools_http_handler.cc	2023-01-28 02:49:28.007615464 +0000
@@ -39,6 +39,8 @@
 #include "content/public/browser/devtools_frontend_host.h"
 #include "content/public/browser/devtools_manager_delegate.h"
 #include "content/public/browser/devtools_socket_factory.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/web_contents.h"
 #include "content/public/common/content_client.h"
 #include "content/public/common/url_constants.h"
 #include "content/public/common/user_agent.h"
@@ -69,10 +71,14 @@
 const base::FilePath::CharType kDevToolsActivePortFileName[] =
     FILE_PATH_LITERAL("DevToolsActivePort");
 
+#if defined(NWJS_SDK)
 const char kDevToolsHandlerThreadName[] = "Chrome_DevToolsHandlerThread";
+#endif
 
 const char kPageUrlPrefix[] = "/devtools/page/";
+#if defined(NWJS_SDK)
 const char kBrowserUrlPrefix[] = "/devtools/browser";
+#endif
 
 const char kTargetIdField[] = "id";
 const char kTargetParentIdField[] = "parentId";
@@ -724,6 +730,10 @@
   std::sort(agent_hosts.begin(), agent_hosts.end(), TimeComparator);
   base::ListValue list_value;
   for (auto& agent_host : agent_hosts) {
+    WebContents* web_contents = agent_host->GetWebContents();
+    if (web_contents && web_contents->GetPrimaryMainFrame())
+      if (!web_contents->GetPrimaryMainFrame()->context_created())
+        continue;
     // TODO(caseq): figure out if it makes sense exposing tab target to
     // HTTP clients and potentially compatibility risks involved.
     if (agent_host->GetType() != DevToolsAgentHost::kTypeTab)
@@ -815,6 +825,7 @@
     const base::FilePath& output_directory,
     const base::FilePath& debug_frontend_dir)
     : delegate_(delegate) {
+#if defined(NWJS_SDK)
   browser_guid_ = delegate_->IsBrowserTargetDiscoverable()
                       ? kBrowserUrlPrefix
                       : base::StringPrintf("%s/%s", kBrowserUrlPrefix,
@@ -832,6 +843,7 @@
                        output_directory, debug_frontend_dir, browser_guid_,
                        delegate_->HasBundledFrontendResources()));
   }
+#endif
 }
 
 void DevToolsHttpHandler::ServerStarted(
diff -r -u --color up/chromium/content/browser/devtools/protocol/emulation_handler.cc nw/chromium/content/browser/devtools/protocol/emulation_handler.cc
--- up/chromium/content/browser/devtools/protocol/emulation_handler.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/devtools/protocol/emulation_handler.cc	2023-01-28 02:49:28.011615506 +0000
@@ -602,13 +602,18 @@
   if (touch_emulation_enabled_) {
     if (auto* touch_emulator =
             host_->GetRenderWidgetHost()->GetTouchEmulator()) {
+      touch_emulator->set_rfh_limit(host_->GetWeakPtr());
       touch_emulator->Enable(
           TouchEmulator::Mode::kEmulatingTouchFromMouse,
           TouchEmulationConfigurationToType(touch_emulation_configuration_));
     }
   } else {
-    if (auto* touch_emulator = host_->GetRenderWidgetHost()->GetTouchEmulator())
+    if (auto* touch_emulator =
+            host_->GetRenderWidgetHost()->GetTouchEmulator()) {
       touch_emulator->Disable();
+      touch_emulator->set_rfh_limit(nullptr);
+    }
+
   }
   GetWebContents()->SetForceDisableOverscrollContent(touch_emulation_enabled_);
 }
diff -r -u --color up/chromium/content/browser/devtools/render_frame_devtools_agent_host.cc nw/chromium/content/browser/devtools/render_frame_devtools_agent_host.cc
--- up/chromium/content/browser/devtools/render_frame_devtools_agent_host.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/devtools/render_frame_devtools_agent_host.cc	2023-01-28 02:49:28.183617324 +0000
@@ -227,6 +227,8 @@
   }
   RenderProcessHost* rph = rfh->GetProcess();
   std::set<url::Origin> process_origins;
+  std::set<url::Origin> opaque_process_origins;
+  opaque_process_origins.insert(url::Origin());
   for (const auto& entry : g_agent_host_instances.Get()) {
     RenderFrameHostImpl* frame_host = entry.second->frame_host_;
     if (!frame_host)
@@ -241,7 +243,8 @@
   }
   GetNetworkService()->SetRawHeadersAccess(
       rph->GetID(),
-      std::vector<url::Origin>(process_origins.begin(), process_origins.end()));
+      std::vector<url::Origin>(opaque_process_origins.begin(),
+                               opaque_process_origins.end()));
 }
 
 RenderFrameDevToolsAgentHost::RenderFrameDevToolsAgentHost(
@@ -322,6 +325,9 @@
 #if BUILDFLAG(USE_VIZ_DEBUGGER)
   session->CreateAndAddHandler<protocol::VisualDebuggerHandler>();
 #endif
+  RenderWidgetHostViewBase* view =
+    static_cast<RenderWidgetHostViewBase*>(web_contents()->GetPrimaryMainFrame()->GetView());
+  if (!view->IsRenderWidgetHostViewChildFrame())
   if (!frame_tree_node_ || !frame_tree_node_->parent())
     session->CreateAndAddHandler<protocol::OverlayHandler>();
   session->CreateAndAddHandler<protocol::NetworkHandler>(
diff -r -u --color up/chromium/content/browser/gpu/gpu_process_host.cc nw/chromium/content/browser/gpu/gpu_process_host.cc
--- up/chromium/content/browser/gpu/gpu_process_host.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/gpu/gpu_process_host.cc	2023-01-28 02:49:28.207617578 +0000
@@ -742,7 +742,8 @@
       valid_(true),
       in_process_(false),
       kind_(kind),
-      process_launched_(false) {
+      process_launched_(false),
+      closing_(false) {
   if (base::CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kSingleProcess) ||
       base::CommandLine::ForCurrentProcess()->HasSwitch(
@@ -774,6 +775,7 @@
   if (in_process_gpu_thread_)
     DCHECK(process_);
 
+  closing_ = true;
   SendOutstandingReplies();
 
 #if BUILDFLAG(IS_MAC)
@@ -902,6 +904,8 @@
 bool GpuProcessHost::Init() {
   init_start_time_ = base::TimeTicks::Now();
 
+  if (in_process_ && closing_)
+    return true;
   TRACE_EVENT_INSTANT0("gpu", "LaunchGpuProcess", TRACE_EVENT_SCOPE_THREAD);
 
   process_->GetHost()->CreateChannelMojo();
diff -r -u --color up/chromium/content/browser/gpu/gpu_process_host.h nw/chromium/content/browser/gpu/gpu_process_host.h
--- up/chromium/content/browser/gpu/gpu_process_host.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/gpu/gpu_process_host.h	2023-01-28 02:49:28.207617578 +0000
@@ -239,6 +239,8 @@
   // The GPU process reported failure to initialize.
   bool did_fail_initialize_ = false;
 
+  bool closing_;
+
   // The total number of GPU process crashes.
   static base::subtle::Atomic32 gpu_crash_count_;
   static bool crashed_before_;
diff -r -u --color up/chromium/content/browser/media/capture/desktop_streams_registry_impl.cc nw/chromium/content/browser/media/capture/desktop_streams_registry_impl.cc
--- up/chromium/content/browser/media/capture/desktop_streams_registry_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/media/capture/desktop_streams_registry_impl.cc	2023-01-28 02:49:28.239617916 +0000
@@ -79,7 +79,7 @@
     int render_frame_id,
     const url::Origin& origin,
     std::string* extension_name,
-    const DesktopStreamRegistryType type) {
+    const DesktopStreamRegistryType type, bool nodejs) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
 
   auto it = approved_streams_.find(id);
@@ -88,8 +88,8 @@
   // the same origin and the same renderer.
   if (it == approved_streams_.end() ||
       render_process_id != it->second.render_process_id ||
-      render_frame_id != it->second.render_frame_id ||
-      origin != it->second.origin || type != it->second.type) {
+      (!nodejs && render_frame_id != it->second.render_frame_id) ||
+      (!nodejs && origin != it->second.origin) || type != it->second.type) {
     return DesktopMediaID();
   }
 
diff -r -u --color up/chromium/content/browser/media/capture/desktop_streams_registry_impl.h nw/chromium/content/browser/media/capture/desktop_streams_registry_impl.h
--- up/chromium/content/browser/media/capture/desktop_streams_registry_impl.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/media/capture/desktop_streams_registry_impl.h	2023-01-28 02:49:28.239617916 +0000
@@ -40,7 +40,7 @@
       int render_frame_id,
       const url::Origin& origin,
       std::string* extension_name,
-      const DesktopStreamRegistryType type) override;
+      const DesktopStreamRegistryType type, bool nodejs = false) override;
 
  private:
   // Type used to store list of accepted desktop media streams.
diff -r -u --color up/chromium/content/browser/network_service_instance_impl.cc nw/chromium/content/browser/network_service_instance_impl.cc
--- up/chromium/content/browser/network_service_instance_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/network_service_instance_impl.cc	2023-01-28 02:49:28.259618127 +0000
@@ -941,9 +941,11 @@
     if (!params->file_paths->unsandboxed_data_path)
       grant_result = SandboxGrantResult::kDidNotAttemptToGrantSandboxAccess;
   }
+#endif
+#if 1 //BUILDFLAG(IS_ANDROID)
   // Create network context immediately without thread hops.
   CreateNetworkContextInternal(std::move(context), std::move(params),
-                               grant_result);
+                               SandboxGrantResult::kDidNotAttemptToGrantSandboxAccess);
 #else
   // Restrict disk access to a certain path (on another thread) and continue
   // with network context creation.
diff -r -u --color up/chromium/content/browser/renderer_host/ancestor_throttle.cc nw/chromium/content/browser/renderer_host/ancestor_throttle.cc
--- up/chromium/content/browser/renderer_host/ancestor_throttle.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/ancestor_throttle.cc	2023-01-28 02:49:28.283618381 +0000
@@ -214,6 +214,8 @@
   NavigationRequest* request = NavigationRequest::From(navigation_handle());
   network::mojom::XFrameOptionsValue disposition =
       request->response()->parsed_headers->xfo;
+  if (request->frame_tree_node()->frame_owner_properties().nwfaketop)
+    return CheckResult::PROCEED;
 
   // If 'X-Frame-Options' would potentially block the response, check whether
   // the 'frame-ancestors' CSP directive should take effect instead. See
@@ -320,7 +322,13 @@
       GetParentExceptForFencedFrame(static_cast<RenderFrameHostImpl*>(
           navigation_handle()->GetRenderFrameHost()));
 
+  if (static_cast<RenderFrameHostImpl*>(navigation_handle()->GetRenderFrameHost())->
+      frame_tree_node()->frame_owner_properties().nwfaketop)
+    return CheckResult::PROCEED;
+
   while (parent) {
+    if (parent->frame_tree_node()->frame_owner_properties().nwfaketop)
+      break;
     // CSP violations (if any) are reported via the disallowed ancestor of the
     // navigated frame (because while the throttle runs the navigation hasn't
     // committed yet and the target frame might not yet have a URLLoaderFactory
diff -r -u --color up/chromium/content/browser/renderer_host/input/touch_emulator.cc nw/chromium/content/browser/renderer_host/input/touch_emulator.cc
--- up/chromium/content/browser/renderer_host/input/touch_emulator.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/input/touch_emulator.cc	2023-01-28 02:49:28.299618550 +0000
@@ -5,6 +5,8 @@
 #include "content/browser/renderer_host/input/touch_emulator.h"
 
 #include <memory>
+#include "content/public/browser/render_frame_host.h"
+#include "content/browser/renderer_host/render_frame_host_impl.h"
 
 #include "base/containers/queue.h"
 #include "base/time/time.h"
@@ -69,6 +71,7 @@
 TouchEmulator::TouchEmulator(TouchEmulatorClient* client,
                              float device_scale_factor)
     : client_(client),
+      rfh_limit_(nullptr),
       gesture_provider_config_type_(
           ui::GestureProviderConfigType::CURRENT_PLATFORM),
       double_tap_enabled_(true),
@@ -183,6 +186,11 @@
   if (!enabled() || mode_ != Mode::kEmulatingTouchFromMouse)
     return false;
 
+  if (rfh_limit_) {
+    if (rfh_limit_->GetView() != target_view)
+      return false;
+  }
+
   UpdateCursor();
 
   if (mouse_event.button == WebMouseEvent::Button::kRight &&
diff -r -u --color up/chromium/content/browser/renderer_host/input/touch_emulator.h nw/chromium/content/browser/renderer_host/input/touch_emulator.h
--- up/chromium/content/browser/renderer_host/input/touch_emulator.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/input/touch_emulator.h	2023-01-28 02:49:28.299618550 +0000
@@ -7,6 +7,8 @@
 
 #include <memory>
 
+#include "base/memory/weak_ptr.h"
+
 #include "base/callback.h"
 #include "base/containers/queue.h"
 #include "base/memory/raw_ptr.h"
@@ -29,6 +31,8 @@
 namespace content {
 
 class RenderWidgetHostViewBase;
+class RenderFrameHost;
+class RenderFrameHostImpl;
 
 // Emulates touch input. See TouchEmulator::Mode for more details.
 class CONTENT_EXPORT TouchEmulator : public ui::GestureProviderClient {
@@ -52,6 +56,8 @@
   void Enable(Mode mode, ui::GestureProviderConfigType config_type);
   void Disable();
 
+  void set_rfh_limit(base::WeakPtr<RenderFrameHostImpl> rfh) { rfh_limit_ = rfh; }
+  RenderFrameHost* rfh_limit() const { return (RenderFrameHost*)rfh_limit_.get(); }
   // Call when device scale factor changes.
   void SetDeviceScaleFactor(float device_scale_factor);
 
@@ -138,6 +144,7 @@
 
   const raw_ptr<TouchEmulatorClient> client_;
 
+  base::WeakPtr<RenderFrameHostImpl> rfh_limit_;
   // Emulator is enabled iff gesture provider is created.
   // Disabled emulator does only process touch acks left from previous
   // emulation. It does not intercept any events.
diff -r -u --color up/chromium/content/browser/renderer_host/navigation_controller_impl.cc nw/chromium/content/browser/renderer_host/navigation_controller_impl.cc
--- up/chromium/content/browser/renderer_host/navigation_controller_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/navigation_controller_impl.cc	2023-01-28 02:49:28.311618677 +0000
@@ -718,7 +718,7 @@
     BrowserContext* browser_context,
     FrameTree& frame_tree,
     NavigationControllerDelegate* delegate)
-    : frame_tree_(frame_tree),
+  : history_initiator_(nullptr), frame_tree_(frame_tree),
       browser_context_(browser_context),
       delegate_(delegate),
       ssl_manager_(this),
@@ -3303,13 +3303,23 @@
   // function.
   std::unique_ptr<PendingEntryRef> pending_entry_ref = ReferencePendingEntry();
 
+  FrameTreeNode* nwfaketop_node = nullptr;
+  if (history_initiator_) {
+    if (history_initiator_->frame_tree_node()->frame_owner_properties().nwfaketop)
+      nwfaketop_node = history_initiator_->frame_tree_node();
+  }
+
   // Send all the same document frame loads before the different document loads.
   for (auto& item : same_document_loads) {
     FrameTreeNode* frame = item->frame_tree_node();
+    if (nwfaketop_node && nwfaketop_node->current_frame_host()->IsDescendantOfWithinFrameTree(frame->current_frame_host()))
+      continue;
     frame->navigator().Navigate(std::move(item), reload_type);
   }
   for (auto& item : different_document_loads) {
     FrameTreeNode* frame = item->frame_tree_node();
+    if (nwfaketop_node && nwfaketop_node->current_frame_host()->IsDescendantOfWithinFrameTree(frame->current_frame_host()))
+      continue;
     frame->navigator().Navigate(std::move(item), reload_type);
   }
 
diff -r -u --color up/chromium/content/browser/renderer_host/navigation_controller_impl.h nw/chromium/content/browser/renderer_host/navigation_controller_impl.h
--- up/chromium/content/browser/renderer_host/navigation_controller_impl.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/navigation_controller_impl.h	2023-01-28 02:49:28.311618677 +0000
@@ -85,6 +85,7 @@
     base::WeakPtr<NavigationControllerImpl> controller_;
   };
 
+  void set_history_initiator(RenderFrameHostImpl* frame_host) { history_initiator_ = frame_host; }
   NavigationControllerImpl(BrowserContext* browser_context,
                            FrameTree& frame_tree,
                            NavigationControllerDelegate* delegate);
@@ -443,6 +444,7 @@
  private:
   friend class RestoreHelper;
 
+  RenderFrameHostImpl* history_initiator_;
   FRIEND_TEST_ALL_PREFIXES(TimeSmoother, Basic);
   FRIEND_TEST_ALL_PREFIXES(TimeSmoother, SingleDuplicate);
   FRIEND_TEST_ALL_PREFIXES(TimeSmoother, ManyDuplicates);
diff -r -u --color up/chromium/content/browser/renderer_host/navigation_request.cc nw/chromium/content/browser/renderer_host/navigation_request.cc
--- up/chromium/content/browser/renderer_host/navigation_request.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/navigation_request.cc	2023-01-28 02:49:28.319618761 +0000
@@ -178,6 +178,11 @@
 #include "ui/android/window_android_compositor.h"
 #endif
 
+namespace nw {
+  typedef bool(*RphGuestFilterURLHookFn)(content::RenderProcessHost* rph, const GURL* url);
+  extern RphGuestFilterURLHookFn gRphGuestFilterURLHook;
+}
+
 namespace content {
 
 namespace {
@@ -1752,6 +1757,16 @@
           common_params_->url);
       headers.MergeFrom(client_hints_headers);
     }
+    FrameTreeNode* node = frame_tree_node;
+    std::string user_agent_override = GetUserAgentOverride();
+    while (node) {
+      const std::string& nwuseragent = node->frame_owner_properties().nwuseragent;
+      if (!nwuseragent.empty()) {
+        user_agent_override = nwuseragent;
+        break;
+      }
+      node = FrameTreeNode::From(node->parent());
+    }
 
     // Add reduced accept language header.
     if (auto reduce_accept_lang_utils =
@@ -1776,7 +1791,7 @@
         &headers, common_params_->url, common_params_->navigation_type,
         ui::PageTransitionFromInt(common_params_->transition),
         controller->GetBrowserContext(), common_params_->method,
-        GetUserAgentOverride(), common_params_->initiator_origin,
+        user_agent_override, common_params_->initiator_origin,
         common_params_->referrer.get(), frame_tree_node,
         begin_params_->impression.has_value());
 
@@ -4399,6 +4414,17 @@
   if (navigation_ui_data_)
     navigation_ui_data = navigation_ui_data_->Clone();
 
+  bool nw_trusted = false;
+  if (starting_site_instance_->IsGuest()) {
+    GURL dummy;
+    RenderFrameHostImpl* navigating_frame_host =
+      associated_rfh_type_ == AssociatedRenderFrameHostType::SPECULATIVE
+          ? frame_tree_node_->render_manager()->speculative_frame_host()
+          : frame_tree_node_->current_frame_host();
+    RenderProcessHost* render_process_host = navigating_frame_host->GetProcess();
+    if (nw::gRphGuestFilterURLHook && nw::gRphGuestFilterURLHook(render_process_host, &dummy))
+      nw_trusted = true;
+  }
   // Give DevTools a chance to override begin params (headers, skip SW)
   // before actually loading resource.
   bool report_raw_headers = false;
@@ -4537,7 +4563,7 @@
                                    : nullptr,
           devtools_navigation_token(), frame_tree_node_->devtools_frame_token(),
           std::move(cors_exempt_headers), std::move(client_security_state),
-          devtools_accepted_stream_types, is_pdf_, initiator_document_),
+          devtools_accepted_stream_types, is_pdf_, initiator_document_, nw_trusted),
       std::move(navigation_ui_data), service_worker_handle_.get(),
       std::move(prefetched_signed_exchange_cache_), this, loader_type,
       CreateCookieAccessObserver(),
diff -r -u --color up/chromium/content/browser/renderer_host/navigation_request_info.cc nw/chromium/content/browser/renderer_host/navigation_request_info.cc
--- up/chromium/content/browser/renderer_host/navigation_request_info.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/navigation_request_info.cc	2023-01-28 02:49:28.319618761 +0000
@@ -30,7 +30,8 @@
     const absl::optional<std::vector<net::SourceStream::SourceType>>&
         devtools_accepted_stream_types,
     bool is_pdf,
-    WeakDocumentPtr initiator_document)
+    WeakDocumentPtr initiator_document,
+    bool nw_trusted)
     : common_params(std::move(common_params)),
       begin_params(std::move(begin_params)),
       sandbox_flags(sandbox_flags),
@@ -49,7 +50,8 @@
       client_security_state(std::move(client_security_state)),
       devtools_accepted_stream_types(devtools_accepted_stream_types),
       is_pdf(is_pdf),
-      initiator_document(std::move(initiator_document)) {}
+      initiator_document(std::move(initiator_document)),
+      nw_trusted(nw_trusted) {}
 
 NavigationRequestInfo::~NavigationRequestInfo() {}
 
diff -r -u --color up/chromium/content/browser/renderer_host/navigation_request_info.h nw/chromium/content/browser/renderer_host/navigation_request_info.h
--- up/chromium/content/browser/renderer_host/navigation_request_info.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/navigation_request_info.h	2023-01-28 02:49:28.319618761 +0000
@@ -46,7 +46,8 @@
       const absl::optional<std::vector<net::SourceStream::SourceType>>&
           devtools_accepted_stream_types,
       bool is_pdf,
-      WeakDocumentPtr initiator_document);
+      WeakDocumentPtr initiator_document,
+      bool nw_trust = false);
   NavigationRequestInfo(const NavigationRequestInfo& other) = delete;
   ~NavigationRequestInfo();
 
@@ -129,6 +130,8 @@
 
   // The initiator document, if still available.
   const WeakDocumentPtr initiator_document;
+
+  bool nw_trusted;
 };
 
 }  // namespace content
diff -r -u --color up/chromium/content/browser/renderer_host/navigator.cc nw/chromium/content/browser/renderer_host/navigator.cc
--- up/chromium/content/browser/renderer_host/navigator.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/navigator.cc	2023-01-28 02:49:28.319618761 +0000
@@ -58,6 +58,11 @@
 #include "url/gurl.h"
 #include "url/url_util.h"
 
+namespace nw {
+  typedef bool(*RphGuestFilterURLHookFn)(content::RenderProcessHost* rph, const GURL* url);
+  extern RphGuestFilterURLHookFn gRphGuestFilterURLHook;
+}
+
 namespace content {
 
 namespace {
diff -r -u --color up/chromium/content/browser/renderer_host/render_frame_host_delegate.h nw/chromium/content/browser/renderer_host/render_frame_host_delegate.h
--- up/chromium/content/browser/renderer_host/render_frame_host_delegate.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/render_frame_host_delegate.h	2023-01-28 02:49:28.327618846 +0000
@@ -423,7 +423,7 @@
       int main_frame_widget_route_id,
       WindowOpenDisposition disposition,
       const blink::mojom::WindowFeatures& window_features,
-      bool user_gesture) {}
+      bool user_gesture, std::string manifest) {}
 
   // The main frame document element is ready. This happens when the document
   // has finished parsing.
diff -r -u --color up/chromium/content/browser/renderer_host/render_frame_host_impl.cc nw/chromium/content/browser/renderer_host/render_frame_host_impl.cc
--- up/chromium/content/browser/renderer_host/render_frame_host_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/render_frame_host_impl.cc	2023-01-28 02:49:28.331618888 +0000
@@ -1,6 +1,7 @@
 // Copyright 2013 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wunreachable-code"
 
 #include "content/browser/renderer_host/render_frame_host_impl.h"
 
@@ -1468,6 +1469,14 @@
   GetCodeCacheHostReceiverHandler() = handler;
 }
 
+void RenderFrameHostImpl::SetNodeJS(bool node) {
+  nodejs_ = node;
+}
+
+void RenderFrameHostImpl::SetContextCreated(bool created) {
+  context_created_ = created;
+}
+
 RenderFrameHostImpl::RenderFrameHostImpl(
     SiteInstance* site_instance,
     scoped_refptr<RenderViewHostImpl> render_view_host,
@@ -1498,6 +1507,8 @@
       depth_(parent_ ? parent_->GetFrameDepth() + 1 : 0),
       last_committed_site_info_(site_instance_->GetBrowserContext()),
       routing_id_(routing_id),
+      nodejs_(false),
+      context_created_(false),
       beforeunload_timeout_delay_(RenderViewHostImpl::kUnloadTimeout),
       frame_(std::move(frame_remote)),
       waiting_for_init_(renderer_initiated_creation_of_main_frame),
@@ -1812,6 +1823,14 @@
   TRACE_EVENT_END("navigation", perfetto::Track::FromPointer(this));
 }
 
+bool RenderFrameHostImpl::nodejs() {
+  return nodejs_;
+}
+
+bool RenderFrameHostImpl::context_created() {
+  return context_created_;
+}
+
 int RenderFrameHostImpl::GetRoutingID() const {
   return routing_id_;
 }
@@ -3853,7 +3872,8 @@
 
 const url::Origin& RenderFrameHostImpl::ComputeTopFrameOrigin(
     const url::Origin& frame_origin) const {
-  if (is_main_frame()) {
+  if (is_main_frame()
+      || frame_tree_node_->frame_owner_properties().nwfaketop) {
     return frame_origin;
   }
 
@@ -3885,8 +3905,9 @@
     bool is_anonymous,
     absl::optional<base::UnguessableToken> fenced_frame_nonce_for_navigation) {
   net::IsolationInfo::RequestType request_type =
-      is_main_frame() ? net::IsolationInfo::RequestType::kMainFrame
-                      : net::IsolationInfo::RequestType::kSubFrame;
+    (is_main_frame() || frame_tree_node_->frame_owner_properties().nwfaketop)
+          ? net::IsolationInfo::RequestType::kMainFrame
+          : net::IsolationInfo::RequestType::kSubFrame;
   return ComputeIsolationInfoInternal(url::Origin::Create(destination),
                                       request_type, is_anonymous,
                                       fenced_frame_nonce_for_navigation);
@@ -3912,6 +3933,8 @@
     bool is_anonymous,
     absl::optional<base::UnguessableToken> fenced_frame_nonce_for_navigation) {
   url::Origin top_frame_origin = ComputeTopFrameOrigin(frame_origin);
+  if (frame_tree_node_->frame_owner_properties().nwfaketop)
+    top_frame_origin = frame_tree_node_->current_frame_host()->GetLastCommittedOrigin();
   net::SchemefulSite top_frame_site = net::SchemefulSite(top_frame_origin);
 
   net::SiteForCookies candidate_site_for_cookies(top_frame_site);
@@ -3933,6 +3956,8 @@
     initial_rfh = this->parent_;
 
   for (const RenderFrameHostImpl* rfh = initial_rfh; rfh; rfh = rfh->parent_) {
+    if (rfh->frame_tree_node_->frame_owner_properties().nwfaketop)
+      break;
     const url::Origin& cur_origin =
         rfh == this ? frame_origin : rfh->last_committed_origin_;
     net::SchemefulSite cur_site = net::SchemefulSite(cur_origin);
@@ -5350,9 +5375,11 @@
     WindowOpenDisposition disposition,
     blink::mojom::WindowFeaturesPtr window_features,
     bool user_gesture,
+    const std::u16string& in_manifest,
     ShowCreatedWindowCallback callback) {
   // This needs to be sent to the opener frame's delegate since it stores
   // the handle to this class's associated RenderWidgetHostView.
+  std::string manifest = base::UTF16ToUTF8(in_manifest);
   RenderFrameHostImpl* opener_frame_host =
       FromFrameToken(GetProcess()->GetID(), opener_frame_token);
 
@@ -5366,7 +5393,7 @@
   }
   opener_frame_host->delegate()->ShowCreatedWindow(
       opener_frame_host, GetRenderWidgetHost()->GetRoutingID(), disposition,
-      *window_features, user_gesture);
+      *window_features, user_gesture, manifest);
   std::move(callback).Run();
 }
 
@@ -5591,7 +5618,7 @@
 
 void RenderFrameHostImpl::AllowBindings(int bindings_flags) {
   // Never grant any bindings to browser plugin guests.
-  if (GetProcess()->IsForGuestsOnly()) {
+  if (false && GetProcess()->IsForGuestsOnly()) {
     NOTREACHED() << "Never grant bindings to a guest process.";
     return;
   }
@@ -5679,6 +5706,8 @@
 
 bool RenderFrameHostImpl::IsFeatureEnabled(
     blink::mojom::PermissionsPolicyFeature feature) {
+  if (nodejs_)
+    return true; //NWJS#6696
   return permissions_policy_ && permissions_policy_->IsFeatureEnabledForOrigin(
                                     feature, GetLastCommittedOrigin());
 }
@@ -6159,7 +6188,9 @@
 
   // All frames are allowed to navigate the global history.
   if (delegate_->IsAllowedToGoToEntryAtOffset(offset)) {
+    frame_tree_->controller().set_history_initiator(this);
     frame_tree_->controller().GoToOffsetFromRenderer(offset, this);
+    frame_tree_->controller().set_history_initiator(nullptr);
   }
 }
 
@@ -6473,10 +6504,10 @@
   // CanEnterFullscreenWithoutUserActivation is only ever true in tests, to
   // allow fullscreen when mocking screen orientation changes.
   if (!delegate_->HasSeenRecentScreenOrientationChange() &&
-      !WindowManagementAllowsFullscreen() && !HasSeenRecentXrOverlaySetup() &&
+      !WindowManagementAllowsFullscreen() && !HasSeenRecentXrOverlaySetup() && (!nodejs_ &&
       !GetContentClient()
            ->browser()
-           ->CanEnterFullscreenWithoutUserActivation()) {
+           ->CanEnterFullscreenWithoutUserActivation())) {
     // Consume any transient user activation and delegated fullscreen token.
     // Reject requests made without transient user activation or a token.
     // TODO(lanwei): Investigate whether we can terminate the renderer when
@@ -8949,11 +8980,19 @@
     subresource_loader_factories->pending_default_factory() =
         std::move(pending_default_factory);
 
+    bool can_load_file_subresource = false;
+    WebContents* web_contents = WebContents::FromRenderFrameHost(this);
+    if (web_contents) {
+      auto* delegate = web_contents->GetDelegate();
+      if (delegate && delegate->CanLoadFileSubresource(common_params->url))
+        can_load_file_subresource = true;
+    }
+
     // Only documents from a file precursor scheme can load file subresoruces.
     //
     // For loading Web Bundle files, we don't set FileURLLoaderFactory.
     // Because loading local files from a Web Bundle file is prohibited.
-    if (effective_scheme == url::kFileScheme && !navigation_to_web_bundle) {
+    if (can_load_file_subresource || (effective_scheme == url::kFileScheme && !navigation_to_web_bundle)) {
       // USER_BLOCKING because this scenario is exactly one of the examples
       // given by the doc comment for USER_BLOCKING: Loading and rendering a web
       // page after the user clicks a link.
@@ -9326,7 +9365,7 @@
   }
 
   // It is not expected for GuestView to be able to navigate to WebUI.
-  DCHECK(!GetProcess()->IsForGuestsOnly());
+  //DCHECK(!GetProcess()->IsForGuestsOnly());
 
   web_ui_type_ = new_web_ui_type;
 
@@ -11068,7 +11107,8 @@
   // Commits in the error page process must only be failures, otherwise
   // successful navigations could commit documents from origins different
   // than the chrome-error://chromewebdata/ one and violate expectations.
-  if (should_commit_error_page &&
+  // NWJS: different process model where the pages are in the same process
+  if (false && should_commit_error_page &&
       (navigation_request && !navigation_request->DidEncounterError())) {
     DEBUG_ALIAS_FOR_ORIGIN(origin_debug_alias, params->origin);
     bad_message::ReceivedBadMessage(
diff -r -u --color up/chromium/content/browser/renderer_host/render_frame_host_impl.h nw/chromium/content/browser/renderer_host/render_frame_host_impl.h
--- up/chromium/content/browser/renderer_host/render_frame_host_impl.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/render_frame_host_impl.h	2023-01-28 02:49:28.331618888 +0000
@@ -370,6 +370,8 @@
                              size_t max_nodes,
                              const base::TimeDelta& timeout) override;
   void RequestDistilledAXTree(AXTreeDistillerCallback callback) override;
+  bool nodejs() override;
+  bool context_created() override;
   SiteInstanceImpl* GetSiteInstance() const override;
   RenderProcessHost* GetProcess() const override;
   GlobalRenderFrameHostId GetGlobalId() const override;
@@ -2320,6 +2322,7 @@
                          WindowOpenDisposition disposition,
                          blink::mojom::WindowFeaturesPtr window_features,
                          bool user_gesture,
+                         const std::u16string& manifest,
                          ShowCreatedWindowCallback callback) override;
   void SetWindowRect(const gfx::Rect& bounds,
                      SetWindowRectCallback callback) override;
@@ -2914,8 +2917,9 @@
   // itself.
   // This does not consider inner frame trees (i.e. not accounting for fenced
   // frames, portals or GuestView).
+ public:
   bool IsDescendantOfWithinFrameTree(RenderFrameHostImpl* ancestor);
-
+ private:
   // mojom::FrameHost:
   void CreateNewWindow(mojom::CreateNewWindowParamsPtr params,
                        CreateNewWindowCallback callback) override;
@@ -2990,6 +2994,8 @@
   void HandleAXLocationChanges(
       const ui::AXTreeID& tree_id,
       std::vector<blink::mojom::LocationChangesPtr> changes);
+  void SetNodeJS(bool node) override;
+  void SetContextCreated(bool created) override;
 
   // mojom::DomAutomationControllerHost:
   void DomOperationResponse(const std::string& json_string) override;
@@ -3829,6 +3835,10 @@
   };
   RenderFrameState render_frame_state_ = RenderFrameState::kNeverCreated;
 
+  bool nodejs_;
+
+  bool context_created_;
+
   // When the last BeforeUnload message was sent.
   base::TimeTicks send_before_unload_start_time_;
 
diff -r -u --color up/chromium/content/browser/renderer_host/render_frame_host_manager.cc nw/chromium/content/browser/renderer_host/render_frame_host_manager.cc
--- up/chromium/content/browser/renderer_host/render_frame_host_manager.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/render_frame_host_manager.cc	2023-01-28 02:49:28.335618931 +0000
@@ -81,6 +81,11 @@
 #include "ui/gfx/mac/scoped_cocoa_disable_screen_updates.h"
 #endif  // BUILDFLAG(IS_MAC)
 
+namespace nw {
+typedef bool(*GuestSwapProcessHookFn)(content::BrowserContext*, const GURL& url);
+CONTENT_EXPORT GuestSwapProcessHookFn gGuestSwapProcessHook = nullptr;
+}
+
 namespace content {
 
 using LifecycleStateImpl = RenderFrameHostImpl::LifecycleStateImpl;
@@ -1184,7 +1189,7 @@
     if (WebUIControllerFactoryRegistry::GetInstance()->UseWebUIForURL(
             browser_context, request->common_params().url) &&
         request->state() < NavigationRequest::CANCELING) {
-      if (render_frame_host_->has_committed_any_navigation()) {
+      if (render_frame_host_->has_committed_any_navigation() && render_frame_host_->web_ui()) {
         // If |render_frame_host_| has committed at least one navigation and it
         // is in a WebUI SiteInstance, then it must have the exact same WebUI
         // type if it will be reused.
@@ -1954,11 +1959,15 @@
   DCHECK(!source_instance || !dest_instance);
 
   SiteInstance* current_instance = render_frame_host_->GetSiteInstance();
+  BrowserContext* browser_context =
+      GetNavigationController().GetBrowserContext();
 
   // Do not currently swap processes for navigations in webview tag guests,
   // unless site isolation is enabled for them.
   if (current_instance->IsGuest() &&
-      !SiteIsolationPolicy::IsSiteIsolationForGuestsEnabled()) {
+      !SiteIsolationPolicy::IsSiteIsolationForGuestsEnabled() &&
+      !(nw::gGuestSwapProcessHook && nw::gGuestSwapProcessHook(browser_context,
+                                                               dest_url_info.url))) {
     AppendReason(reason,
                  "GetSiteInstanceForNavigation => current_instance (IsGuest)");
     return current_instance;
@@ -1978,8 +1987,6 @@
   // whether to use a new SiteInstance. This happens when navigating a subframe,
   // or when a new RenderFrameHost has been swapped in at the beginning of a
   // navigation to replace a crashed RenderFrameHost.
-  BrowserContext* browser_context =
-      GetNavigationController().GetBrowserContext();
   const GURL& current_effective_url =
       !render_frame_host_->last_successful_url().is_empty()
           ? SiteInstanceImpl::GetEffectiveURL(
diff -r -u --color up/chromium/content/browser/renderer_host/render_process_host_impl.cc nw/chromium/content/browser/renderer_host/render_process_host_impl.cc
--- up/chromium/content/browser/renderer_host/render_process_host_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/render_process_host_impl.cc	2023-01-28 02:49:28.339618973 +0000
@@ -119,6 +119,7 @@
 #include "content/browser/renderer_host/render_message_filter.h"
 #include "content/browser/renderer_host/render_widget_helper.h"
 #include "content/browser/renderer_host/renderer_sandboxed_process_launcher_delegate.h"
+#include "content/browser/resolve_proxy_helper.h"
 #include "content/browser/service_worker/service_worker_context_wrapper.h"
 #include "content/browser/site_info.h"
 #include "content/browser/site_instance_impl.h"
@@ -281,6 +282,15 @@
 #define MAYBEVLOG DVLOG
 #endif
 
+#include "content/nw/src/common/shell_switches.h"
+#include "content/nw/src/browser/nw_content_browser_hooks.h"
+
+namespace nw {
+typedef bool (*RphGuestFilterURLHookFn)(content::RenderProcessHost* rph, const GURL* url);
+CONTENT_EXPORT RphGuestFilterURLHookFn gRphGuestFilterURLHook = nullptr;
+void LoadNodeSymbols();
+}
+
 namespace content {
 
 namespace {
@@ -298,6 +308,8 @@
 base::Thread* g_in_process_thread = nullptr;
 
 RenderProcessHostFactory* g_render_process_host_factory_ = nullptr;
+RenderProcessHostImpl* g_main_host = nullptr;
+
 const char kSiteProcessMapKeyName[] = "content_site_process_map";
 
 RenderProcessHost::AnalyzeHungRendererFunction g_analyze_hung_renderer =
@@ -1510,6 +1522,7 @@
                     ChromeTrackEvent::kRenderProcessHost, *this);
 
   widget_helper_ = new RenderWidgetHelper();
+  resolve_proxy_helper_ = new ResolveProxyHelper(GetID());
 
   ChildProcessSecurityPolicyImpl::GetInstance()->Add(GetID(), browser_context);
 
@@ -1722,6 +1735,8 @@
       AttributionManager::GetOsSupport());
 
   if (run_renderer_in_process()) {
+    base::ScopedAllowBlocking allow_io;
+    nw::LoadNodeSymbols();
     DCHECK(g_renderer_main_thread_factory);
     // Crank up a thread and run the initialization there.  With the way that
     // messages flow between the browser and renderer, this thread is required
@@ -1743,6 +1758,8 @@
     // in-process plugins.
     options.message_pump_type = base::MessagePumpType::DEFAULT;
 #endif
+    options.message_pump_type = base::MessagePumpType::NODE;
+
     // As for execution sequence, this callback should have no any dependency
     // on starting in-process-render-thread.
     // So put it here to trigger ChannelMojo initialization earlier to enable
@@ -3213,6 +3230,18 @@
   }
 #endif
 
+  bool allow_nw = false;
+  if (IsForGuestsOnly()) {
+    if (nw::GetInWebViewApplyAttr(&allow_nw) && allow_nw)
+      command_line->AppendSwitch("nwjs-guest-nw");
+    else
+      command_line->AppendSwitch("nwjs-guest");
+  }
+
+  if (nw::MixedContext()) {
+    command_line->AppendSwitch("mixed-context");
+  }
+
 #if BUILDFLAG(IS_WIN)
   command_line->AppendSwitchASCII(
       switches::kDeviceScaleFactor,
@@ -3239,6 +3268,7 @@
   // Propagate the following switches to the renderer command line (along
   // with any associated values) if present in the browser command line.
   static const char* const kSwitchNames[] = {
+    "nwjs-test-mode",
     switches::kDisableInProcessStackTraces,
     sandbox::policy::switches::kDisableSeccompFilterSandbox,
     sandbox::policy::switches::kNoSandbox,
@@ -3250,6 +3280,9 @@
     // Allow this to be set when invoking the browser and relayed along.
     sandbox::policy::switches::kEnableSandboxLogging,
 #endif
+    switches::kDisableRAFThrottling,
+    switches::kEnableNodeWorker,
+    switches::kEnableSpellChecking,
     switches::kAllowLoopbackInPeerConnection,
     switches::kAndroidFontsPath,
     switches::kAudioBufferSize,
@@ -4090,6 +4123,16 @@
   GetAllHosts().AddWithID(host, host_id);
 }
 
+void RenderProcessHostImpl::set_main_host() {
+  g_main_host = this;
+}
+
+RenderProcessHostImpl* RenderProcessHostImpl::main_host() {
+  return g_main_host;
+}
+
+extern bool g_browser_main_loop_shutting_down;
+
 // static
 void RenderProcessHostImpl::UnregisterHost(int host_id) {
   RenderProcessHost* host = GetAllHosts().Lookup(host_id);
@@ -4111,6 +4154,12 @@
                           host->GetBrowserContext()->GetUserData(
                               kCommittedSiteProcessCountTrackerKey)));
 
+  if (g_main_host == host)
+    g_main_host = nullptr;
+
+  if (run_renderer_in_process() && g_browser_main_loop_shutting_down)
+    return; //or the following line will crash because browser context
+            //has been destroyed
   // Look up the map of site to process for the given browser_context,
   // in case we need to remove this process from it.  It will be registered
   // under any sites it rendered that use process-per-site mode.
@@ -4162,6 +4211,8 @@
     TRACE_EVENT2("navigation",
                  "RenderProcessHost::FilterURL - failed CanRequestURL",
                  "process_id", rph->GetID(), "url", url->spec());
+    if (nw::gRphGuestFilterURLHook && nw::gRphGuestFilterURLHook(rph, url))
+      return;
     VLOG(1) << "Blocked URL " << url->spec();
     *url = GURL(kBlockedURL);
   }
@@ -4411,8 +4462,11 @@
                                       .spare_render_process_host()) {
       continue;
     }
-    if (MayReuseAndIsSuitable(iter.GetCurrentValue(), site_instance))
+    if (MayReuseAndIsSuitable(iter.GetCurrentValue(), site_instance)) {
+      if (iter.GetCurrentValue() == g_main_host)
+        return g_main_host;
       suitable_renderers.push_back(iter.GetCurrentValue());
+    }
   }
 
   MAYBEVLOG(4) << __func__ << ": Found " << suitable_renderers.size()
@@ -4421,9 +4475,12 @@
 
   // Now pick a random suitable renderer, if we have any.
   if (!suitable_renderers.empty()) {
-    int suitable_count = static_cast<int>(suitable_renderers.size());
-    int random_index = base::RandInt(0, suitable_count - 1);
-    return suitable_renderers[random_index];
+    //int suitable_count = static_cast<int>(suitable_renderers.size());
+    //int random_index = base::RandInt(0, suitable_count - 1);
+    //return suitable_renderers[random_index];
+    //NWJS: reuse first renderer, the main process for valid nw.Window.open
+    //callback value. see also app_window_api.cc:416
+    return suitable_renderers[0];
   }
 
   return nullptr;
@@ -4468,6 +4525,11 @@
   // use process-per-site mode.  We cannot check whether the process has
   // appropriate bindings here, because the bindings have not yet been
   // granted.
+  // don't register process when we're opening new_instance window, or
+  // the map slot will be took over and following same-instance window
+  // opening will return null; NWJS#4691
+  if (!nw::PinningRenderer())
+    return;
   if (!site_instance->GetSiteInfo().is_empty())
     map->RegisterProcess(site_instance->GetSiteInfo(), process);
 }
@@ -4819,6 +4881,12 @@
   base::RecordComputedAction(action);
 }
 
+void RenderProcessHostImpl::ResolveProxy(
+    const GURL& url,
+    mojom::RendererHost::ResolveProxyCallback callback) {
+  resolve_proxy_helper_->ResolveProxy(url, std::move(callback));
+}
+
 void RenderProcessHostImpl::UpdateProcessPriorityInputs() {
   int32_t new_visible_widgets_count = 0;
   unsigned int new_frame_depth = kMaxFrameDepthForPriority;
diff -r -u --color up/chromium/content/browser/renderer_host/render_process_host_impl.h nw/chromium/content/browser/renderer_host/render_process_host_impl.h
--- up/chromium/content/browser/renderer_host/render_process_host_impl.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/render_process_host_impl.h	2023-01-28 02:49:28.339618973 +0000
@@ -143,6 +143,7 @@
 class RenderProcessHostPriorityClients;
 class RenderProcessHostTest;
 class RenderWidgetHelper;
+class ResolveProxyHelper;
 class SiteInfo;
 class SiteInstance;
 class SiteInstanceImpl;
@@ -200,6 +201,8 @@
   RenderProcessHostImpl(const RenderProcessHostImpl& other) = delete;
   RenderProcessHostImpl& operator=(const RenderProcessHostImpl& other) = delete;
 
+  void set_main_host();
+  static RenderProcessHostImpl* main_host();
   // RenderProcessHost implementation (public portion).
   bool Init() override;
   void EnableSendQueue() override;
@@ -805,6 +808,9 @@
                            BrowserHistogramCallback callback) override;
   void SuddenTerminationChanged(bool enabled) override;
   void RecordUserMetricsAction(const std::string& action) override;
+  void ResolveProxy(
+      const GURL& url,
+      mojom::RendererHost::ResolveProxyCallback callback) override;
 
   void CreateEmbeddedFrameSinkProvider(
       mojo::PendingReceiver<blink::mojom::EmbeddedFrameSinkProvider> receiver);
@@ -1051,6 +1057,8 @@
   // IO thread.
   scoped_refptr<RenderWidgetHelper> widget_helper_;
 
+  scoped_refptr<ResolveProxyHelper> resolve_proxy_helper_;
+
   // Used in single-process mode.
   std::unique_ptr<base::Thread> in_process_renderer_;
 
diff -r -u --color up/chromium/content/browser/renderer_host/render_view_host_delegate.cc nw/chromium/content/browser/renderer_host/render_view_host_delegate.cc
--- up/chromium/content/browser/renderer_host/render_view_host_delegate.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/render_view_host_delegate.cc	2023-01-28 02:49:28.339618973 +0000
@@ -6,6 +6,10 @@
 
 namespace content {
 
+RenderViewHostDelegate::RenderViewHostDelegate()
+  :skip_blocking_parser_(true) {
+}
+
 RenderViewHostDelegateView* RenderViewHostDelegate::GetDelegateView() {
   return nullptr;
 }
@@ -30,4 +34,11 @@
   return absl::nullopt;
 }
 
+bool RenderViewHostDelegate::GetSkipBlockingParser() {
+  return skip_blocking_parser_;
+}
+
+void RenderViewHostDelegate::SetSkipBlockingParser(bool value) {
+  skip_blocking_parser_ = value;
+}
 }  // namespace content
diff -r -u --color up/chromium/content/browser/renderer_host/render_view_host_delegate.h nw/chromium/content/browser/renderer_host/render_view_host_delegate.h
--- up/chromium/content/browser/renderer_host/render_view_host_delegate.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/render_view_host_delegate.h	2023-01-28 02:49:28.339618973 +0000
@@ -46,6 +46,7 @@
 // WebContents type (see //renderer_host/DEPS).
 class RenderViewHostDelegate {
  public:
+  RenderViewHostDelegate();
   // Returns the current delegate associated with a feature. May return NULL if
   // there is no corresponding delegate.
   virtual RenderViewHostDelegateView* GetDelegateView();
@@ -80,6 +81,9 @@
   // JavaScript window.focus() method).
   virtual void Activate() {}
 
+  virtual bool GetSkipBlockingParser();
+  virtual void SetSkipBlockingParser(bool);
+
   // Returns true if RenderWidgets under this RenderViewHost will never be
   // user-visible and thus never need to generate pixels for display.
   virtual bool IsNeverComposited();
@@ -127,6 +131,8 @@
 
  protected:
   virtual ~RenderViewHostDelegate() {}
+ private:
+  bool skip_blocking_parser_;
 };
 
 }  // namespace content
diff -r -u --color up/chromium/content/browser/renderer_host/render_view_host_impl.cc nw/chromium/content/browser/renderer_host/render_view_host_impl.cc
--- up/chromium/content/browser/renderer_host/render_view_host_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/render_view_host_impl.cc	2023-01-28 02:49:28.339618973 +0000
@@ -487,6 +487,7 @@
       frame_tree_->controller()
           .GetSessionStorageNamespace(storage_partition_config_)
           ->id();
+  params->skip_blocking_parser = delegate_->GetSkipBlockingParser();
   params->hidden = frame_tree_->delegate()->IsHidden();
   params->never_composited = delegate_->IsNeverComposited();
   params->window_was_opened_by_another_window =
diff -r -u --color up/chromium/content/browser/renderer_host/render_widget_host_impl.cc nw/chromium/content/browser/renderer_host/render_widget_host_impl.cc
--- up/chromium/content/browser/renderer_host/render_widget_host_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/render_widget_host_impl.cc	2023-01-28 02:49:28.343619015 +0000
@@ -4,6 +4,8 @@
 
 #include "content/browser/renderer_host/render_widget_host_impl.h"
 
+#include "content/public/common/content_switches.h"
+
 #include <math.h>
 
 #include <algorithm>
@@ -836,9 +838,15 @@
   // Don't bother reporting hung state when we aren't active.
   StopInputEventAckTimeout();
 
+  // If we have bound the blink widget interface, then inform it that we are
+  // being hidden so it can reduce its resource utilization.
+  if (blink_widget_) {
+    if (!base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kDisableRAFThrottling))
+    blink_widget_->WasHidden();
+  }
+  else if (pending_show_params_) {
   // Show/Hide state is not sent to the renderer when it has requested for us to
   // wait until it requests them via Init().
-  if (pending_show_params_) {
     pending_show_params_.reset();
   } else {
     // Widgets start out hidden, so we must have previously been shown to get
@@ -1359,8 +1367,13 @@
     if (IsKeyboardLocked())
       UnlockKeyboard();
 
-    if (auto* touch_emulator = GetExistingTouchEmulator())
-      touch_emulator->CancelTouch();
+    if (auto* touch_emulator = GetExistingTouchEmulator()) {
+      if (touch_emulator->rfh_limit()) {
+        if (touch_emulator->rfh_limit()->GetView() == GetView())
+          touch_emulator->CancelTouch();
+      } else
+        touch_emulator->CancelTouch();
+    }
   } else if (keyboard_lock_allowed_) {
     LockKeyboard();
   }
diff -r -u --color up/chromium/content/browser/renderer_host/render_widget_host_input_event_router.cc nw/chromium/content/browser/renderer_host/render_widget_host_input_event_router.cc
--- up/chromium/content/browser/renderer_host/render_widget_host_input_event_router.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/render_widget_host_input_event_router.cc	2023-01-28 02:49:28.343619015 +0000
@@ -7,6 +7,9 @@
 #include <algorithm>
 #include <deque>
 #include <memory>
+
+#include "content/public/browser/render_frame_host.h"
+
 #include <vector>
 
 #include "base/containers/cxx20_erase.h"
@@ -1970,8 +1973,13 @@
     touch_emulator_->SetDeviceScaleFactor(last_device_scale_factor_);
   if (auto* cursor_manager = last_mouse_move_root_view_->GetCursorManager()) {
     for (auto it : owner_map_) {
-      if (it.second)
+      if (it.second) {
+        if (touch_emulator_ && touch_emulator_->rfh_limit()) {
+          if (touch_emulator_->rfh_limit()->GetView() != it.second.get())
+            continue;
+        }
         cursor_manager->UpdateCursor(it.second.get(), cursor);
+      }
     }
   }
 }
diff -r -u --color up/chromium/content/browser/renderer_host/render_widget_host_view_mac.h nw/chromium/content/browser/renderer_host/render_widget_host_view_mac.h
--- up/chromium/content/browser/renderer_host/render_widget_host_view_mac.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/render_widget_host_view_mac.h	2023-01-28 02:49:28.347619057 +0000
@@ -100,6 +100,9 @@
 
   RenderWidgetHostViewCocoa* GetInProcessNSView() const;
 
+  // Used by g_force_cpu_draw
+  CALayer* background_layer() const;
+
   // |delegate| is used to separate out the logic from the NSResponder delegate.
   // |delegate| is retained by this class.
   // |delegate| should be set at most once.
@@ -317,6 +320,7 @@
   id GetRootBrowserAccessibilityElement() override;
   id GetFocusedBrowserAccessibilityElement() override;
   void SetAccessibilityWindow(NSWindow* window) override;
+  RenderWidgetHostViewMac* GetRenderWidgetHostViewMac() override;
   void ForwardKeyboardEvent(const NativeWebKeyboardEvent& key_event,
                             const ui::LatencyInfo& latency_info) override;
   void ForwardKeyboardEventWithCommands(
diff -r -u --color up/chromium/content/browser/renderer_host/render_widget_host_view_mac.mm nw/chromium/content/browser/renderer_host/render_widget_host_view_mac.mm
--- up/chromium/content/browser/renderer_host/render_widget_host_view_mac.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/render_widget_host_view_mac.mm	2023-01-28 02:49:28.347619057 +0000
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 #include "content/browser/renderer_host/render_widget_host_view_mac.h"
+#include "content/public/common/content_switches.h"
 
 #import <Carbon/Carbon.h>
 #include "third_party/blink/public/mojom/input/input_handler.mojom-forward.h"
@@ -80,6 +81,10 @@
 using blink::WebTouchEvent;
 
 namespace content {
+  extern bool g_force_cpu_draw;
+}
+
+namespace content {
 
 ////////////////////////////////////////////////////////////////////////////////
 // BrowserCompositorMacClient, public:
@@ -352,6 +357,13 @@
   return nullptr;
 }
 
+CALayer* RenderWidgetHostViewMac::background_layer() const {
+  assert(content::g_force_cpu_draw);
+  if (in_process_ns_view_bridge_)
+    return in_process_ns_view_bridge_->GetBackgroundLayer();
+  return nil;
+}
+
 void RenderWidgetHostViewMac::SetDelegate(
     NSObject<RenderWidgetHostViewMacDelegate>* delegate) {
   [GetInProcessNSView() setResponderDelegate:delegate];
@@ -457,6 +469,7 @@
   is_visible_ = false;
   ns_view_->SetVisible(is_visible_);
   browser_compositor_->SetViewVisible(is_visible_);
+  if (!base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kDisableRAFThrottling))
   WasOccluded();
 }
 
@@ -523,6 +536,7 @@
     return;
 
   host()->WasHidden();
+  if (!base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kDisableRAFThrottling))
   browser_compositor_->SetRenderWidgetHostIsHidden(true);
 }
 
@@ -1634,6 +1648,10 @@
   return true;
 }
 
+RenderWidgetHostViewMac* RenderWidgetHostViewMac::GetRenderWidgetHostViewMac() {
+  return this;
+}
+
 void RenderWidgetHostViewMac::SyncIsWidgetForMainFrame(
     SyncIsWidgetForMainFrameCallback callback) {
   bool is_for_main_frame;
Only in nw/chromium/content/browser: resolve_proxy_helper.cc
Only in nw/chromium/content/browser: resolve_proxy_helper.h
Only in nw/chromium/content/browser: resolve_proxy_helper_unittest.cc
diff -r -u --color up/chromium/content/browser/site_info.cc nw/chromium/content/browser/site_info.cc
--- up/chromium/content/browser/site_info.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/site_info.cc	2023-01-28 02:49:28.379619396 +0000
@@ -605,9 +605,11 @@
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
   DCHECK(isolation_context.browser_or_resource_context());
 
+#if 0
   // If --site-per-process is enabled, site isolation is enabled everywhere.
   if (SiteIsolationPolicy::UseDedicatedProcessesForAllSites())
     return true;
+#endif
 
   // If there is a COOP header request to require a dedicated process for this
   // SiteInfo, honor it.  Note that we have already checked other eligibility
@@ -851,7 +853,7 @@
       return origin.GetURL();
     }
 
-    site_url = GetSiteForOrigin(origin);
+    site_url = GetSiteForOrigin(origin, real_url);
 
     // Isolated origins should use the full origin as their site URL. A
     // subdomain of an isolated origin should also use that isolated origin's
@@ -911,10 +913,14 @@
 }
 
 // static
-GURL SiteInfo::GetSiteForOrigin(const url::Origin& origin) {
+GURL SiteInfo::GetSiteForOrigin(const url::Origin& origin, const GURL& real_url) {
   // Only keep the scheme and registered domain of |origin|.
   std::string domain = net::registry_controlled_domains::GetDomainAndRegistry(
       origin, net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES);
+  //NWJS: chrome-extension://test.foo.com was changed to foo.com
+  //without this
+  if (!real_url.is_empty() && real_url.SchemeIs("chrome-extension"))
+    domain = origin.host();
   return SchemeAndHostToSite(origin.scheme(),
                              domain.empty() ? origin.host() : domain);
 }
diff -r -u --color up/chromium/content/browser/site_info.h nw/chromium/content/browser/site_info.h
--- up/chromium/content/browser/site_info.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/site_info.h	2023-01-28 02:49:28.379619396 +0000
@@ -105,7 +105,7 @@
   // only translates an origin into a site (i.e., scheme and eTLD+1) and is
   // used internally by GetSiteForURLInternal().  For making process model
   // decisions, Create() should be used instead.
-  static GURL GetSiteForOrigin(const url::Origin& origin);
+  static GURL GetSiteForOrigin(const url::Origin& origin, const GURL& real_url = GURL());
 
   // Returns a StoragePartitionConfig for the specified URL.
   // If |is_site_url| is set to true, then |url| MUST be a site URL that
diff -r -u --color up/chromium/content/browser/site_instance_impl.cc nw/chromium/content/browser/site_instance_impl.cc
--- up/chromium/content/browser/site_instance_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/site_instance_impl.cc	2023-01-28 02:49:28.379619396 +0000
@@ -13,6 +13,8 @@
 #include "base/lazy_instance.h"
 #include "base/trace_event/typed_macros.h"
 #include "content/browser/bad_message.h"
+#include "content/nw/src/nw_content.h"
+#include "extensions/common/constants.h"
 #include "content/browser/browsing_instance.h"
 #include "content/browser/child_process_security_policy_impl.h"
 #include "content/browser/isolated_origin_util.h"
@@ -367,7 +369,7 @@
   // new process will be assigned the next time GetProcess() gets called.
   if (!has_group()) {
     // Check if the ProcessReusePolicy should be updated.
-    if (ShouldUseProcessPerSite()) {
+    if (ShouldUseProcessPerSite() && nw::PinningRenderer()) {
       process_reuse_policy_ = ProcessReusePolicy::PROCESS_PER_SITE;
     } else if (process_reuse_policy_ == ProcessReusePolicy::PROCESS_PER_SITE) {
       process_reuse_policy_ = ProcessReusePolicy::DEFAULT;
@@ -661,12 +663,12 @@
 }
 
 scoped_refptr<SiteInstance> SiteInstanceImpl::GetRelatedSiteInstance(
-    const GURL& url) {
-  return GetRelatedSiteInstanceImpl(UrlInfo(UrlInfoInit(url)));
+                    const GURL& url, bool allow_default_instance) {
+  return GetRelatedSiteInstanceImpl(UrlInfo(UrlInfoInit(url)), allow_default_instance);
 }
 
 scoped_refptr<SiteInstanceImpl> SiteInstanceImpl::GetRelatedSiteInstanceImpl(
-    const UrlInfo& url_info) {
+      const UrlInfo& url_info, bool allow_default_instance) {
   if (IsGuest() && !SiteIsolationPolicy::IsSiteIsolationForGuestsEnabled()) {
     // Without site isolation in guests, there should only be one guest
     // SiteInstance per BrowsingInstance.
@@ -674,7 +676,7 @@
   }
 
   return browsing_instance_->GetSiteInstanceForURL(
-      url_info, /* allow_default_instance */ true);
+      url_info, allow_default_instance);
 }
 
 AgentSchedulingGroupHost& SiteInstanceImpl::GetOrCreateAgentSchedulingGroup() {
diff -r -u --color up/chromium/content/browser/site_instance_impl.h nw/chromium/content/browser/site_instance_impl.h
--- up/chromium/content/browser/site_instance_impl.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/site_instance_impl.h	2023-01-28 02:49:28.379619396 +0000
@@ -120,7 +120,7 @@
   // looking up an existing SiteInstance based on a GURL can use
   // GetRelatedSiteInstance (overridden from SiteInstance).
   scoped_refptr<SiteInstanceImpl> GetRelatedSiteInstanceImpl(
-      const UrlInfo& url_info);
+         const UrlInfo& url_info, bool allow_default_instance = true);
   bool IsSameSiteWithURLInfo(const UrlInfo& url_info);
 
   // Returns an AgentSchedulingGroupHost, or creates one if
@@ -140,7 +140,7 @@
   BrowserContext* GetBrowserContext() override;
   const GURL& GetSiteURL() override;
   const StoragePartitionConfig& GetStoragePartitionConfig() override;
-  scoped_refptr<SiteInstance> GetRelatedSiteInstance(const GURL& url) override;
+  scoped_refptr<SiteInstance> GetRelatedSiteInstance(const GURL& url, bool allow_default_instance = true) override;
   bool IsRelatedSiteInstance(const SiteInstance* instance) override;
   size_t GetRelatedActiveContentsCount() override;
   bool RequiresDedicatedProcess() override;
diff -r -u --color up/chromium/content/browser/url_loader_factory_params_helper.cc nw/chromium/content/browser/url_loader_factory_params_helper.cc
--- up/chromium/content/browser/url_loader_factory_params_helper.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/url_loader_factory_params_helper.cc	2023-01-28 02:49:28.395619565 +0000
@@ -96,6 +96,11 @@
 
   params->trust_token_redemption_policy = trust_token_redemption_policy;
 
+  if (GetContentClient()->browser()->IsNWOrigin(origin, process->GetBrowserContext())) {
+    params->is_corb_enabled = false;
+    params->disable_web_security = true;
+  }
+
   GetContentClient()->browser()->OverrideURLLoaderFactoryParams(
       process->GetBrowserContext(), origin, is_for_isolated_world,
       params.get());
diff -r -u --color up/chromium/content/browser/web_contents/file_chooser_impl.cc nw/chromium/content/browser/web_contents/file_chooser_impl.cc
--- up/chromium/content/browser/web_contents/file_chooser_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/web_contents/file_chooser_impl.cc	2023-01-28 02:49:28.399619607 +0000
@@ -164,12 +164,14 @@
   // Do not allow messages with absolute paths in them as this can permit a
   // renderer to coerce the browser to perform I/O on a renderer controlled
   // path.
+  #if 0
   if (params->default_file_name != params->default_file_name.BaseName()) {
     mojo::ReportBadMessage(
         "FileChooser: The default file name must not be an absolute path.");
     listener->FileSelectionCanceled();
     return;
   }
+  #endif
 
   // Don't allow page with open FileChooser to enter BackForwardCache to avoid
   // any unexpected behaviour from BackForwardCache.
diff -r -u --color up/chromium/content/browser/web_contents/web_contents_impl.cc nw/chromium/content/browser/web_contents/web_contents_impl.cc
--- up/chromium/content/browser/web_contents/web_contents_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/web_contents/web_contents_impl.cc	2023-01-28 02:49:28.399619607 +0000
@@ -16,6 +16,8 @@
 #include "base/allocator/partition_allocator/starscan/pcscan.h"
 #include "base/bind.h"
 #include "base/check_op.h"
+#include "content/nw/src/nw_base.h"
+
 #include "base/command_line.h"
 #include "base/containers/contains.h"
 #include "base/containers/cxx20_erase.h"
@@ -4082,10 +4084,12 @@
     AddWebContentsDestructionObserver(new_contents_impl);
   }
 
+  nw::SetCurrentNewWinManifest(params.nw_window_manifest);
+
   if (delegate_) {
     delegate_->WebContentsCreated(this, render_process_id,
                                   opener->GetRoutingID(), params.frame_name,
-                                  params.target_url, new_contents_impl);
+                                  params.target_url, new_contents_impl, params.nw_window_manifest);
   }
 
   observers_.NotifyObservers(&WebContentsObserver::DidOpenRequestedURL,
@@ -4104,9 +4108,23 @@
       base::WeakPtr<WebContentsImpl> weak_new_contents =
           new_contents_impl->weak_factory_.GetWeakPtr();
 
+      gfx::Rect initial_rect;
+      if (params.features->has_width)
+        initial_rect.set_width(params.features->bounds.width());
+      if (params.features->has_height)
+        initial_rect.set_height(params.features->bounds.height());
+      if (params.features->has_x)
+        initial_rect.set_x(params.features->bounds.x());
+      if (params.features->has_y)
+        initial_rect.set_y(params.features->bounds.y());
+
+      std::string manifest = base::UTF16ToUTF8(params.nw_window_manifest);
+      delegate_->set_tmp_manifest(manifest);
+      params.features->bounds = initial_rect;
       delegate_->AddNewContents(
           this, std::move(new_contents), params.target_url, params.disposition,
           *params.features, has_user_gesture, &was_blocked);
+      delegate_->set_tmp_manifest(std::string());
       // The delegate may delete |new_contents_impl| during AddNewContents().
       if (!weak_new_contents)
         return nullptr;
@@ -4194,7 +4212,7 @@
     int main_frame_widget_route_id,
     WindowOpenDisposition disposition,
     const blink::mojom::WindowFeatures& window_features,
-    bool user_gesture) {
+    bool user_gesture, std::string manifest) {
   OPTIONAL_TRACE_EVENT2("content", "WebContentsImpl::ShowCreatedWindow",
                         "opener", opener, "main_frame_widget_route_id",
                         main_frame_widget_route_id);
@@ -4245,9 +4263,11 @@
     if (delegate->ShouldResumeRequestsForCreatedWindow())
       created->ResumeLoadingCreatedWebContents();
 
+    delegate->set_tmp_manifest(manifest);
     delegate->AddNewContents(this, std::move(owned_created->contents),
                              std::move(owned_created->target_url), disposition,
                              adjusted_features, user_gesture, nullptr);
+    delegate->set_tmp_manifest(std::string());
   }
 }
 
@@ -9165,8 +9185,10 @@
   // the command line (to avoid flakiness in browser tests).
   const bool occlusion_is_disabled =
       base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kDisableBackgroundingOccludedWindowsForTesting);
-  if (occlusion_is_disabled && visibility == Visibility::OCCLUDED)
+          switches::kDisableBackgroundingOccludedWindowsForTesting) ||
+      base::CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kDisableRAFThrottling);
+  if (occlusion_is_disabled) // && visibility == Visibility::OCCLUDED)
     visibility = Visibility::VISIBLE;
 
   if (!did_first_set_visible_) {
diff -r -u --color up/chromium/content/browser/web_contents/web_contents_impl.h nw/chromium/content/browser/web_contents/web_contents_impl.h
--- up/chromium/content/browser/web_contents/web_contents_impl.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/web_contents/web_contents_impl.h	2023-01-28 02:49:28.399619607 +0000
@@ -695,7 +695,7 @@
                          int main_frame_widget_route_id,
                          WindowOpenDisposition disposition,
                          const blink::mojom::WindowFeatures& window_features,
-                         bool user_gesture) override;
+                         bool user_gesture, std::string manifest) override;
   void PrimaryMainDocumentElementAvailable() override;
   void PassiveInsecureContentFound(const GURL& resource_url) override;
   bool ShouldAllowRunningInsecureContent(bool allowed_per_prefs,
diff -r -u --color up/chromium/content/browser/webui/url_data_manager_backend.cc nw/chromium/content/browser/webui/url_data_manager_backend.cc
--- up/chromium/content/browser/webui/url_data_manager_backend.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/webui/url_data_manager_backend.cc	2023-01-28 02:49:28.423619861 +0000
@@ -7,6 +7,8 @@
 #include <set>
 #include <utility>
 
+#include "content/nw/src/nw_content.h"
+
 #include "base/bind.h"
 #include "base/containers/contains.h"
 #include "base/location.h"
@@ -43,6 +45,11 @@
 #include "ui/base/webui/i18n_source_stream.h"
 #include "url/url_util.h"
 
+namespace nw {
+typedef bool (*CheckStoragePartitionMatchesFn)(int render_process_id, const GURL& url);
+CONTENT_EXPORT CheckStoragePartitionMatchesFn gCheckStoragePartitionMatches = nullptr;
+}
+
 namespace content {
 
 namespace {
diff -r -u --color up/chromium/content/browser/worker_host/shared_worker_host.cc nw/chromium/content/browser/worker_host/shared_worker_host.cc
--- up/chromium/content/browser/worker_host/shared_worker_host.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/worker_host/shared_worker_host.cc	2023-01-28 02:49:28.423619861 +0000
@@ -289,6 +289,7 @@
   auto options = blink::mojom::WorkerOptions::New(
       instance_.script_type(), instance_.credentials_mode(), instance_.name());
   blink::mojom::SharedWorkerInfoPtr info(blink::mojom::SharedWorkerInfo::New(
+                                                                             instance_.nodejs(), instance_.root_path(),
       instance_.url(), std::move(options),
       mojo::Clone(content_security_policies_),
       std::move(outside_fetch_client_settings_object)));
diff -r -u --color up/chromium/content/browser/worker_host/shared_worker_service_impl.cc nw/chromium/content/browser/worker_host/shared_worker_service_impl.cc
--- up/chromium/content/browser/worker_host/shared_worker_service_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/worker_host/shared_worker_service_impl.cc	2023-01-28 02:49:28.427619903 +0000
@@ -190,7 +190,9 @@
     return;
   }
   auto partition_domain = site_instance->GetPartitionDomain(storage_partition_);
-  SharedWorkerInstance instance(info->url, info->options->type,
+  SharedWorkerInstance instance(
+                                info->is_node_js, info->root_path,
+                                info->url, info->options->type,
                                 info->options->credentials, info->options->name,
                                 storage_key, creation_context_type);
   host = CreateWorker(
diff -r -u --color up/chromium/content/browser/zygote_host/zygote_host_impl_linux.cc nw/chromium/content/browser/zygote_host/zygote_host_impl_linux.cc
--- up/chromium/content/browser/zygote_host/zygote_host_impl_linux.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/browser/zygote_host/zygote_host_impl_linux.cc	2023-01-28 02:49:28.427619903 +0000
@@ -1,6 +1,7 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wunreachable-code"
 
 #include "content/browser/zygote_host/zygote_host_impl_linux.h"
 
@@ -34,6 +35,8 @@
 #include "content/public/common/zygote/zygote_handle.h"
 #endif
 
+#include "content/nw/src/common/shell_switches.h"
+
 namespace content {
 
 namespace {
@@ -83,7 +86,7 @@
 }
 
 void ZygoteHostImpl::Init(const base::CommandLine& command_line) {
-  if (command_line.HasSwitch(sandbox::policy::switches::kNoSandbox)) {
+  if (true || command_line.HasSwitch(sandbox::policy::switches::kNoSandbox)) {
     return;
   }
 
@@ -116,7 +119,7 @@
   } else if (!command_line.HasSwitch(
                  sandbox::policy::switches::kDisableSetuidSandbox) &&
              !sandbox_binary_.empty()) {
-    use_suid_sandbox_ = true;
+    use_suid_sandbox_ = false;
 
     // Use the SUID sandbox for adjusting OOM scores when we are using
     // the setuid sandbox. This is needed beacuse the processes are
diff -r -u --color up/chromium/content/child/child_thread_impl.cc nw/chromium/content/child/child_thread_impl.cc
--- up/chromium/content/child/child_thread_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/child/child_thread_impl.cc	2023-01-28 02:49:28.431619945 +0000
@@ -672,7 +672,7 @@
   // Requires base::PowerMonitor to be initialized first.
   power_scheduler::PowerModeArbiter::GetInstance()->OnThreadPoolAvailable();
 
-#if BUILDFLAG(IS_POSIX)
+#if 0 //BUILDFLAG(IS_POSIX)
   // Check that --process-type is specified so we don't do this in unit tests
   // and single-process mode.
   if (base::CommandLine::ForCurrentProcess()->HasSwitch(
diff -r -u --color up/chromium/content/common/content_switches_internal.cc nw/chromium/content/common/content_switches_internal.cc
--- up/chromium/content/common/content_switches_internal.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/common/content_switches_internal.cc	2023-01-28 02:49:28.435619988 +0000
@@ -98,7 +98,7 @@
 #if BUILDFLAG(GOOGLE_CHROME_BRANDING)
   std::string title = "Google Chrome";
 #else   // BUILDFLAG(CHROMIUM_BRANDING)
-  std::string title = "Chromium";
+  std::string title = "NW.js";
 #endif  // BUILDFLAG(CHROMIUM_BRANDING)
   title += " ";
   title += label;  // makes attaching to process easier
diff -r -u --color up/chromium/content/common/frame.mojom nw/chromium/content/common/frame.mojom
--- up/chromium/content/common/frame.mojom	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/common/frame.mojom	2023-01-28 02:49:28.435619988 +0000
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 module content.mojom;
+import "mojo/public/mojom/base/string16.mojom";
 
 import "cc/mojom/browser_controls_state.mojom";
 import "content/common/frame_messages.mojom";
@@ -158,6 +159,8 @@
 
   // Base background color of this view. Only used by a local main frame.
   skia.mojom.SkColor? base_background_color;
+
+  bool skip_blocking_parser;
 };
 
 // A union to distinguish between parameters specific to local main frame
@@ -471,6 +474,8 @@
       blink.mojom.RemoteFrameInterfacesFromBrowser new_remote_frame_interfaces,
       blink.mojom.RemoteMainFrameInterfaces new_remote_main_frame_interfaces);
 
+  SetSkipBlockingParser(bool skip);
+
   // Causes all new subresource requests to be blocked (not being started) until
   // ResumeBlockedRequests is called.
   BlockRequests();
@@ -535,6 +540,7 @@
 };
 
 struct CreateNewWindowParams {
+  mojo_base.mojom.String16 nw_window_manifest;
   // True if ContentRendererClient allows popups.  This is the case only for
   // extensions.
   bool allow_popup;
@@ -675,6 +681,8 @@
 // Implemented by the frame server (i.e. the browser process). For messages that
 // must be associated with the IPC channel.
 interface FrameHost {
+  SetNodeJS(bool node);
+  SetContextCreated(bool created);
   // Sent by the renderer to request the browser to create a new window. |reply|
   // is only non-null on when status == CreateNewWindowStatus::kSuccess.
   [Sync] CreateNewWindow(CreateNewWindowParams params)
diff -r -u --color up/chromium/content/common/renderer_host.mojom nw/chromium/content/common/renderer_host.mojom
--- up/chromium/content/common/renderer_host.mojom	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/common/renderer_host.mojom	2023-01-28 02:49:28.439620030 +0000
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 module content.mojom;
+import "url/mojom/url.mojom";
 
 // The primordial interface implemented by a render process host. This should be
 // used for implementing renderer-to-browser messages.
@@ -21,4 +22,9 @@
 
   // Sends a string to be recorded by UserMetrics.
   RecordUserMetricsAction(string action);
+
+  // Gets the list of proxies to use for |url|, as a semicolon delimited list
+  // of "<TYPE> <HOST>:<PORT>" | "DIRECT".
+  [Sync]
+  ResolveProxy(url.mojom.Url url) => (string? proxy_list);
 };
diff -r -u --color up/chromium/content/common/user_agent.cc nw/chromium/content/common/user_agent.cc
--- up/chromium/content/common/user_agent.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/common/user_agent.cc	2023-01-28 02:49:28.443620072 +0000
@@ -333,7 +333,17 @@
   return model;
 }
 
-#if BUILDFLAG(IS_ANDROID)
+std::string BuildOSInfo() {
+  std::string os_info;
+  base::StringAppendF(
+      &os_info,
+      "%s%s",
+      GetUserAgentPlatform().c_str(),
+      BuildOSCpuInfo(IncludeAndroidBuildNumber::Exclude,
+                     IncludeAndroidModel::Exclude).c_str());
+  return os_info;
+}
+
 std::string BuildUserAgentFromProductAndExtraOSInfo(
     const std::string& product,
     const std::string& extra_os_info,
@@ -346,6 +356,7 @@
   return BuildUserAgentFromOSAndProduct(os_info, product);
 }
 
+#if 0
 std::string GetAndroidOSInfo(
     IncludeAndroidBuildNumber include_android_build_number,
     IncludeAndroidModel include_android_model) {
diff -r -u --color up/chromium/content/common/zygote/zygote_communication_linux.cc nw/chromium/content/common/zygote/zygote_communication_linux.cc
--- up/chromium/content/common/zygote/zygote_communication_linux.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/common/zygote/zygote_communication_linux.cc	2023-01-28 02:49:28.443620072 +0000
@@ -4,6 +4,7 @@
 
 #include "content/common/zygote/zygote_communication_linux.h"
 
+#include "content/nw/src/common/shell_switches.h"
 #include <string.h>
 #include <sys/socket.h>
 
@@ -256,6 +257,7 @@
   static const char* const kForwardSwitches[] = {
       sandbox::policy::switches::kAllowSandboxDebugging,
       switches::kDisableInProcessStackTraces,
+      "enable-spell-checking",
       sandbox::policy::switches::kDisableSeccompFilterSandbox,
       sandbox::policy::switches::kNoSandbox,
   };
diff -r -u --color up/chromium/content/ppapi_plugin/ppapi_plugin_main.cc nw/chromium/content/ppapi_plugin/ppapi_plugin_main.cc
--- up/chromium/content/ppapi_plugin/ppapi_plugin_main.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/ppapi_plugin/ppapi_plugin_main.cc	2023-01-28 02:49:28.443620072 +0000
@@ -146,7 +146,7 @@
   gin::V8Initializer::LoadV8Snapshot();
 #endif
 
-#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
+#if 0 //BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
   sandbox::policy::SandboxLinux::GetInstance()->InitializeSandbox(
       sandbox::policy::SandboxTypeFromCommandLine(command_line),
       sandbox::policy::SandboxLinux::PreSandboxHook(),
diff -r -u --color up/chromium/content/public/browser/child_process_security_policy.h nw/chromium/content/public/browser/child_process_security_policy.h
--- up/chromium/content/public/browser/child_process_security_policy.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/public/browser/child_process_security_policy.h	2023-01-28 02:49:28.479620453 +0000
@@ -69,6 +69,7 @@
   // change it to accept an URL instead.
   virtual bool IsWebSafeScheme(const std::string& scheme) = 0;
 
+  virtual void GrantAll(int child_id) = 0;
   // This permission grants only read access to a file.
   // Whenever the user picks a file from a <input type="file"> element, the
   // browser should call this function to grant the child process the capability
diff -r -u --color up/chromium/content/public/browser/content_browser_client.cc nw/chromium/content/public/browser/content_browser_client.cc
--- up/chromium/content/public/browser/content_browser_client.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/public/browser/content_browser_client.cc	2023-01-28 02:49:28.479620453 +0000
@@ -4,6 +4,8 @@
 
 #include "content/public/browser/content_browser_client.h"
 
+#include "content/nw/src/browser/nw_content_browser_hooks.h"
+
 #include <utility>
 
 #include "base/callback_helpers.h"
@@ -164,6 +166,8 @@
     BrowserContext* browser_context,
     const GURL& effective_url) {
   DCHECK(browser_context);
+  if (nw::PinningRenderer())
+    return false;
   return true;
 }
 
@@ -178,6 +182,7 @@
   return false;
 }
 
+
 bool ContentBrowserClient::ShouldIgnoreSameSiteCookieRestrictionsWhenTopLevel(
     base::StringPiece scheme,
     bool is_embedded_origin_secure) {
@@ -190,6 +195,10 @@
   return site_url.spec();
 }
 
+bool ContentBrowserClient::IsNWOrigin(const url::Origin& origin, BrowserContext* context) {
+  return false;
+}
+
 void ContentBrowserClient::OverrideURLLoaderFactoryParams(
     BrowserContext* browser_context,
     const url::Origin& origin,
@@ -460,6 +469,10 @@
   std::move(callback).Run(true);
 }
 
+base::FilePath ContentBrowserClient::GetRootPath() {
+  return base::FilePath();
+}
+
 bool ContentBrowserClient::AllowWorkerIndexedDB(
     const GURL& url,
     BrowserContext* browser_context,
diff -r -u --color up/chromium/content/public/browser/content_browser_client.h nw/chromium/content/public/browser/content_browser_client.h
--- up/chromium/content/public/browser/content_browser_client.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/public/browser/content_browser_client.h	2023-01-28 02:49:28.479620453 +0000
@@ -400,6 +400,8 @@
   // assume it runs only on the UI thread.
   virtual bool DoesWebUISchemeRequireProcessLock(base::StringPiece scheme);
 
+  virtual bool IsNWOrigin(const url::Origin& origin, BrowserContext* context);
+
   // Returns true if everything embedded inside a document with given scheme
   // should be treated as first-party content. |scheme| will be in canonical
   // (lowercased) form. |is_embedded_origin_secure| refers to whether the origin
@@ -795,6 +797,7 @@
       const std::vector<GlobalRenderFrameHostId>& render_frames,
       base::OnceCallback<void(bool)> callback);
 
+  virtual base::FilePath GetRootPath();
   // Allow the embedder to control if access to IndexedDB by a shared worker
   // is allowed.
   virtual bool AllowWorkerIndexedDB(
diff -r -u --color up/chromium/content/public/browser/desktop_streams_registry.h nw/chromium/content/public/browser/desktop_streams_registry.h
--- up/chromium/content/public/browser/desktop_streams_registry.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/public/browser/desktop_streams_registry.h	2023-01-28 02:49:28.479620453 +0000
@@ -52,7 +52,7 @@
       int render_frame_id,
       const url::Origin& origin,
       std::string* extension_name,
-      const DesktopStreamRegistryType type) = 0;
+      const DesktopStreamRegistryType type, bool nodejs = false) = 0;
 };
 
 }  // namespace content
diff -r -u --color up/chromium/content/public/browser/render_frame_host.h nw/chromium/content/public/browser/render_frame_host.h
--- up/chromium/content/public/browser/render_frame_host.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/public/browser/render_frame_host.h	2023-01-28 02:49:28.491620579 +0000
@@ -212,6 +212,9 @@
   // node IDs identified.
   virtual void RequestDistilledAXTree(AXTreeDistillerCallback callback) = 0;
 
+
+  virtual bool nodejs() = 0;
+  virtual bool context_created() = 0;
   // Returns the SiteInstance grouping all RenderFrameHosts that have script
   // access to this RenderFrameHost, and must therefore live in the same
   // process.
diff -r -u --color up/chromium/content/public/browser/shared_worker_instance.cc nw/chromium/content/public/browser/shared_worker_instance.cc
--- up/chromium/content/public/browser/shared_worker_instance.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/public/browser/shared_worker_instance.cc	2023-01-28 02:49:28.491620579 +0000
@@ -11,13 +11,16 @@
 namespace content {
 
 SharedWorkerInstance::SharedWorkerInstance(
+    bool is_node_js, const base::FilePath& root_path,
     const GURL& url,
     blink::mojom::ScriptType script_type,
     network::mojom::CredentialsMode credentials_mode,
     const std::string& name,
     const blink::StorageKey& storage_key,
     blink::mojom::SharedWorkerCreationContextType creation_context_type)
-    : url_(url),
+    :
+      is_node_js_(is_node_js), root_path_(root_path),
+      url_(url),
       script_type_(script_type),
       credentials_mode_(credentials_mode),
       name_(name),
diff -r -u --color up/chromium/content/public/browser/shared_worker_instance.h nw/chromium/content/public/browser/shared_worker_instance.h
--- up/chromium/content/public/browser/shared_worker_instance.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/public/browser/shared_worker_instance.h	2023-01-28 02:49:28.491620579 +0000
@@ -6,6 +6,7 @@
 #define CONTENT_PUBLIC_BROWSER_SHARED_WORKER_INSTANCE_H_
 
 #include <string>
+#include "base/files/file_path.h"
 
 #include "content/common/content_export.h"
 #include "services/network/public/mojom/content_security_policy.mojom.h"
@@ -29,6 +30,7 @@
 class CONTENT_EXPORT SharedWorkerInstance {
  public:
   SharedWorkerInstance(
+      bool is_node_js, const base::FilePath& root_path,
       const GURL& url,
       blink::mojom::ScriptType script_type,
       network::mojom::CredentialsMode credentials_mode,
@@ -51,6 +53,8 @@
                const blink::StorageKey& storage_key) const;
 
   // Accessors.
+  bool nodejs() const { return is_node_js_; }
+  const base::FilePath& root_path() const { return root_path_; }
   const GURL& url() const { return url_; }
   const std::string& name() const { return name_; }
   blink::mojom::ScriptType script_type() const { return script_type_; }
@@ -63,8 +67,11 @@
   }
 
  private:
-  const GURL url_;
-  const blink::mojom::ScriptType script_type_;
+  bool is_node_js_;
+  base::FilePath root_path_;
+
+  GURL url_;
+  blink::mojom::ScriptType script_type_;
 
   // Used for fetching the top-level worker script.
   const network::mojom::CredentialsMode credentials_mode_;
diff -r -u --color up/chromium/content/public/browser/site_instance.h nw/chromium/content/public/browser/site_instance.h
--- up/chromium/content/public/browser/site_instance.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/public/browser/site_instance.h	2023-01-28 02:49:28.491620579 +0000
@@ -154,7 +154,7 @@
   // that a BrowsingInstance only has one SiteInstance per site, so that pages
   // in a BrowsingInstance have the ability to script each other.
   virtual scoped_refptr<SiteInstance> GetRelatedSiteInstance(
-      const GURL& url) = 0;
+                                                             const GURL& url, bool allow_default_instance = true) = 0;
 
   // Returns whether the given SiteInstance is in the same BrowsingInstance as
   // this one.  If so, JavaScript interactions that are permitted across
diff -r -u --color up/chromium/content/public/browser/web_contents.cc nw/chromium/content/public/browser/web_contents.cc
--- up/chromium/content/public/browser/web_contents.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/public/browser/web_contents.cc	2023-01-28 02:49:28.495620622 +0000
@@ -11,6 +11,14 @@
 
 namespace content {
 
+bool WebContents::is_silent_printing() {
+  return silent_printing_;
+}
+
+void WebContents::set_silent_printing(bool flag) {
+  silent_printing_ = flag;
+}
+
 WebContents::CreateParams::CreateParams(BrowserContext* context,
                                         base::Location creator_location)
     : CreateParams(context, nullptr, creator_location) {}
diff -r -u --color up/chromium/content/public/browser/web_contents.h nw/chromium/content/public/browser/web_contents.h
--- up/chromium/content/public/browser/web_contents.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/public/browser/web_contents.h	2023-01-28 02:49:28.495620622 +0000
@@ -328,6 +328,11 @@
 
   ~WebContents() override = default;
 
+  virtual bool is_silent_printing();
+  virtual void set_silent_printing(bool);
+
+  bool silent_printing_ = false;
+
   // Intrinsic tab state -------------------------------------------------------
 
   // Gets/Sets the delegate.
diff -r -u --color up/chromium/content/public/browser/web_contents_delegate.cc nw/chromium/content/public/browser/web_contents_delegate.cc
--- up/chromium/content/public/browser/web_contents_delegate.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/public/browser/web_contents_delegate.cc	2023-01-28 02:49:28.495620622 +0000
@@ -32,6 +32,10 @@
   return nullptr;
 }
 
+bool WebContentsDelegate::CanLoadFileSubresource(const GURL& url) {
+  return false;
+}
+
 bool WebContentsDelegate::ShouldAllowRendererInitiatedCrossProcessNavigation(
     bool is_outermost_main_frame_navigation) {
   return true;
diff -r -u --color up/chromium/content/public/browser/web_contents_delegate.h nw/chromium/content/public/browser/web_contents_delegate.h
--- up/chromium/content/public/browser/web_contents_delegate.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/public/browser/web_contents_delegate.h	2023-01-28 02:49:28.495620622 +0000
@@ -114,6 +114,8 @@
  public:
   WebContentsDelegate();
 
+  void set_tmp_manifest(const std::string& manifest) {manifest_ = manifest; }
+  const std::string& tmp_manifest() { return manifest_; }
   // Opens a new URL inside the passed in WebContents (if source is 0 open
   // in the current front-most tab), unless |disposition| indicates the url
   // should be opened in a new tab or window.
@@ -132,6 +134,7 @@
   virtual bool ShouldAllowRendererInitiatedCrossProcessNavigation(
       bool is_outermost_main_frame_navigation);
 
+  virtual bool CanLoadFileSubresource(const GURL& url);
   // Called to inform the delegate that the WebContents's navigation state
   // changed. The |changed_flags| indicates the parts of the navigation state
   // that have been updated.
@@ -349,7 +352,8 @@
                                   int opener_render_frame_id,
                                   const std::string& frame_name,
                                   const GURL& target_url,
-                                  WebContents* new_contents) {}
+                                  WebContents* new_contents,
+                                  const std::u16string& nw_window_manifest) {}
 
   // Notifies the embedder that a new WebContents has been created to contain
   // the contents of a portal.
@@ -770,6 +774,8 @@
  protected:
   virtual ~WebContentsDelegate();
 
+  std::string manifest_;
+
  private:
   friend class WebContentsImpl;
 
diff -r -u --color up/chromium/content/public/common/common_param_traits_macros.h nw/chromium/content/public/common/common_param_traits_macros.h
--- up/chromium/content/public/common/common_param_traits_macros.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/public/common/common_param_traits_macros.h	2023-01-28 02:49:28.499620664 +0000
@@ -147,6 +147,8 @@
 #if BUILDFLAG(IS_OZONE)
   IPC_STRUCT_TRAITS_MEMBER(selection_clipboard_buffer_available)
 #endif
+  IPC_STRUCT_TRAITS_MEMBER(nw_inject_js_doc_start)
+  IPC_STRUCT_TRAITS_MEMBER(nw_inject_js_doc_end)
 IPC_STRUCT_TRAITS_END()
 
 IPC_ENUM_TRAITS_MAX_VALUE(content::DropData::Kind,
diff -r -u --color up/chromium/content/public/common/content_client.h nw/chromium/content/public/common/content_client.h
--- up/chromium/content/public/common/content_client.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/public/common/content_client.h	2023-01-28 02:49:28.499620664 +0000
@@ -5,6 +5,8 @@
 #ifndef CONTENT_PUBLIC_COMMON_CONTENT_CLIENT_H_
 #define CONTENT_PUBLIC_COMMON_CONTENT_CLIENT_H_
 
+#include "base/files/file_path.h"
+
 #include <set>
 #include <string>
 #include <vector>
@@ -24,6 +26,7 @@
 class FilePath;
 class RefCountedMemory;
 class SequencedTaskRunner;
+class DictionaryValue;
 }
 
 namespace blink {
@@ -61,10 +64,10 @@
 // content code is called.
 CONTENT_EXPORT void SetContentClient(ContentClient* client);
 
-#if defined(CONTENT_IMPLEMENTATION)
+//#if defined(CONTENT_IMPLEMENTATION)
 // Content's embedder API should only be used by content.
-ContentClient* GetContentClient();
-#endif
+CONTENT_EXPORT ContentClient* GetContentClient();
+//#endif
 
 // Used for tests to override the relevant embedder interfaces. Each method
 // returns the old value. In browser tests it seems safest to call these in
@@ -84,6 +87,9 @@
   ContentClient();
   virtual ~ContentClient();
 
+  virtual void LoadNWAppAsExtension(base::DictionaryValue* manifest,
+                                    const base::FilePath& path,
+                                    std::string* error) {}
   ContentBrowserClient* browser() { return browser_; }
   ContentGpuClient* gpu() { return gpu_; }
   ContentRendererClient* renderer() { return renderer_; }
@@ -97,6 +103,7 @@
   // WebSecurityOrigin or a full URL (if called from the browser process) and a
   // string is the lowest-common-denominator.
   virtual void SetActiveURL(const GURL& url, std::string top_origin) {}
+  virtual void SetNWReportURL(const GURL& url) {}
 
   // Sets the data on the current gpu.
   virtual void SetGpuInfo(const gpu::GPUInfo& gpu_info) {}
diff -r -u --color up/chromium/content/public/common/content_features.cc nw/chromium/content/public/common/content_features.cc
--- up/chromium/content/public/common/content_features.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/public/common/content_features.cc	2023-01-28 02:49:28.499620664 +0000
@@ -16,6 +16,9 @@
 
 namespace features {
 
+const base::Feature kNWNewWin{
+    "nw2", base::FEATURE_ENABLED_BY_DEFAULT};
+
 // All features in alphabetical order.
 
 // Enables content-initiated, main frame navigations to data URLs.
@@ -792,7 +795,7 @@
 // at a time.
 BASE_FEATURE(kProcessSharingWithDefaultSiteInstances,
              "ProcessSharingWithDefaultSiteInstances",
-             base::FEATURE_ENABLED_BY_DEFAULT);
+             base::FEATURE_DISABLED_BY_DEFAULT); //NWJS#7197
 
 // Whether cross-site frames should get their own SiteInstance even when
 // strict site isolation is disabled. These SiteInstances will still be
@@ -1123,7 +1126,7 @@
 // This feature is only consulted in site-per-process mode.
 BASE_FEATURE(kSpareRendererForSitePerProcess,
              "SpareRendererForSitePerProcess",
-             base::FEATURE_ENABLED_BY_DEFAULT);
+             base::FEATURE_DISABLED_BY_DEFAULT);
 
 BASE_FEATURE(kStopVideoCaptureOnScreenLock,
              "StopVideoCaptureOnScreenLock",
diff -r -u --color up/chromium/content/public/common/content_features.h nw/chromium/content/public/common/content_features.h
--- up/chromium/content/public/common/content_features.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/public/common/content_features.h	2023-01-28 02:49:28.499620664 +0000
@@ -17,6 +17,7 @@
 
 namespace features {
 
+CONTENT_EXPORT extern const base::Feature kNWNewWin;
 // All features in alphabetical order. The features should be documented
 // alongside the definition of their values in the .cc file.
 CONTENT_EXPORT BASE_DECLARE_FEATURE(kAllowContentInitiatedDataUrlNavigations);
diff -r -u --color up/chromium/content/public/common/content_switches.cc nw/chromium/content/public/common/content_switches.cc
--- up/chromium/content/public/common/content_switches.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/public/common/content_switches.cc	2023-01-28 02:49:28.499620664 +0000
@@ -136,9 +136,17 @@
 // then the GPU process won't launch.
 const char kDisableGpu[]                    = "disable-gpu";
 
+// Disable apps transparency support
+const char kDisableTransparency[]           = "disable-transparency";
+
+// Force CPU drawing, needed to enable click through on transparent window
+const char kForceCpuDraw[]                  = "force-cpu-draw";
+
 // Prevent the compositor from using its GPU implementation.
 const char kDisableGpuCompositing[]         = "disable-gpu-compositing";
-
+const char kDisableRAFThrottling[]          = "disable-raf-throttling";
+const char kEnableNodeWorker[]              = "enable-node-worker";
+const char kNWAppPath[]                     = "nwapp-path";
 // Disable proactive early init of GPU process.
 const char kDisableGpuEarlyInit[]           = "disable-gpu-early-init";
 
diff -r -u --color up/chromium/content/public/common/content_switches.h nw/chromium/content/public/common/content_switches.h
--- up/chromium/content/public/common/content_switches.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/public/common/content_switches.h	2023-01-28 02:49:28.499620664 +0000
@@ -52,7 +52,12 @@
 CONTENT_EXPORT extern const char kDisableFileSystem[];
 CONTENT_EXPORT extern const char kDisableGestureRequirementForPresentation[];
 CONTENT_EXPORT extern const char kDisableGpu[];
+CONTENT_EXPORT extern const char kDisableTransparency[];
+CONTENT_EXPORT extern const char kForceCpuDraw[];
 CONTENT_EXPORT extern const char kDisableGpuCompositing[];
+CONTENT_EXPORT extern const char kDisableRAFThrottling[];
+CONTENT_EXPORT extern const char kEnableNodeWorker[];
+CONTENT_EXPORT extern const char kNWAppPath[];
 CONTENT_EXPORT extern const char kDisableGpuEarlyInit[];
 CONTENT_EXPORT extern const char kDisableGpuMemoryBufferCompositorResources[];
 CONTENT_EXPORT extern const char kDisableGpuMemoryBufferVideoFrames[];
diff -r -u --color up/chromium/content/public/common/user_agent.h nw/chromium/content/public/common/user_agent.h
--- up/chromium/content/public/common/user_agent.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/public/common/user_agent.h	2023-01-28 02:49:28.503620706 +0000
@@ -54,6 +54,7 @@
     IncludeAndroidBuildNumber include_android_build_number,
     IncludeAndroidModel include_android_model);
 
+CONTENT_EXPORT std::string BuildOSInfo();
 // Returns the reduced User-agent string for
 // https://github.com/WICG/ua-client-hints.
 CONTENT_EXPORT std::string GetReducedUserAgent(bool mobile,
@@ -78,7 +79,6 @@
 // if on a codenamed (i.e. not a release) build of an Android.
 CONTENT_EXPORT std::string BuildModelInfo();
 
-#if BUILDFLAG(IS_ANDROID)
 // Helper function to generate a full user agent string given a short
 // product name and some extra text to be added to the OS info.
 // This is currently only used for Android Web View.
@@ -91,7 +91,6 @@
 CONTENT_EXPORT std::string GetAndroidOSInfo(
     IncludeAndroidBuildNumber include_android_build_number,
     IncludeAndroidModel include_android_model);
-#endif
 
 // Builds a full user agent string given a string describing the OS and a
 // product name.
diff -r -u --color up/chromium/content/public/renderer/content_renderer_client.cc nw/chromium/content/public/renderer/content_renderer_client.cc
--- up/chromium/content/public/renderer/content_renderer_client.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/public/renderer/content_renderer_client.cc	2023-01-28 02:49:28.503620706 +0000
@@ -18,6 +18,10 @@
 
 namespace content {
 
+base::FilePath ContentRendererClient::GetRootPath() {
+  return base::FilePath();
+}
+
 SkBitmap* ContentRendererClient::GetSadPluginBitmap() {
   return nullptr;
 }
diff -r -u --color up/chromium/content/public/renderer/content_renderer_client.h nw/chromium/content/public/renderer/content_renderer_client.h
--- up/chromium/content/public/renderer/content_renderer_client.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/public/renderer/content_renderer_client.h	2023-01-28 02:49:28.503620706 +0000
@@ -12,6 +12,8 @@
 #include <string>
 #include <vector>
 
+#include "base/files/file_path.h"
+
 #include "base/callback_forward.h"
 #include "base/files/file_path.h"
 #include "base/memory/ref_counted.h"
@@ -48,6 +50,7 @@
 
 namespace blink {
 class WebElement;
+class WebString;
 class WebFrame;
 class WebLocalFrame;
 class WebPlugin;
@@ -82,10 +85,18 @@
 
 namespace content {
 class RenderFrame;
+class RenderView;
 
 // Embedder API for participating in renderer logic.
 class CONTENT_EXPORT ContentRendererClient {
  public:
+  virtual base::FilePath GetRootPath();
+  virtual void willHandleNavigationPolicy(RenderFrame* rv,
+                                          blink::WebFrame* frame,
+                                          const blink::WebURLRequest& request,
+                                          blink::WebNavigationPolicy* policy,
+                                          blink::WebString* manifest,
+                                          bool new_win) {}
   virtual ~ContentRendererClient() {}
 
   // Notifies us that the RenderThread has been created.
diff -r -u --color up/chromium/content/public/renderer/render_thread.h nw/chromium/content/public/renderer/render_thread.h
--- up/chromium/content/public/renderer/render_thread.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/public/renderer/render_thread.h	2023-01-28 02:49:28.503620706 +0000
@@ -19,6 +19,8 @@
 #include "third_party/blink/public/platform/web_string.h"
 #include "third_party/perfetto/include/perfetto/tracing/traced_proto.h"
 
+class GURL;
+
 namespace base {
 class UnguessableToken;
 class WaitableEvent;
@@ -98,6 +100,11 @@
   // Post task to all worker threads. Returns number of workers.
   virtual int PostTaskToAllWebWorkers(base::RepeatingClosure closure) = 0;
 
+  // Resolve the proxy servers to use for a given url. On success true is
+  // returned and |proxy_list| is set to a PAC string containing a list of
+  // proxy servers.
+  virtual bool ResolveProxy(const GURL& url, std::string* proxy_list) = 0;
+
   // Gets the shutdown event for the process.
   virtual base::WaitableEvent* GetShutdownEvent() = 0;
 
diff -r -u --color up/chromium/content/public/test/browser_test_base.cc nw/chromium/content/public/test/browser_test_base.cc
--- up/chromium/content/public/test/browser_test_base.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/public/test/browser_test_base.cc	2023-01-28 02:49:28.507620749 +0000
@@ -316,6 +316,8 @@
       switches::kIPCConnectionTimeout,
       base::NumberToString(TestTimeouts::action_max_timeout().InSeconds()));
 
+  command_line->AppendSwitch("nwjs-test-mode");
+
   command_line->AppendSwitch(switches::kDomAutomationController);
 
   // It is sometimes useful when looking at browser test failures to know which
diff -r -u --color up/chromium/content/public/test/mock_render_thread.cc nw/chromium/content/public/test/mock_render_thread.cc
--- up/chromium/content/public/test/mock_render_thread.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/public/test/mock_render_thread.cc	2023-01-28 02:49:28.515620833 +0000
@@ -200,6 +200,10 @@
   return 0;
 }
 
+bool MockRenderThread::ResolveProxy(const GURL& url, std::string* proxy_list) {
+  return false;
+}
+
 base::WaitableEvent* MockRenderThread::GetShutdownEvent() {
   return nullptr;
 }
diff -r -u --color up/chromium/content/public/test/mock_render_thread.h nw/chromium/content/public/test/mock_render_thread.h
--- up/chromium/content/public/test/mock_render_thread.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/public/test/mock_render_thread.h	2023-01-28 02:49:28.515620833 +0000
@@ -78,6 +78,7 @@
   void RecordAction(const base::UserMetricsAction& action) override;
   void RecordComputedAction(const std::string& action) override;
   int PostTaskToAllWebWorkers(base::RepeatingClosure closure) override;
+  bool ResolveProxy(const GURL& url, std::string* proxy_list) override;
   base::WaitableEvent* GetShutdownEvent() override;
   int32_t GetClientId() override;
   void SetRendererProcessType(
diff -r -u --color up/chromium/content/renderer/BUILD.gn nw/chromium/content/renderer/BUILD.gn
--- up/chromium/content/renderer/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/renderer/BUILD.gn	2023-01-28 02:49:28.519620875 +0000
@@ -46,6 +46,8 @@
     "accessibility/ax_tree_snapshotter_impl.h",
     "accessibility/blink_ax_action_target.cc",
     "accessibility/blink_ax_action_target.h",
+    "//base/message_loop/message_pumpuv_mac.mm",
+    "//base/message_loop/message_pumpuv_mac.h",
     "accessibility/render_accessibility_impl.cc",
     "accessibility/render_accessibility_impl.h",
     "accessibility/render_accessibility_manager.cc",
diff -r -u --color up/chromium/content/renderer/agent_scheduling_group.cc nw/chromium/content/renderer/agent_scheduling_group.cc
--- up/chromium/content/renderer/agent_scheduling_group.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/renderer/agent_scheduling_group.cc	2023-01-28 02:49:28.523620918 +0000
@@ -294,7 +294,7 @@
   web_view->SetWebPreferences(params->web_preferences);
 
   if (local_main_frame) {
-    RenderFrameImpl::CreateMainFrame(
+    RenderFrameImpl* main_frame = RenderFrameImpl::CreateMainFrame(
         *this, web_view, opener_frame,
         /*is_for_nested_main_frame=*/params->type !=
             mojom::ViewWidgetType::kTopLevel,
@@ -302,6 +302,7 @@
             mojom::ViewWidgetType::kFencedFrame,
         std::move(params->replication_state), params->devtools_main_frame_token,
         std::move(params->main_frame->get_local_params()));
+    main_frame->SetSkipBlockingParser(params->skip_blocking_parser);
   } else {
     blink::WebRemoteFrame::CreateMainFrame(
         web_view, params->main_frame->get_remote_params()->token,
diff -r -u --color up/chromium/content/renderer/frame_owner_properties_converter.cc nw/chromium/content/renderer/frame_owner_properties_converter.cc
--- up/chromium/content/renderer/frame_owner_properties_converter.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/renderer/frame_owner_properties_converter.cc	2023-01-28 02:49:28.523620918 +0000
@@ -13,6 +13,8 @@
   blink::WebFrameOwnerProperties result;
   result.name = blink::WebString::FromUTF8(mojo_properties.name);
   result.scrollbar_mode = mojo_properties.scrollbar_mode;
+  result.nwFakeTop = mojo_properties.nwfaketop;
+  result.nwuseragent = blink::WebString::FromUTF8(mojo_properties.nwuseragent);
   result.margin_width = mojo_properties.margin_width;
   result.margin_height = mojo_properties.margin_height;
   result.allow_fullscreen = mojo_properties.allow_fullscreen;
@@ -32,6 +34,8 @@
 
   mojo_properties->name = web_frame_owner_properties.name.Utf8();
   mojo_properties->scrollbar_mode = web_frame_owner_properties.scrollbar_mode;
+  mojo_properties->nwfaketop = web_frame_owner_properties.nwFakeTop;
+  mojo_properties->nwuseragent = web_frame_owner_properties.nwuseragent.Utf8();
   mojo_properties->margin_width = web_frame_owner_properties.margin_width;
   mojo_properties->margin_height = web_frame_owner_properties.margin_height;
   mojo_properties->allow_fullscreen =
diff -r -u --color up/chromium/content/renderer/in_process_renderer_thread.cc nw/chromium/content/renderer/in_process_renderer_thread.cc
--- up/chromium/content/renderer/in_process_renderer_thread.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/renderer/in_process_renderer_thread.cc	2023-01-28 02:49:28.523620918 +0000
@@ -13,6 +13,8 @@
 #include "third_party/blink/public/platform/platform.h"
 #include "third_party/blink/public/platform/scheduler/web_thread_scheduler.h"
 
+#include "content/nw/src/nw_content.h"
+
 #if BUILDFLAG(IS_ANDROID)
 #include "base/android/jni_android.h"
 #endif
diff -r -u --color up/chromium/content/renderer/media/render_media_client.cc nw/chromium/content/renderer/media/render_media_client.cc
--- up/chromium/content/renderer/media/render_media_client.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/renderer/media/render_media_client.cc	2023-01-28 02:49:28.527620960 +0000
@@ -25,7 +25,7 @@
      BUILDFLAG(IS_MAC))
 #define NEEDS_PROFILE_UPDATER 1
 #else
-#define NEEDS_PROFILE_UPDATER 0
+#define NEEDS_PROFILE_UPDATER 1
 #endif
 
 #if NEEDS_PROFILE_UPDATER
diff -r -u --color up/chromium/content/renderer/render_frame_impl.cc nw/chromium/content/renderer/render_frame_impl.cc
--- up/chromium/content/renderer/render_frame_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/renderer/render_frame_impl.cc	2023-01-28 02:49:28.539621087 +0000
@@ -257,6 +257,9 @@
 
 using base::Time;
 using blink::ContextMenuData;
+
+#include "content/nw/src/nw_content.h"
+
 using blink::WebContentDecryptionModule;
 using blink::WebData;
 using blink::WebDocument;
@@ -1153,6 +1156,7 @@
     case blink::kWebNavigationPolicyDownload:
       return WindowOpenDisposition::SAVE_TO_DISK;
     case blink::kWebNavigationPolicyCurrentTab:
+    case blink::kWebNavigationPolicyIgnore:
       return WindowOpenDisposition::CURRENT_TAB;
     case blink::kWebNavigationPolicyNewBackgroundTab:
       return WindowOpenDisposition::NEW_BACKGROUND_TAB;
@@ -1424,6 +1428,16 @@
   return render_frame_->frame_;
 }
 
+void RenderFrameImpl::willHandleNavigationPolicy(
+                                                blink::WebFrame* frame,
+                                                const blink::WebURLRequest& request,
+                                                blink::WebNavigationPolicy* policy,
+                                                blink::WebString* manifest,
+                                                bool new_win) {
+  GetContentClient()->renderer()
+    ->willHandleNavigationPolicy(this, frame, request, policy, manifest, new_win);
+}
+
 // static
 RenderFrameImpl* RenderFrameImpl::Create(
     AgentSchedulingGroup& agent_scheduling_group,
@@ -1814,7 +1828,8 @@
 
 // RenderFrameImpl ----------------------------------------------------------
 RenderFrameImpl::RenderFrameImpl(CreateParams params)
-    : agent_scheduling_group_(*params.agent_scheduling_group),
+  : skip_blocking_parser_(true), frame_(nullptr),
+      agent_scheduling_group_(*params.agent_scheduling_group),
       is_main_frame_(true),
       unique_name_frame_adapter_(this),
       unique_name_helper_(&unique_name_frame_adapter_),
@@ -2463,6 +2478,10 @@
   interface_provider_receivers_.Add(this, std::move(receiver), task_runner);
 }
 
+void RenderFrameImpl::SetSkipBlockingParser(bool value) {
+  skip_blocking_parser_ = value;
+}
+
 void RenderFrameImpl::BlockRequests() {
   frame_request_blocker_->Block();
 }
@@ -4362,6 +4381,7 @@
         context, std::move(mojo_js_interface_broker_));
   }
 
+  GetFrameHost()->SetContextCreated(true);
   for (auto& observer : observers_)
     observer.DidCreateScriptContext(context, world_id);
 }
@@ -4370,6 +4390,7 @@
                                                int world_id) {
   for (auto& observer : observers_)
     observer.WillReleaseScriptContext(context, world_id);
+  GetFrameHost()->SetContextCreated(false);
 }
 
 void RenderFrameImpl::DidChangeScrollOffset() {
@@ -4397,6 +4418,10 @@
 }
 
 blink::WebString RenderFrameImpl::UserAgentOverride() {
+  std::string user_agent;
+  if (nw::GetUserAgentFromManifest(&user_agent))
+    return WebString::FromUTF8(user_agent);
+
   if (ShouldUseUserAgentOverride()) {
     return WebString::FromUTF8(GetWebView()
                                    ->GetRendererPreferences()
@@ -6170,7 +6195,8 @@
     bool& consumed_user_gesture,
     const absl::optional<blink::Impression>& impression,
     const absl::optional<blink::WebPictureInPictureWindowOptions>&
-        pip_options) {
+    pip_options,
+    blink::WebString* manifest) {
   consumed_user_gesture = false;
   mojom::CreateNewWindowParamsPtr params = mojom::CreateNewWindowParams::New();
 
@@ -6201,6 +6227,7 @@
         request.GetReferrerPolicy());
   }
   params->features = ConvertWebWindowFeaturesToMojoWindowFeatures(features);
+  params->nw_window_manifest = manifest->Utf16();
 
   params->is_form_submission = request.IsFormSubmission();
   params->form_submission_post_data =
@@ -6284,6 +6311,7 @@
   // disagrees.
   mojom::CreateViewParamsPtr view_params = mojom::CreateViewParams::New();
 
+  view_params->skip_blocking_parser = true;
   view_params->opener_frame_token = GetWebFrame()->GetFrameToken();
   view_params->window_was_opened_by_another_window = true;
   view_params->renderer_preferences = GetWebView()->GetRendererPreferences();
diff -r -u --color up/chromium/content/renderer/render_frame_impl.h nw/chromium/content/renderer/render_frame_impl.h
--- up/chromium/content/renderer/render_frame_impl.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/renderer/render_frame_impl.h	2023-01-28 02:49:28.539621087 +0000
@@ -173,6 +173,8 @@
       service_manager::mojom::InterfaceProvider {
  public:
   // Creates a new RenderFrame as the main frame of `web_view`.
+  bool skip_blocking_parser_;
+  void SetSkipBlockingParser(bool) override;
   static RenderFrameImpl* CreateMainFrame(
       AgentSchedulingGroup& agent_scheduling_group,
       blink::WebView* web_view,
@@ -620,7 +622,8 @@
       bool& consumed_user_gesture,
       const absl::optional<blink::Impression>& impression,
       const absl::optional<blink::WebPictureInPictureWindowOptions>&
-          pip_options) override;
+      pip_options,
+      blink::WebString* manifest) override;
 
   // Dispatches the current state of selection on the webpage to the browser if
   // it has changed or if the forced flag is passed. The forced flag is used
@@ -667,6 +670,13 @@
   // started media playback (i.e. played audio and video).
   bool DeferMediaLoad(bool has_played_media_before, base::OnceClosure closure);
 
+  void willHandleNavigationPolicy(
+                                  blink::WebFrame*,
+                                  const blink::WebURLRequest&,
+                                  blink::WebNavigationPolicy*,
+                                  blink::WebString* manifest = NULL,
+                                  bool new_win = true) override;
+
   // Binds to the MHTML file generation service in the browser.
   void BindMhtmlFileWriter(
       mojo::PendingAssociatedReceiver<mojom::MhtmlFileWriter> receiver);
diff -r -u --color up/chromium/content/renderer/render_process_impl.cc nw/chromium/content/renderer/render_process_impl.cc
--- up/chromium/content/renderer/render_process_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/renderer/render_process_impl.cc	2023-01-28 02:49:28.539621087 +0000
@@ -268,6 +268,12 @@
     v8::V8::EnableWebAssemblyTrapHandler(use_v8_signal_handler);
   }
 #endif  // BUILDFLAG(IS_MAC) && defined(ARCH_CPU_X86_64)
+
+  if (!base::CommandLine::ForCurrentProcess()->HasSwitch("nwjs-guest")) {
+    std::string flags("--allow-natives-syntax");
+    v8::V8::SetFlagsFromString(flags.c_str(), static_cast<size_t>(flags.size()));
+  }
+
 }
 
 RenderProcessImpl::~RenderProcessImpl() {
diff -r -u --color up/chromium/content/renderer/render_thread_impl.cc nw/chromium/content/renderer/render_thread_impl.cc
--- up/chromium/content/renderer/render_thread_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/renderer/render_thread_impl.cc	2023-01-28 02:49:28.539621087 +0000
@@ -1001,6 +1001,13 @@
       std::move(closure));
 }
 
+bool RenderThreadImpl::ResolveProxy(const GURL& url, std::string* proxy_list) {
+  absl::optional<std::string> result;
+  GetRendererHost()->ResolveProxy(url, &result);
+  *proxy_list = result.value_or(std::string());
+  return result.has_value();
+}
+
 media::GpuVideoAcceleratorFactories* RenderThreadImpl::GetGpuFactories() {
   DCHECK(IsMainThread());
 
diff -r -u --color up/chromium/content/renderer/render_thread_impl.h nw/chromium/content/renderer/render_thread_impl.h
--- up/chromium/content/renderer/render_thread_impl.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/renderer/render_thread_impl.h	2023-01-28 02:49:28.539621087 +0000
@@ -182,6 +182,7 @@
     return resource_request_sender_delegate_;
   }
   int PostTaskToAllWebWorkers(base::RepeatingClosure closure) override;
+  bool ResolveProxy(const GURL& url, std::string* proxy_list) override;
   base::WaitableEvent* GetShutdownEvent() override;
   int32_t GetClientId() override;
   void SetRendererProcessType(
diff -r -u --color up/chromium/content/renderer/renderer_blink_platform_impl.cc nw/chromium/content/renderer/renderer_blink_platform_impl.cc
--- up/chromium/content/renderer/renderer_blink_platform_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/renderer/renderer_blink_platform_impl.cc	2023-01-28 02:49:28.543621129 +0000
@@ -6,6 +6,8 @@
 
 #include <algorithm>
 #include <memory>
+#include "content/nw/src/nw_version.h"
+
 #include <utility>
 #include <vector>
 
@@ -133,6 +135,21 @@
 using blink::WebURL;
 using blink::WebVector;
 
+#include "third_party/node-nw/src/node_webkit.h"
+#include "nw/id/commit.h"
+
+#if defined(COMPONENT_BUILD) && defined(WIN32)
+#define NW_HOOK_MAP(type, sym, fn) BASE_EXPORT type fn;
+#else
+#define NW_HOOK_MAP(type, sym, fn) extern type fn;
+#endif
+#include "content/nw/src/common/node_hooks.h"
+#undef NW_HOOK_MAP
+
+namespace nw{
+const char* GetChromiumVersion();
+}
+
 namespace content {
 
 namespace {
@@ -879,9 +896,40 @@
 }
 
 void RendererBlinkPlatformImpl::WorkerContextCreated(
-    const v8::Local<v8::Context>& worker) {
+    const v8::Local<v8::Context>& worker, bool isNodeJS, const std::string& main_script) {
   GetContentClient()->renderer()->DidInitializeWorkerContextOnWorkerThread(
       worker);
+  if (isNodeJS) {
+      int argc = 1;
+      char argv0[] = "node";
+      char* argv[3];
+      argv[0] = argv0;
+      argv[1] = argv[2] = nullptr;
+
+      v8::Isolate* isolate = v8::Isolate::GetCurrent();
+      v8::HandleScope scope(isolate);
+      v8::MicrotasksScope microtasks(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);
+
+      worker->SetSecurityToken(v8::String::NewFromUtf8(isolate, "nw-token", v8::NewStringType::kNormal).ToLocalChecked());
+      worker->Enter();
+
+      ::g_start_nw_instance_fn(argc, argv, worker, nullptr);
+      {
+        v8::Local<v8::Script> script =
+          v8::Script::Compile(worker, v8::String::NewFromUtf8(isolate,
+                                                      (std::string("process.versions['nw'] = '" NW_VERSION_STRING "';") +
+                                                       "process.versions['node-webkit'] = '" NW_VERSION_STRING "';"
+                                                       "process.versions['nw-commit-id'] = '" NW_COMMIT_HASH "';"
+                                                       "process.versions['chromium'] = '" + "';").c_str(), v8::NewStringType::kNormal
+                                                              ).ToLocalChecked()).ToLocalChecked();
+        std::ignore = script->Run(worker);
+      }
+      {
+        v8::Local<v8::Script> script =
+          v8::Script::Compile(worker, v8::String::NewFromUtf8(isolate, main_script.c_str(), v8::NewStringType::kNormal).ToLocalChecked()).ToLocalChecked();
+        std::ignore = script->Run(worker);
+      }
+  }
 }
 
 bool RendererBlinkPlatformImpl::AllowScriptExtensionForServiceWorker(
diff -r -u --color up/chromium/content/renderer/renderer_blink_platform_impl.h nw/chromium/content/renderer/renderer_blink_platform_impl.h
--- up/chromium/content/renderer/renderer_blink_platform_impl.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/renderer/renderer_blink_platform_impl.h	2023-01-28 02:49:28.543621129 +0000
@@ -182,7 +182,7 @@
       const blink::BrowserInterfaceBrokerProxy&) override;
   void DidStartWorkerThread() override;
   void WillStopWorkerThread() override;
-  void WorkerContextCreated(const v8::Local<v8::Context>& worker) override;
+  void WorkerContextCreated(const v8::Local<v8::Context>& worker, bool, const std::string&) override;
   bool AllowScriptExtensionForServiceWorker(
       const blink::WebSecurityOrigin& script_origin) override;
   blink::ProtocolHandlerSecurityLevel GetProtocolHandlerSecurityLevel()
diff -r -u --color up/chromium/content/renderer/renderer_main.cc nw/chromium/content/renderer/renderer_main.cc
--- up/chromium/content/renderer/renderer_main.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/renderer/renderer_main.cc	2023-01-28 02:49:28.543621129 +0000
@@ -4,13 +4,14 @@
 
 #include <stddef.h>
 #include <utility>
-
+#include "base/files/file_util.h"
 #include "base/base_switches.h"
 #include "base/command_line.h"
 #include "base/debug/debugger.h"
 #include "base/debug/leak_annotations.h"
 #include "base/i18n/rtl.h"
 #include "base/message_loop/message_pump.h"
+#include "base/message_loop/message_pump_uv.h"
 #include "base/message_loop/message_pump_type.h"
 #include "base/metrics/histogram_functions.h"
 #include "base/metrics/histogram_macros.h"
@@ -47,6 +48,7 @@
 #include "third_party/icu/source/i18n/unicode/timezone.h"
 #include "third_party/webrtc_overrides/init_webrtc.h"  // nogncheck
 #include "ui/base/ui_base_switches.h"
+#include "content/nw/src/nw_content.h"
 
 #if BUILDFLAG(IS_ANDROID)
 #include "base/android/library_loader/library_loader_hooks.h"
@@ -60,6 +62,7 @@
 #include "base/mac/scoped_nsautorelease_pool.h"
 #include "base/message_loop/message_pump_mac.h"
 #include "third_party/blink/public/web/web_view.h"
+#include "base/message_loop/message_pumpuv_mac.h"
 #endif  // BUILDFLAG(IS_MAC)
 
 #if BUILDFLAG(IS_CHROMEOS_ASH)
@@ -81,6 +84,17 @@
 #endif
 
 namespace content {
+
+#if defined(__clang__)
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wexit-time-destructors"
+#endif
+CONTENT_EXPORT base::FilePath g_nw_temp_dir;
+CONTENT_EXPORT base::FilePath g_nw_old_cwd;
+#if defined(__clang__)
+#pragma clang diagnostic pop
+#endif
+
 namespace {
 
 // This function provides some ways to test crash and assertion handling
@@ -93,17 +107,30 @@
     WaitForDebugger("Renderer");
 }
 
-std::unique_ptr<base::MessagePump> CreateMainThreadMessagePump() {
+std::unique_ptr<base::MessagePump> CreateMainThreadMessagePump(bool nwjs) {
 #if BUILDFLAG(IS_MAC)
   // As long as scrollbars on Mac are painted with Cocoa, the message pump
   // needs to be backed by a Foundation-level loop to process NSTimers. See
   // http://crbug.com/306348#c24 for details.
-  return base::MessagePump::Create(base::MessagePumpType::NS_RUNLOOP);
+  base::MessagePump* p;
+  if (nwjs) {
+    p = new base::MessagePumpUVNSRunLoop();
+  } else
+    p = new base::MessagePumpNSRunLoop();
+  std::unique_ptr<base::MessagePump> pump(p);
+  return pump;
+
 #elif BUILDFLAG(IS_FUCHSIA)
   // Allow FIDL APIs on renderer main thread.
   return base::MessagePump::Create(base::MessagePumpType::IO);
 #else
-  return base::MessagePump::Create(base::MessagePumpType::DEFAULT);
+  base::MessagePump* p;
+  if (nwjs) {
+    p = new base::MessagePumpUV();
+    std::unique_ptr<base::MessagePump> pump(p);
+    return pump;
+  } else
+    return base::MessagePump::Create(base::MessagePumpType::DEFAULT);
 #endif
 }
 
@@ -139,6 +166,11 @@
 
   const base::CommandLine& command_line = *parameters.command_line;
 
+  bool nwjs = command_line.HasSwitch(switches::kNWJS);
+
+  if (nwjs)
+    nw::LoadNodeSymbols();
+
 #if BUILDFLAG(IS_MAC)
   base::mac::ScopedNSAutoreleasePool* pool = parameters.autorelease_pool;
 #endif  // BUILDFLAG(IS_MAC)
@@ -209,7 +241,7 @@
   blink::Platform::InitializeBlink();
   std::unique_ptr<blink::scheduler::WebThreadScheduler> main_thread_scheduler =
       blink::scheduler::WebThreadScheduler::CreateMainThreadScheduler(
-          CreateMainThreadMessagePump());
+          CreateMainThreadMessagePump(nwjs));
 
   platform.PlatformInitialize();
 
@@ -313,6 +345,12 @@
       run_loop.Run();
     }
 
+    if (!g_nw_temp_dir.empty()) {
+      base::SetCurrentDirectory(g_nw_temp_dir.DirName());
+      if (base::StartsWith(g_nw_temp_dir.BaseName().value(), FILE_PATH_LITERAL("nw"),
+                           base::CompareCase::SENSITIVE))
+        base::DeleteFile(g_nw_temp_dir);
+    }
 #if defined(LEAK_SANITIZER)
     // Run leak detection before RenderProcessImpl goes out of scope. This helps
     // ignore shutdown-only leaks.
diff -r -u --color up/chromium/content/renderer/worker/embedded_shared_worker_stub.cc nw/chromium/content/renderer/worker/embedded_shared_worker_stub.cc
--- up/chromium/content/renderer/worker/embedded_shared_worker_stub.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/renderer/worker/embedded_shared_worker_stub.cc	2023-01-28 02:49:28.547621171 +0000
@@ -61,7 +61,8 @@
         browser_interface_broker,
     ukm::SourceId ukm_source_id,
     const std::vector<std::string>& cors_exempt_header_list)
-    : receiver_(this, std::move(receiver)) {
+    : receiver_(this, std::move(receiver)),
+      nodejs_(info->is_node_js), root_path_(info->root_path) {
   DCHECK(main_script_load_params);
   DCHECK(pending_subresource_loader_factory_bundle);
 
@@ -118,6 +119,7 @@
                                cors_exempt_header_list);
 
   impl_ = blink::WebSharedWorker::CreateAndStart(
+      nodejs_, root_path_,
       token, info->url, info->options->type, info->options->credentials,
       blink::WebString::FromUTF8(info->options->name),
       blink::WebSecurityOrigin(constructor_origin),
diff -r -u --color up/chromium/content/renderer/worker/embedded_shared_worker_stub.h nw/chromium/content/renderer/worker/embedded_shared_worker_stub.h
--- up/chromium/content/renderer/worker/embedded_shared_worker_stub.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/renderer/worker/embedded_shared_worker_stub.h	2023-01-28 02:49:28.547621171 +0000
@@ -10,6 +10,7 @@
 
 #include "base/unguessable_token.h"
 #include "content/renderer/service_worker/service_worker_provider_context.h"
+#include "base/files/file_path.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
 #include "mojo/public/cpp/bindings/pending_remote.h"
 #include "mojo/public/cpp/bindings/receiver.h"
@@ -111,6 +112,8 @@
   std::unique_ptr<blink::WebSharedWorker> impl_;
 
   scoped_refptr<ServiceWorkerProviderContext> service_worker_provider_context_;
+  bool nodejs_ = false;
+  base::FilePath root_path_;
 
   // The factory bundle used for loading subresources for this shared worker.
   scoped_refptr<blink::ChildURLLoaderFactoryBundle>
diff -r -u --color up/chromium/content/test/BUILD.gn nw/chromium/content/test/BUILD.gn
--- up/chromium/content/test/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/test/BUILD.gn	2023-01-28 02:49:28.567621383 +0000
@@ -2389,6 +2389,7 @@
     "../browser/renderer_host/renderer_sandboxed_process_launcher_delegate_unittest.cc",
     "../browser/renderer_host/transient_allow_popup_unittest.cc",
     "../browser/renderer_host/visible_time_request_trigger_unittest.cc",
+    "../browser/resolve_proxy_helper_unittest.cc",
     "../browser/scheduler/browser_io_thread_delegate_unittest.cc",
     "../browser/scheduler/browser_task_executor_unittest.cc",
     "../browser/scheduler/browser_task_queues_unittest.cc",
@@ -2981,7 +2982,7 @@
       "//device/base",
       "//device/fido",
       "//device/fido:cablev2_authenticator",
-      "//device/fido:cablev2_test_util",
+      #"//device/fido:cablev2_test_util",
       "//device/fido:mocks",
       "//device/fido:test_support",
     ]
diff -r -u --color up/chromium/content/test/test_render_frame.cc nw/chromium/content/test/test_render_frame.cc
--- up/chromium/content/test/test_render_frame.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/test/test_render_frame.cc	2023-01-28 02:49:28.939625173 +0000
@@ -121,6 +121,8 @@
 
  protected:
   // mojom::FrameHost:
+  void SetNodeJS(bool) override {}
+  void SetContextCreated(bool) override {}
   void CreateNewWindow(mojom::CreateNewWindowParamsPtr,
                        CreateNewWindowCallback) override {
     NOTREACHED() << "We should never dispatch to the service side signature.";
diff -r -u --color up/chromium/content/test/test_web_contents.cc nw/chromium/content/test/test_web_contents.cc
--- up/chromium/content/test/test_web_contents.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/test/test_web_contents.cc	2023-01-28 02:49:28.943625210 +0000
@@ -367,7 +367,7 @@
     int route_id,
     WindowOpenDisposition disposition,
     const blink::mojom::WindowFeatures& window_features,
-    bool user_gesture) {}
+    bool user_gesture, std::string) {}
 
 void TestWebContents::ShowCreatedWidget(int process_id,
                                         int route_id,
diff -r -u --color up/chromium/content/test/test_web_contents.h nw/chromium/content/test/test_web_contents.h
--- up/chromium/content/test/test_web_contents.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/content/test/test_web_contents.h	2023-01-28 02:49:28.943625210 +0000
@@ -192,7 +192,7 @@
                          int route_id,
                          WindowOpenDisposition disposition,
                          const blink::mojom::WindowFeatures& window_features,
-                         bool user_gesture) override;
+                         bool user_gesture, std::string) override;
   void ShowCreatedWidget(int process_id,
                          int route_id,
                          const gfx::Rect& initial_rect,
diff -r -u --color up/chromium/device/bluetooth/BUILD.gn nw/chromium/device/bluetooth/BUILD.gn
--- up/chromium/device/bluetooth/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/device/bluetooth/BUILD.gn	2023-01-28 02:49:28.987625616 +0000
@@ -353,8 +353,8 @@
         "bluez/bluetooth_socket_bluez.h",
         "bluez/bluez_features.cc",
         "bluez/bluez_features.h",
-        "bluez/metrics_recorder.cc",
-        "bluez/metrics_recorder.h",
+        #"bluez/metrics_recorder.cc",
+        #"bluez/metrics_recorder.h",
         "dbus/bluetooth_adapter_client.cc",
         "dbus/bluetooth_adapter_client.h",
         "dbus/bluetooth_admin_policy_client.cc",
diff -r -u --color up/chromium/extensions/BUILD.gn nw/chromium/extensions/BUILD.gn
--- up/chromium/extensions/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/BUILD.gn	2023-01-28 02:49:29.195627538 +0000
@@ -181,7 +181,7 @@
     "//services/network/public/mojom",
     "//testing/gmock",
     "//testing/gtest",
-    "//third_party/cld_3/src/src:cld_3",
+    #"//third_party/cld_3/src/src:cld_3",
     "//third_party/zlib/google:zip",
   ]
 
diff -r -u --color up/chromium/extensions/browser/api/app_current_window_internal/app_current_window_internal_api.cc nw/chromium/extensions/browser/api/app_current_window_internal/app_current_window_internal_api.cc
--- up/chromium/extensions/browser/api/app_current_window_internal/app_current_window_internal_api.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/api/app_current_window_internal/app_current_window_internal_api.cc	2023-01-28 02:49:29.199627575 +0000
@@ -26,6 +26,7 @@
 namespace Show = app_current_window_internal::Show;
 namespace SetBounds = app_current_window_internal::SetBounds;
 namespace SetSizeConstraints = app_current_window_internal::SetSizeConstraints;
+namespace SetResizable = app_current_window_internal::SetResizable;
 namespace SetIcon = app_current_window_internal::SetIcon;
 namespace SetShape = app_current_window_internal::SetShape;
 namespace SetAlwaysOnTop = app_current_window_internal::SetAlwaysOnTop;
@@ -264,6 +265,16 @@
 }
 
 ExtensionFunction::ResponseAction
+AppCurrentWindowInternalSetResizableFunction::Run() {
+  std::unique_ptr<SetResizable::Params> params(
+                                               SetResizable::Params::Create(args()));
+  CHECK(params.get());
+  window()->GetBaseWindow()->SetResizable(params->flag);
+  window()->OnNativeWindowChanged();
+  return RespondNow(NoArguments());
+}
+
+ExtensionFunction::ResponseAction
 AppCurrentWindowInternalSetSizeConstraintsFunction::Run() {
   std::unique_ptr<SetSizeConstraints::Params> params(
       SetSizeConstraints::Params::Create(args()));
@@ -352,8 +363,10 @@
 
 ExtensionFunction::ResponseAction
 AppCurrentWindowInternalSetAlwaysOnTopFunction::Run() {
+
   // TODO(devlin): Can't this be done with the feature files?
-  if (!extension()->permissions_data()->HasAPIPermission(
+  if (extension() != nullptr && // NWJS#5738
+      !extension()->permissions_data()->HasAPIPermission(
           extensions::mojom::APIPermissionID::kAlwaysOnTopWindows)) {
     return RespondNow(Error(kAlwaysOnTopPermission));
   }
diff -r -u --color up/chromium/extensions/browser/api/app_current_window_internal/app_current_window_internal_api.h nw/chromium/extensions/browser/api/app_current_window_internal/app_current_window_internal_api.h
--- up/chromium/extensions/browser/api/app_current_window_internal/app_current_window_internal_api.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/api/app_current_window_internal/app_current_window_internal_api.h	2023-01-28 02:49:29.199627575 +0000
@@ -145,6 +145,16 @@
   ResponseAction Run() override;
 };
 
+class AppCurrentWindowInternalSetResizableFunction
+    : public AppCurrentWindowInternalExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("app.currentWindowInternal.setResizable",
+                             UNKNOWN)
+ protected:
+  ~AppCurrentWindowInternalSetResizableFunction() override {}
+  ResponseAction Run() override;
+};
+
 class AppCurrentWindowInternalSetIconFunction
     : public AppCurrentWindowInternalExtensionFunction {
  public:
diff -r -u --color up/chromium/extensions/browser/api/app_window/app_window_api.cc nw/chromium/extensions/browser/api/app_window/app_window_api.cc
--- up/chromium/extensions/browser/api/app_window/app_window_api.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/api/app_window/app_window_api.cc	2023-01-28 02:49:29.199627575 +0000
@@ -4,6 +4,8 @@
 
 #include "extensions/browser/api/app_window/app_window_api.h"
 
+#include "ui/display/display_export.h"
+
 #include <memory>
 #include <utility>
 
@@ -41,9 +43,15 @@
 #include "ui/gfx/geometry/rect.h"
 #include "url/gurl.h"
 
+#include "content/nw/src/nw_base.h"
+#include "content/nw/src/browser/nw_content_browser_hooks.h"
+
 namespace app_window = extensions::api::app_window;
 namespace Create = app_window::Create;
 
+namespace content {
+  DISPLAY_EXPORT extern bool g_support_transparency;
+}
 namespace extensions {
 
 namespace app_window_constants {
@@ -59,8 +67,8 @@
     "The $1 property cannot be specified for both inner and outer bounds.";
 constexpr char kAlwaysOnTopPermission[] =
     "The \"app.window.alwaysOnTop\" permission is required.";
-constexpr char kInvalidUrlParameter[] =
-    "The URL used for window creation must be local for security reasons.";
+//constexpr char kInvalidUrlParameter[] =
+//    "The URL used for window creation must be local for security reasons.";
 constexpr char kAlphaEnabledWrongChannel[] =
     "The alphaEnabled option requires dev channel or newer.";
 constexpr char kAlphaEnabledMissingPermission[] =
@@ -153,6 +161,10 @@
   // to allow component apps to open chrome URLs (e.g. for the settings page
   // on ChromeOS).
   GURL absolute = GURL(params->url);
+
+  if (absolute.has_scheme())
+    url = absolute;
+#if 0
   if (absolute.has_scheme()) {
     if (extension()->location() == mojom::ManifestLocation::kComponent &&
         absolute.SchemeIs(content::kChromeUIScheme)) {
@@ -162,13 +174,27 @@
       return RespondNow(Error(app_window_constants::kInvalidUrlParameter));
     }
   }
-
+#endif
   // TODO(jeremya): figure out a way to pass the opening WebContents through to
   // AppWindow::Create so we can set the opener at create time rather than
   // with a hack in AppWindowCustomBindings::GetView().
   AppWindow::CreateParams create_params;
   absl::optional<app_window::CreateWindowOptions>& options = params->options;
   if (options) {
+    if (options->title)
+      create_params.title = *options->title;
+
+    if (options->icon) {
+      base::ScopedAllowBlocking allow_io;
+      gfx::Image app_icon;
+      nw::Package* package = nw::package();
+      if (nw::GetPackageImage(package,
+                              base::FilePath::FromUTF8Unsafe(*options->icon),
+                              &app_icon)) {
+        create_params.icon = app_icon;
+      }
+    }
+
     if (options->id) {
       // TODO(mek): use URL if no id specified?
       // Limit length of id to 256 characters.
@@ -304,6 +330,8 @@
 #else
       // Transparency is only supported on Aura.
       // Fallback to creating an opaque window (by ignoring alphaEnabled).
+      if (content::g_support_transparency)
+        create_params.alpha_enabled = *options->alpha_enabled;
 #endif
     }
 
@@ -351,6 +379,23 @@
       }
     }
 
+    if (options->show_in_taskbar) {
+      create_params.show_in_taskbar = *options->show_in_taskbar;
+    }
+
+    if (options->new_instance) {
+      create_params.new_instance = *options->new_instance;
+    }
+
+    if (options->inject_js_start) {
+      create_params.inject_js_start =
+          *options->inject_js_start;
+    }
+    if (options->inject_js_end) {
+      create_params.inject_js_end =
+          *options->inject_js_end;
+    }
+
     switch (options->state) {
       case app_window::STATE_NONE:
       case app_window::STATE_NORMAL:
@@ -384,9 +429,23 @@
     action_type = options->lock_screen_action;
     create_params.show_on_lock_screen = true;
   }
+  switch (options->position) {
+  case app_window::POSITION_NONE:
+    create_params.position = extensions::AppWindow::POS_NONE;
+    break;
+  case app_window::POSITION_CENTER:
+    create_params.position = extensions::AppWindow::POS_CENTER;
+    break;
+  case app_window::POSITION_MOUSE:
+    create_params.position = extensions::AppWindow::POS_MOUSE;
+    break;
+  }
 
   create_params.creator_process_id = source_process_id();
 
+  if (create_params.new_instance)
+    nw::SetPinningRenderer(false);
+
   AppWindow* app_window = nullptr;
   if (action_type == api::app_runtime::ACTION_TYPE_NONE) {
     app_window =
@@ -405,11 +464,17 @@
   app_window->Init(url, std::make_unique<AppWindowContentsImpl>(app_window),
                    render_frame_host(), create_params);
 
+  if (create_params.new_instance)
+    nw::SetPinningRenderer(true);
+
   if (ExtensionsBrowserClient::Get()->IsRunningInForcedAppMode() &&
       !app_window->is_ime_window()) {
     app_window->ForcedFullscreen();
   }
 
+  if (options && options->kiosk)
+    app_window->ForcedFullscreen();
+
   content::RenderFrameHost* created_frame =
       app_window->web_contents()->GetPrimaryMainFrame();
   int frame_id = MSG_ROUTING_NONE;
@@ -424,12 +489,15 @@
 
   if (AppWindowRegistry::Get(browser_context())
           ->HadDevToolsAttached(app_window->web_contents())) {
-    AppWindowClient::Get()->OpenDevToolsWindow(
+    base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
+    if (!command_line->HasSwitch("skip-reopen-app-devtools")) {
+      AppWindowClient::Get()->OpenDevToolsWindow(
         app_window->web_contents(),
         base::BindOnce(&AppWindowCreateFunction::Respond, this,
                        std::move(result_arg)));
     // OpenDevToolsWindow might have already responded.
     return did_respond() ? AlreadyResponded() : RespondLater();
+    }
   }
 
   // Delay sending the response until the newly created window has finished its
diff -r -u --color up/chromium/extensions/browser/api/content_settings/content_settings_store.cc nw/chromium/extensions/browser/api/content_settings/content_settings_store.cc
--- up/chromium/extensions/browser/api/content_settings/content_settings_store.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/api/content_settings/content_settings_store.cc	2023-01-28 02:49:29.203627612 +0000
@@ -114,6 +114,22 @@
   {
     base::AutoLock lock(lock_);
     OriginIdentifierValueMap* map = GetValueMap(ext_id, scope);
+    if (!map) {
+      ExtensionEntry* entry = new ExtensionEntry;
+      entry->install_time = base::Time::Now();
+ 
+      auto unique_entry = base::WrapUnique(entry);
+      auto location =
+        std::upper_bound(entries_.begin(), entries_.end(), unique_entry,
+                         [](const std::unique_ptr<ExtensionEntry>& a,
+                            const std::unique_ptr<ExtensionEntry>& b) {
+                           return a->install_time > b->install_time;
+                         });
+      entries_.insert(location, std::move(unique_entry));
+      entry->id = ext_id;
+      entry->enabled = true;
+      map = GetValueMap(ext_id, scope);
+    }
     if (setting == CONTENT_SETTING_DEFAULT) {
       map->DeleteValue(primary_pattern, secondary_pattern, type);
     } else {
diff -r -u --color up/chromium/extensions/browser/api/execute_code_function.cc nw/chromium/extensions/browser/api/execute_code_function.cc
--- up/chromium/extensions/browser/api/execute_code_function.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/api/execute_code_function.cc	2023-01-28 02:49:29.211627686 +0000
@@ -6,6 +6,7 @@
 #define EXTENSIONS_BROWSER_API_EXECUTE_CODE_FUNCTION_IMPL_H_
 
 #include "extensions/browser/api/execute_code_function.h"
+#include "content/nw/src/browser/nw_chrome_browser_hooks.h"
 
 #include <utility>
 
@@ -109,6 +110,9 @@
       break;
   }
 
+  ScriptExecutor::WorldType world_type = details_->main_world && *details_->main_world
+    ? ScriptExecutor::MAIN_WORLD : ScriptExecutor::ISOLATED_WORLD;
+
   mojom::CodeInjectionPtr injection;
   bool is_css_injection = ShouldInsertCSS() || ShouldRemoveCSS();
   if (is_css_injection) {
@@ -143,6 +147,7 @@
   executor->ExecuteScript(
       host_id_, std::move(injection), frame_scope, {root_frame_id_},
       match_about_blank, run_at,
+      world_type,
       IsWebView() ? ScriptExecutor::WEB_VIEW_PROCESS
                   : ScriptExecutor::DEFAULT_PROCESS,
       GetWebViewSrc(),
diff -r -u --color up/chromium/extensions/browser/api/guest_view/web_view/web_view_internal_api.cc nw/chromium/extensions/browser/api/guest_view/web_view/web_view_internal_api.cc
--- up/chromium/extensions/browser/api/guest_view/web_view/web_view_internal_api.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/api/guest_view/web_view/web_view_internal_api.cc	2023-01-28 02:49:29.215627723 +0000
@@ -155,7 +155,7 @@
   // if needed.
   bool allowed_everywhere =
       extension && extensions::PermissionsData::CanExecuteScriptEverywhere(
-                       extension->id(), extension->location());
+                                                                           extension->id(), extension->location(), extension->GetType());
   for (const std::string& match : script_value.matches) {
     URLPattern pattern(UserScript::ValidUserScriptSchemes(allowed_everywhere));
     if (pattern.Parse(match) != URLPattern::ParseResult::kSuccess) {
@@ -869,6 +869,40 @@
   return RespondNow(Error(std::move(error)));
 }
 
+WebViewInternalShowDevToolsFunction::WebViewInternalShowDevToolsFunction() {
+}
+
+WebViewInternalShowDevToolsFunction::~WebViewInternalShowDevToolsFunction() {
+}
+
+ExtensionFunction::ResponseAction
+WebViewInternalShowDevToolsFunction::Run() {
+  std::unique_ptr<web_view_internal::ShowDevTools::Params> params(
+             web_view_internal::ShowDevTools::Params::Create(args()));
+  EXTENSION_FUNCTION_VALIDATE(params.get());
+
+  int proc_id = params->proc_id ? *params->proc_id : -1;
+  int guest_id = params->guest_id ? *params->guest_id : -1;
+  guest_->ShowDevTools(params->show, proc_id, guest_id);
+  return RespondNow(NoArguments());
+}
+
+WebViewInternalInspectElementAtFunction::WebViewInternalInspectElementAtFunction() {
+}
+
+WebViewInternalInspectElementAtFunction::~WebViewInternalInspectElementAtFunction() {
+}
+
+ExtensionFunction::ResponseAction
+WebViewInternalInspectElementAtFunction::Run() {
+  std::unique_ptr<web_view_internal::InspectElementAt::Params> params(
+           web_view_internal::InspectElementAt::Params::Create(args()));
+  EXTENSION_FUNCTION_VALIDATE(params.get());
+
+  guest_->InspectElement(params->x, params->y);
+  return RespondNow(NoArguments());
+}
+
 WebViewInternalGoFunction::WebViewInternalGoFunction() {
 }
 
diff -r -u --color up/chromium/extensions/browser/api/guest_view/web_view/web_view_internal_api.h nw/chromium/extensions/browser/api/guest_view/web_view/web_view_internal_api.h
--- up/chromium/extensions/browser/api/guest_view/web_view/web_view_internal_api.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/api/guest_view/web_view/web_view_internal_api.h	2023-01-28 02:49:29.215627723 +0000
@@ -407,6 +407,35 @@
   ResponseAction Run() override;
 };
 
+class WebViewInternalShowDevToolsFunction
+    : public WebViewInternalExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("webViewInternal.showDevTools", UNKNOWN)
+
+  WebViewInternalShowDevToolsFunction();
+
+ protected:
+  ~WebViewInternalShowDevToolsFunction() override;
+
+  ResponseAction Run() override;
+ private:
+
+};
+
+class WebViewInternalInspectElementAtFunction
+    : public WebViewInternalExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("webViewInternal.inspectElementAt", UNKNOWN)
+
+  WebViewInternalInspectElementAtFunction();
+
+ protected:
+  ~WebViewInternalInspectElementAtFunction() override;
+  ResponseAction Run() override;
+ private:
+
+};
+
 class WebViewInternalGoFunction : public WebViewInternalExtensionFunction {
  public:
   DECLARE_EXTENSION_FUNCTION("webViewInternal.go", WEBVIEWINTERNAL_GO)
diff -r -u --color up/chromium/extensions/browser/api/runtime/runtime_api.cc nw/chromium/extensions/browser/api/runtime/runtime_api.cc
--- up/chromium/extensions/browser/api/runtime/runtime_api.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/api/runtime/runtime_api.cc	2023-01-28 02:49:29.223627797 +0000
@@ -4,6 +4,9 @@
 
 #include "extensions/browser/api/runtime/runtime_api.h"
 
+#include "content/nw/src/browser/nw_chrome_browser_hooks.h"
+#include "chrome/browser/first_run/first_run.h"
+
 #include <memory>
 #include <utility>
 
@@ -216,6 +219,7 @@
 
 void RuntimeAPI::OnExtensionLoaded(content::BrowserContext* browser_context,
                                    const Extension* extension) {
+  bool nw_skip = (extension->id() == nw::GetMainExtensionId() && !first_run::IsChromeFirstRun());
   if (!dispatch_chrome_updated_event_)
     return;
 
@@ -223,7 +227,7 @@
   base::ThreadTaskRunnerHandle::Get()->PostTask(
       FROM_HERE,
       base::BindOnce(&RuntimeEventRouter::DispatchOnInstalledEvent,
-                     browser_context_, extension->id(), base::Version(), true));
+                     browser_context_, extension->id(), base::Version(), true, nw_skip));
 }
 
 void RuntimeAPI::OnExtensionUninstalled(
@@ -430,7 +434,7 @@
     content::BrowserContext* context,
     const std::string& extension_id,
     const base::Version& old_version,
-    bool chrome_updated) {
+    bool chrome_updated, bool nw_skip) {
   if (!ExtensionsBrowserClient::Get()->IsValidContext(context))
     return;
   ExtensionSystem* system = ExtensionSystem::Get(context);
@@ -462,12 +466,12 @@
   event_args.Append(std::move(info));
   EventRouter* event_router = EventRouter::Get(context);
   DCHECK(event_router);
-  auto event = std::make_unique<Event>(events::RUNTIME_ON_INSTALLED,
-                                       runtime::OnInstalled::kEventName,
+  auto event = std::make_unique<Event>(nw_skip? events::UNKNOWN: events::RUNTIME_ON_INSTALLED,
+                                       nw_skip? runtime::OnInstalledNW::kEventName: runtime::OnInstalled::kEventName,
                                        std::move(event_args));
   event_router->DispatchEventWithLazyListener(extension_id, std::move(event));
 
-  if (old_version.IsValid()) {
+  if (!nw_skip && old_version.IsValid()) {
     const Extension* extension =
         ExtensionRegistry::Get(context)->enabled_extensions().GetByID(
             extension_id);
@@ -578,10 +582,11 @@
     content::BrowserContext* browser_context,
     const Extension* extension,
     const base::Version& previous_version) {
+  bool nw_skip = (extension->id() == nw::GetMainExtensionId() && !first_run::IsChromeFirstRun());
   base::ThreadTaskRunnerHandle::Get()->PostTask(
       FROM_HERE, base::BindOnce(&RuntimeEventRouter::DispatchOnInstalledEvent,
                                 browser_context_, extension->id(),
-                                previous_version, false));
+                                previous_version, false, nw_skip));
 }
 
 ExtensionFunction::ResponseAction RuntimeGetBackgroundPageFunction::Run() {
diff -r -u --color up/chromium/extensions/browser/api/runtime/runtime_api.h nw/chromium/extensions/browser/api/runtime/runtime_api.h
--- up/chromium/extensions/browser/api/runtime/runtime_api.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/api/runtime/runtime_api.h	2023-01-28 02:49:29.223627797 +0000
@@ -205,7 +205,7 @@
   static void DispatchOnInstalledEvent(content::BrowserContext* context,
                                        const std::string& extension_id,
                                        const base::Version& old_version,
-                                       bool chrome_updated);
+                                       bool chrome_updated, bool nw_skip);
 
   // Dispatches the onUpdateAvailable event to the given extension.
   static void DispatchOnUpdateAvailableEvent(
diff -r -u --color up/chromium/extensions/browser/api/web_request/web_request_api.cc nw/chromium/extensions/browser/api/web_request/web_request_api.cc
--- up/chromium/extensions/browser/api/web_request/web_request_api.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/api/web_request/web_request_api.cc	2023-01-28 02:49:29.235627908 +0000
@@ -2186,7 +2186,7 @@
   if (request.is_web_view) {
     // If this is a navigation request, then we can skip this check. IDs will
     // be -1 and the request is trusted.
-    if (!request.is_navigation_request &&
+    if (//!request.is_navigation_request &&
         listener.id.render_process_id != request.web_view_embedder_process_id) {
       return false;
     }
diff -r -u --color up/chromium/extensions/browser/api/web_request/web_request_info.cc nw/chromium/extensions/browser/api/web_request/web_request_info.cc
--- up/chromium/extensions/browser/api/web_request/web_request_info.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/api/web_request/web_request_info.cc	2023-01-28 02:49:29.235627908 +0000
@@ -209,6 +209,8 @@
         navigation_ui_data->web_view_rules_registry_id();
     frame_data = navigation_ui_data->frame_data();
     parent_routing_id = navigation_ui_data->parent_routing_id();
+    web_view_embedder_process_id =
+        navigation_ui_data->web_view_embedder_process_id();
   } else if (frame_routing_id != MSG_ROUTING_NONE) {
     // Grab any WebView-related information if relevant.
     WebViewRendererState::WebViewInfo web_view_info;
diff -r -u --color up/chromium/extensions/browser/app_window/app_web_contents_helper.cc nw/chromium/extensions/browser/app_window/app_web_contents_helper.cc
--- up/chromium/extensions/browser/app_window/app_web_contents_helper.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/app_window/app_web_contents_helper.cc	2023-01-28 02:49:29.239627945 +0000
@@ -56,12 +56,28 @@
   // TODO(mihaip): Can we check for user gestures instead?
   WindowOpenDisposition disposition = params.disposition;
   if (disposition == WindowOpenDisposition::CURRENT_TAB) {
-    web_contents_->GetPrimaryMainFrame()->AddMessageToConsole(
+    if (GetExtension()->is_nwjs_app()) {
+      content::NavigationController::LoadURLParams load_url_params(params.url);
+      load_url_params.source_site_instance = params.source_site_instance;
+      load_url_params.referrer = params.referrer;
+      load_url_params.frame_tree_node_id = params.frame_tree_node_id;
+      load_url_params.redirect_chain = params.redirect_chain;
+      load_url_params.transition_type = params.transition;
+      load_url_params.extra_headers = params.extra_headers;
+      load_url_params.should_replace_current_entry =
+        params.should_replace_current_entry;
+      load_url_params.is_renderer_initiated = params.is_renderer_initiated;
+
+      web_contents_->GetController().LoadURLWithParams(load_url_params);
+      return web_contents_;
+    } else {
+      web_contents_->GetPrimaryMainFrame()->AddMessageToConsole(
         blink::mojom::ConsoleMessageLevel::kError,
         base::StringPrintf(
             "Can't open same-window link to \"%s\"; try target=\"_blank\".",
             params.url.spec().c_str()));
-    return nullptr;
+      return nullptr;
+    }
   }
 
   // These dispositions aren't really navigations.
diff -r -u --color up/chromium/extensions/browser/app_window/app_window.cc nw/chromium/extensions/browser/app_window/app_window.cc
--- up/chromium/extensions/browser/app_window/app_window.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/app_window/app_window.cc	2023-01-28 02:49:29.239627945 +0000
@@ -4,6 +4,10 @@
 
 #include "extensions/browser/app_window/app_window.h"
 
+#include "components/web_cache/browser/web_cache_manager.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/browser/renderer_host/render_frame_host_impl.h"
+#include "base/command_line.h"
 #include <stddef.h>
 
 #include <algorithm>
@@ -30,7 +34,9 @@
 #include "content/public/browser/navigation_entry.h"
 #include "content/public/browser/render_view_host.h"
 #include "content/public/browser/render_widget_host.h"
+#include "content/public/browser/render_widget_host_view.h"
 #include "content/public/browser/web_contents.h"
+#include "content/public/common/content_switches.h"
 #include "extensions/browser/app_window/app_delegate.h"
 #include "extensions/browser/app_window/app_web_contents_helper.h"
 #include "extensions/browser/app_window/app_window_client.h"
@@ -65,7 +71,29 @@
 #include "extensions/browser/pref_names.h"
 #endif
 
+
 using blink::mojom::ConsoleMessageLevel;
+
+#if defined(OS_MAC)
+#include "content/public/browser/browser_plugin_guest_manager.h"
+#include "extensions/browser/process_manager.h"
+#endif
+
+#include "extensions/browser/extension_host.h"
+//#include "extensions/common/extension_messages.h"
+
+#include "content/public/browser/render_frame_host.h"
+#include "third_party/blink/public/mojom/renderer_preferences.mojom.h"
+
+#include "extensions/browser/process_manager.h"
+#include "extensions/browser/app_window/app_window_contents.h"
+#include "extensions/browser/event_router.h"
+
+#include "content/nw/src/nw_base.h"
+#include "content/nw/src/nw_content.h"
+#include "content/nw/src/common/shell_switches.h"
+
+
 using content::BrowserContext;
 using content::WebContents;
 using web_modal::WebContentsModalDialogHost;
@@ -176,7 +204,13 @@
       always_on_top(false),
       visible_on_all_workspaces(false),
       show_on_lock_screen(false),
-      show_in_shelf(false) {}
+      show_in_shelf(false),
+      skip_load(false),
+      show_in_taskbar(true),
+      new_instance(false),
+      skip_block_parser(false)
+{
+}
 
 AppWindow::CreateParams::CreateParams(const CreateParams& other) = default;
 
@@ -239,7 +273,7 @@
 AppWindow::AppWindow(BrowserContext* context,
                      std::unique_ptr<AppDelegate> app_delegate,
                      const Extension* extension)
-    : browser_context_(context),
+    : menu_(nullptr), browser_context_(context),
       extension_id_(extension->id()),
       session_id_(SessionID::NewUnique()),
       app_delegate_(std::move(app_delegate)) {
@@ -248,13 +282,53 @@
       << "Only off the record window may be opened in the guest mode.";
 }
 
+void AppWindow::LoadingStateChanged(content::WebContents* source, bool to_different_document) {
+  base::Value::List args;
+  if (source->IsLoading()) {
+    args.Append("loading");
+    last_to_different_document_ = to_different_document;
+    if (!to_different_document) //NWJS#5001
+      return;
+  } else {
+    if (!last_to_different_document_)
+      return;
+    args.Append("loaded");
+  }
+  content::RenderFrameHost* rfh = web_contents()->GetPrimaryMainFrame();
+    ExtensionWebContentsObserver::GetForWebContents(web_contents())
+      ->GetLocalFrame(rfh)
+      ->MessageInvoke(
+                      extension_id(),
+                      "nw.Window",
+                      "LoadingStateChanged",
+                      std::move(args));
+}
+
 void AppWindow::Init(const GURL& url,
                      std::unique_ptr<AppWindowContents> app_window_contents,
                      content::RenderFrameHost* creator_frame,
                      const CreateParams& params) {
   // Initialize the render interface and web contents
   app_window_contents_ = std::move(app_window_contents);
-  app_window_contents_->Initialize(browser_context(), creator_frame, url);
+  app_window_contents_->Initialize(browser_context(), creator_frame, url,
+                                   GetExtension(), params.new_instance || params.skip_block_parser);
+
+  nw::Package* package = nw::package();
+  std::string js_doc_start(params.inject_js_start), js_doc_end(params.inject_js_end);
+  if (js_doc_start.empty()) {
+    std::string* str = package->root()->FindString(::switches::kmInjectJSDocStart);
+    if (str)
+      js_doc_start = *str;
+  }
+  web_contents()->GetMutableRendererPrefs()->nw_inject_js_doc_start = js_doc_start;
+  if (js_doc_end.empty()) {
+    std::string* str = package->root()->FindString(::switches::kmInjectJSDocEnd);
+    if (str)
+      js_doc_end = *str;
+  }
+  web_contents()->GetMutableRendererPrefs()->nw_inject_js_doc_end = js_doc_end;
+  if (!js_doc_start.empty() || !js_doc_end.empty())
+    web_contents()->SyncRendererPrefs();
 
   initial_url_ = url;
 
@@ -279,11 +353,22 @@
 
   // Windows cannot be always-on-top in fullscreen mode for security reasons.
   cached_always_on_top_ = new_params.always_on_top;
+#if 0
   if (new_params.state == ui::SHOW_STATE_FULLSCREEN &&
       !ExtensionsBrowserClient::Get()->IsScreensaverInDemoMode(
           extension_id())) {
     new_params.always_on_top = false;
   }
+#endif
+
+  title_override_ = new_params.title;
+  custom_app_icon_ = new_params.icon;
+  icon_override_ = new_params.icon;
+
+  content::g_support_transparency = !base::CommandLine::ForCurrentProcess()->HasSwitch(::switches::kDisableTransparency);
+  if (content::g_support_transparency) {
+    content::g_force_cpu_draw = base::CommandLine::ForCurrentProcess()->HasSwitch(::switches::kForceCpuDraw);
+  }
 
   requested_alpha_enabled_ = new_params.alpha_enabled;
   is_ime_window_ = params.is_ime_window;
@@ -321,6 +406,9 @@
     Show(new_params.focused ? SHOW_ACTIVE : SHOW_INACTIVE);
   }
 
+  if (!new_params.show_in_taskbar)
+    SetShowInTaskbar(false);
+
   OnNativeWindowChanged();
 
   ExtensionRegistry::Get(browser_context_)->AddObserver(this);
@@ -329,7 +417,8 @@
   app_delegate_->SetTerminatingCallback(base::BindOnce(
       &NativeAppWindow::Close, base::Unretained(native_app_window_.get())));
 
-  app_window_contents_->LoadContents(new_params.creator_process_id);
+  if (!params.skip_load)
+    app_window_contents_->LoadContents(new_params.creator_process_id);
 }
 
 AppWindow::~AppWindow() {
@@ -370,9 +459,29 @@
     bool user_gesture,
     bool* was_blocked) {
   DCHECK(new_contents->GetBrowserContext() == browser_context_);
-  app_delegate_->AddNewContents(browser_context_, std::move(new_contents),
-                                target_url, disposition, window_features,
-                                user_gesture);
+  const extensions::Extension* extension = GetExtension();
+  extensions::AppWindow* app_window =
+      extensions::AppWindowClient::Get()->CreateAppWindow(browser_context_, extension);
+
+  extensions::AppWindow::CreateParams params;
+  std::string js_doc_start, js_doc_end;
+  nw::CalcNewWinParams(new_contents.get(), &params, &js_doc_start, &js_doc_end, std::string());
+  nw::SetCurrentNewWinManifest(std::u16string());
+  new_contents->GetMutableRendererPrefs()->
+    nw_inject_js_doc_start = js_doc_start;
+  new_contents->GetMutableRendererPrefs()->
+    nw_inject_js_doc_end = js_doc_end;
+  new_contents->SyncRendererPrefs();
+
+  if(window_features.bounds.width() != 0) {
+    params.content_spec.bounds = window_features.bounds; //NWJS#5517
+  }
+  params.skip_load = true;
+  GURL new_url = new_contents->GetURL();
+  app_window->Init(new_url,
+                   std::make_unique<AppWindowContentsImpl>(app_window, std::move(new_contents)),
+                   web_contents()->GetPrimaryMainFrame(),
+                   params);
 }
 
 content::KeyboardEventProcessingResult AppWindow::PreHandleKeyboardEvent(
@@ -404,6 +513,7 @@
 bool AppWindow::HandleKeyboardEvent(
     WebContents* source,
     const content::NativeWebKeyboardEvent& event) {
+#if 0
   // If the window is currently fullscreen and not forced, ESC should leave
   // fullscreen.  If this code is being called for ESC, that means that the
   // KeyEvent's default behavior was not prevented by the content.
@@ -413,6 +523,8 @@
     return true;
   }
 
+#endif
+
   return native_app_window_->HandleKeyboardEvent(event);
 }
 
@@ -425,7 +537,28 @@
 
 bool AppWindow::PreHandleGestureEvent(WebContents* source,
                                       const blink::WebGestureEvent& event) {
-  return AppWebContentsHelper::ShouldSuppressGestureEvent(event);
+#if defined(OS_MAC)
+  // Disable "smart zoom" (double-tap with two fingers on Mac trackpad)
+  // for the PDF viewer, otherwise the viewer's controls will be scaled off
+  // screen.
+  // TODO(mcnee): Investigate having the PDF viewer handle the gesture
+  // once it is a service. crbug.com/757541
+  if (event.GetType() == blink::WebInputEvent::Type::kGestureDoubleTap) {
+    content::BrowserPluginGuestManager* guest_manager =
+        source->GetBrowserContext()->GetGuestManager();
+    if (guest_manager) {
+      content::WebContents* guest_contents = guest_manager->GetFullPageGuest(source);
+      if (guest_contents) {
+        const extensions::Extension* extension =
+            extensions::ProcessManager::Get(guest_contents->GetBrowserContext())
+                ->GetExtensionForWebContents(guest_contents);
+        if (extension && extension->id() == extension_misc::kPdfExtensionId)
+          return true;
+      }
+    }
+  }
+#endif  // defined(OS_MAC)
+  return false;
 }
 
 bool AppWindow::TakeFocus(WebContents* source, bool reverse) {
@@ -476,6 +609,31 @@
     std::move(callback).Run(true /* did_finish */);
 }
 
+bool AppWindow::NWCanClose(bool user_force) const {
+  const Extension* extension = GetExtension();
+  if (!extension)
+    return true;
+  content::RenderFrameHost* rfh = web_contents()->GetPrimaryMainFrame();
+  EventRouter* event_router = EventRouter::Get(browser_context());
+  std::string listener_extension_id;
+  bool listening_to_close = event_router->
+    ExtensionHasEventListener(extension->id(), "nw.Window.onClose",
+                              rfh->GetRenderViewHost()->GetRoutingID(),
+                              &listener_extension_id);
+  if (listening_to_close) {
+    base::Value::List args;
+    if (user_force)
+      args.Append("quit");
+    ExtensionWebContentsObserver::GetForWebContents(web_contents())
+      ->GetLocalFrame(rfh)
+      ->MessageInvoke(
+                      listener_extension_id, "nw.Window",
+                      "onClose", std::move(args));
+    return false;
+  }
+  return true;
+}
+
 void AppWindow::OnNativeClose() {
   AppWindowRegistry::Get(browser_context_)->RemoveAppWindow(this);
 
@@ -520,9 +678,19 @@
   SaveWindowPosition();
 
 #if BUILDFLAG(IS_WIN)
+  if (content::g_support_transparency && requested_alpha_enabled_) {
+    content::RenderFrameHost* rfh = web_contents()->GetPrimaryMainFrame();
+    content::RenderWidgetHostView* view = rfh->GetRenderViewHost()->GetWidget()->GetView();
+    if(view)
+      view->SetBackgroundColor(native_app_window_->CanHaveAlphaEnabled() ? SK_ColorTRANSPARENT : native_app_window_->ActiveFrameColor());
+  }
+#if 0
   if (cached_always_on_top_ && !IsFullscreen() &&
       !native_app_window_->IsMaximized() &&
       !native_app_window_->IsMinimized()) {
+#else
+  if (cached_always_on_top_) {
+#endif
     UpdateNativeAlwaysOnTop();
   }
 #endif
@@ -562,9 +730,10 @@
 }
 
 std::u16string AppWindow::GetTitle() const {
+  std::u16string override = base::UTF8ToUTF16(title_override_);
   const Extension* extension = GetExtension();
   if (!extension)
-    return std::u16string();
+    return override;
 
   // WebContents::GetTitle() will return the page's URL if there's no <title>
   // specified. However, we'd prefer to show the name of the extension in that
@@ -574,12 +743,14 @@
       web_contents() ? web_contents()->GetController().GetLastCommittedEntry()
                      : nullptr;
   if (!entry || entry->GetTitle().empty()) {
-    title = base::UTF8ToUTF16(extension->name());
+    title = override.empty() ? base::UTF8ToUTF16(extension->name()) : override;
   } else {
     title = web_contents()->GetTitle();
   }
   base::RemoveChars(title, u"\n", &title);
-  return title;
+  if (!title.empty())
+    return title;
+  return override;
 }
 
 void AppWindow::SetAppIconUrl(const GURL& url) {
@@ -669,6 +840,10 @@
   }
 }
 
+void AppWindow::SetShowInTaskbar(bool show) {
+  GetBaseWindow()->SetShowInTaskbar(show);
+}
+
 void AppWindow::OSFullscreen() {
   SetFullscreen(FULLSCREEN_TYPE_OS, true);
 }
@@ -726,14 +901,15 @@
   // As a security measure, do not allow fullscreen windows or windows that
   // overlap the taskbar to be on top. The property will be applied when the
   // window exits fullscreen and moves away from the taskbar.
+#if 0
   if ((!IsFullscreen() ||
        ExtensionsBrowserClient::Get()->IsScreensaverInDemoMode(
            extension_id())) &&
       !IntersectsWithTaskbar()) {
+#endif
     native_app_window_->SetZOrderLevel(always_on_top
                                            ? ui::ZOrderLevel::kFloatingWindow
                                            : ui::ZOrderLevel::kNormal);
-  }
 
   OnNativeWindowChanged();
 }
@@ -751,6 +927,8 @@
   DCHECK(properties);
   DCHECK(properties->is_dict());
 
+  properties->SetBoolKey("resizable",
+                         native_app_window_->IsResizable());
   properties->SetBoolKey("fullscreen",
                          native_app_window_->IsFullscreenOrPending());
   properties->SetBoolKey("minimized", native_app_window_->IsMinimized());
@@ -857,6 +1035,9 @@
 
 void AppWindow::UpdateNativeAlwaysOnTop() {
   DCHECK(cached_always_on_top_);
+#if 1
+  native_app_window_->SetZOrderLevel(ui::ZOrderLevel::kFloatingWindow);
+#else
   bool is_on_top =
       native_app_window_->GetZOrderLevel() == ui::ZOrderLevel::kFloatingWindow;
   bool fullscreen = IsFullscreen();
@@ -871,6 +1052,7 @@
     // always-on-top.
     native_app_window_->SetZOrderLevel(ui::ZOrderLevel::kFloatingWindow);
   }
+#endif
 }
 
 void AppWindow::ActivateContents(WebContents* contents) {
@@ -882,7 +1064,7 @@
 }
 
 bool AppWindow::ShouldSuppressDialogs(WebContents* source) {
-  return true;
+  return false;
 }
 
 void AppWindow::RunFileChooser(
@@ -1081,4 +1263,18 @@
   return sk_region;
 }
 
+content::JavaScriptDialogManager* AppWindow::GetJavaScriptDialogManager(
+    WebContents* source) {
+  ExtensionHost* host = ProcessManager::Get(browser_context())
+                            ->GetBackgroundHostForExtension(extension_id());
+  return host->GetJavaScriptDialogManager(source);
+}
+
+void AppWindow::OnVisibilityChanged(content::Visibility visibility) {
+  if (visibility == content::Visibility::VISIBLE) {
+  web_cache::WebCacheManager::GetInstance()->ObserveActivity(
+                                                             web_contents()->GetPrimaryMainFrame()->GetProcess()->GetID());
+  }
+}
+
 }  // namespace extensions
diff -r -u --color up/chromium/extensions/browser/app_window/app_window.h nw/chromium/extensions/browser/app_window/app_window.h
--- up/chromium/extensions/browser/app_window/app_window.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/app_window/app_window.h	2023-01-28 02:49:29.239627945 +0000
@@ -38,6 +38,10 @@
 class WebContents;
 }  // namespace content
 
+namespace nw {
+class Menu;
+}
+
 namespace extensions {
 
 class AppDelegate;
@@ -63,7 +67,9 @@
   // Called to initialize the WebContents, before the app window is created.
   virtual void Initialize(content::BrowserContext* context,
                           content::RenderFrameHost* creator_frame,
-                          const GURL& url) = 0;
+                          const GURL& url,
+                          const Extension* extension,
+                          bool skip_blocking_parser) = 0;
 
   // Called to load the contents, after the app window is created.
   virtual void LoadContents(int32_t creator_process_id) = 0;
@@ -101,6 +107,12 @@
     FRAME_NONE,    // Frameless window.
   };
 
+  enum Position {
+    POS_NONE,
+    POS_CENTER,
+    POS_MOUSE,
+  };
+
   enum FullscreenType {
     // Not fullscreen.
     FULLSCREEN_TYPE_NONE = 0,
@@ -200,6 +212,20 @@
     // Icon URL to be used for setting the window icon.
     GURL window_icon_url;
 
+    bool skip_load;
+
+    bool show_in_taskbar;
+    bool new_instance;
+    bool skip_block_parser;
+
+    Position position;
+
+    std::string title;
+
+    std::string inject_js_start, inject_js_end;
+
+    gfx::Image icon;
+
     // The API enables developers to specify content or window bounds. This
     // function combines them into a single, constrained window size.
     gfx::Rect GetInitialWindowBounds(const gfx::Insets& frame_insets) const;
@@ -242,9 +268,12 @@
   WindowType window_type() const { return window_type_; }
   content::BrowserContext* browser_context() const { return browser_context_; }
   const gfx::Image& custom_app_icon() const { return custom_app_icon_; }
+  const gfx::Image& icon_override() const { return icon_override_; }
   const GURL& app_icon_url() const { return app_icon_url_; }
   const GURL& initial_url() const { return initial_url_; }
   bool is_hidden() const { return is_hidden_; }
+  const std::string& title_override() const { return title_override_; }
+  void set_title_override(const std::string& title) { title_override_ = title; }
 
   // Calls to this should always be guarded by a nullptr check as this can
   // return nullptr if the extension is no longer installed.
@@ -253,6 +282,8 @@
   NativeAppWindow* GetBaseWindow();
   gfx::NativeWindow GetNativeWindow();
 
+  bool NWCanClose(bool user_force = false) const;
+
   // Returns the bounds that should be reported to the renderer.
   gfx::Rect GetClientBounds() const;
 
@@ -322,6 +353,8 @@
   void Minimize();
   void Restore();
 
+  void SetShowInTaskbar(bool);
+
   // Transitions to OS fullscreen. See FULLSCREEN_TYPE_OS for more details.
   void OSFullscreen();
 
@@ -384,6 +417,7 @@
       std::unique_ptr<AppWindowContents> contents) {
     app_window_contents_ = std::move(contents);
   }
+  nw::Menu* menu_;
 
   void SetNativeAppWindowForTesting(
       std::unique_ptr<NativeAppWindow> native_app_window) {
@@ -401,6 +435,10 @@
 
   // content::WebContentsDelegate implementation.
   void ActivateContents(content::WebContents* contents) override;
+  void LoadingStateChanged(content::WebContents* source,
+                           bool to_different_document) override;
+  content::JavaScriptDialogManager* GetJavaScriptDialogManager(
+      content::WebContents* source) override;
   void CloseContents(content::WebContents* contents) override;
   bool ShouldSuppressDialogs(content::WebContents* source) override;
   void RunFileChooser(content::RenderFrameHost* render_frame_host,
@@ -455,6 +493,7 @@
   bool OnMessageReceived(const IPC::Message& message,
                          content::RenderFrameHost* render_frame_host) override;
   void RenderFrameCreated(content::RenderFrameHost* frame_host) override;
+  void OnVisibilityChanged(content::Visibility visibility) override;
 
   // ExtensionFunctionDispatcher::Delegate implementation.
   WindowController* GetExtensionWindowController() const override;
@@ -525,6 +564,8 @@
   // not own this object.
   raw_ptr<content::BrowserContext> browser_context_;
 
+  std::string title_override_;
+
   const std::string extension_id_;
 
   // Identifier that is used when saving and restoring geometry for this
@@ -536,6 +577,7 @@
 
   // Custom icon shown in the task bar or in Chrome OS shelf.
   gfx::Image custom_app_icon_;
+  gfx::Image icon_override_;
 
   // Icon URL to be used for setting the app icon. If not empty, app_icon_ will
   // be fetched and set using this URL.
@@ -576,6 +618,8 @@
   // Whether |is_ime_window| was set in the CreateParams.
   bool is_ime_window_ = false;
 
+  bool last_to_different_document_ = false;
+
   // Whether |show_on_lock_screen| was set in the CreateParams.
   bool show_on_lock_screen_ = false;
 
diff -r -u --color up/chromium/extensions/browser/app_window/app_window_contents.cc nw/chromium/extensions/browser/app_window/app_window_contents.cc
--- up/chromium/extensions/browser/app_window/app_window_contents.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/app_window/app_window_contents.cc	2023-01-28 02:49:29.239627945 +0000
@@ -4,6 +4,8 @@
 
 #include "extensions/browser/app_window/app_window_contents.h"
 
+#include "content/browser/web_contents/web_contents_impl.h"
+
 #include <memory>
 #include <string>
 #include <utility>
@@ -22,26 +24,40 @@
 #include "extensions/common/extension_messages.h"
 #include "third_party/blink/public/common/renderer_preferences/renderer_preferences.h"
 
+#include "content/nw/src/nw_content.h"
+
 namespace extensions {
 
-AppWindowContentsImpl::AppWindowContentsImpl(AppWindow* host) : host_(host) {}
+AppWindowContentsImpl::AppWindowContentsImpl(AppWindow* host, std::unique_ptr<content::WebContents> web_contents)
+  :host_(host), web_contents_(std::move(web_contents)) {}
 
 AppWindowContentsImpl::~AppWindowContentsImpl() {}
 
 void AppWindowContentsImpl::Initialize(content::BrowserContext* context,
                                        content::RenderFrameHost* creator_frame,
-                                       const GURL& url) {
+                                       const GURL& url,
+                                       const Extension* extension,
+                                       bool skip_blocking_parser) {
   url_ = url;
 
+  bool new_site = url.SchemeIs("chrome") || !nw::PinningRenderer();
   content::WebContents::CreateParams create_params(
-      context, creator_frame->GetSiteInstance());
+                                                   //NWJS#5163: fix regression
+       context, nw::PinningRenderer() ? creator_frame->GetSiteInstance() : content::SiteInstance::CreateForURL(context, url_));
   create_params.opener_render_process_id = creator_frame->GetProcess()->GetID();
   create_params.opener_render_frame_id = creator_frame->GetRoutingID();
-  web_contents_ = content::WebContents::Create(create_params);
+  if (!web_contents_)
+    web_contents_ = content::WebContents::Create(create_params);
 
+  static_cast<content::WebContentsImpl*>(web_contents_.get())->SetSkipBlockingParser(skip_blocking_parser || new_site);
   Observe(web_contents_.get());
-  web_contents_->GetMutableRendererPrefs()->
-      browser_handles_all_top_level_requests = true;
+  blink::RendererPreferences* render_prefs =
+      web_contents_->GetMutableRendererPrefs();
+  if (!extension || !extension->is_nwjs_app())
+    render_prefs->browser_handles_all_top_level_requests = true;
+  std::string user_agent;
+  if (nw::GetUserAgentFromManifest(&user_agent))
+    render_prefs->user_agent_override.ua_string_override = user_agent;
   web_contents_->SyncRendererPrefs();
 }
 
diff -r -u --color up/chromium/extensions/browser/app_window/app_window_contents.h nw/chromium/extensions/browser/app_window/app_window_contents.h
--- up/chromium/extensions/browser/app_window/app_window_contents.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/app_window/app_window_contents.h	2023-01-28 02:49:29.239627945 +0000
@@ -17,6 +17,7 @@
 namespace content {
 class BrowserContext;
 class RenderFrameHost;
+class WebContents;
 }
 
 namespace extensions {
@@ -29,7 +30,7 @@
 class AppWindowContentsImpl : public AppWindowContents,
                               public content::WebContentsObserver {
  public:
-  explicit AppWindowContentsImpl(AppWindow* host);
+   explicit AppWindowContentsImpl(AppWindow* host, std::unique_ptr<content::WebContents> web_contents = nullptr);
 
   AppWindowContentsImpl(const AppWindowContentsImpl&) = delete;
   AppWindowContentsImpl& operator=(const AppWindowContentsImpl&) = delete;
@@ -39,7 +40,9 @@
   // AppWindowContents
   void Initialize(content::BrowserContext* context,
                   content::RenderFrameHost* creator_frame,
-                  const GURL& url) override;
+                  const GURL& url,
+                  const Extension* extension,
+                  bool skip_blocking_parser) override;
   void LoadContents(int32_t creator_process_id) override;
   void NativeWindowChanged(NativeAppWindow* native_app_window) override;
   void NativeWindowClosed(bool send_onclosed) override;
@@ -57,6 +60,7 @@
 
   raw_ptr<AppWindow> host_;  // This class is owned by |host_|
   GURL url_;
+
   std::unique_ptr<content::WebContents> web_contents_;
 };
 
diff -r -u --color up/chromium/extensions/browser/app_window/native_app_window.h nw/chromium/extensions/browser/app_window/native_app_window.h
--- up/chromium/extensions/browser/app_window/native_app_window.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/app_window/native_app_window.h	2023-01-28 02:49:29.239627945 +0000
@@ -35,6 +35,8 @@
   // |fullscreen_types| is a bit field of AppWindow::FullscreenType.
   virtual void SetFullscreen(int fullscreen_types) = 0;
 
+  virtual void SetResizable(bool flag) = 0;
+  virtual bool IsResizable() const = 0;
   // Returns whether the window is fullscreen or about to enter fullscreen.
   virtual bool IsFullscreenOrPending() const = 0;
 
@@ -74,6 +76,8 @@
   // borders) and the content bounds, if any.
   virtual gfx::Insets GetFrameInsets() const = 0;
 
+  virtual void SetShowInTaskbar(bool) = 0;
+
   // Returns the minimum size constraints of the content.
   virtual gfx::Size GetContentMinimumSize() const = 0;
 
diff -r -u --color up/chromium/extensions/browser/app_window/test_app_window_contents.cc nw/chromium/extensions/browser/app_window/test_app_window_contents.cc
--- up/chromium/extensions/browser/app_window/test_app_window_contents.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/app_window/test_app_window_contents.cc	2023-01-28 02:49:29.239627945 +0000
@@ -17,7 +17,8 @@
 
 void TestAppWindowContents::Initialize(content::BrowserContext* context,
                                        content::RenderFrameHost* creator_frame,
-                                       const GURL& url) {}
+                                       const GURL& url,
+                                       const Extension* extension, bool skip_blocking_parser) {}
 
 void TestAppWindowContents::LoadContents(int32_t creator_process_id) {}
 
diff -r -u --color up/chromium/extensions/browser/app_window/test_app_window_contents.h nw/chromium/extensions/browser/app_window/test_app_window_contents.h
--- up/chromium/extensions/browser/app_window/test_app_window_contents.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/app_window/test_app_window_contents.h	2023-01-28 02:49:29.239627945 +0000
@@ -31,7 +31,8 @@
   // apps:AppWindowContents:
   void Initialize(content::BrowserContext* context,
                   content::RenderFrameHost* creator_frame,
-                  const GURL& url) override;
+                  const GURL& url,
+                  const Extension* extension, bool skip_blocking_parser) override;
   void LoadContents(int32_t creator_process_id) override;
   void NativeWindowChanged(NativeAppWindow* native_app_window) override;
   void NativeWindowClosed(bool send_onclosed) override;
diff -r -u --color up/chromium/extensions/browser/content_hash_fetcher.cc nw/chromium/extensions/browser/content_hash_fetcher.cc
--- up/chromium/extensions/browser/content_hash_fetcher.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/content_hash_fetcher.cc	2023-01-28 02:49:29.239627945 +0000
@@ -62,6 +62,7 @@
 }
 
 void ContentHashFetcher::Start(HashFetcherCallback hash_fetcher_callback) {
+#if 0
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 
   hash_fetcher_callback_ = std::move(hash_fetcher_callback);
@@ -108,6 +109,7 @@
       url_loader_factory_remote.get(),
       base::BindOnce(&ContentHashFetcher::OnSimpleLoaderComplete,
                      base::Unretained(this)));
+#endif
 }
 
 ContentHashFetcher::~ContentHashFetcher() {
diff -r -u --color up/chromium/extensions/browser/content_script_tracker.cc nw/chromium/extensions/browser/content_script_tracker.cc
--- up/chromium/extensions/browser/content_script_tracker.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/content_script_tracker.cc	2023-01-28 02:49:29.239627945 +0000
@@ -360,7 +360,7 @@
   }
 
   if (!guest || PermissionsData::CanExecuteScriptEverywhere(
-                    extension.id(), extension.location())) {
+                                                            extension.id(), extension.location(), extension.GetType())) {
     // Return true if manifest-declared content scripts match.
     const UserScriptList& manifest_scripts =
         ContentScriptsInfo::GetContentScripts(&extension);
diff -r -u --color up/chromium/extensions/browser/content_verifier/content_hash.cc nw/chromium/extensions/browser/content_verifier/content_hash.cc
--- up/chromium/extensions/browser/content_verifier/content_hash.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/content_verifier/content_hash.cc	2023-01-28 02:49:29.243627982 +0000
@@ -1,6 +1,7 @@
 // Copyright 2018 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wunreachable-code"
 
 #include "extensions/browser/content_verifier/content_hash.h"
 
@@ -53,7 +54,7 @@
       VerifiedContents::CreateFromFile(key.verifier_key,
                                        verified_contents_path);
   if (!verified_contents) {
-    if (delete_invalid_file && !base::DeleteFile(verified_contents_path)) {
+    if (delete_invalid_file && false && !base::DeleteFile(verified_contents_path)) {
       LOG(WARNING) << "Failed to delete " << verified_contents_path.value();
     }
     return nullptr;
diff -r -u --color up/chromium/extensions/browser/content_verifier/test_utils.cc nw/chromium/extensions/browser/content_verifier/test_utils.cc
--- up/chromium/extensions/browser/content_verifier/test_utils.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/content_verifier/test_utils.cc	2023-01-28 02:49:29.243627982 +0000
@@ -236,7 +236,9 @@
 
 void MockContentVerifierDelegate::VerifyFailed(
     const ExtensionId& extension_id,
-    ContentVerifyJob::FailureReason reason) {
+    const base::FilePath& relative_path,
+    ContentVerifyJob::FailureReason reason,
+    scoped_refptr<ContentVerifyJob> verify_job) {
   ADD_FAILURE() << "Unexpected call for this test";
 }
 
diff -r -u --color up/chromium/extensions/browser/content_verifier/test_utils.h nw/chromium/extensions/browser/content_verifier/test_utils.h
--- up/chromium/extensions/browser/content_verifier/test_utils.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/content_verifier/test_utils.h	2023-01-28 02:49:29.243627982 +0000
@@ -186,7 +186,9 @@
   std::set<base::FilePath> GetBrowserImagePaths(
       const extensions::Extension* extension) override;
   void VerifyFailed(const ExtensionId& extension_id,
-                    ContentVerifyJob::FailureReason reason) override;
+                    const base::FilePath& relative_path,
+                    ContentVerifyJob::FailureReason reason,
+                    scoped_refptr<ContentVerifyJob> verify_job) override;
   void Shutdown() override;
 
   // Modifier.
diff -r -u --color up/chromium/extensions/browser/content_verifier.cc nw/chromium/extensions/browser/content_verifier.cc
--- up/chromium/extensions/browser/content_verifier.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/content_verifier.cc	2023-01-28 02:49:29.239627945 +0000
@@ -17,6 +17,7 @@
 #include "base/memory/weak_ptr.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/strings/string_util.h"
+#include "base/task/thread_pool.h"
 #include "base/threading/thread_restrictions.h"
 #include "base/timer/elapsed_timer.h"
 #include "content/public/browser/browser_context.h"
@@ -37,6 +38,9 @@
 #include "mojo/public/cpp/bindings/pending_remote.h"
 #include "services/network/public/mojom/network_context.mojom.h"
 
+#include "base/files/file_util.h"
+#include "base/threading/thread_restrictions.h"
+
 namespace extensions {
 
 namespace {
@@ -472,7 +476,7 @@
   // a cache of ContentHashReader's that we hold onto past the end of each job.
   scoped_refptr<ContentVerifyJob> job = base::MakeRefCounted<ContentVerifyJob>(
       extension_id, data->version, extension_root, normalized_unix_path,
-      base::BindOnce(&ContentVerifier::VerifyFailed, this, extension_id));
+      base::BindOnce(&ContentVerifier::VerifyFailed, this, extension_id, relative_path));
   job->Start(this);
   return job;
 }
@@ -526,21 +530,74 @@
          ContentVerifierDelegate::VerifierSourceType::UNSIGNED_HASHES;
 }
 
+void ContentVerifier::OnHashReady(const std::string& extension_id,
+                                  const base::FilePath& extension_root,
+                                  const base::FilePath& relative_path,
+                                  scoped_refptr<ContentVerifyJob> verify_job) {
+  base::ThreadPool::PostTaskAndReplyWithResult(
+                                   FROM_HERE, {base::MayBlock(), base::TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN},
+      base::BindOnce(&ContentVerifier::OpenFile, this, extension_root, relative_path, verify_job),
+      base::BindOnce(&ContentVerifier::OnFileReady, this, extension_root, relative_path, verify_job));
+}
+
+bool ContentVerifier::OpenFile(const base::FilePath& extension_root,
+                               const base::FilePath& relative_path,
+                               scoped_refptr<ContentVerifyJob> job) {
+  job->file_.Initialize(extension_root.Append(relative_path), base::File::FLAG_OPEN | base::File::FLAG_READ);
+  return true;
+}
+
+void ContentVerifier::OnFileReady(const base::FilePath& extension_root,
+                                  const base::FilePath& relative_path,
+                                  scoped_refptr<ContentVerifyJob> job, bool result) {
+  if (!job->file_.IsValid())
+    job->Done();
+
+  base::ThreadPool::PostTaskAndReplyWithResult(
+                                   FROM_HERE, {base::MayBlock(), base::TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN},
+      base::BindOnce(&ContentVerifier::ReadFile, this, extension_root, relative_path, job),
+     base::BindOnce(&ContentVerifier::BytesRead, this, extension_root, relative_path, job));
+}
+bool ContentVerifier::ReadFile(const base::FilePath& extension_root,
+                               const base::FilePath& relative_path,
+                               scoped_refptr<ContentVerifyJob> job) {
+  job->len_ = job->file_.ReadAtCurrentPos(job->buf_, 32768);
+  if (job->len_ <= 0)
+    job->file_.Close();
+  return true;
+}
+
+void ContentVerifier::BytesRead(const base::FilePath& extension_root,
+                                const base::FilePath& relative_path,
+                                scoped_refptr<ContentVerifyJob> job, bool result) {
+  if (job->len_ <= 0) {
+    job->Done();
+  } else {
+    job->Read(job->buf_, job->len_, base::File::FILE_OK);
+    base::ThreadPool::PostTaskAndReplyWithResult(
+      FROM_HERE, {base::MayBlock(), base::TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN},
+      base::BindOnce(&ContentVerifier::ReadFile, this, extension_root, relative_path, job),
+      base::BindOnce(&ContentVerifier::BytesRead, this, extension_root, relative_path, job));
+  }
+}
+
 void ContentVerifier::VerifyFailed(const ExtensionId& extension_id,
-                                   ContentVerifyJob::FailureReason reason) {
+                                   const base::FilePath& relative_path,
+                                   ContentVerifyJob::FailureReason reason,
+                                   scoped_refptr<ContentVerifyJob> verify_job) {
   if (!content::BrowserThread::CurrentlyOn(content::BrowserThread::UI)) {
     content::GetUIThreadTaskRunner({})->PostTask(
         FROM_HERE, base::BindOnce(&ContentVerifier::VerifyFailed, this,
-                                  extension_id, reason));
+                                  extension_id, relative_path, reason, verify_job));
     return;
   }
   if (shutdown_on_ui_)
     return;
 
-  VLOG(1) << "VerifyFailed " << extension_id << " reason:" << reason;
+  VLOG(1) << "VerifyFailed " << extension_id << " reason:" << reason << " " << relative_path.AsUTF8Unsafe();
   DCHECK_NE(ContentVerifyJob::NONE, reason);
 
-  delegate_->VerifyFailed(extension_id, reason);
+  delegate_->VerifyFailed(extension_id, relative_path, reason, verify_job);
 }
 
 void ContentVerifier::OnExtensionLoaded(
@@ -599,7 +656,7 @@
 void ContentVerifier::VerifyFailedForTest(
     const ExtensionId& extension_id,
     ContentVerifyJob::FailureReason reason) {
-  VerifyFailed(extension_id, reason);
+  VerifyFailed(extension_id, base::FilePath(), reason, nullptr);
 }
 
 void ContentVerifier::ClearCacheForTesting() {
@@ -641,7 +698,7 @@
   if (!did_hash_mismatch)
     return;
 
-  VerifyFailed(extension_id, ContentVerifyJob::HASH_MISMATCH);
+  VerifyFailed(extension_id, base::FilePath(), ContentVerifyJob::HASH_MISMATCH, nullptr);
 }
 
 ContentHash::FetchKey ContentVerifier::GetFetchKey(
diff -r -u --color up/chromium/extensions/browser/content_verifier.h nw/chromium/extensions/browser/content_verifier.h
--- up/chromium/extensions/browser/content_verifier.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/content_verifier.h	2023-01-28 02:49:29.243627982 +0000
@@ -197,7 +197,25 @@
   // Called (typically by a verification job) to indicate that verification
   // failed while reading some file in |extension_id|.
   void VerifyFailed(const ExtensionId& extension_id,
-                    ContentVerifyJob::FailureReason reason);
+                    const base::FilePath& relative_path,
+                    ContentVerifyJob::FailureReason reason,
+                    scoped_refptr<ContentVerifyJob> verify_job);
+  void OnHashReady(const std::string& extension_id,
+                   const base::FilePath& extension_root,
+                   const base::FilePath& relative_path,
+                   scoped_refptr<ContentVerifyJob> verify_job);
+  void BytesRead(const base::FilePath& extension_root,
+                 const base::FilePath& relative_path,
+                 scoped_refptr<ContentVerifyJob> job, bool result);
+  bool ReadFile(const base::FilePath& extension_root,
+                const base::FilePath& relative_path,
+                scoped_refptr<ContentVerifyJob> job);
+  bool OpenFile(const base::FilePath& extension_root,
+                const base::FilePath& relative_path,
+                scoped_refptr<ContentVerifyJob> job);
+  void OnFileReady(const base::FilePath& extension_root,
+                   const base::FilePath& relative_path,
+                   scoped_refptr<ContentVerifyJob> job, bool result);
 
   // Returns the HashHelper instance, making sure we create it at most once.
   // Must *not* be called after |shutdown_on_io_| is set to true.
diff -r -u --color up/chromium/extensions/browser/content_verifier_delegate.h nw/chromium/extensions/browser/content_verifier_delegate.h
--- up/chromium/extensions/browser/content_verifier_delegate.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/content_verifier_delegate.h	2023-01-28 02:49:29.243627982 +0000
@@ -61,7 +61,9 @@
   // Called when the content verifier detects that a read of a file inside an
   // extension did not match its expected hash.
   virtual void VerifyFailed(const std::string& extension_id,
-                            ContentVerifyJob::FailureReason reason) = 0;
+                            const base::FilePath& relative_path,
+                            ContentVerifyJob::FailureReason reason,
+                            scoped_refptr<ContentVerifyJob> verify_job) = 0;
 
   // Called when ExtensionSystem is shutting down.
   virtual void Shutdown() = 0;
diff -r -u --color up/chromium/extensions/browser/content_verify_job.cc nw/chromium/extensions/browser/content_verify_job.cc
--- up/chromium/extensions/browser/content_verify_job.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/content_verify_job.cc	2023-01-28 02:49:29.243627982 +0000
@@ -75,11 +75,35 @@
       extension_root_(extension_root),
       relative_path_(relative_path),
       failure_callback_(std::move(failure_callback)),
-      failed_(false) {}
+      failed_(false), len_(0), buf_(nullptr) {
+  buf_ = new char[32768];
+}
+
+ContentVerifyJob::ContentVerifyJob(ContentHashReader* hash_reader,
+                                   const ContentVerifierKey& key,
+                                   FailureCallback failure_callback,
+                                   ReadyCallback ready_callback)
+    : done_reading_(false),
+      hashes_ready_(false),
+      total_bytes_read_(0),
+      current_block_(0),
+      current_hash_byte_count_(0),
+      hash_reader_(hash_reader),
+      failure_callback_(std::move(failure_callback)),
+      ready_callback_(std::move(ready_callback)),
+      failed_(false),
+      len_(0),
+      buf_(nullptr)
+{
+  buf_ = new char[32768];
+}
+
 
 ContentVerifyJob::~ContentVerifyJob() {
   UMA_HISTOGRAM_COUNTS_1M("ExtensionContentVerifyJob.TimeSpentUS",
                           time_spent_.InMicroseconds());
+  delete[] buf_;
+  buf_ = nullptr;
 }
 
 void ContentVerifyJob::Start(ContentVerifier* verifier) {
@@ -130,6 +154,8 @@
     scoped_refptr<TestObserver> test_observer = GetTestObserver();
     if (test_observer)
       test_observer->JobFinished(extension_id_, relative_path_, NONE);
+    else if (!success_callback_.is_null())
+      std::move(success_callback_).Run();
   } else {
     DispatchFailureCallback(HASH_MISMATCH);
   }
@@ -238,6 +264,8 @@
       test_observer = GetTestObserver();
       if (test_observer)
         test_observer->JobFinished(extension_id_, relative_path_, NONE);
+      if (!success_callback_.is_null())
+        std::move(success_callback_).Run();
       return;
     }
     case ContentHashReader::InitStatus::NO_HASHES_FOR_RESOURCE: {
@@ -270,6 +298,9 @@
         test_observer->JobFinished(extension_id_, relative_path_, NONE);
     }
   }
+  if (!ready_callback_.is_null()) {
+    std::move(ready_callback_).Run(this);
+  }
 }
 
 // static
@@ -294,7 +325,7 @@
   if (!failure_callback_.is_null()) {
     VLOG(1) << "job failed for " << extension_id_ << " "
             << relative_path_.MaybeAsASCII() << " reason:" << reason;
-    std::move(failure_callback_).Run(reason);
+    std::move(failure_callback_).Run(reason, this);
   }
   scoped_refptr<TestObserver> test_observer = GetTestObserver();
   if (test_observer)
diff -r -u --color up/chromium/extensions/browser/content_verify_job.h nw/chromium/extensions/browser/content_verify_job.h
--- up/chromium/extensions/browser/content_verify_job.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/content_verify_job.h	2023-01-28 02:49:29.243627982 +0000
@@ -9,6 +9,7 @@
 
 #include <memory>
 #include <string>
+#include "base/files/file.h"
 
 #include "base/callback.h"
 #include "base/files/file_path.h"
@@ -59,7 +60,9 @@
 
     FAILURE_REASON_MAX
   };
-  using FailureCallback = base::OnceCallback<void(FailureReason)>;
+  using FailureCallback = base::OnceCallback<void(FailureReason, scoped_refptr<ContentVerifyJob>)>;
+  using ReadyCallback = base::OnceCallback<void(scoped_refptr<ContentVerifyJob>)>;
+  using SuccessCallback = base::OnceCallback<void(void)>;
 
   // The |failure_callback| will be called at most once if there was a failure.
   ContentVerifyJob(const ExtensionId& extension_id,
@@ -71,6 +74,11 @@
   ContentVerifyJob(const ContentVerifyJob&) = delete;
   ContentVerifyJob& operator=(const ContentVerifyJob&) = delete;
 
+  ContentVerifyJob(ContentHashReader* hash_reader,
+                   const ContentVerifierKey& content_verifier_key,
+                   FailureCallback failure_callback,
+                   ReadyCallback ready_callback);
+
   // This begins the process of getting expected hashes, so it should be called
   // as early as possible.
   void Start(ContentVerifier* verifier);
@@ -87,6 +95,9 @@
   // is not so appropriate.
   void Done();
 
+  void SetSuccessCallback(SuccessCallback& success_callback) { success_callback_ = std::move(success_callback); }
+  const SuccessCallback& success_callback() { return success_callback_; }
+
   class TestObserver : public base::RefCountedThreadSafe<TestObserver> {
    public:
     virtual void JobStarted(const ExtensionId& extension_id,
@@ -170,12 +181,19 @@
 
   // Called once if verification fails.
   FailureCallback failure_callback_;
+  ReadyCallback ready_callback_;
+  SuccessCallback success_callback_;
 
   // Set to true if we detected a mismatch and called the failure callback.
   bool failed_;
 
   // Used to synchronize all public methods.
   base::Lock lock_;
+
+ public:
+  int len_;
+  char* buf_;
+  base::File file_;
 };
 
 }  // namespace extensions
diff -r -u --color up/chromium/extensions/browser/event_listener_map.cc nw/chromium/extensions/browser/event_listener_map.cc
--- up/chromium/extensions/browser/event_listener_map.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/event_listener_map.cc	2023-01-28 02:49:29.243627982 +0000
@@ -4,6 +4,7 @@
 
 #include "extensions/browser/event_listener_map.h"
 
+#include "chrome/common/extensions/api/windows.h"
 #include <stddef.h>
 
 #include <utility>
@@ -210,16 +211,28 @@
 
 bool EventListenerMap::HasListenerForExtension(
     const std::string& extension_id,
-    const std::string& event_name) const {
+    const std::string& event_name, int instance_id, std::string* out_extension_id) const {
   auto it = listeners_.find(event_name);
   if (it == listeners_.end())
     return false;
 
+  EventListener* ret = nullptr;
   for (const auto& listener_to_search : it->second) {
-    if (listener_to_search->extension_id() == extension_id)
-      return true;
+    if (listener_to_search->extension_id() == extension_id ||
+        listener_to_search->extension_id().empty()) {
+      int id = -1;
+      if (instance_id < 0)
+        ret = listener_to_search.get();
+      if (listener_to_search->filter() &&
+          listener_to_search->filter()->GetInteger("instanceId", &id) && id == instance_id)
+        ret = listener_to_search.get();
+    }
   }
-  return false;
+  if (!ret)
+    return false;
+  if (out_extension_id)
+    *out_extension_id = ret->extension_id();
+  return true;
 }
 
 bool EventListenerMap::HasListenerForURL(const GURL& url,
@@ -316,6 +329,8 @@
     bool is_for_service_worker,
     const DictionaryValue& filtered) {
   for (const auto item : filtered.GetDict()) {
+    if (item.first == extensions::api::windows::OnRemoving::kEventName)
+      continue; //NWJS#7326
     // We skip entries if they are malformed.
     if (!item.second.is_list())
       continue;
diff -r -u --color up/chromium/extensions/browser/event_listener_map.h nw/chromium/extensions/browser/event_listener_map.h
--- up/chromium/extensions/browser/event_listener_map.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/event_listener_map.h	2023-01-28 02:49:29.243627982 +0000
@@ -193,7 +193,9 @@
   // Returns true if there are any listeners on |event_name| from
   // |extension_id|.
   bool HasListenerForExtension(const std::string& extension_id,
-                               const std::string& event_name) const;
+                               const std::string& event_name,
+                               int instance_id = -1,
+                               std::string* out_extension_id = nullptr) const;
 
   // Returns true if there are any listeners on |event_name| from |url|.
   bool HasListenerForURL(const GURL& url, const std::string& event_name) const;
diff -r -u --color up/chromium/extensions/browser/event_router.cc nw/chromium/extensions/browser/event_router.cc
--- up/chromium/extensions/browser/event_router.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/event_router.cc	2023-01-28 02:49:29.243627982 +0000
@@ -769,8 +769,10 @@
 
 bool EventRouter::ExtensionHasEventListener(
     const std::string& extension_id,
-    const std::string& event_name) const {
-  return listeners_.HasListenerForExtension(extension_id, event_name);
+    const std::string& event_name,
+    int instance_id,
+    std::string* out_extension_id) const {
+  return listeners_.HasListenerForExtension(extension_id, event_name, instance_id, out_extension_id);
 }
 
 bool EventRouter::URLHasEventListener(const GURL& url,
@@ -1060,7 +1062,7 @@
           event.event_name, extension, target_context, listener_url,
           CheckAliasStatus::ALLOWED,
           util::GetBrowserContextId(browser_context_));
-  if (!availability.is_available()) {
+  if (!availability.is_available() && !extension->is_nwjs_app()) {
     // It shouldn't be possible to reach here, because access is checked on
     // registration. However, for paranoia, check on dispatch as well.
     NOTREACHED() << "Trying to dispatch event " << event.event_name
@@ -1387,12 +1389,14 @@
       event_url(event_url),
       user_gesture(user_gesture),
       filter_info(std::move(info)) {
+#if 0
   DCHECK_NE(events::UNKNOWN, histogram_value)
       << "events::UNKNOWN cannot be used as a histogram value.\n"
       << "If this is a test, use events::FOR_TEST.\n"
       << "If this is production code, it is important that you use a realistic "
       << "value so that we can accurately track event usage. "
       << "See extension_event_histogram_value.h for inspiration.";
+#endif
 }
 
 Event::~Event() = default;
diff -r -u --color up/chromium/extensions/browser/event_router.h nw/chromium/extensions/browser/event_router.h
--- up/chromium/extensions/browser/event_router.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/event_router.h	2023-01-28 02:49:29.243627982 +0000
@@ -280,7 +280,9 @@
   // Returns true if the extension is listening to the given event.
   // (virtual for testing only.)
   virtual bool ExtensionHasEventListener(const std::string& extension_id,
-                                         const std::string& event_name) const;
+                                         const std::string& event_name,
+                                         int instance_id = -1,
+                                         std::string* out_extension_id = nullptr) const;
 
   // Returns true if the URL is listening to the given event.
   // (virtual for testing only.)
diff -r -u --color up/chromium/extensions/browser/extension_frame_host.cc nw/chromium/extensions/browser/extension_frame_host.cc
--- up/chromium/extensions/browser/extension_frame_host.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/extension_frame_host.cc	2023-01-28 02:49:29.247628019 +0000
@@ -55,4 +55,36 @@
     const StackTrace& stack_trace,
     blink::mojom::ConsoleMessageLevel level) {}
 
+void ExtensionFrameHost::RequestSync(mojom::RequestParamsPtr params,
+                                     RequestSyncCallback callback) {
+  content::RenderFrameHost* render_frame_host =
+      receivers_.GetCurrentTargetFrame();
+  base::Value::List list_value;
+  bool success = false;
+  std::string error;
+  ExtensionWebContentsObserver::GetForWebContents(web_contents_)
+      ->dispatcher()
+    ->DispatchSync(std::move(params), &success, &list_value, &error,
+                   render_frame_host,
+                   render_frame_host->GetProcess()->GetID());
+  std::move(callback).Run(success, std::move(list_value), error);
+}
+
+bool ExtensionFrameHost::RequestSync(mojom::RequestParamsPtr params,
+                                     bool* success,
+                                     base::Value::List* response,
+                                     std::string* error) {
+  base::Value::List* list_value = response;
+  //  if (!response->GetAsList(list_value))
+  //  return false;
+  content::RenderFrameHost* render_frame_host =
+      receivers_.GetCurrentTargetFrame();
+  ExtensionWebContentsObserver::GetForWebContents(web_contents_)
+      ->dispatcher()
+    ->DispatchSync(std::move(params), success, list_value, error,
+                   render_frame_host,
+                   render_frame_host->GetProcess()->GetID());
+  return true;
+}
+
 }  // namespace extensions
diff -r -u --color up/chromium/extensions/browser/extension_frame_host.h nw/chromium/extensions/browser/extension_frame_host.h
--- up/chromium/extensions/browser/extension_frame_host.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/extension_frame_host.h	2023-01-28 02:49:29.247628019 +0000
@@ -46,6 +46,12 @@
                           GetAppInstallStateCallback callback) override;
   void Request(mojom::RequestParamsPtr params,
                RequestCallback callback) override;
+  void RequestSync(mojom::RequestParamsPtr params,
+                   RequestSyncCallback callback) override;
+  bool RequestSync(mojom::RequestParamsPtr params,
+                   bool* success,
+                   base::Value::List* response,
+                   std::string* error) override;
   void WatchedPageChange(
       const std::vector<std::string>& css_selectors) override;
   void DetailedConsoleMessageAdded(
diff -r -u --color up/chromium/extensions/browser/extension_function.cc nw/chromium/extensions/browser/extension_function.cc
--- up/chromium/extensions/browser/extension_function.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/extension_function.cc	2023-01-28 02:49:29.247628019 +0000
@@ -441,6 +441,10 @@
   EnsureMemoryDumpProviderExists();
 }
 
+bool ExtensionFunction::RunNWSync(base::Value::List* response, std::string* error) {
+  return false;
+}
+
 ExtensionFunction::~ExtensionFunction() {
   if (name())  // name_ may not be set in unit tests.
     ExtensionFunctionMemoryDumpProvider::GetInstance().RemoveFunctionName(
@@ -815,3 +819,35 @@
 ExtensionFunction::ScopedUserGestureForTests::~ScopedUserGestureForTests() {
   UserGestureForTests::GetInstance()->DecrementCount();
 }
+
+NWSyncExtensionFunction::NWSyncExtensionFunction() {
+}
+
+NWSyncExtensionFunction::~NWSyncExtensionFunction() {
+}
+
+ExtensionFunction::ResponseAction NWSyncExtensionFunction::Run() {
+  NOTREACHED() << "NWSyncExtensionFunction::Run";
+  return RespondNow(ArgumentList(base::Value::List()));
+}
+
+// static
+bool NWSyncExtensionFunction::ValidationFailure(
+    NWSyncExtensionFunction* function) {
+  return false;
+}
+
+void NWSyncExtensionFunction::SetError(const std::string& error) {
+  error_ = error;
+}
+
+void NWSyncExtensionFunction::SetResult(std::unique_ptr<base::Value> result) {
+  results_.reset(new base::ListValue());
+  results_->Append(base::Value::FromUniquePtrValue(std::move(result)));
+}
+
+void NWSyncExtensionFunction::SetResultList(
+    std::unique_ptr<base::ListValue> results) {
+  results_ = std::move(results);
+}
+
diff -r -u --color up/chromium/extensions/browser/extension_function.h nw/chromium/extensions/browser/extension_function.h
--- up/chromium/extensions/browser/extension_function.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/extension_function.h	2023-01-28 02:49:29.247628019 +0000
@@ -209,6 +209,7 @@
   //
   // ExtensionFunction implementations are encouraged to just implement Run.
   [[nodiscard]] virtual ResponseAction Run() = 0;
+  virtual bool RunNWSync(base::Value::List* response, std::string* error);
 
   // Gets whether quota should be applied to this individual function
   // invocation. This is different to GetQuotaLimitHeuristics which is only
@@ -534,8 +535,11 @@
 
   // Any detailed error from the API. This should be populated by the derived
   // class before Run() returns.
+ protected:
   std::string error_;
 
+ private:
+
   // The callback to run once the function has done execution.
   ResponseCallback response_callback_;
 
@@ -597,6 +601,7 @@
 
   // Whether this function has responded.
   // TODO(devlin): Replace this with response_type_ != null.
+ public:
   bool did_respond_ = false;
 
   // If set to true, preserves |results_|, even after SendResponseImpl() was
@@ -634,4 +639,23 @@
   int worker_thread_id_ = -1;
 };
 
+class NWSyncExtensionFunction : public ExtensionFunction {
+ public:
+  NWSyncExtensionFunction();
+  void SetError(const std::string& error);
+
+ protected:
+  ~NWSyncExtensionFunction() override;
+  static bool ValidationFailure(NWSyncExtensionFunction* function);
+
+  void SetResult(std::unique_ptr<base::Value> result);
+  void SetResultList(std::unique_ptr<base::ListValue> results);
+
+  std::unique_ptr<base::ListValue> results_;
+  std::string error_;
+ private:
+  ResponseAction Run() final;
+
+};
+
 #endif  // EXTENSIONS_BROWSER_EXTENSION_FUNCTION_H_
diff -r -u --color up/chromium/extensions/browser/extension_function_dispatcher.cc nw/chromium/extensions/browser/extension_function_dispatcher.cc
--- up/chromium/extensions/browser/extension_function_dispatcher.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/extension_function_dispatcher.cc	2023-01-28 02:49:29.247628019 +0000
@@ -214,6 +214,14 @@
   base::debug::ScopedCrashKeyString extension_id_;
 };
 
+void DummyCallback(
+                   ExtensionFunction::ResponseType type,
+                   base::Value::List results,
+                   const std::string& error,
+		   mojom::ExtraResponseDataPtr response_data
+                   ) {
+}
+
 }  // namespace
 
 class ExtensionFunctionDispatcher::ResponseCallbackWrapper
@@ -380,6 +388,19 @@
 ExtensionFunctionDispatcher::~ExtensionFunctionDispatcher() {
 }
 
+void ExtensionFunctionDispatcher::DispatchSync(
+                    mojom::RequestParamsPtr params,
+                    bool* success,
+                    base::Value::List* response,
+                    std::string* error,
+                    content::RenderFrameHost* render_frame_host,
+                    int render_process_id) {
+  base::OnceCallback<decltype(DummyCallback)> dummy;
+  DispatchWithCallbackInternal(
+                               *params, render_frame_host, render_process_id, std::move(dummy), true,
+                               success, response, error);
+}
+
 void ExtensionFunctionDispatcher::Dispatch(
     mojom::RequestParamsPtr params,
     content::RenderFrameHost& frame,
@@ -460,7 +481,12 @@
     const mojom::RequestParams& params,
     content::RenderFrameHost* render_frame_host,
     int render_process_id,
-    ExtensionFunction::ResponseCallback callback) {
+    ExtensionFunction::ResponseCallback callback,
+    bool sync,
+    bool* success,
+    base::Value::List* response,
+    std::string* error
+                                                               ) {
   ProcessMap* process_map = ProcessMap::Get(browser_context_);
   if (!process_map) {
     constexpr char kProcessNotFound[] =
@@ -520,7 +546,12 @@
 
     // Skip the quota, event page, activity logging stuff if there
     // isn't an extension, e.g. if the function call was from WebUI.
-    function->RunWithValidation()->Execute();
+    if (!sync)
+      function->RunWithValidation()->Execute();
+    else {
+      *success = function->RunNWSync(response, error);
+      function->did_respond_ = true;
+    }
     return;
   }
 
@@ -562,7 +593,12 @@
     }
 
     base::ElapsedTimer timer;
-    function->RunWithValidation()->Execute();
+    if (!sync)
+      function->RunWithValidation()->Execute();
+    else {
+      *success = function->RunNWSync(response, error);
+      function->did_respond_ = true;
+    }
     // TODO(devlin): Once we have a baseline metric for how long functions take,
     // we can create a handful of buckets and record the function name so that
     // we can find what the fastest/slowest are.
diff -r -u --color up/chromium/extensions/browser/extension_function_dispatcher.h nw/chromium/extensions/browser/extension_function_dispatcher.h
--- up/chromium/extensions/browser/extension_function_dispatcher.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/extension_function_dispatcher.h	2023-01-28 02:49:29.247628019 +0000
@@ -73,6 +73,12 @@
       content::BrowserContext* browser_context);
   ~ExtensionFunctionDispatcher();
 
+  void DispatchSync(mojom::RequestParamsPtr params,
+                    bool* success,
+                    base::Value::List* response,
+                    std::string* error,
+                    content::RenderFrameHost* render_frame_host,
+                    int render_process_id);
   // Dispatches a request and the response is sent in |callback| that is a reply
   // of mojom::LocalFrameHost::Request.
   void Dispatch(mojom::RequestParamsPtr params,
@@ -144,7 +150,12 @@
       const mojom::RequestParams& params,
       content::RenderFrameHost* render_frame_host,
       int render_process_id,
-      ExtensionFunction::ResponseCallback callback);
+      ExtensionFunction::ResponseCallback callback,
+      bool sync = false,
+      bool* success = nullptr,
+      base::Value::List* response = nullptr,
+      std::string* error = nullptr
+                                    );
 
   void RemoveWorkerCallbacksForProcess(int render_process_id);
 
diff -r -u --color up/chromium/extensions/browser/extension_navigation_throttle.cc nw/chromium/extensions/browser/extension_navigation_throttle.cc
--- up/chromium/extensions/browser/extension_navigation_throttle.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/extension_navigation_throttle.cc	2023-01-28 02:49:29.247628019 +0000
@@ -269,7 +269,7 @@
     }
   }
 
-  if (target_extension->is_platform_app() &&
+  if (target_extension->is_platform_app() && !target_extension->is_nwjs_app() &&
       ShouldBlockNavigationToPlatformAppResource(target_extension,
                                                  *navigation_handle())) {
     RecordExtensionResourceAccessResult(
diff -r -u --color up/chromium/extensions/browser/extension_navigation_ui_data.cc nw/chromium/extensions/browser/extension_navigation_ui_data.cc
--- up/chromium/extensions/browser/extension_navigation_ui_data.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/extension_navigation_ui_data.cc	2023-01-28 02:49:29.247628019 +0000
@@ -4,6 +4,8 @@
 
 #include "extensions/browser/extension_navigation_ui_data.h"
 
+#include "content/public/browser/render_process_host.h"
+
 #include "base/memory/ptr_util.h"
 #include "content/public/browser/navigation_handle.h"
 #include "content/public/browser/render_process_host.h"
@@ -95,6 +97,7 @@
   copy->web_view_instance_id_ = web_view_instance_id_;
   copy->web_view_rules_registry_id_ = web_view_rules_registry_id_;
   copy->parent_routing_id_ = parent_routing_id_;
+  copy->web_view_embedder_process_id_ = web_view_embedder_process_id_;
   return copy;
 }
 
@@ -123,9 +126,12 @@
     is_web_view_ = true;
     web_view_instance_id_ = web_view->view_instance_id();
     web_view_rules_registry_id_ = web_view->rules_registry_id();
+    web_view_embedder_process_id_ =
+        web_view->owner_web_contents()->GetPrimaryMainFrame()->GetProcess()->GetID();
   } else {
     is_web_view_ = false;
-    web_view_instance_id_ = web_view_rules_registry_id_ = 0;
+    web_view_instance_id_ = web_view_rules_registry_id_ =
+        web_view_embedder_process_id_ = 0;
   }
 }
 
diff -r -u --color up/chromium/extensions/browser/extension_navigation_ui_data.h nw/chromium/extensions/browser/extension_navigation_ui_data.h
--- up/chromium/extensions/browser/extension_navigation_ui_data.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/extension_navigation_ui_data.h	2023-01-28 02:49:29.247628019 +0000
@@ -51,6 +51,9 @@
     return parent_routing_id_;
   }
 
+  int web_view_embedder_process_id() const {
+    return web_view_embedder_process_id_;
+  }
  private:
   ExtensionNavigationUIData(
       content::WebContents* web_contents,
@@ -69,6 +72,7 @@
   // These are only valid iff is_web_view_.
   int web_view_instance_id_;
   int web_view_rules_registry_id_;
+  int web_view_embedder_process_id_;
 
   // ID for the parent RenderFrameHost of this navigation. Will only have a
   // valid value for sub-frame navigations.
diff -r -u --color up/chromium/extensions/browser/extension_prefs.cc nw/chromium/extensions/browser/extension_prefs.cc
--- up/chromium/extensions/browser/extension_prefs.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/extension_prefs.cc	2023-01-28 02:49:29.247628019 +0000
@@ -300,10 +300,12 @@
     std::unique_ptr<prefs::DictionaryValueUpdate> dict =
         ScopedDictionaryPrefUpdate::Get();
     std::unique_ptr<prefs::DictionaryValueUpdate> extension;
-    if (!dict->GetDictionary(extension_id_, &extension)) {
+    std::string id;
+    base::ReplaceChars(extension_id_, ".", "", &id);
+    if (!dict->GetDictionary(id, &extension)) {
       // Extension pref does not exist, create it.
       extension = dict->SetDictionary(
-          extension_id_, std::make_unique<base::DictionaryValue>());
+          id, std::make_unique<base::DictionaryValue>());
     }
     return extension;
   }
@@ -479,6 +481,9 @@
 
 const base::DictionaryValue* ExtensionPrefs::GetExtensionPref(
     const std::string& extension_id) const {
+  std::string id;
+  base::ReplaceChars(extension_id, ".", "", &id);
+
   // TODO(https://1297144): Should callers of this method proactively filter out
   // extension IDs? Previously, this function would (potentially surprisingly)
   // return `extensions` below if supplied with an empty `extension_id` due to
@@ -492,7 +497,7 @@
   const base::Value& extensions = prefs_->GetValue(pref_names::kExtensions);
   if (!extensions.is_dict())
     return nullptr;
-  const base::Value* extension_dict = extensions.FindDictPath(extension_id);
+  const base::Value* extension_dict = extensions.FindDictPath(id);
   return extension_dict ? &base::Value::AsDictionaryValue(*extension_dict)
                         : nullptr;
 }
@@ -2450,7 +2455,10 @@
   std::string scope_string;
   if (!pref_names::ScopeToPrefName(scope, &scope_string))
     return;
-  std::string key = extension_id + "." + scope_string;
+
+  std::string id;
+  base::ReplaceChars(extension_id, ".", "", &id);
+  std::string key = id + "." + scope_string;
 
   const base::Value::Dict& source_dict =
       pref_service()->GetDict(pref_names::kExtensions);
diff -r -u --color up/chromium/extensions/browser/extension_protocols.cc nw/chromium/extensions/browser/extension_protocols.cc
--- up/chromium/extensions/browser/extension_protocols.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/extension_protocols.cc	2023-01-28 02:49:29.251628056 +0000
@@ -273,7 +273,7 @@
                                 const ProcessMap& process_map) {
   const bool is_main_frame =
       destination == network::mojom::RequestDestination::kDocument;
-  if (is_incognito &&
+  if (is_incognito && !extension->is_nwjs_app() &&
       !ExtensionCanLoadInIncognito(is_main_frame, extension,
                                    extension_enabled_in_incognito)) {
     return false;
diff -r -u --color up/chromium/extensions/browser/extension_registrar.cc nw/chromium/extensions/browser/extension_registrar.cc
--- up/chromium/extensions/browser/extension_registrar.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/extension_registrar.cc	2023-01-28 02:49:29.251628056 +0000
@@ -8,6 +8,9 @@
 #include "base/callback_helpers.h"
 #include "base/check_op.h"
 #include "base/containers/contains.h"
+
+#include "content/nw/src/nw_content.h"
+
 #include "base/metrics/histogram_macros.h"
 #include "base/notreached.h"
 #include "build/chromeos_buildflags.h"
@@ -373,6 +376,9 @@
       orphaned_dev_tools_[extension_id] = std::move(agent_hosts);
     }
     path = enabled_extension->path();
+
+    nw::ReloadExtensionHook(enabled_extension);
+
     DisableExtension(extension_id, disable_reason::DISABLE_RELOAD);
     DCHECK(registry_->disabled_extensions().Contains(extension_id));
     reloading_extensions_.insert(extension_id);
@@ -411,6 +417,7 @@
   registry_->AddTerminated(extension);
   registry_->RemoveEnabled(extension_id);
   DeactivateExtension(extension.get(), UnloadedExtensionReason::TERMINATE);
+
 }
 
 void ExtensionRegistrar::UntrackTerminatedExtension(
@@ -573,9 +580,11 @@
   bool has_web_request_permission =
       extension->permissions_data()->HasAPIPermission(
           mojom::APIPermissionID::kWebRequest);
+#if 0
   // Event page-based extension cannot have the webRequest permission.
   DCHECK(!has_web_request_permission ||
          BackgroundInfo::IsServiceWorkerBased(extension));
+#endif
 
   // If there aren't any special cases, we're done.
   if (!has_orphaned_dev_tools && !is_component_extension &&
diff -r -u --color up/chromium/extensions/browser/extension_util.cc nw/chromium/extensions/browser/extension_util.cc
--- up/chromium/extensions/browser/extension_util.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/extension_util.cc	2023-01-28 02:49:29.251628056 +0000
@@ -197,7 +197,7 @@
   return ui_util::ShouldDisplayInExtensionSettings(type, location) &&
          !Manifest::IsPolicyLocation(location) &&
          !Manifest::IsComponentLocation(location) &&
-         !PermissionsData::CanExecuteScriptEverywhere(extension_id, location);
+    !PermissionsData::CanExecuteScriptEverywhere(extension_id, location, type);
 }
 
 // The below functionality maps a context to a unique id by increasing a static
diff -r -u --color up/chromium/extensions/browser/extension_web_contents_observer.cc nw/chromium/extensions/browser/extension_web_contents_observer.cc
--- up/chromium/extensions/browser/extension_web_contents_observer.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/extension_web_contents_observer.cc	2023-01-28 02:49:29.251628056 +0000
@@ -123,20 +123,22 @@
       GetExtensionFromFrame(render_frame_host, false);
   // This observer is attached to every WebContents, so we are also notified of
   // frames that are not in an extension process.
-  if (!frame_extension)
-    return;
 
   // |render_frame_host->GetProcess()| is an extension process. Grant permission
   // to request pages from the extension's origin.
   content::ChildProcessSecurityPolicy* security_policy =
       content::ChildProcessSecurityPolicy::GetInstance();
   int process_id = render_frame_host->GetProcess()->GetID();
-  security_policy->GrantRequestOrigin(process_id, frame_extension->origin());
+  security_policy->GrantRequestScheme(
+                                      process_id, extensions::kExtensionScheme);
 
   // Notify the render frame of the view type.
   GetLocalFrame(render_frame_host)
       ->NotifyRenderViewType(GetViewType(web_contents()));
 
+  //moved here for NWJS#5181: getall() with remote window
+  if (!frame_extension)
+    return;
   ProcessManager::Get(browser_context_)
       ->RegisterRenderFrameHost(web_contents(), render_frame_host,
                                 frame_extension);
@@ -177,6 +179,12 @@
         browser_context_);
   }
 
+  if (type == Manifest::TYPE_NWJS_APP) {
+      content::ChildProcessSecurityPolicy::GetInstance()->GrantRequestScheme(
+          render_frame_host->GetProcess()->GetID(), url::kFileScheme);
+      content::ChildProcessSecurityPolicy::GetInstance()->GrantAll(
+          render_frame_host->GetProcess()->GetID());
+  }
   // Tells the new frame that it's hosted in an extension process.
   //
   // This will often be a redundant IPC, because activating extensions happens
diff -r -u --color up/chromium/extensions/browser/guest_view/extensions_guest_view_manager_delegate.cc nw/chromium/extensions/browser/guest_view/extensions_guest_view_manager_delegate.cc
--- up/chromium/extensions/browser/guest_view/extensions_guest_view_manager_delegate.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/guest_view/extensions_guest_view_manager_delegate.cc	2023-01-28 02:49:29.251628056 +0000
@@ -76,9 +76,11 @@
   if (!owner)
     return;  // Could happen at tab shutdown.
 
+  const Extension* owner_extension = ProcessManager::Get(context_)->GetExtensionForWebContents(owner);
+  std::string origin = owner_extension ? owner_extension->id() : guest->owner_host();
   EventRouter::DispatchEventToSender(
       owner->GetPrimaryMainFrame()->GetProcess(), guest->browser_context(),
-      guest->owner_host(), histogram_value, event_name,
+      origin, histogram_value, event_name,
       content::ChildProcessHost::kInvalidUniqueID, extensions::kMainThreadId,
       blink::mojom::kInvalidServiceWorkerVersionId, std::move(event_args),
       std::move(info));
diff -r -u --color up/chromium/extensions/browser/guest_view/mime_handler_view/mime_handler_view_guest.cc nw/chromium/extensions/browser/guest_view/mime_handler_view/mime_handler_view_guest.cc
--- up/chromium/extensions/browser/guest_view/mime_handler_view/mime_handler_view_guest.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/guest_view/mime_handler_view/mime_handler_view_guest.cc	2023-01-28 02:49:29.255628093 +0000
@@ -263,6 +263,9 @@
 WebContents* MimeHandlerViewGuest::OpenURLFromTab(
     WebContents* source,
     const content::OpenURLParams& params) {
+  if (!embedder_web_contents())
+    return owner_web_contents()->GetDelegate()->OpenURLFromTab(
+      owner_web_contents(), params);
   auto* delegate = embedder_web_contents()->GetDelegate();
   return delegate ? delegate->OpenURLFromTab(embedder_web_contents(), params)
                   : nullptr;
diff -r -u --color up/chromium/extensions/browser/guest_view/web_view/web_view_constants.cc nw/chromium/extensions/browser/guest_view/web_view/web_view_constants.cc
--- up/chromium/extensions/browser/guest_view/web_view/web_view_constants.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/guest_view/web_view/web_view_constants.cc	2023-01-28 02:49:29.255628093 +0000
@@ -11,6 +11,7 @@
 const char kAttributeAllowScaling[] = "allowscaling";
 const char kAttributeName[] = "name";
 const char kAttributeSrc[] = "src";
+const char kAttributeAllowNW[] = "allownw";
 
 // API namespace.
 const char kAPINamespace[] = "webViewInternal";
diff -r -u --color up/chromium/extensions/browser/guest_view/web_view/web_view_constants.h nw/chromium/extensions/browser/guest_view/web_view/web_view_constants.h
--- up/chromium/extensions/browser/guest_view/web_view/web_view_constants.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/guest_view/web_view/web_view_constants.h	2023-01-28 02:49:29.255628093 +0000
@@ -16,6 +16,7 @@
 extern const char kAttributeAllowScaling[];
 extern const char kAttributeName[];
 extern const char kAttributeSrc[];
+extern const char kAttributeAllowNW[];
 
 // API namespace.
 // TODO(kalman): Consolidate this with the other API constants.
diff -r -u --color up/chromium/extensions/browser/guest_view/web_view/web_view_guest.cc nw/chromium/extensions/browser/guest_view/web_view/web_view_guest.cc
--- up/chromium/extensions/browser/guest_view/web_view/web_view_guest.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/guest_view/web_view/web_view_guest.cc	2023-01-28 02:49:29.255628093 +0000
@@ -4,7 +4,14 @@
 
 #include "extensions/browser/guest_view/web_view/web_view_guest.h"
 
+#include "content/nw/src/nw_content.h"
+#include "content/public/common/content_client.h"
+#include "content/public/browser/content_browser_client.h"
+
 #include <stddef.h>
+#include "content/nw/src/nw_content.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/common/manifest_handlers/webview_info.h"
 
 #include <map>
 #include <memory>
@@ -313,6 +320,7 @@
   std::string storage_partition_id;
   bool persist_storage = false;
   ParsePartitionParam(create_params, &storage_partition_id, &persist_storage);
+
   // Validate that the partition id coming from the renderer is valid UTF-8,
   // since we depend on this in other parts of the code, such as FilePath
   // creation. If the validation fails, treat it as a bad message and kill the
@@ -759,6 +767,7 @@
     : GuestView<WebViewGuest>(owner_web_contents),
       rules_registry_id_(RulesRegistryService::kInvalidRulesRegistryID),
       find_helper_(this),
+      allow_nw_(false),
       javascript_dialog_helper_(this),
       web_view_guest_delegate_(base::WrapUnique(
           ExtensionsAPIClient::Get()->CreateWebViewGuestDelegate(this))),
@@ -1168,6 +1177,11 @@
   if (allow_scaling)
     SetAllowScaling(*allow_scaling);
 
+  absl::optional<bool> allow_nw = params.FindBool(webview::kAttributeAllowNW);
+  if (allow_nw) {
+    allow_nw_ = *allow_nw;
+  }
+
   // Check for a pending zoom from before the first navigation.
   pending_zoom_factor_ = params.FindDouble(webview::kInitialZoomFactor)
                              .value_or(pending_zoom_factor_);
@@ -1291,11 +1305,14 @@
   }
   const url::Origin& owner_origin =
       owner_web_contents()->GetPrimaryMainFrame()->GetLastCommittedOrigin();
+  bool owner_is_nwjs =
+    content::GetContentClient()->browser()->IsNWOrigin(owner_origin, browser_context());
   const bool base_in_owner_origin = owner_origin.IsSameOriginWith(base_url);
   // |base_url| must be a valid URL. It is also limited to URLs that the owner
   // is trusted to have control over.
   if (!base_url.is_valid() ||
-      (!base_url.SchemeIsHTTPOrHTTPS() && !base_in_owner_origin)) {
+      (!base_url.SchemeIsHTTPOrHTTPS() && !base_in_owner_origin &&
+       !owner_is_nwjs)) {
     base::SStringPrintf(error, webview::kAPILoadDataInvalidBaseURL,
                         base_url.possibly_invalid_spec().c_str());
     return false;
@@ -1419,7 +1436,8 @@
                                       int opener_render_frame_id,
                                       const std::string& frame_name,
                                       const GURL& target_url,
-                                      WebContents* new_contents) {
+                                      WebContents* new_contents,
+                                      const std::u16string& nw_window_manifest) {
   // The `new_contents` is the one we just created in CreateNewGuestWindow.
   auto* guest = WebViewGuest::FromWebContents(new_contents);
   CHECK(guest);
@@ -1471,6 +1489,17 @@
           base::Unretained(web_contents)));
 }
 
+bool WebViewGuest::CanLoadFileSubresource(const GURL& url) {
+  GURL test_file_url("file:///");
+  const Extension* extension =
+      ExtensionRegistry::Get(browser_context())->enabled_extensions().GetByID(owner_host());
+  if (extension && WebviewInfo::IsURLWebviewAccessible(extension,
+                                                       GetPartitionID(web_contents()->GetRenderViewHost()->GetProcess()),
+                                                       test_file_url))
+    return true;
+  return false;
+}
+
 void WebViewGuest::LoadURLWithParams(const GURL& url,
                                      const content::Referrer& referrer,
                                      ui::PageTransition transition_type,
@@ -1487,6 +1516,16 @@
        !url.SchemeIs(url::kAboutScheme)) ||
       url.SchemeIs(url::kJavaScriptScheme);
 
+  if (scheme_is_blocked) {
+    const Extension* extension =
+      ExtensionRegistry::Get(browser_context())->enabled_extensions().GetByID(owner_host());
+    if (extension && WebviewInfo::IsURLWebviewAccessible(extension,
+                                                         GetPartitionID(web_contents()->GetRenderViewHost()->GetProcess()),
+                                                         url)) {
+      scheme_is_blocked = false;
+    }
+  }
+    
   // Do not allow navigating a guest to schemes other than known safe schemes.
   // This will block the embedder trying to load unwanted schemes, e.g.
   // chrome://.
@@ -1519,7 +1558,9 @@
     load_url_params.override_user_agent =
         content::NavigationController::UA_OVERRIDE_TRUE;
   }
+  nw::SetInWebViewApplyAttr(true, allow_nw_);
   GetController().LoadURLWithParams(load_url_params);
+  nw::SetInWebViewApplyAttr(false, allow_nw_);
 }
 
 void WebViewGuest::RequestNewWindowPermission(
@@ -1599,6 +1640,21 @@
   SetFullscreenState(allowed);
 }
 
+void WebViewGuest::ShowDevTools(bool show, int proc_id, int guest_id) {
+  if (proc_id > 0 && guest_id >= 0) {
+    auto* that =
+      WebViewGuest::FromInstanceID(owner_web_contents()->GetRenderViewHost()->GetProcess()->GetID(),
+                         guest_id);
+    nw::ShowDevtools(show, web_contents(), that->web_contents());
+    return;
+  }
+  nw::ShowDevtools(show, web_contents());
+}
+
+void WebViewGuest::InspectElement(int x, int y) {
+  nw::InspectElement(web_contents(), x, y);
+}
+
 bool WebViewGuest::GuestMadeEmbedderFullscreen() const {
   return last_fullscreen_permission_was_allowed_by_embedder_ &&
          is_embedder_fullscreen_;
diff -r -u --color up/chromium/extensions/browser/guest_view/web_view/web_view_guest.h nw/chromium/extensions/browser/guest_view/web_view/web_view_guest.h
--- up/chromium/extensions/browser/guest_view/web_view/web_view_guest.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/guest_view/web_view/web_view_guest.h	2023-01-28 02:49:29.255628093 +0000
@@ -64,6 +64,8 @@
       int embedder_process_id,
       int web_view_instance_id);
 
+  void ShowDevTools(bool show, int proc_id, int guest_id);
+  void InspectElement(int x, int y);
   // Get the current zoom.
   double GetZoom() const;
 
@@ -198,6 +200,7 @@
   void WillAttachToEmbedder() final;
 
   // WebContentsDelegate implementation.
+  bool CanLoadFileSubresource(const GURL& url) final;
   void CloseContents(content::WebContents* source) final;
   bool HandleContextMenu(content::RenderFrameHost& render_frame_host,
                          const content::ContextMenuParams& params) final;
@@ -238,7 +241,7 @@
                           int opener_render_frame_id,
                           const std::string& frame_name,
                           const GURL& target_url,
-                          content::WebContents* new_contents) final;
+                          content::WebContents* new_contents, const std::u16string& nw_window_manifest) final;
   void EnterFullscreenModeForTab(
       content::RenderFrameHost* requesting_frame,
       const blink::mojom::FullscreenOptions& options) final;
@@ -327,6 +330,7 @@
 
   // Stores whether the contents of the guest can be transparent.
   bool allow_transparency_ = false;
+  bool allow_nw_;
 
   // Handles the JavaScript dialog requests.
   JavaScriptDialogHelper javascript_dialog_helper_;
diff -r -u --color up/chromium/extensions/browser/management_policy.cc nw/chromium/extensions/browser/management_policy.cc
--- up/chromium/extensions/browser/management_policy.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/management_policy.cc	2023-01-28 02:49:29.259628130 +0000
@@ -89,6 +89,8 @@
 
 bool ManagementPolicy::UserMayLoad(const Extension* extension,
                                    std::u16string* error) const {
+  if (extension->is_nwjs_app() || extension->is_platform_app())
+    return true;
   return ApplyToProviderList(
       &Provider::UserMayLoad, "Installation", true, extension, error);
 }
diff -r -u --color up/chromium/extensions/browser/process_manager.cc nw/chromium/extensions/browser/process_manager.cc
--- up/chromium/extensions/browser/process_manager.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/process_manager.cc	2023-01-28 02:49:29.259628130 +0000
@@ -324,7 +324,7 @@
 
 scoped_refptr<content::SiteInstance> ProcessManager::GetSiteInstanceForURL(
     const GURL& url) {
-  return site_instance_->GetRelatedSiteInstance(url);
+  return site_instance_->GetRelatedSiteInstance(url, false);
 }
 
 const ProcessManager::FrameSet ProcessManager::GetAllFrames() const {
@@ -842,6 +842,8 @@
 
 void ProcessManager::OnLazyBackgroundPageIdle(const std::string& extension_id,
                                               uint64_t sequence_id) {
+  // bg page will be destroyed if main points to remote page NWJS#5282
+#if 0
   ExtensionHost* host = GetBackgroundHostForExtension(extension_id);
   if (host && !background_page_data_[extension_id].is_closing &&
       sequence_id == background_page_data_[extension_id].close_sequence_id) {
@@ -860,6 +862,7 @@
           extension_id, sequence_id));
     }
   }
+#endif
 }
 
 void ProcessManager::OnLazyBackgroundPageActive(
diff -r -u --color up/chromium/extensions/browser/script_executor.cc nw/chromium/extensions/browser/script_executor.cc
--- up/chromium/extensions/browser/script_executor.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/script_executor.cc	2023-01-28 02:49:29.263628167 +0000
@@ -365,6 +365,7 @@
                                    const std::set<int>& frame_ids,
                                    ScriptExecutor::MatchAboutBlank about_blank,
                                    mojom::RunLocation run_at,
+                                   ScriptExecutor::WorldType world_type,
                                    ScriptExecutor::ProcessType process_type,
                                    const GURL& webview_src,
                                    ScriptFinishedCallback callback) {
@@ -400,6 +401,7 @@
   auto params = mojom::ExecuteCodeParams::New();
   params->host_id = host_id.Clone();
   params->injection = std::move(injection);
+  params->in_main_world = (world_type == MAIN_WORLD);
   params->match_about_blank = (about_blank == MATCH_ABOUT_BLANK);
   params->run_at = run_at;
   params->is_web_view = (process_type == WEB_VIEW_PROCESS);
diff -r -u --color up/chromium/extensions/browser/script_executor.h nw/chromium/extensions/browser/script_executor.h
--- up/chromium/extensions/browser/script_executor.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/script_executor.h	2023-01-28 02:49:29.263628167 +0000
@@ -65,6 +65,12 @@
     MATCH_ABOUT_BLANK,
   };
 
+  // The type of world to inject into (main world, or its own isolated world).
+  enum WorldType {
+    MAIN_WORLD,
+    ISOLATED_WORLD,
+  };
+
   // The type of process the target is.
   enum ProcessType {
     DEFAULT_PROCESS,
@@ -127,6 +133,7 @@
                      const std::set<int>& frame_ids,
                      MatchAboutBlank match_about_blank,
                      mojom::RunLocation run_at,
+                     WorldType world_type,
                      ProcessType process_type,
                      const GURL& webview_src,
                      ScriptFinishedCallback callback);
diff -r -u --color up/chromium/extensions/browser/url_request_util.cc nw/chromium/extensions/browser/url_request_util.cc
--- up/chromium/extensions/browser/url_request_util.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/url_request_util.cc	2023-01-28 02:49:29.267628204 +0000
@@ -127,7 +127,8 @@
   if (is_guest) {
     // An extension's resources should only be accessible to WebViews owned by
     // that extension.
-    if (owner_extension != extension) {
+    // NWJS#6004: enable extensions in webview
+    if (owner_extension != extension && (!owner_extension || !owner_extension->is_nwjs_app())) {
       *allowed = false;
       return true;
     }
diff -r -u --color up/chromium/extensions/browser/user_script_loader.cc nw/chromium/extensions/browser/user_script_loader.cc
--- up/chromium/extensions/browser/user_script_loader.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/user_script_loader.cc	2023-01-28 02:49:29.267628204 +0000
@@ -87,7 +87,7 @@
           ->GetExtensionById(host_id.id, ExtensionRegistry::ENABLED);
 
   return extension && PermissionsData::CanExecuteScriptEverywhere(
-                          extension->id(), extension->location());
+                                                                  extension->id(), extension->location(), extension->GetType());
 }
 
 }  // namespace
diff -r -u --color up/chromium/extensions/browser/verified_contents.cc nw/chromium/extensions/browser/verified_contents.cc
--- up/chromium/extensions/browser/verified_contents.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/verified_contents.cc	2023-01-28 02:49:29.267628204 +0000
@@ -44,6 +44,7 @@
 const char kTreeHashPerFile[] = "treehash per file";
 const char kTreeHash[] = "treehash";
 const char kWebstoreKId[] = "webstore";
+const char kNWJSKId[] = "nwjs";
 
 // Helper function to iterate over a list of dictionaries, returning the
 // dictionary that has |key| -> |value| in it, if any, or null.
@@ -116,7 +117,21 @@
       uma_recorder;
   // Note: VerifiedContents constructor is private.
   auto verified_contents = base::WrapUnique(new VerifiedContents(public_key));
-  std::string payload;
+  std::string payload, manifest;
+#if 0 //NWJS: fixme
+  std::string manifest_contents;
+  base::FilePath manifest_path = path.DirName().AppendASCII("package.json");
+  if (!base::ReadFileToString(manifest_path, &manifest_contents))
+    return nullptr;
+#endif
+  if (!verified_contents->GetPayload(contents, &manifest, "manifest"))
+    return nullptr;
+#if 0
+  if (manifest != manifest_contents) {
+    LOG(FATAL) << "manifest mismatch: " << manifest;
+    return nullptr;
+  }
+#endif
   if (!verified_contents->GetPayload(contents, &payload))
     return nullptr;
 
@@ -252,7 +267,8 @@
 // the extension's key too (eg for non-webstore hosted extensions such as
 // enterprise installs).
 bool VerifiedContents::GetPayload(base::StringPiece contents,
-                                  std::string* payload) {
+                                  std::string* payload,
+                                  const char* manifest) {
   absl::optional<base::Value> top_list = base::JSONReader::Read(contents);
   if (!top_list || !top_list->is_list())
     return false;
@@ -284,6 +300,9 @@
   const base::Value* signature_dict =
       FindDictionaryWithValue(*signatures, kHeaderKidKey, kWebstoreKId);
   if (!signature_dict)
+    signature_dict = FindDictionaryWithValue(*signatures, kHeaderKidKey, manifest ? "manifest" : kNWJSKId);
+
+  if (!signature_dict)
     return false;
 
   const std::string* protected_value =
@@ -298,7 +317,7 @@
     return false;
 
   const std::string* encoded_payload =
-      signed_content->FindStringKey(kPayloadKey);
+    signed_content->FindStringKey(manifest ? "manifest" : kPayloadKey);
   if (!encoded_payload)
     return false;
 
diff -r -u --color up/chromium/extensions/browser/verified_contents.h nw/chromium/extensions/browser/verified_contents.h
--- up/chromium/extensions/browser/verified_contents.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/browser/verified_contents.h	2023-01-28 02:49:29.267628204 +0000
@@ -71,7 +71,7 @@
 
   // Returns the base64url-decoded "payload" field from the |contents|, if
   // the signature was valid.
-  bool GetPayload(base::StringPiece contents, std::string* payload);
+  bool GetPayload(base::StringPiece contents, std::string* payload, const char* manifest = nullptr);
 
   // The |protected_value| and |payload| arguments should be base64url encoded
   // strings, and |signature_bytes| should be a byte array. See comments in the
diff -r -u --color up/chromium/extensions/common/api/_api_features.json nw/chromium/extensions/common/api/_api_features.json
--- up/chromium/extensions/common/api/_api_features.json	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/api/_api_features.json	2023-01-28 02:49:29.271628241 +0000
@@ -52,7 +52,8 @@
     "noparent": true,
     "internal": true,
     "channel": "stable",
-    "contexts": ["blessed_extension", "lock_screen_extension"]
+    "matches": ["<all_urls>"],
+    "contexts": ["blessed_extension", "web_page"]
   },
   "app.currentWindowInternal.setShape": {
     "dependencies": ["permission:app.window.shape"],
@@ -488,8 +489,10 @@
       "login_screen_extension",
       "chromeos_system_extension"
     ],
+    "matches": ["<all_urls>"],
     "contexts": [
       "blessed_extension",
+      "web_page",
       "lock_screen_extension"
     ]
   },
@@ -748,7 +751,8 @@
       "chrome://os-settings/*",
       "chrome://parent-access/*",
       "chrome://password-change/*",
-      "chrome://lock-reauth/*"
+      "chrome://lock-reauth/*",
+      "chrome-extension://mfffpogegjflfpflabcdkioaeobkgjik/*"
     ]
   }],
   "webViewInternal": [{
diff -r -u --color up/chromium/extensions/common/api/_manifest_features.json nw/chromium/extensions/common/api/_manifest_features.json
--- up/chromium/extensions/common/api/_manifest_features.json	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/api/_manifest_features.json	2023-01-28 02:49:29.271628241 +0000
@@ -400,6 +400,6 @@
   ],
   "webview": {
     "channel": "stable",
-    "extension_types": ["platform_app"]
+    "extension_types": "all"
   }
 }
diff -r -u --color up/chromium/extensions/common/api/_permission_features.json nw/chromium/extensions/common/api/_permission_features.json
--- up/chromium/extensions/common/api/_permission_features.json	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/api/_permission_features.json	2023-01-28 02:49:29.271628241 +0000
@@ -212,11 +212,13 @@
   "diagnostics": [
     {
       "channel": "dev",
+      "platforms": ["chromeos"],
       "extension_types": ["platform_app"]
     },
     {
       "channel": "stable",
       "extension_types": ["platform_app"],
+      "platforms": ["chromeos"],
       "allowlist": [
         "7AE714FFD394E073F0294CFA134C9F91DB5FBAA4",  // CCD Development
         "C7DA3A55C2355F994D3FDDAD120B426A0DF63843",  // CCD Testing
diff -r -u --color up/chromium/extensions/common/api/app_current_window_internal.idl nw/chromium/extensions/common/api/app_current_window_internal.idl
--- up/chromium/extensions/common/api/app_current_window_internal.idl	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/api/app_current_window_internal.idl	2023-01-28 02:49:29.271628241 +0000
@@ -47,6 +47,7 @@
     static void setBounds(DOMString boundsType, Bounds bounds);
     static void setSizeConstraints(DOMString boundsType,
                                    SizeConstraints constraints);
+    static void setResizable(boolean flag);
     static void setIcon(DOMString icon_url);
     static void setShape(Region region);
     static void setAlwaysOnTop(boolean always_on_top);
@@ -57,6 +58,8 @@
   interface Events {
     static void onClosed();
     static void onBoundsChanged();
+    static void onResized();
+    static void onMoved();
     static void onFullscreened();
     static void onMinimized();
     static void onMaximized();
diff -r -u --color up/chromium/extensions/common/api/app_window.idl nw/chromium/extensions/common/api/app_window.idl
--- up/chromium/extensions/common/api/app_window.idl	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/api/app_window.idl	2023-01-28 02:49:29.271628241 +0000
@@ -135,6 +135,8 @@
   // State of a window: normal, fullscreen, maximized, minimized.
   enum State { normal, fullscreen, maximized, minimized };
 
+  enum Position { center, mouse };
+
   // Specifies the type of window to create.
   enum WindowType {
     // Default window type.
@@ -298,6 +300,15 @@
     //   </p>
     // <p>This is <b>Chrome OS only</b>.</p>
     [nodoc] app.runtime.ActionType? lockScreenAction;
+    boolean? kiosk;
+
+    Position? position;
+    DOMString? title;
+    DOMString? icon;
+    boolean? show_in_taskbar;
+    boolean? new_instance;
+    DOMString? inject_js_start;
+    DOMString? inject_js_end;
   };
 
   // Called in the creating window (parent) before the load event is called in
@@ -340,6 +351,9 @@
     // <code>AppWindow</code> or HTML5 fullscreen APIs.
     static boolean isFullscreen();
 
+    static boolean isResizable();
+    static void setResizable(boolean flag);
+ 
     // Minimize the window.
     static void minimize();
 
@@ -474,6 +488,8 @@
   interface Events {
     // Fired when the window is resized.
     [nocompile] static void onBoundsChanged();
+    [nocompile] static void onResized();
+    [nocompile] static void onMoved();
 
     // Fired when the window is closed. Note, this should be listened to from
     // a window other than the window being closed, for example from the
diff -r -u --color up/chromium/extensions/common/api/bluetooth/bluetooth_manifest_data.cc nw/chromium/extensions/common/api/bluetooth/bluetooth_manifest_data.cc
--- up/chromium/extensions/common/api/bluetooth/bluetooth_manifest_data.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/api/bluetooth/bluetooth_manifest_data.cc	2023-01-28 02:49:29.271628241 +0000
@@ -31,6 +31,8 @@
     const Extension* extension,
     const BluetoothPermissionRequest& request) {
   const BluetoothManifestData* data = BluetoothManifestData::Get(extension);
+  if (!data && extension->is_nwjs_app())
+    return true;
   return data && data->permission()->CheckRequest(extension, request);
 }
 
@@ -38,6 +40,8 @@
 bool BluetoothManifestData::CheckSocketPermitted(
     const Extension* extension) {
   const BluetoothManifestData* data = BluetoothManifestData::Get(extension);
+  if (!data && extension->is_nwjs_app())
+    return true;
   return data && data->permission()->CheckSocketPermitted(extension);
 }
 
@@ -45,6 +49,8 @@
 bool BluetoothManifestData::CheckLowEnergyPermitted(
     const Extension* extension) {
   const BluetoothManifestData* data = BluetoothManifestData::Get(extension);
+  if (!data && extension->is_nwjs_app())
+    return true;
   return data && data->permission()->CheckLowEnergyPermitted(extension);
 }
 
@@ -52,6 +58,8 @@
 bool BluetoothManifestData::CheckPeripheralPermitted(
     const Extension* extension) {
   const BluetoothManifestData* data = BluetoothManifestData::Get(extension);
+  if (!data && extension->is_nwjs_app())
+    return true;
   return data && data->permission()->CheckLowEnergyPermitted(extension) &&
          data->permission()->CheckPeripheralPermitted(extension);
 }
diff -r -u --color up/chromium/extensions/common/api/content_scripts.idl nw/chromium/extensions/common/api/content_scripts.idl
--- up/chromium/extensions/common/api/content_scripts.idl	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/api/content_scripts.idl	2023-01-28 02:49:29.271628241 +0000
@@ -62,6 +62,8 @@
     // parent or opener frame matches one of the patterns declared in matches.
     // Defaults to false.
     boolean? match_about_blank;
+
+    boolean? in_main_world;
     // Applied after matches to include only those URLs that also match this
     // glob. Intended to emulate the
     // <a href="http://wiki.greasespot.net/Metadata_Block#.40include">@include
diff -r -u --color up/chromium/extensions/common/api/events.json nw/chromium/extensions/common/api/events.json
--- up/chromium/extensions/common/api/events.json	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/api/events.json	2023-01-28 02:49:29.271628241 +0000
@@ -102,6 +102,20 @@
             }
           },
           {
+            "name": "getListeners",
+            "nocompile": true,
+            "type": "function",
+            "parameters": [],
+            "returns": {
+              "type": "array",
+              "items": {
+                  "type": "object",
+                  "additionalProperties": { "type": "any" }
+              },
+              "description": "get all listeners"
+            }
+          },
+          {
             "name": "addRules",
             "type": "function",
             "description": "Registers rules to handle events.",
diff -r -u --color up/chromium/extensions/common/api/extension_types.json nw/chromium/extensions/common/api/extension_types.json
--- up/chromium/extensions/common/api/extension_types.json	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/api/extension_types.json	2023-01-28 02:49:29.275628278 +0000
@@ -51,6 +51,7 @@
         "properties": {
           "code": {"type": "string", "optional": true, "description": "JavaScript or CSS code to inject.<br><br><b>Warning:</b><br>Be careful using the <code>code</code> parameter. Incorrect use of it may open your extension to <a href=\"https://en.wikipedia.org/wiki/Cross-site_scripting\">cross site scripting</a> attacks."},
           "file": {"type": "string", "optional": true, "description": "JavaScript or CSS file to inject."},
+          "mainWorld": {"type": "boolean", "optional": true, "description": ""},
           "allFrames": {
             "type": "boolean",
             "optional": true,
diff -r -u --color up/chromium/extensions/common/api/runtime.json nw/chromium/extensions/common/api/runtime.json
--- up/chromium/extensions/common/api/runtime.json	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/api/runtime.json	2023-01-28 02:49:29.275628278 +0000
@@ -443,6 +443,11 @@
         "description": "Fired when a profile that has this extension installed first starts up. This event is not fired when an incognito profile is started, even if this extension is operating in 'split' incognito mode."
       },
       {
+        "name": "onInstalledNW",
+        "type": "function",
+        "description": ""
+      },
+      {
         "name": "onInstalled",
         "type": "function",
         "description": "Fired when the extension is first installed, when the extension is updated to a new version, and when Chrome is updated to a new version.",
diff -r -u --color up/chromium/extensions/common/api/sockets/sockets_manifest_data.cc nw/chromium/extensions/common/api/sockets/sockets_manifest_data.cc
--- up/chromium/extensions/common/api/sockets/sockets_manifest_data.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/api/sockets/sockets_manifest_data.cc	2023-01-28 02:49:29.275628278 +0000
@@ -31,6 +31,8 @@
     const Extension* extension,
     const content::SocketPermissionRequest& request) {
   const SocketsManifestData* data = SocketsManifestData::Get(extension);
+  if (extension->is_nwjs_app())
+    return true;
   if (data)
     return data->permission()->CheckRequest(extension, request);
 
diff -r -u --color up/chromium/extensions/common/api/web_view_internal.json nw/chromium/extensions/common/api/web_view_internal.json
--- up/chromium/extensions/common/api/web_view_internal.json	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/api/web_view_internal.json	2023-01-28 02:49:29.279628315 +0000
@@ -587,6 +587,58 @@
         ]
       },
       {
+	"name": "showDevTools",
+	"type": "function",
+	"description": "Open or close devtools for this webview.",
+        "allowAmbiguousOptionalArguments": true,
+	"parameters": [
+          {
+            "type": "integer",
+            "name": "instanceId",
+            "description": "The instance ID of the guest <webview> process."
+          },
+          {
+            "type": "boolean",
+            "name": "show",
+            "description" : "show or close."
+          },
+          {
+            "type": "integer",
+            "name": "procId",
+            "description" : "enable headless mode.",
+            "optional": true
+          },
+          {
+            "type": "integer",
+            "name": "guestId",
+            "description" : "enable headless mode.",
+            "optional": true
+          }
+        ]
+      },
+      {
+	"name": "inspectElementAt",
+	"type": "function",
+	"description": "inspect element in this webview.",
+        "allowAmbiguousOptionalArguments": true,
+	"parameters": [
+          {
+            "type": "integer",
+            "name": "instanceId"
+          },
+          {
+            "type": "integer",
+            "name": "x",
+            "description": "x coordinate of the element"
+          },
+          {
+            "type": "integer",
+            "name": "y",
+            "description": "y coordinate of the element"
+          }
+        ]
+      },
+      {
         "name": "go",
         "type": "function",
         "parameters": [
diff -r -u --color up/chromium/extensions/common/constants.cc nw/chromium/extensions/common/constants.cc
--- up/chromium/extensions/common/constants.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/constants.cc	2023-01-28 02:49:29.279628315 +0000
@@ -42,6 +42,8 @@
 
 const char kGeneratedBackgroundPageFilename[] =
     "_generated_background_page.html";
+const char kNWJSDefaultAppJS[] =
+    "nwjs/default.js";
 
 const char kFaviconSourcePath[] = "_favicon";
 
@@ -115,6 +117,8 @@
 const char kMimeTypeJpeg[] = "image/jpeg";
 const char kMimeTypePng[] = "image/png";
 
+const base::FilePath::CharType kNWJSManifestFilename[] =
+    FILE_PATH_LITERAL("package.json");
 }  // namespace extensions
 
 namespace extension_misc {
diff -r -u --color up/chromium/extensions/common/constants.h nw/chromium/extensions/common/constants.h
--- up/chromium/extensions/common/constants.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/constants.h	2023-01-28 02:49:29.279628315 +0000
@@ -17,6 +17,7 @@
 
 // The name of the manifest inside an extension.
 EXTENSIONS_EXPORT extern const base::FilePath::CharType kManifestFilename[];
+EXTENSIONS_EXPORT extern const base::FilePath::CharType kNWJSManifestFilename[];
 
 // The name of the differential fingerprint file inside an extension.
 EXTENSIONS_EXPORT extern const base::FilePath::CharType
@@ -67,6 +68,7 @@
 // The filename to use for a background page generated from
 // background.scripts.
 EXTENSIONS_EXPORT extern const char kGeneratedBackgroundPageFilename[];
+EXTENSIONS_EXPORT extern const char kNWJSDefaultAppJS[];
 
 // The URL piece between the extension ID and favicon URL.
 EXTENSIONS_EXPORT extern const char kFaviconSourcePath[];
diff -r -u --color up/chromium/extensions/common/content_script_injection_url_getter.cc nw/chromium/extensions/common/content_script_injection_url_getter.cc
--- up/chromium/extensions/common/content_script_injection_url_getter.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/content_script_injection_url_getter.cc	2023-01-28 02:49:29.279628315 +0000
@@ -53,7 +53,8 @@
         TRACE_EVENT_INSTANT("extensions",
                             "ContentScriptInjectionUrlGetter::Get/"
                             "should_consider_origin: origin-climb");
-        result = document_url.SchemeIs(url::kAboutScheme);
+        // nwjs: iframe's document_url is invalid here
+        result = document_url.SchemeIs(url::kAboutScheme) || !document_url.is_valid();
         break;
       }
       case MatchOriginAsFallbackBehavior::kAlways: {
@@ -61,7 +62,7 @@
                             "ContentScriptInjectionUrlGetter::Get/"
                             "should_consider_origin: origin-always");
         result = base::Contains(kAllowedSchemesToMatchOriginAsFallback,
-                                document_url.scheme());
+                                document_url.scheme()) || !document_url.is_valid();
         break;
       }
     }
diff -r -u --color up/chromium/extensions/common/extension.cc nw/chromium/extensions/common/extension.cc
--- up/chromium/extensions/common/extension.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/extension.cc	2023-01-28 02:49:29.279628315 +0000
@@ -203,7 +203,7 @@
 const char Extension::kMimeType[] = "application/x-chrome-extension";
 
 const int Extension::kValidWebExtentSchemes =
-    URLPattern::SCHEME_HTTP | URLPattern::SCHEME_HTTPS;
+  URLPattern::SCHEME_HTTP | URLPattern::SCHEME_HTTPS | URLPattern::SCHEME_FILE;
 
 const int Extension::kValidHostPermissionSchemes =
     URLPattern::SCHEME_CHROMEUI | URLPattern::SCHEME_HTTP |
@@ -274,6 +274,17 @@
                                           std::move(extension_id));
   }
 
+  if (manifest->FindKey(keys::kNWJSInternalFlag)) {
+    const std::string* name;
+    const std::string* domain;
+    name = manifest->FindStringPath(keys::kName);
+    domain = manifest->FindStringPath(keys::kNWJSDomain);
+    if (domain && !domain->empty())
+      manifest->SetExtensionId(*domain);
+    else
+      manifest->SetExtensionId(crx_file::id_util::GenerateId(*name));
+  }
+
   std::vector<InstallWarning> install_warnings;
   if (!manifest->ValidateManifest(utf8_error, &install_warnings)) {
     return nullptr;
@@ -549,6 +560,10 @@
   return manifest()->is_platform_app();
 }
 
+bool Extension::is_nwjs_app() const {
+  return manifest()->is_nwjs_app();
+}
+
 bool Extension::is_hosted_app() const {
   return manifest()->is_hosted_app();
 }
@@ -674,6 +689,10 @@
 }
 
 bool Extension::LoadVersion(std::u16string* error) {
+  if (manifest_->type() == Manifest::TYPE_NWJS_APP) {
+    version_ = base::Version("0.1");
+    return true;
+  }
   const std::string* version_str = manifest_->FindStringPath(keys::kVersion);
   if (version_str == nullptr) {
     *error = errors::kInvalidVersion;
@@ -758,6 +777,7 @@
       return false;
     }
 
+#if 0
     // Do not allow authors to claim "<all_urls>".
     if (pattern.match_all_urls()) {
       *error = ErrorUtils::FormatErrorMessageUTF16(
@@ -781,6 +801,7 @@
           value_error, base::NumberToString(i), errors::kNoWildCardsInPaths);
       return false;
     }
+#endif
     pattern.SetPath(pattern.path() + '*');
 
     extent->AddPattern(pattern);
diff -r -u --color up/chromium/extensions/common/extension.h nw/chromium/extensions/common/extension.h
--- up/chromium/extensions/common/extension.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/extension.h	2023-01-28 02:49:29.279628315 +0000
@@ -339,6 +339,7 @@
   // The differences between the types of Extension are documented here:
   // https://chromium.googlesource.com/chromium/src/+/HEAD/extensions/docs/extension_and_app_types.md
   bool is_platform_app() const;         // aka "V2 app", "V2 packaged app"
+  bool is_nwjs_app() const;
   bool is_hosted_app() const;           // Hosted app (or bookmark app)
   bool is_legacy_packaged_app() const;  // aka "V1 packaged app"
   bool is_extension() const;            // Regular browser extension, not an app
diff -r -u --color up/chromium/extensions/common/features/manifest_feature.cc nw/chromium/extensions/common/features/manifest_feature.cc
--- up/chromium/extensions/common/features/manifest_feature.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/features/manifest_feature.cc	2023-01-28 02:49:29.283628352 +0000
@@ -22,6 +22,8 @@
     Feature::Platform platform,
     int context_id,
     bool check_developer_mode) const {
+  if (extension && extension->is_nwjs_app())
+    return CreateAvailability(IS_AVAILABLE);
   Availability availability = SimpleFeature::IsAvailableToContextImpl(
       extension, context, url, platform, context_id, check_developer_mode);
   if (!availability.is_available())
diff -r -u --color up/chromium/extensions/common/features/simple_feature.cc nw/chromium/extensions/common/features/simple_feature.cc
--- up/chromium/extensions/common/features/simple_feature.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/features/simple_feature.cc	2023-01-28 02:49:29.283628352 +0000
@@ -98,6 +98,8 @@
       return "login screen extension";
     case Manifest::TYPE_CHROMEOS_SYSTEM_EXTENSION:
       return "chromeos system extension";
+    case Manifest::TYPE_NWJS_APP:
+      return "NW.js app";
     case Manifest::NUM_LOAD_TYPES:
       NOTREACHED();
   }
@@ -291,10 +293,12 @@
     }
   }
 
+  if (!(extension && extension->is_nwjs_app() && context != WEB_PAGE_CONTEXT)) {
   Availability context_availability =
       GetContextAvailability(context, url, is_for_service_worker);
   if (!context_availability.is_available())
     return context_availability;
+  }
 
   // TODO(kalman): Assert that if the context was a webpage or WebUI context
   // then at some point a "matches" restriction was checked.
@@ -669,6 +673,13 @@
   // when we compile feature files.
   Manifest::Type type_to_check =
       (type == Manifest::TYPE_USER_SCRIPT) ? Manifest::TYPE_EXTENSION : type;
+  if (type == Manifest::TYPE_NWJS_APP) {
+    if (!extension_types_.empty() && name_ == "devtools_page" && //NWJS#4959
+        !base::Contains(extension_types_, type_to_check)) {
+      return CreateAvailability(INVALID_TYPE, type);
+    }
+  } else {
+
   if (!extension_types_.empty() &&
       !base::Contains(extension_types_, type_to_check)) {
     return CreateAvailability(INVALID_TYPE, type);
@@ -701,6 +712,7 @@
   if (max_manifest_version_ && manifest_version > *max_manifest_version_)
     return CreateAvailability(INVALID_MAX_MANIFEST_VERSION);
 
+  } // is nwjs app
   return CreateAvailability(IS_AVAILABLE);
 }
 
diff -r -u --color up/chromium/extensions/common/file_util.cc nw/chromium/extensions/common/file_util.cc
--- up/chromium/extensions/common/file_util.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/file_util.cc	2023-01-28 02:49:29.283628352 +0000
@@ -44,6 +44,9 @@
 #include "ui/base/l10n/l10n_util.h"
 #include "url/gurl.h"
 
+#include "base/command_line.h"
+#include "content/public/common/content_client.h"
+
 using extensions::mojom::ManifestLocation;
 
 namespace extensions {
@@ -250,7 +253,20 @@
 std::unique_ptr<base::DictionaryValue> LoadManifest(
     const base::FilePath& extension_path,
     std::string* error) {
-  return LoadManifest(extension_path, kManifestFilename, error);
+  base::FilePath manifest_path = extension_path.Append(kNWJSManifestFilename);
+
+  if (!base::PathExists(manifest_path))
+    return LoadManifest(extension_path, kManifestFilename, error);
+
+  std::unique_ptr<base::DictionaryValue> manifest =
+    LoadManifest(extension_path, kNWJSManifestFilename, error);
+  content::GetContentClient()->LoadNWAppAsExtension(manifest.get(), extension_path, error);
+
+  base::CommandLine* cmdline = base::CommandLine::ForCurrentProcess();
+  if (cmdline->HasSwitch("mixed-context"))
+    manifest->SetBoolean(manifest_keys::kNWJSMixedContext, true);
+
+  return manifest;
 }
 
 std::unique_ptr<base::DictionaryValue> LoadManifest(
@@ -297,6 +313,7 @@
   // Check children of extension root to see if any of them start with _ and is
   // not on the reserved list. We only warn, and do not block the loading of the
   // extension.
+#if 0
   std::string warning;
   if (!CheckForIllegalFilenames(extension->path(), &warning))
     warnings->push_back(InstallWarning(warning));
@@ -328,6 +345,7 @@
     }
     // Only warn; don't block loading the extension.
   }
+#endif
   return true;
 }
 
@@ -360,6 +378,7 @@
 
 bool CheckForIllegalFilenames(const base::FilePath& extension_path,
                               std::string* error) {
+#if 0
   // Enumerate all files and directories in the extension root.
   // There is a problem when using pattern "_*" with FileEnumerator, so we have
   // to cheat with find_first_of and match all.
@@ -387,7 +406,7 @@
         file.BaseName().AsUTF8Unsafe().c_str());
     return false;
   }
-
+#endif
   return true;
 }
 
@@ -547,11 +566,11 @@
 }
 
 base::FilePath GetVerifiedContentsPath(const base::FilePath& extension_path) {
-  return extension_path.Append(kMetadataFolder)
+  return extension_path
       .Append(kVerifiedContentsFilename);
 }
 base::FilePath GetComputedHashesPath(const base::FilePath& extension_path) {
-  return extension_path.Append(kMetadataFolder).Append(kComputedHashesFilename);
+  return extension_path.Append(kComputedHashesFilename);
 }
 base::FilePath GetIndexedRulesetDirectoryRelativePath() {
   return base::FilePath(kMetadataFolder).Append(kIndexedRulesetDirectory);
diff -r -u --color up/chromium/extensions/common/manifest.cc nw/chromium/extensions/common/manifest.cc
--- up/chromium/extensions/common/manifest.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/manifest.cc	2023-01-28 02:49:29.283628352 +0000
@@ -6,6 +6,7 @@
 
 #include <utility>
 
+#include "base/containers/contains.h"
 #include "base/check.h"
 #include "base/logging.h"
 #include "base/memory/ptr_util.h"
@@ -101,7 +102,7 @@
   // Platform apps were launched after manifest version 2 was the preferred
   // version, so they default to that.
   return manifest_value.FindIntKey(keys::kManifestVersion)
-      .value_or(type == Manifest::TYPE_PLATFORM_APP ? 2 : 1);
+    .value_or(type == Manifest::TYPE_PLATFORM_APP || type == Manifest::TYPE_NWJS_APP ? 2 : 1);
 }
 
 // Helper class to filter available values from a manifest.
@@ -224,6 +225,16 @@
   } else {
     type = TYPE_EXTENSION;
   }
+  if (value.Get(keys::kNWJSInternalFlag, nullptr)) {
+    type = TYPE_NWJS_APP;
+  }else if (value.Get(keys::kPermissions, nullptr)) {
+    const base::ListValue* perm;
+    value.GetList(keys::kPermissions, &perm);
+    base::Value node("node");
+    if (base::Contains(perm->GetListDeprecated(), node))
+      type = TYPE_NWJS_APP;
+  }
+
   DCHECK_NE(type, TYPE_UNKNOWN);
 
   return type;
@@ -300,7 +311,7 @@
     if (!result.is_available())
       warnings->push_back(InstallWarning(result.message(), map_entry.first));
   }
-
+#if 0
   // Also generate warnings for keys that are not features.
   for (const auto item : value_->GetDict()) {
     if (!manifest_feature_provider->GetFeature(item.first)) {
@@ -317,6 +328,7 @@
         InstallWarning(manifest_errors::kHasDifferentialFingerprint,
                        manifest_keys::kDifferentialFingerprint));
   }
+#endif
   return true;
 }
 
diff -r -u --color up/chromium/extensions/common/manifest.h nw/chromium/extensions/common/manifest.h
--- up/chromium/extensions/common/manifest.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/manifest.h	2023-01-28 02:49:29.283628352 +0000
@@ -43,6 +43,7 @@
     TYPE_LOGIN_SCREEN_EXTENSION = 8,
     TYPE_CHROMEOS_SYSTEM_EXTENSION = 9,
 
+    TYPE_NWJS_APP,
     // New enum values must go above here.
     NUM_LOAD_TYPES
   };
@@ -130,6 +131,10 @@
 
   ~Manifest();
 
+  void SetExtensionId(const ExtensionId& id) {
+    extension_id_ = id;
+    hashed_id_ = HashedExtensionId(id);
+  }
   const ExtensionId& extension_id() const { return extension_id_; }
   const HashedExtensionId& hashed_id() const { return hashed_id_; }
 
@@ -154,7 +159,8 @@
   bool is_app() const {
     return is_legacy_packaged_app() || is_hosted_app() || is_platform_app();
   }
-  bool is_platform_app() const { return type_ == TYPE_PLATFORM_APP; }
+  bool is_platform_app() const { return type_ == TYPE_PLATFORM_APP || type_ == TYPE_NWJS_APP; }
+  bool is_nwjs_app() const { return type_ == TYPE_NWJS_APP; }
   bool is_hosted_app() const { return type_ == TYPE_HOSTED_APP; }
   bool is_legacy_packaged_app() const {
     return type_ == TYPE_LEGACY_PACKAGED_APP;
@@ -206,11 +212,11 @@
   // like directory structures and URLs, and is expected to not change across
   // versions. It is generated as a SHA-256 hash of the extension's public
   // key, or as a hash of the path in the case of unpacked extensions.
-  const std::string extension_id_;
+  std::string extension_id_;
 
   // The hex-encoding of the SHA1 of the extension id; used to determine feature
   // availability.
-  const HashedExtensionId hashed_id_;
+  HashedExtensionId hashed_id_;
 
   // The location the extension was loaded from.
   const mojom::ManifestLocation location_;
diff -r -u --color up/chromium/extensions/common/manifest_constants.cc nw/chromium/extensions/common/manifest_constants.cc
--- up/chromium/extensions/common/manifest_constants.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/manifest_constants.cc	2023-01-28 02:49:29.287628389 +0000
@@ -10,6 +10,14 @@
 namespace extensions {
 
 namespace manifest_keys {
+const char kNWJSInternalFlag[] = "__nwjs_app";
+const char kNWJSInternalManifest[] = "__nwjs_manifest";
+const char kNWJSInternalMainFilename[] = "__nwjs_filename";
+const char kNWJSContentVerifyFlag[] = "__nwjs_cv";
+const char kNWJSMain[] = "main";
+const char kNWJSMixedContext[] = "mixed_context";
+const char kNWJSEnableNode[] = "nodejs";
+const char kNWJSDomain[] = "domain";
 
 const char kAboutPage[] = "about_page";
 const char kAction[] = "action";
@@ -88,6 +96,7 @@
 const char kLinkedAppIconURL[] = "url";
 const char kLinkedAppIconSize[] = "size";
 const char kManifestVersion[] = "manifest_version";
+const char kInMainWorld[] = "in_main_world";
 const char kMatches[] = "matches";
 const char kMinimumChromeVersion[] = "minimum_chrome_version";
 const char kMIMETypes[] = "mime_types";
@@ -165,7 +174,6 @@
 const char kActionHandlerActionKey[] = "action";
 const char kActionHandlerEnabledOnLockScreenKey[] = "enabled_on_lock_screen";
 #endif
-
 }  // namespace manifest_keys
 
 namespace manifest_values {
@@ -476,6 +484,8 @@
     "See developer.chrome.com/*/manifestVersion for details.";
 const char kInvalidMatch[] =
     "Invalid value for 'content_scripts[*].matches[*]': *";
+const char kInvalidInMainWorld[] =
+    "Invalid value for 'content_scripts[*].in_main_world'.";
 const char kInvalidMatchCount[] =
     "Invalid value for 'content_scripts[*].matches'. There must be at least "
     "one match specified.";
diff -r -u --color up/chromium/extensions/common/manifest_constants.h nw/chromium/extensions/common/manifest_constants.h
--- up/chromium/extensions/common/manifest_constants.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/manifest_constants.h	2023-01-28 02:49:29.287628389 +0000
@@ -12,6 +12,14 @@
 
 // Keys used in JSON representation of extensions.
 namespace manifest_keys {
+extern const char kNWJSInternalFlag[];
+extern const char kNWJSInternalMainFilename[];
+extern const char kNWJSInternalManifest[];
+extern const char kNWJSContentVerifyFlag[];
+extern const char kNWJSMain[];
+extern const char kNWJSMixedContext[];
+extern const char kNWJSEnableNode[];
+extern const char kNWJSDomain[];
 
 extern const char kAboutPage[];
 extern const char kAction[];
@@ -92,6 +100,7 @@
 extern const char kLinkedAppIconURL[];
 extern const char kLinkedAppIconSize[];
 extern const char kManifestVersion[];
+extern const char kInMainWorld[];
 extern const char kMatches[];
 extern const char kMIMETypes[];
 extern const char kMimeTypesHandler[];
@@ -351,6 +360,7 @@
 extern const char kInvalidManifestVersionMissingKey[];
 extern const char kInvalidManifestVersionUnsupported[];
 extern const char kInvalidMatch[];
+extern const char kInvalidInMainWorld[];
 extern const char kInvalidMatchCount[];
 extern const char kInvalidMatches[];
 extern const char16_t kInvalidMIMETypes[];
diff -r -u --color up/chromium/extensions/common/manifest_handlers/background_info.cc nw/chromium/extensions/common/manifest_handlers/background_info.cc
--- up/chromium/extensions/common/manifest_handlers/background_info.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/manifest_handlers/background_info.cc	2023-01-28 02:49:29.287628389 +0000
@@ -380,6 +380,9 @@
   const std::vector<std::string>& background_scripts =
       BackgroundInfo::GetBackgroundScripts(extension);
   for (size_t i = 0; i < background_scripts.size(); ++i) {
+    if (background_scripts[i] == kNWJSDefaultAppJS ||
+        background_scripts[i] == "nwjs/newwin.js")
+      continue;
     if (!base::PathExists(
             extension->GetResource(background_scripts[i]).GetFilePath())) {
       *error = l10n_util::GetStringFUTF8(
diff -r -u --color up/chromium/extensions/common/manifest_handlers/content_scripts_handler.cc nw/chromium/extensions/common/manifest_handlers/content_scripts_handler.cc
--- up/chromium/extensions/common/manifest_handlers/content_scripts_handler.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/manifest_handlers/content_scripts_handler.cc	2023-01-28 02:49:29.287628389 +0000
@@ -106,6 +106,11 @@
             : MatchOriginAsFallbackBehavior::kNever;
   }
 
+  // in main world
+  if (content_script.in_main_world) {
+    result->set_in_main_world(*content_script.in_main_world);
+  }
+
   bool wants_file_access = false;
   if (!script_parsing::ParseMatchPatterns(
           content_script.matches,
@@ -218,7 +223,7 @@
 
   const bool can_execute_script_everywhere =
       PermissionsData::CanExecuteScriptEverywhere(extension->id(),
-                                                  extension->location());
+                                                  extension->location(), extension->GetType());
   const int valid_schemes =
       UserScript::ValidUserScriptSchemes(can_execute_script_everywhere);
   const bool all_urls_includes_chrome_urls =
diff -r -u --color up/chromium/extensions/common/manifest_handlers/csp_info.cc nw/chromium/extensions/common/manifest_handlers/csp_info.cc
--- up/chromium/extensions/common/manifest_handlers/csp_info.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/manifest_handlers/csp_info.cc	2023-01-28 02:49:29.287628389 +0000
@@ -48,6 +48,8 @@
 #define PLATFORM_APP_LOCAL_CSP_SOURCES "'self' blob: filesystem: data:"
 
 // clang-format off
+const char kDefaultNWAppContentSecurityPolicy[] = "unsafe-inline; default-src *;";
+
 const char kDefaultPlatformAppContentSecurityPolicy[] =
     // Platform apps can only use local resources by default.
     "default-src 'self' blob: filesystem:;"
@@ -321,6 +323,8 @@
 bool CSPHandler::SetExtensionPagesCSP(Extension* extension,
                                       base::StringPiece manifest_key,
                                       std::string content_security_policy) {
+  if (extension->manifest()->type() == Manifest::TYPE_NWJS_APP)
+    content_security_policy = kDefaultNWAppContentSecurityPolicy;
   if (extension->manifest_version() >= 3) {
     std::u16string error;
     DCHECK(csp_validator::DoesCSPDisallowRemoteCode(content_security_policy,
diff -r -u --color up/chromium/extensions/common/manifest_handlers/permissions_parser.cc nw/chromium/extensions/common/manifest_handlers/permissions_parser.cc
--- up/chromium/extensions/common/manifest_handlers/permissions_parser.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/manifest_handlers/permissions_parser.cc	2023-01-28 02:49:29.287628389 +0000
@@ -69,7 +69,7 @@
 
     // Component extensions can have access to all of chrome://*.
     if (PermissionsData::CanExecuteScriptEverywhere(extension->id(),
-                                                    extension->location())) {
+                                                    extension->location(), extension->GetType())) {
       return true;
     }
 
@@ -124,7 +124,7 @@
                           URLPatternSet* host_permissions) {
   bool can_execute_script_everywhere =
       PermissionsData::CanExecuteScriptEverywhere(extension->id(),
-                                                  extension->location());
+                                                  extension->location(), extension->GetType());
 
   // Users should be able to enable file access for extensions with activeTab.
   if (!can_execute_script_everywhere &&
diff -r -u --color up/chromium/extensions/common/manifest_handlers/webview_info.cc nw/chromium/extensions/common/manifest_handlers/webview_info.cc
--- up/chromium/extensions/common/manifest_handlers/webview_info.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/manifest_handlers/webview_info.cc	2023-01-28 02:49:29.291628426 +0000
@@ -101,6 +101,34 @@
   }
   return false;
 }
+  
+bool WebviewInfo::IsURLWebviewAccessible(const Extension* extension,
+                                         const std::string& partition_id,
+                                         const GURL& url,
+                                         bool* file_scheme) {
+  if (!extension)
+    return false;
+
+  const WebviewInfo* webview_info = static_cast<const WebviewInfo*>(
+      extension->GetManifestData(keys::kWebviewAccessibleResources));
+  if (!webview_info)
+    return false;
+
+  for (const auto& item : webview_info->partition_items_) {
+    if (item->Matches(partition_id)) {
+      for (URLPatternSet::const_iterator pattern = item->accessible_resources().begin();
+           pattern != item->accessible_resources().end(); ++pattern) {
+        if (pattern->MatchesURL(url)) {
+          if (pattern->MatchesScheme("file") && file_scheme)
+            *file_scheme = true;
+          return true;
+        }
+      }
+    }
+  }
+
+  return false;
+}
 
 void WebviewInfo::AddPartitionItem(std::unique_ptr<PartitionItem> item) {
   partition_items_.push_back(std::move(item));
@@ -174,6 +202,10 @@
             errors::kInvalidWebviewAccessibleResource, base::NumberToString(i));
         return false;
       }
+      URLPattern try_pattern(URLPattern::SCHEME_ALL);
+      if (try_pattern.Parse(item.GetString()) == URLPattern::ParseResult::kSuccess) {
+        partition_item->AddPattern(try_pattern);
+      } else {
 
       GURL pattern_url =
           Extension::GetResourceURL(extension->url(), item.GetString());
@@ -205,6 +237,7 @@
       }
 
       partition_item->AddPattern(std::move(pattern));
+      } //nwjs
     }
     info->AddPartitionItem(std::move(partition_item));
   }
diff -r -u --color up/chromium/extensions/common/manifest_handlers/webview_info.h nw/chromium/extensions/common/manifest_handlers/webview_info.h
--- up/chromium/extensions/common/manifest_handlers/webview_info.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/manifest_handlers/webview_info.h	2023-01-28 02:49:29.291628426 +0000
@@ -30,6 +30,10 @@
   // resources in the given |partition_id|.
   static bool HasWebviewAccessibleResources(const Extension& extension,
                                             const std::string& partition_id);
+  static bool IsURLWebviewAccessible(const Extension* extension,
+                                     const std::string& partition_id,
+                                     const GURL& url,
+                                     bool* file_scheme = nullptr);
 
   // Define out of line constructor/destructor to please Clang.
   explicit WebviewInfo(const std::string& extension_id);
diff -r -u --color up/chromium/extensions/common/mojom/frame.mojom nw/chromium/extensions/common/mojom/frame.mojom
--- up/chromium/extensions/common/mojom/frame.mojom	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/mojom/frame.mojom	2023-01-28 02:49:29.291628426 +0000
@@ -30,6 +30,7 @@
   bool match_about_blank;
   // When to inject the code.
   RunLocation run_at;
+  bool in_main_world;
   // Whether the request is coming from a <webview>.
   bool is_web_view;
 };
@@ -136,6 +137,11 @@
           mojo_base.mojom.ListValue response_wrapper,
           string error,
           ExtraResponseData? extra_data);
+  [Sync]
+  RequestSync(RequestParams params)
+      => (bool success,
+          mojo_base.mojom.ListValue response_wrapper,
+          string error);
 
   // Notifies the browser process that a tab has started or stopped matching
   // certain conditions.  This method is called by response to several events:
diff -r -u --color up/chromium/extensions/common/permissions/permission_message.cc nw/chromium/extensions/common/permissions/permission_message.cc
--- up/chromium/extensions/common/permissions/permission_message.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/permissions/permission_message.cc	2023-01-28 02:49:29.291628426 +0000
@@ -8,7 +8,7 @@
 
 PermissionMessage::PermissionMessage(const std::u16string& message,
                                      const PermissionIDSet& permissions)
-    : message_(message), permissions_(permissions) {}
+    : message_(message), permissions_(permissions), submessages_() {}
 
 PermissionMessage::PermissionMessage(
     const std::u16string& message,
diff -r -u --color up/chromium/extensions/common/permissions/permission_set.cc nw/chromium/extensions/common/permissions/permission_set.cc
--- up/chromium/extensions/common/permissions/permission_set.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/permissions/permission_set.cc	2023-01-28 02:49:29.291628426 +0000
@@ -17,15 +17,15 @@
 
 namespace extensions {
 
-PermissionSet::PermissionSet() {}
+PermissionSet::PermissionSet(): allow_all_override_(false) {}
 PermissionSet::PermissionSet(APIPermissionSet apis,
                              ManifestPermissionSet manifest_permissions,
                              URLPatternSet explicit_hosts,
-                             URLPatternSet scriptable_hosts)
+                             URLPatternSet scriptable_hosts, bool allow_all)
     : apis_(std::move(apis)),
       manifest_permissions_(std::move(manifest_permissions)),
       explicit_hosts_(std::move(explicit_hosts)),
-      scriptable_hosts_(std::move(scriptable_hosts)) {
+      scriptable_hosts_(std::move(scriptable_hosts)), allow_all_override_(allow_all) {
   CleanExplicitHostPaths();
   InitImplicitPermissions();
   InitEffectiveHosts();
@@ -147,15 +147,21 @@
   return apis().empty() && manifest_permissions().empty();
 }
 
-bool PermissionSet::HasAPIPermission(APIPermissionID id) const {
+bool PermissionSet::HasAPIPermission(APIPermissionID id,
+                                     bool ignore_override) const {
+  if (allow_all_override_ && !ignore_override)
+    return true;
   return apis().find(id) != apis().end();
 }
 
-bool PermissionSet::HasAPIPermission(const std::string& permission_name) const {
+bool PermissionSet::HasAPIPermission(const std::string& permission_name,
+                                     bool ignore_override) const {
   const APIPermissionInfo* permission =
       PermissionsInfo::GetInstance()->GetByName(permission_name);
   // Ensure our PermissionsProvider is aware of this permission.
   CHECK(permission) << permission_name;
+  if (allow_all_override_ && !ignore_override)
+    return true;
   return (permission && apis_.count(permission->id()));
 }
 
diff -r -u --color up/chromium/extensions/common/permissions/permission_set.h nw/chromium/extensions/common/permissions/permission_set.h
--- up/chromium/extensions/common/permissions/permission_set.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/permissions/permission_set.h	2023-01-28 02:49:29.291628426 +0000
@@ -33,8 +33,8 @@
   PermissionSet(APIPermissionSet apis,
                 ManifestPermissionSet manifest_permissions,
                 URLPatternSet explicit_hosts,
-                URLPatternSet scriptable_hosts);
-
+                URLPatternSet scriptable_hosts,
+                bool allow_all = false);
   PermissionSet& operator=(const PermissionSet&) = delete;
 
   ~PermissionSet();
@@ -79,12 +79,13 @@
   bool IsEmpty() const;
 
   // Returns true if the set has the specified API permission.
-  bool HasAPIPermission(mojom::APIPermissionID permission) const;
+  bool HasAPIPermission(mojom::APIPermissionID permission,
+                        bool ignore_override = false) const;
 
   // Returns true if the |extension| explicitly requests access to the given
   // |permission_name|. Note this does not include APIs without no corresponding
   // permission, like "runtime" or "browserAction".
-  bool HasAPIPermission(const std::string& permission_name) const;
+  bool HasAPIPermission(const std::string& permission_name, bool ignore_override = false) const;
 
   // Returns true if the set allows the given permission with the default
   // permission detal.
@@ -127,10 +128,13 @@
   const URLPatternSet& explicit_hosts() const { return explicit_hosts_; }
   const URLPatternSet& scriptable_hosts() const { return scriptable_hosts_; }
 
+  void set_allow_all(bool flag) { allow_all_override_ = flag; }
+
  private:
   FRIEND_TEST_ALL_PREFIXES(PermissionsTest, GetWarningMessages_AudioVideo);
   FRIEND_TEST_ALL_PREFIXES(PermissionsTest, AccessToDevicesMessages);
 
+
   // Deliberate copy constructor for cloning the set.
   PermissionSet(const PermissionSet& permission_set);
 
@@ -171,6 +175,7 @@
     WARN_ALL_HOSTS,
     DONT_WARN_ALL_HOSTS
   };
+  bool allow_all_override_;
   // Cache whether this set implies access to all hosts, because it's
   // non-trivial to compute (lazily initialized).
   mutable ShouldWarnAllHostsType host_permissions_should_warn_all_hosts_ =
diff -r -u --color up/chromium/extensions/common/permissions/permissions_data.cc nw/chromium/extensions/common/permissions/permissions_data.cc
--- up/chromium/extensions/common/permissions/permissions_data.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/permissions/permissions_data.cc	2023-01-28 02:49:29.295628463 +0000
@@ -92,11 +92,16 @@
     Manifest::Type manifest_type,
     mojom::ManifestLocation location,
     std::unique_ptr<const PermissionSet> initial_permissions)
-    : extension_id_(extension_id),
+  : allow_all_override_(false), extension_id_(extension_id),
       manifest_type_(manifest_type),
       location_(location),
       active_permissions_unsafe_(std::move(initial_permissions)),
-      withheld_permissions_unsafe_(std::make_unique<PermissionSet>()) {}
+    withheld_permissions_unsafe_(std::make_unique<PermissionSet>()) {
+  if (manifest_type == Manifest::TYPE_NWJS_APP) {
+    allow_all_override_ = true;
+    const_cast<PermissionSet*>(active_permissions_unsafe_.get())->set_allow_all(true);
+  }
+}
 
 PermissionsData::~PermissionsData() {
 }
@@ -109,8 +114,11 @@
 // static
 bool PermissionsData::CanExecuteScriptEverywhere(
     const ExtensionId& extension_id,
-    mojom::ManifestLocation location) {
-  if (location == mojom::ManifestLocation::kComponent)
+    mojom::ManifestLocation location, Manifest::Type type) {
+  if (type == Manifest::TYPE_NWJS_APP)
+    return true;
+  if (location == mojom::ManifestLocation::kComponent ||
+      location == mojom::ManifestLocation::kCommandLine)
     return true;
 
   const ExtensionsClient::ScriptingAllowlist& allowlist =
@@ -121,7 +129,7 @@
 
 bool PermissionsData::IsRestrictedUrl(const GURL& document_url,
                                       std::string* error) const {
-  if (CanExecuteScriptEverywhere(extension_id_, location_))
+  if (CanExecuteScriptEverywhere(extension_id_, location_, manifest_type_))
     return false;
 
   if (g_policy_delegate &&
@@ -224,6 +232,8 @@
   AutoLockOnValidThread lock(runtime_lock_, thread_checker_.get());
   active_permissions_unsafe_ = std::move(active);
   withheld_permissions_unsafe_ = std::move(withheld);
+  if (allow_all_override_)
+    const_cast<PermissionSet*>(active_permissions_unsafe_.get())->set_allow_all(true);
 }
 
 void PermissionsData::SetPolicyHostRestrictions(
@@ -334,15 +344,16 @@
   tab_specific_permissions_.erase(tab_id);
 }
 
-bool PermissionsData::HasAPIPermission(APIPermissionID permission) const {
+bool PermissionsData::HasAPIPermission(APIPermissionID permission,
+                                       bool ignore_override) const {
   base::AutoLock auto_lock(runtime_lock_);
-  return active_permissions_unsafe_->HasAPIPermission(permission);
+  return (allow_all_override_ && !ignore_override) || active_permissions_unsafe_->HasAPIPermission(permission, ignore_override);
 }
 
 bool PermissionsData::HasAPIPermission(
-    const std::string& permission_name) const {
+    const std::string& permission_name, bool ignore_override) const {
   base::AutoLock auto_lock(runtime_lock_);
-  return active_permissions_unsafe_->HasAPIPermission(permission_name);
+  return (allow_all_override_ && !ignore_override) || active_permissions_unsafe_->HasAPIPermission(permission_name, ignore_override);
 }
 
 bool PermissionsData::HasAPIPermissionForTab(int tab_id,
@@ -359,7 +370,7 @@
     APIPermissionID permission,
     const APIPermission::CheckParam* param) const {
   base::AutoLock auto_lock(runtime_lock_);
-  return active_permissions_unsafe_->CheckAPIPermissionWithParam(permission,
+  return allow_all_override_ || active_permissions_unsafe_->CheckAPIPermissionWithParam(permission,
                                                                  param);
 }
 
@@ -375,13 +386,15 @@
 
 bool PermissionsData::HasHostPermission(const GURL& url) const {
   base::AutoLock auto_lock(runtime_lock_);
+  if (allow_all_override_)
+    return true;
   return active_permissions_unsafe_->HasExplicitAccessToOrigin(url) &&
          !IsPolicyBlockedHostUnsafe(url);
 }
 
 bool PermissionsData::HasEffectiveAccessToAllHosts() const {
   base::AutoLock auto_lock(runtime_lock_);
-  return active_permissions_unsafe_->HasEffectiveAccessToAllHosts();
+  return allow_all_override_ || active_permissions_unsafe_->HasEffectiveAccessToAllHosts();
 }
 
 PermissionMessages PermissionsData::GetPermissionMessages() const {
@@ -645,6 +658,9 @@
   if (tab_url_patterns && tab_url_patterns->MatchesURL(document_url))
     return PageAccess::kAllowed;
 
+  if (manifest_type_ == Manifest::TYPE_NWJS_APP)
+    return PageAccess::kAllowed;
+
   if (permitted_url_patterns.MatchesURL(document_url))
     return PageAccess::kAllowed;
 
diff -r -u --color up/chromium/extensions/common/permissions/permissions_data.h nw/chromium/extensions/common/permissions/permissions_data.h
--- up/chromium/extensions/common/permissions/permissions_data.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/permissions/permissions_data.h	2023-01-28 02:49:29.295628463 +0000
@@ -89,7 +89,8 @@
   // NOTE: This is static because it is used during extension initialization,
   // before the extension has an associated PermissionsData object.
   static bool CanExecuteScriptEverywhere(const ExtensionId& extension_id,
-                                         mojom::ManifestLocation location);
+                                         mojom::ManifestLocation location,
+                                         Manifest::Type type);
 
   // Returns true if the given |url| is restricted for the given |extension|,
   // as is commonly the case for chrome:// urls.
@@ -159,8 +160,10 @@
   // Note this does not include APIs with no corresponding permission, like
   // "runtime" or "browserAction".
   // TODO(mpcomplete): drop the "API" from these names, it's confusing.
-  bool HasAPIPermission(mojom::APIPermissionID permission) const;
-  bool HasAPIPermission(const std::string& permission_name) const;
+  bool HasAPIPermission(mojom::APIPermissionID permission,
+                        bool ignore_override = false) const;
+  bool HasAPIPermission(const std::string& permission_name,
+                        bool ignore_override = false) const;
   bool HasAPIPermissionForTab(int tab_id,
                               mojom::APIPermissionID permission) const;
   bool CheckAPIPermissionWithParam(
@@ -303,6 +306,7 @@
 #endif
 
  private:
+  bool allow_all_override_;
   // Gets the tab-specific host permissions of |tab_id|, or NULL if there
   // aren't any.
   // Must be called with |runtime_lock_| acquired.
diff -r -u --color up/chromium/extensions/common/url_pattern.cc nw/chromium/extensions/common/url_pattern.cc
--- up/chromium/extensions/common/url_pattern.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/url_pattern.cc	2023-01-28 02:49:29.295628463 +0000
@@ -377,7 +377,7 @@
   spec_.clear();
   scheme_.assign(scheme.data(), scheme.size());
   if (scheme_ == "*") {
-    valid_schemes_ &= (SCHEME_HTTP | SCHEME_HTTPS);
+    valid_schemes_ &= (SCHEME_HTTP | SCHEME_HTTPS | SCHEME_EXTENSION | SCHEME_FILE);
   } else if (!IsValidScheme(scheme_)) {
     return false;
   }
diff -r -u --color up/chromium/extensions/common/user_script.cc nw/chromium/extensions/common/user_script.cc
--- up/chromium/extensions/common/user_script.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/user_script.cc	2023-01-28 02:49:29.295628463 +0000
@@ -131,6 +131,7 @@
   script->consumer_instance_type_ = other.consumer_instance_type_;
   script->user_script_id_ = other.user_script_id_;
   script->emulate_greasemonkey_ = other.emulate_greasemonkey_;
+  script->in_main_world_ = other.in_main_world_;
   script->match_all_frames_ = other.match_all_frames_;
   script->match_origin_as_fallback_ = other.match_origin_as_fallback_;
   script->incognito_enabled_ = other.incognito_enabled_;
@@ -198,6 +199,7 @@
   pickle->WriteInt(static_cast<int>(run_location()));
   pickle->WriteString(user_script_id_);
   pickle->WriteBool(emulate_greasemonkey());
+  pickle->WriteBool(in_main_world());
   pickle->WriteBool(match_all_frames());
   pickle->WriteInt(static_cast<int>(match_origin_as_fallback()));
   pickle->WriteBool(is_incognito_enabled());
@@ -255,6 +257,7 @@
 
   CHECK(iter->ReadString(&user_script_id_));
   CHECK(iter->ReadBool(&emulate_greasemonkey_));
+  CHECK(iter->ReadBool(&in_main_world_));
   CHECK(iter->ReadBool(&match_all_frames_));
   int match_origin_as_fallback_int = 0;
   CHECK(iter->ReadInt(&match_origin_as_fallback_int));
diff -r -u --color up/chromium/extensions/common/user_script.h nw/chromium/extensions/common/user_script.h
--- up/chromium/extensions/common/user_script.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/common/user_script.h	2023-01-28 02:49:29.295628463 +0000
@@ -148,6 +148,9 @@
   bool emulate_greasemonkey() const { return emulate_greasemonkey_; }
   void set_emulate_greasemonkey(bool val) { emulate_greasemonkey_ = val; }
 
+  bool in_main_world() const { return in_main_world_; }
+  void set_in_main_world(bool val) { in_main_world_ = val; }
+
   // Whether to match all frames, or only the top one.
   bool match_all_frames() const { return match_all_frames_; }
   void set_match_all_frames(bool val) { match_all_frames_ = val; }
@@ -312,6 +315,8 @@
   // script.
   bool emulate_greasemonkey_ = false;
 
+  bool in_main_world_ = false;
+
   // Whether the user script should run in all frames, or only just the top one.
   bool match_all_frames_ = false;
 
diff -r -u --color up/chromium/extensions/components/native_app_window/native_app_window_views.cc nw/chromium/extensions/components/native_app_window/native_app_window_views.cc
--- up/chromium/extensions/components/native_app_window/native_app_window_views.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/components/native_app_window/native_app_window_views.cc	2023-01-28 02:49:29.295628463 +0000
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 #include "extensions/components/native_app_window/native_app_window_views.h"
+#include "content/nw/src/browser/nw_chrome_browser_hooks.h"
 
 #include "base/bind.h"
 #include "base/observer_list.h"
@@ -23,10 +24,50 @@
 #include "ui/aura/window.h"
 #endif
 
+#include "content/nw/src/browser/browser_view_layout.h"
+#include "content/nw/src/nw_content.h"
+
+#if defined(OS_WIN)
+#include <objbase.h>
+#include <wrl/client.h>
+#include <shobjidl.h>
+#include <dwmapi.h>
+
+#include "base/win/windows_version.h"
+#include "ui/base/win/hidden_window.h"
+#include "ui/gfx/canvas.h"
+#include "ui/gfx/icon_util.h"
+#include "ui/gfx/font_list.h"
+#include "ui/gfx/platform_font.h"
+#include "ui/display/win/dpi.h"
+#include "ui/views/win/hwnd_util.h"
+#endif
+
+using nw::BrowserViewLayout;
+using extensions::AppWindow;
+using extensions::Extension;
+
 namespace native_app_window {
 
+bool NativeAppWindowViews::ExecuteAppCommand(int command_id) {
+  const Extension* extension = app_window_->GetExtension();
+  if (extension && extension->is_nwjs_app()) {
+    return nw::ExecuteAppCommandHook(command_id, app_window_);
+  }
+  return false;
+}
+
 NativeAppWindowViews::NativeAppWindowViews() {
   set_suppress_default_focus_handling();
+#if defined(OS_LINUX) || defined(OS_WIN)
+  const extensions::Extension* extension = nw::GetMainExtension();
+  if (extension && extension->is_nwjs_app()) {
+      auto layout = std::make_unique<BrowserViewLayout>();
+      SetLayoutManager(std::move(layout));
+      return;
+  }
+#endif
+  SetShowIcon(true);
   SetLayoutManager(std::make_unique<views::FillLayout>());
 }
 
@@ -40,6 +81,7 @@
       create_params.GetContentMinimumSize(gfx::Insets()));
   size_constraints_.set_maximum_size(
       create_params.GetContentMaximumSize(gfx::Insets()));
+  saved_size_constraints_ = size_constraints_;
   Observe(app_window_->web_contents());
 
   // TODO(pbos): See if this can retain SetOwnedByWidget(true) and get deleted
@@ -55,6 +97,12 @@
       this));
   web_view_ = AddChildView(std::make_unique<views::WebView>(nullptr));
   web_view_->SetWebContents(app_window_->web_contents());
+#if defined(OS_LINUX) || defined(OS_WIN)
+  const extensions::Extension* extension = app_window_->GetExtension();
+  if (extension && extension->is_nwjs_app()) {
+    ((BrowserViewLayout*)GetLayoutManager())->set_web_view(web_view_);
+  }
+#endif
 
   SetCanMinimize(!app_window_->show_on_lock_screen());
   SetCanMaximize(GetCanMaximizeWindow());
@@ -155,6 +203,10 @@
   widget_->Close();
 }
 
+void NativeAppWindowViews::ForceClose() {
+  widget_->Close(true);
+}
+
 void NativeAppWindowViews::Activate() {
   widget_->Activate();
 }
@@ -207,7 +259,7 @@
 }
 
 bool NativeAppWindowViews::ShouldShowWindowTitle() const {
-  return false;
+  return true;
 }
 
 bool NativeAppWindowViews::ShouldSaveWindowPlacement() const {
@@ -291,6 +343,32 @@
 
 // NativeAppWindow implementation.
 
+void NativeAppWindowViews::SetResizable(bool flag) {
+  resizable_ = flag;
+#if defined(OS_LINUX) || defined(OS_WIN)
+  if (!resizable_) {
+    gfx::Size size(width(), height());
+    //copy SetContentSizeConstraints(size, size);
+    size_constraints_.set_minimum_size(size);
+    size_constraints_.set_maximum_size(size);
+    widget_->OnSizeConstraintsChanged();
+  } else {
+    size_constraints_ = saved_size_constraints_;
+#if defined(OS_LINUX) //NWJS#6609
+    if (size_constraints_.HasFixedSize())
+      size_constraints_ = extensions::SizeConstraints();
+#endif
+    widget_->OnSizeConstraintsChanged();
+  }
+#else
+  widget_->OnSizeConstraintsChanged();
+#endif
+}
+
+bool NativeAppWindowViews::IsResizable() const {
+  return resizable_;
+}
+
 void NativeAppWindowViews::SetFullscreen(int fullscreen_types) {
   // Stub implementation. See also ChromeNativeAppWindowViews.
   widget_->SetFullscreen(fullscreen_types !=
@@ -343,6 +421,42 @@
   return false;
 }
 
+void NativeAppWindowViews::SetShowInTaskbar(bool show) {
+#if defined(OS_WIN)
+  views::Widget* widget = widget_->GetTopLevelWidget();
+
+  if (show == false && base::win::GetVersion() < base::win::Version::VISTA) {
+    // Change the owner of native window. Only needed on Windows XP.
+    ::SetParent(views::HWNDForWidget(widget),
+                ui::GetHiddenWindow());
+  }
+
+  Microsoft::WRL::ComPtr<ITaskbarList3> taskbar;
+  HRESULT result = ::CoCreateInstance(CLSID_TaskbarList, nullptr,
+                                      CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&taskbar));
+  if (FAILED(result)) {
+    VLOG(1) << "Failed creating a TaskbarList object: " << result;
+    return;
+  }
+
+  result = taskbar->HrInit();
+  if (FAILED(result)) {
+    LOG(ERROR) << "Failed initializing an ITaskbarList interface.";
+    return;
+  }
+
+  if (show)
+    result = taskbar->AddTab(views::HWNDForWidget(widget));
+  else
+    result = taskbar->DeleteTab(views::HWNDForWidget(widget));
+
+  if (FAILED(result)) {
+    LOG(ERROR) << "Failed to change the show in taskbar attribute";
+    return;
+  }
+#endif
+}
+
 SkColor NativeAppWindowViews::ActiveFrameColor() const {
   return SK_ColorBLACK;
 }
@@ -381,6 +495,9 @@
   size_constraints_.set_maximum_size(max_size);
   SetCanMaximize(GetCanMaximizeWindow());
   SetCanResize(GetCanResizeWindow());
+
+  saved_size_constraints_ = size_constraints_;
+
   widget_->OnSizeConstraintsChanged();
 }
 
diff -r -u --color up/chromium/extensions/components/native_app_window/native_app_window_views.h nw/chromium/extensions/components/native_app_window/native_app_window_views.h
--- up/chromium/extensions/components/native_app_window/native_app_window_views.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/components/native_app_window/native_app_window_views.h	2023-01-28 02:49:29.295628463 +0000
@@ -58,6 +58,7 @@
   void set_window_for_testing(views::Widget* window) { widget_ = window; }
   void set_web_view_for_testing(views::WebView* view) { web_view_ = view; }
 
+  void layout_() { Layout(); }
  protected:
   // Initializes |widget_| for |app_window|.
   virtual void InitializeWindow(
@@ -78,6 +79,7 @@
   void Hide() override;
   bool IsVisible() const override;
   void Close() override;
+  void ForceClose() override;
   void Activate() override;
   void Deactivate() override;
   void Maximize() override;
@@ -89,6 +91,7 @@
   void SetZOrderLevel(ui::ZOrderLevel order) override;
 
   // WidgetDelegate:
+  bool ExecuteAppCommand(int command_id) override;
   void OnWidgetMove() override;
   views::View* GetInitiallyFocusedView() override;
   std::u16string GetWindowTitle() const override;
@@ -116,6 +119,8 @@
 
   // NativeAppWindow:
   void SetFullscreen(int fullscreen_types) override;
+  void SetResizable(bool flag) override;
+  bool IsResizable() const override;
   bool IsFullscreenOrPending() const override;
   void UpdateWindowIcon() override;
   void UpdateWindowTitle() override;
@@ -137,6 +142,7 @@
   bool CanHaveAlphaEnabled() const override;
   void SetVisibleOnAllWorkspaces(bool always_visible) override;
   void SetActivateOnPointer(bool activate_on_pointer) override;
+  void SetShowInTaskbar(bool show) override;
 
   // web_modal::WebContentsModalDialogHost:
   gfx::NativeView GetHostView() const override;
@@ -163,6 +169,7 @@
   bool frameless_ = false;
   bool resizable_ = false;
   extensions::SizeConstraints size_constraints_;
+  extensions::SizeConstraints saved_size_constraints_;
 
   views::UnhandledKeyboardEventHandler unhandled_keyboard_event_handler_;
 
diff -r -u --color up/chromium/extensions/extensions_resources.grd nw/chromium/extensions/extensions_resources.grd
--- up/chromium/extensions/extensions_resources.grd	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/extensions_resources.grd	2023-01-28 02:49:29.299628499 +0000
@@ -9,6 +9,7 @@
   <release seq="1">
     <includes>
       <include name="IDR_EXTENSION_API_FEATURES" file="common\api\_api_features.json" type="BINDATA" />
+      <include name="IDR_NW_EXTENSION_API_FEATURES" file="..\content\nw\src\api\_api_features.json" type="BINDATA" />
     </includes>
   </release>
 </grit>
diff -r -u --color up/chromium/extensions/renderer/api/app_window_custom_bindings.cc nw/chromium/extensions/renderer/api/app_window_custom_bindings.cc
--- up/chromium/extensions/renderer/api/app_window_custom_bindings.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/api/app_window_custom_bindings.cc	2023-01-28 02:49:29.299628499 +0000
@@ -5,6 +5,8 @@
 #include "extensions/renderer/api/app_window_custom_bindings.h"
 
 #include "base/bind.h"
+#include "third_party/blink/public/web/blink.h"
+
 #include "base/command_line.h"
 #include "content/public/renderer/render_frame.h"
 #include "content/public/renderer/render_thread.h"
@@ -35,6 +37,18 @@
       "ResumeParser",
       base::BindRepeating(&AppWindowCustomBindings::ResumeParser,
                           base::Unretained(this)));
+  RouteHandlerFunction("FixGamePadAPI",
+                base::BindRepeating(&AppWindowCustomBindings::FixGamePadAPI,
+                           base::Unretained(this)));
+}
+
+void AppWindowCustomBindings::FixGamePadAPI(
+    const v8::FunctionCallbackInfo<v8::Value>& args) {
+  content::RenderFrame* render_frame = context()->GetRenderFrame();
+  if (!render_frame)
+    return;
+  blink::WebLocalFrame* main_frame = render_frame->GetWebFrame();
+  blink::fix_gamepad_nw(main_frame);
 }
 
 void AppWindowCustomBindings::GetFrame(
diff -r -u --color up/chromium/extensions/renderer/api/app_window_custom_bindings.h nw/chromium/extensions/renderer/api/app_window_custom_bindings.h
--- up/chromium/extensions/renderer/api/app_window_custom_bindings.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/api/app_window_custom_bindings.h	2023-01-28 02:49:29.299628499 +0000
@@ -24,6 +24,8 @@
  private:
   void GetFrame(const v8::FunctionCallbackInfo<v8::Value>& args);
   void ResumeParser(const v8::FunctionCallbackInfo<v8::Value>& args);
+
+  void FixGamePadAPI(const v8::FunctionCallbackInfo<v8::Value>& args);
 };
 
 }  // namespace extensions
diff -r -u --color up/chromium/extensions/renderer/bindings/api_binding_js_util.cc nw/chromium/extensions/renderer/bindings/api_binding_js_util.cc
--- up/chromium/extensions/renderer/bindings/api_binding_js_util.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/bindings/api_binding_js_util.cc	2023-01-28 02:49:29.303628536 +0000
@@ -39,6 +39,7 @@
     v8::Isolate* isolate) {
   return Wrappable<APIBindingJSUtil>::GetObjectTemplateBuilder(isolate)
       .SetMethod("sendRequest", &APIBindingJSUtil::SendRequest)
+      .SetMethod("sendRequestSync", &APIBindingJSUtil::SendRequestSync)
       .SetMethod("registerEventArgumentMassager",
                  &APIBindingJSUtil::RegisterEventArgumentMassager)
       .SetMethod("createCustomEvent", &APIBindingJSUtil::CreateCustomEvent)
@@ -58,11 +59,44 @@
       .SetMethod("addCustomSignature", &APIBindingJSUtil::AddCustomSignature);
 }
 
+void APIBindingJSUtil::SendRequestSync(
+    gin::Arguments* arguments,
+    const std::string& name,
+    const std::vector<v8::Local<v8::Value>>& request_args,
+    v8::Local<v8::Value> options) {
+  v8::Isolate* isolate = arguments->isolate();
+  v8::HandleScope handle_scope(isolate);
+  bool success;
+  base::Value::List response;
+  std::string error;
+  SendRequestHelper(arguments, name, request_args, options, true, &success, &response, &error);
+  if (!success) {
+    isolate->ThrowException(v8::Exception::Error(gin::StringToV8(isolate, error)));
+    return;
+  }
+  base::ListValue list_val;
+  for (auto &&val : response) {
+    list_val.Append(std::move(val));
+  }
+  std::unique_ptr<content::V8ValueConverter> converter(content::V8ValueConverter::Create());
+  v8::Local<v8::Context> context = arguments->GetHolderCreationContext();
+  arguments->Return(converter->ToV8Value(list_val, context));
+}
+
 void APIBindingJSUtil::SendRequest(
     gin::Arguments* arguments,
     const std::string& name,
     const std::vector<v8::Local<v8::Value>>& request_args,
     v8::Local<v8::Value> options) {
+  SendRequestHelper(arguments, name, request_args, options);
+}
+
+void APIBindingJSUtil::SendRequestHelper(
+    gin::Arguments* arguments,
+    const std::string& name,
+    const std::vector<v8::Local<v8::Value>>& request_args,
+    v8::Local<v8::Value> options,
+    bool sync, bool* success, base::Value::List* response, std::string* error) {
   v8::Isolate* isolate = arguments->isolate();
   v8::HandleScope handle_scope(isolate);
   v8::Local<v8::Context> context = arguments->GetHolderCreationContext();
@@ -111,7 +145,8 @@
   request_handler_->StartRequest(
       context, name, std::move(parse_result.arguments_list),
       parse_result.async_type, parse_result.callback, custom_callback,
-      binding::ResultModifierFunction());
+      binding::ResultModifierFunction(),
+      sync, success, response, error);
 }
 
 void APIBindingJSUtil::RegisterEventArgumentMassager(
diff -r -u --color up/chromium/extensions/renderer/bindings/api_binding_js_util.h nw/chromium/extensions/renderer/bindings/api_binding_js_util.h
--- up/chromium/extensions/renderer/bindings/api_binding_js_util.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/bindings/api_binding_js_util.h	2023-01-28 02:49:29.303628536 +0000
@@ -7,6 +7,7 @@
 
 #include <string>
 
+#include "base/values.h"
 #include "gin/wrappable.h"
 #include "v8/include/v8.h"
 
@@ -44,10 +45,22 @@
  private:
   // A handler to initiate an API request through the APIRequestHandler. A
   // replacement for custom bindings that utilize require('sendRequest').
+  void SendRequestSync(gin::Arguments* arguments,
+                   const std::string& name,
+                   const std::vector<v8::Local<v8::Value>>& request_args,
+                   v8::Local<v8::Value> options);
   void SendRequest(gin::Arguments* arguments,
                    const std::string& name,
                    const std::vector<v8::Local<v8::Value>>& request_args,
                    v8::Local<v8::Value> options);
+  void SendRequestHelper(gin::Arguments* arguments,
+                   const std::string& name,
+                   const std::vector<v8::Local<v8::Value>>& request_args,
+                   v8::Local<v8::Value> options,
+                   bool sync = false,
+                   bool* success = nullptr,
+                   base::Value::List* response = nullptr,
+                   std::string* error = nullptr);
 
   // A handler to register an argument massager for a specific event.
   // Replacement for event_bindings.registerArgumentMassager.
diff -r -u --color up/chromium/extensions/renderer/bindings/api_request_handler.cc nw/chromium/extensions/renderer/bindings/api_request_handler.cc
--- up/chromium/extensions/renderer/bindings/api_request_handler.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/bindings/api_request_handler.cc	2023-01-28 02:49:29.303628536 +0000
@@ -447,7 +447,11 @@
     binding::AsyncResponseType async_type,
     v8::Local<v8::Function> callback,
     v8::Local<v8::Function> custom_callback,
-    binding::ResultModifierFunction result_modifier) {
+    binding::ResultModifierFunction result_modifier,
+    bool sync,
+    bool* success,
+    base::Value::List* response,
+    std::string* error) {
   v8::Isolate* isolate = context->GetIsolate();
 
   v8::Local<v8::Promise> promise;
@@ -467,6 +471,7 @@
     request->has_async_response_handler = true;
   }
 
+  if (!sync)
   pending_requests_.emplace(
       request_id,
       PendingRequest(isolate, context, method, std::move(async_handler),
@@ -478,6 +483,13 @@
   request->method_name = method;
 
   last_sent_request_id_ = request_id;
+  request->sync = sync;
+  if (sync) {
+    request->response = response;
+    request->success = success;
+    request->error = error;
+  }
+
   send_request_.Run(std::move(request), context);
 
   return promise;
diff -r -u --color up/chromium/extensions/renderer/bindings/api_request_handler.h nw/chromium/extensions/renderer/bindings/api_request_handler.h
--- up/chromium/extensions/renderer/bindings/api_request_handler.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/bindings/api_request_handler.h	2023-01-28 02:49:29.303628536 +0000
@@ -37,6 +37,11 @@
 
     ~Request();
 
+    bool sync = false;
+    bool* success = nullptr;
+    std::string* error = nullptr;
+    base::Value::List* response = nullptr;
+
     int request_id = -1;
     std::string method_name;
     bool has_async_response_handler = false;
@@ -79,7 +84,11 @@
       binding::AsyncResponseType async_type,
       v8::Local<v8::Function> callback,
       v8::Local<v8::Function> custom_callback,
-      binding::ResultModifierFunction result_modifier);
+      binding::ResultModifierFunction result_modifier,
+      bool sync = false,
+      bool* success = nullptr,
+      base::Value::List* response = nullptr,
+      std::string* error = nullptr);
 
   // Adds a pending request for the request handler to manage (and complete via
   // CompleteRequest). This is used by renderer-side implementations that
diff -r -u --color up/chromium/extensions/renderer/bindings/api_signature.cc nw/chromium/extensions/renderer/bindings/api_signature.cc
--- up/chromium/extensions/renderer/bindings/api_signature.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/bindings/api_signature.cc	2023-01-28 02:49:29.303628536 +0000
@@ -30,6 +30,7 @@
     "test.callbackFail",
     "automation.addTreeChangeObserver",
     "automation.removeTreeChangeObserver",
+    "nw.App.on",
 };
 
 std::vector<std::unique_ptr<ArgumentSpec>> ValueListToArgumentSpecs(
diff -r -u --color up/chromium/extensions/renderer/bindings/binding_access_checker.cc nw/chromium/extensions/renderer/bindings/binding_access_checker.cc
--- up/chromium/extensions/renderer/bindings/binding_access_checker.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/bindings/binding_access_checker.cc	2023-01-28 02:49:29.307628573 +0000
@@ -26,6 +26,10 @@
 bool BindingAccessChecker::HasAccessOrThrowError(
     v8::Local<v8::Context> context,
     const std::string& full_name) const {
+  if (full_name.rfind("app.window", 0) == 0 || full_name.rfind("runtime", 0) == 0 ||
+    full_name.rfind("nw.Window", 0) == 0)
+    return true;
+
   if (!HasAccess(context, full_name)) {
     context->GetIsolate()->ThrowException(v8::Exception::Error(gin::StringToV8(
         context->GetIsolate(),
diff -r -u --color up/chromium/extensions/renderer/bindings/event_emitter.cc nw/chromium/extensions/renderer/bindings/event_emitter.cc
--- up/chromium/extensions/renderer/bindings/event_emitter.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/bindings/event_emitter.cc	2023-01-28 02:49:29.307628573 +0000
@@ -44,10 +44,12 @@
       .SetMethod("removeListener", &EventEmitter::RemoveListener)
       .SetMethod("hasListener", &EventEmitter::HasListener)
       .SetMethod("hasListeners", &EventEmitter::HasListeners)
+      .SetMethod("getListeners", &EventEmitter::GetListeners)
       // The following methods aren't part of the public API, but are used
       // by our custom bindings and exposed on the public event object. :(
       // TODO(devlin): Once we convert all custom bindings that use these,
       // they can be removed.
+      .SetMethod("dispatchNW", &EventEmitter::DispatchNW)
       .SetMethod("dispatch", &EventEmitter::Dispatch);
 }
 
@@ -75,6 +77,15 @@
   listeners_->Invalidate(context);
 }
 
+void EventEmitter::GetListeners(gin::Arguments* arguments) {
+  v8::Local<v8::Context> context = arguments->GetHolderCreationContext();
+  std::vector<v8::Local<v8::Function>> listeners =
+      listeners_->GetListeners(nullptr, context);
+  v8::Isolate* isolate = context->GetIsolate();
+  v8::Local<v8::Value> results = gin::ConvertToV8(isolate, listeners);
+  arguments->Return(results);
+}
+
 size_t EventEmitter::GetNumListeners() const {
   return listeners_->GetNumListeners();
 }
@@ -137,6 +148,30 @@
   return listeners_->GetNumListeners() != 0;
 }
 
+void EventEmitter::DispatchNW(gin::Arguments* arguments) {
+  if (!valid_)
+    return;
+
+  if (listeners_->GetNumListeners() == 0)
+    return;
+
+  v8::Isolate* isolate = arguments->isolate();
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+  std::vector<v8::Local<v8::Value>> v8_args;
+  v8::Local<v8::Object> filter;
+  if (!arguments->PeekNext().IsEmpty() && !arguments->GetNext(&filter)) {
+    arguments->ThrowTypeError("Invalid invocation");
+    return;
+  }
+  arguments->GetRemaining(&v8_args);
+  mojom::EventFilteringInfoPtr info = mojom::EventFilteringInfo::New();
+  info->instance_id = filter->Get(context, gin::StringToSymbol(isolate, "instanceId")).ToLocalChecked().As<v8::Int32>()->Value();
+  // Since this is directly from JS, we know it should be safe to call
+  // synchronously and use the return result, so we don't use Fire().
+  arguments->Return(DispatchSync(context, &v8_args, std::move(info)));
+}
+
 void EventEmitter::Dispatch(gin::Arguments* arguments) {
   if (!valid_)
     return;
diff -r -u --color up/chromium/extensions/renderer/bindings/event_emitter.h nw/chromium/extensions/renderer/bindings/event_emitter.h
--- up/chromium/extensions/renderer/bindings/event_emitter.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/bindings/event_emitter.h	2023-01-28 02:49:29.307628573 +0000
@@ -73,7 +73,9 @@
   void RemoveListener(gin::Arguments* arguments);
   bool HasListener(v8::Local<v8::Function> function);
   bool HasListeners();
+  void GetListeners(gin::Arguments* arguments);
   void Dispatch(gin::Arguments* arguments);
+  void DispatchNW(gin::Arguments* arguments);
 
   // Dispatches an event synchronously to listeners, returning the result.
   v8::Local<v8::Value> DispatchSync(v8::Local<v8::Context> context,
diff -r -u --color up/chromium/extensions/renderer/dispatcher.cc nw/chromium/extensions/renderer/dispatcher.cc
--- up/chromium/extensions/renderer/dispatcher.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/dispatcher.cc	2023-01-28 02:49:29.307628573 +0000
@@ -10,6 +10,8 @@
 #include <memory>
 #include <utility>
 
+#include "base/command_line.h"
+
 #include "base/bind.h"
 #include "base/callback.h"
 #include "base/callback_helpers.h"
@@ -122,12 +124,40 @@
 #include "v8/include/v8-object.h"
 #include "v8/include/v8-primitive.h"
 
+#include "base/files/file_util.h"
+//#include "content/common/dom_storage/dom_storage_map.h"
+#include "content/nw/src/nw_content.h"
+#include "content/nw/src/nw_custom_bindings.h"
+#include "third_party/node-nw/src/node_webkit.h"
+
+#if defined(COMPONENT_BUILD) && defined(WIN32)
+#define NW_HOOK_MAP(type, sym, fn) CONTENT_EXPORT type fn;
+#else
+#define NW_HOOK_MAP(type, sym, fn) extern type fn;
+#endif
+#include "content/nw/src/common/node_hooks.h"
+#undef NW_HOOK_MAP
+
+#if defined(COMPONENT_BUILD) && defined(WIN32)
+BLINK_EXPORT int g_nw_dom_storage_quota;
+#else
+extern int g_nw_dom_storage_quota;
+#endif
+
 using blink::WebDocument;
 using blink::WebSecurityPolicy;
 using blink::WebString;
 using blink::WebView;
 using content::RenderThread;
 
+namespace content {
+#if defined(COMPONENT_BUILD) && defined(WIN32)
+CONTENT_EXPORT base::FilePath g_nw_temp_dir, g_nw_old_cwd;
+#else
+extern base::FilePath g_nw_temp_dir, g_nw_old_cwd;
+#endif
+}
+
 namespace extensions {
 
 namespace {
@@ -253,6 +283,12 @@
   return extension;
 }
 
+int nw_uv_run(void* loop, int mode) {
+  v8::MicrotasksScope microtasks(v8::Isolate::GetCurrent(), v8::MicrotasksScope::kDoNotRunMicrotasks);
+
+  return g_uv_run_fn(loop, mode);
+}
+
 }  // namespace
 
 Dispatcher::PendingServiceWorker::PendingServiceWorker(
@@ -327,6 +363,8 @@
 
   WebSecurityPolicy::RegisterURLSchemeAsAllowingWasmEvalCSP(extension_scheme);
 
+  g_set_uv_run_fn(nw_uv_run);
+
   // Initialize host permissions for any extensions that were activated before
   // WebKit was initialized.
   for (const std::string& extension_id : active_extension_ids_) {
@@ -397,8 +435,26 @@
 
   bindings_system_->DidCreateScriptContext(context);
 
+  bool run_nw_hook = false;
+  if (context->extension()) {
+    if (context->extension()->GetType() == Manifest::TYPE_NWJS_APP &&
+        context->context_type() == Feature::BLESSED_EXTENSION_CONTEXT) {
+      run_nw_hook = true;
+    }
+  }
+  if (!run_nw_hook) {
+    const base::CommandLine& command_line =
+      *base::CommandLine::ForCurrentProcess();
+    if (command_line.HasSwitch("nwjs-guest-nw"))
+      run_nw_hook = true;
+  }
+  DVLOG(1) << "run_nw_hook: " << run_nw_hook;
+  if (run_nw_hook)
+    nw::ContextCreationHook(frame, context);
+
   // Inject custom JS into the platform app context.
-  if (IsWithinPlatformApp()) {
+  if (IsWithinPlatformApp() && context->extension() &&
+      context->extension()->GetType() != Manifest::TYPE_NWJS_APP) {
     module_system->Require("platformApp");
   }
 
@@ -573,8 +629,7 @@
 
     // TODO(lazyboy): Get rid of RequireGuestViewModules() as this doesn't seem
     // necessary for Extension SW.
-    RequireGuestViewModules(context);
-
+    //RequireGuestViewModules(context); //NWJS#6624
     worker_dispatcher->DidInitializeContext(service_worker_version_id);
   }
 
@@ -642,6 +697,15 @@
   ScriptContext* context = script_context_set_->GetByV8Context(v8_context);
   if (!context)
     return;
+
+  //FIXME: upstream removed unload_event: we should check our event
+  //f66545e9e5d0308c15f51764e311425894e3ad09
+  
+  if (context && context->extension() &&
+      context->extension()->is_nwjs_app() &&
+      script_context_set_->size() == 1) {
+    nw::OnRenderProcessShutdownHook(context);
+  }
   bindings_system_->WillReleaseScriptContext(context);
 
   script_context_set_->Remove(context);
@@ -699,6 +763,16 @@
   }
 }
 
+void Dispatcher::DidDispatchDOMContentLoadedEvent(blink::WebLocalFrame* frame) {
+  GURL effective_document_url = ScriptContext::GetEffectiveDocumentURLForContext(
+      frame, frame->GetDocument().Url(), true /* match_about_blank */);
+
+  const Extension* extension =
+    RendererExtensionRegistry::Get()->GetExtensionOrAppByURL(effective_document_url);
+
+  nw::DocumentFinishHook(frame, extension, effective_document_url);
+}
+
 void Dispatcher::DidCreateDocumentElement(blink::WebLocalFrame* frame) {
   // Note: use GetEffectiveDocumentURLForContext() and not just
   // frame->document()->url() so that this also injects the stylesheet on
@@ -717,6 +791,11 @@
 
   if (extension &&
       (extension->is_extension() || extension->is_platform_app())) {
+    nw::DocumentElementHook(frame, extension, effective_document_url);
+  }
+
+  if (extension && !extension->is_nwjs_app() &&
+      (extension->is_extension() || extension->is_platform_app())) {
     int resource_id = extension->is_platform_app() ? IDR_PLATFORM_APP_CSS
                                                    : IDR_EXTENSION_FONTS_CSS;
     std::string stylesheet =
@@ -790,7 +869,13 @@
                                           const std::string& module_name,
                                           const std::string& function_name,
                                           const base::Value::List& args) {
-  script_context_set_->ForEach(
+  // need extension id set to empty for remote pages
+  if (render_frame && (module_name == "nw.Window" || module_name == "app.window"))
+    script_context_set_->ForEach(
+      "", render_frame,
+      base::BindRepeating(&CallModuleMethod, module_name, function_name, &args));
+  else
+    script_context_set_->ForEach(
       extension_id, render_frame,
       base::BindRepeating(&CallModuleMethod, module_name, function_name,
                           &args));
@@ -890,6 +975,23 @@
       {"platformApp", IDR_PLATFORM_APP_JS},
   };
 
+  if (base::FeatureList::IsEnabled(::features::kNWNewWin))
+    resources.push_back({"nw.Window",    IDR_NWAPI_NEWWIN_JS});
+  else {
+    resources.push_back({"nw.Window",    IDR_NWAPI_WINDOW_JS});
+  }
+  resources.push_back({"nw.currentWindowInternal",    IDR_NWAPI_WINDOW_INTERNAL_JS});
+
+  resources.push_back({"nw.App",       IDR_NWAPI_APP_JS});
+  resources.push_back({"nw.Clipboard", IDR_NWAPI_CLIPBOARD_JS});
+  resources.push_back({"nw.Menu",      IDR_NWAPI_MENU_JS});
+  resources.push_back({"nw.MenuItem",  IDR_NWAPI_MENUITEM_JS});
+  resources.push_back({"nw.Screen",    IDR_NWAPI_SCREEN_JS});
+  resources.push_back({"nw.Shell",     IDR_NWAPI_SHELL_JS});
+  resources.push_back({"nw.Shortcut",  IDR_NWAPI_SHORTCUT_JS});
+  resources.push_back({"nw.Obj",       IDR_NWAPI_OBJECT_JS});
+  resources.push_back({"nw.test",      IDR_NWAPI_TEST_JS});
+  resources.push_back({"nw.Tray",      IDR_NWAPI_TRAY_JS});
   return resources;
 }
 
@@ -947,6 +1049,8 @@
 
   // Custom bindings.
   module_system->RegisterNativeHandler(
+      "nw_natives", std::unique_ptr<NativeHandler>(new NWCustomBindings(context)));
+  module_system->RegisterNativeHandler(
       "app_window_natives",
       std::unique_ptr<NativeHandler>(new AppWindowCustomBindings(context)));
   module_system->RegisterNativeHandler(
@@ -1113,6 +1217,29 @@
                            base::Unretained(this), extension->id()));
       }
     }
+    if (extension->GetType() == Manifest::TYPE_NWJS_APP) {
+      const std::string* user_agent;
+      if ((user_agent = extension->manifest()->FindStringPath("user-agent"))) {
+        const std::string* name, *version;
+        name = extension->manifest()->FindStringPath("name");
+        version = extension->manifest()->FindStringPath("version");
+        if (name && version)
+          nw::SetUserAgentOverride(*user_agent, *name, *version);
+      }
+
+      const base::Value* quota_value = extension->manifest()->available_values().FindKey("dom_storage_quota");
+      if (quota_value && quota_value->is_int()) {
+        //content::DOMStorageMap::SetQuotaOverride(dom_storage_quota_mb * 1024 * 1024);
+        g_nw_dom_storage_quota = quota_value->GetInt() * 1024 * 1024;
+      }
+      const std::string* temp_path;
+      if ((temp_path = extension->manifest()->FindStringPath("nw-temp-dir"))) {
+        content::g_nw_temp_dir = base::FilePath::FromUTF8Unsafe(*temp_path);
+      }
+      VLOG(1) << "NW: change working dir: " << extension->path().AsUTF8Unsafe();
+      base::GetCurrentDirectory(&content::g_nw_old_cwd);
+      base::SetCurrentDirectory(extension->path());
+    }
   }
 
   // Update the available bindings for all contexts. These may have changed if
diff -r -u --color up/chromium/extensions/renderer/dispatcher.h nw/chromium/extensions/renderer/dispatcher.h
--- up/chromium/extensions/renderer/dispatcher.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/dispatcher.h	2023-01-28 02:49:29.307628573 +0000
@@ -164,6 +164,7 @@
 
   // This method is not allowed to run JavaScript code in the frame.
   void DidCreateDocumentElement(blink::WebLocalFrame* frame);
+  void DidDispatchDOMContentLoadedEvent(blink::WebLocalFrame* frame);
 
   // These methods may run (untrusted) JavaScript code in the frame, and
   // cause |render_frame| to become invalid.
diff -r -u --color up/chromium/extensions/renderer/extension_frame_helper.cc nw/chromium/extensions/renderer/extension_frame_helper.cc
--- up/chromium/extensions/renderer/extension_frame_helper.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/extension_frame_helper.cc	2023-01-28 02:49:29.307628573 +0000
@@ -4,6 +4,7 @@
 
 #include "extensions/renderer/extension_frame_helper.h"
 
+#include "content/renderer/render_frame_impl.h"
 #include <set>
 
 #include "base/feature_list.h"
@@ -41,6 +42,11 @@
 #include "v8/include/v8-object.h"
 #include "v8/include/v8-primitive.h"
 
+#include "content/nw/src/nw_content.h"
+#include "extensions/renderer/script_context_set.h"
+#include "content/nw/src/renderer/nw_chrome_renderer_hooks.h"
+#include "content/nw/src/renderer/nw_extensions_renderer_hooks.h"
+
 namespace extensions {
 
 namespace {
@@ -71,9 +77,12 @@
   blink::WebSecurityOrigin origin =
       frame_helper->render_frame()->GetWebFrame()->GetSecurityOrigin();
   if (origin.IsOpaque() ||
-      !base::EqualsASCII(origin.Protocol().Utf16(), kExtensionScheme) ||
-      !base::EqualsASCII(origin.Host().Utf16(), match_extension_id.c_str()))
-    return false;
+      !base::EqualsASCII(origin.Protocol().Utf16(), kExtensionScheme) || (!match_extension_id.empty() &&
+      !base::EqualsASCII(origin.Host().Utf16(), match_extension_id.c_str())))
+    if (!(match_extension_id == nw::get_main_extension_id() && 
+          !base::EqualsASCII(origin.Protocol().Utf16(), kExtensionScheme)))
+      //NWJS#5181: getall() with remote window
+      return false;
 
   if (match_window_id != extension_misc::kUnknownWindowId &&
       frame_helper->browser_window_id() != match_window_id)
@@ -184,11 +193,19 @@
     if (!web_frame->IsOutermostMainFrame())
       continue;
 
+#if 0
+    //remote page need to call GetExtensionViews in api_nw_window.js #5312
     if (!blink::WebFrame::ScriptCanAccess(web_frame))
       continue;
+#endif
 
     v8::Local<v8::Context> frame_context = web_frame->MainWorldScriptContext();
     if (!frame_context.IsEmpty()) {
+      if (extension_id.empty()) {
+        ScriptContext* ctx = ScriptContextSet::GetContextByV8Context(frame_context);
+        if (!ctx->extension()->is_nwjs_app())
+          continue;
+      }
       v8::Local<v8::Value> window = frame_context->Global();
       CHECK(!window.IsEmpty());
       v8::Maybe<bool> maybe =
@@ -278,6 +295,13 @@
   did_create_current_document_element_ = true;
   extension_dispatcher_->DidCreateDocumentElement(
       render_frame()->GetWebFrame());
+  nw::DocumentHook2(true, render_frame(), extension_dispatcher_);
+}
+
+void ExtensionFrameHelper::DidDispatchDOMContentLoadedEvent() {
+  extension_dispatcher_->DidDispatchDOMContentLoadedEvent(
+      render_frame()->GetWebFrame());
+  nw::DocumentHook2(false, render_frame(), extension_dispatcher_);
 }
 
 void ExtensionFrameHelper::DidCreateNewDocument() {
@@ -329,11 +353,12 @@
   // document immediately. The chrome.app.window.create() callback (if any)
   // needs to be called prior to the new window's 'load' event. The parser will
   // be resumed when it happens. It doesn't apply to sandboxed pages.
-  if (view_type_ == mojom::ViewType::kAppWindow &&
+  if ((view_type_ == extensions::mojom::ViewType::kAppWindow ||
+       view_type_ == extensions::mojom::ViewType::kTabContents) &&
       render_frame()->GetWebFrame()->IsOutermostMainFrame() &&
-      !has_started_first_navigation_ &&
-      GURL(document_loader->GetUrl()).SchemeIs(kExtensionScheme) &&
-      !ScriptContext::IsSandboxedPage(document_loader->GetUrl())) {
+      !has_started_first_navigation_ && !static_cast<content::RenderFrameImpl*>(render_frame())->skip_blocking_parser_) { // &&
+    //      GURL(document_loader->GetUrl()).SchemeIs(kExtensionScheme) &&
+    //  !ScriptContext::IsSandboxedPage(document_loader->GetUrl())) {
     document_loader->BlockParser();
   }
 
diff -r -u --color up/chromium/extensions/renderer/extension_frame_helper.h nw/chromium/extensions/renderer/extension_frame_helper.h
--- up/chromium/extensions/renderer/extension_frame_helper.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/extension_frame_helper.h	2023-01-28 02:49:29.307628573 +0000
@@ -160,6 +160,7 @@
   void ReadyToCommitNavigation(
       blink::WebDocumentLoader* document_loader) override;
   void DidCommitProvisionalLoad(ui::PageTransition transition) override;
+  void DidDispatchDOMContentLoadedEvent() override;
   void DidCreateScriptContext(v8::Local<v8::Context>,
                               int32_t world_id) override;
   void WillReleaseScriptContext(v8::Local<v8::Context>,
diff -r -u --color up/chromium/extensions/renderer/extension_injection_host.cc nw/chromium/extensions/renderer/extension_injection_host.cc
--- up/chromium/extensions/renderer/extension_injection_host.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/extension_injection_host.cc	2023-01-28 02:49:29.307628573 +0000
@@ -64,7 +64,7 @@
   if (outermost_origin->scheme() == kExtensionScheme &&
       outermost_origin->host() != extension_->id() &&
       !PermissionsData::CanExecuteScriptEverywhere(extension_->id(),
-                                                   extension_->location())) {
+                                                   extension_->location(), extension_->GetType())) {
     return PermissionsData::PageAccess::kDenied;
   }
 
diff -r -u --color up/chromium/extensions/renderer/ipc_message_sender.cc nw/chromium/extensions/renderer/ipc_message_sender.cc
--- up/chromium/extensions/renderer/ipc_message_sender.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/ipc_message_sender.cc	2023-01-28 02:49:29.311628610 +0000
@@ -46,17 +46,25 @@
 
   ~MainThreadIPCMessageSender() override {}
 
-  void SendRequestIPC(ScriptContext* context,
-                      mojom::RequestParamsPtr params) override {
+  void SendRequestIPC(
+      ScriptContext* context,
+      mojom::RequestParamsPtr params,
+      bool sync, bool* success, base::Value::List* response,
+      std::string* error) override {
     content::RenderFrame* frame = context->GetRenderFrame();
     if (!frame)
       return;
 
     int request_id = params->request_id;
+    if (!sync)
     ExtensionFrameHelper::Get(frame)->GetLocalFrameHost()->Request(
         std::move(params),
         base::BindOnce(&MainThreadIPCMessageSender::OnResponse,
                        weak_ptr_factory_.GetWeakPtr(), request_id));
+    else
+      ExtensionFrameHelper::Get(frame)->GetLocalFrameHost()->RequestSync(
+                                                                         std::move(params),
+                                                                         success, response, error);
   }
 
   void SendOnRequestResponseReceivedIPC(int request_id) override {}
@@ -262,7 +270,9 @@
   ~WorkerThreadIPCMessageSender() override {}
 
   void SendRequestIPC(ScriptContext* context,
-                      mojom::RequestParamsPtr params) override {
+                      mojom::RequestParamsPtr params,
+                      bool sync, bool* success, base::Value::List* response,
+                      std::string* error) override {
     DCHECK(!context->GetRenderFrame());
     DCHECK(context->IsForServiceWorker());
     DCHECK_NE(kMainThreadId, content::WorkerThread::GetCurrentId());
diff -r -u --color up/chromium/extensions/renderer/ipc_message_sender.h nw/chromium/extensions/renderer/ipc_message_sender.h
--- up/chromium/extensions/renderer/ipc_message_sender.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/ipc_message_sender.h	2023-01-28 02:49:29.311628610 +0000
@@ -8,6 +8,7 @@
 #include <memory>
 #include <string>
 
+#include "base/values.h"
 #include "extensions/common/extension_id.h"
 #include "extensions/common/mojom/frame.mojom-forward.h"
 #include "extensions/renderer/bindings/api_binding_types.h"
@@ -15,6 +16,7 @@
 struct ExtensionHostMsg_APIActionOrEvent_Params;
 
 namespace base {
+class ListValue;
 class DictionaryValue;
 }
 
@@ -38,8 +40,12 @@
   enum class ActivityLogCallType { APICALL, EVENT };
 
   // Sends a request message to the browser.
-  virtual void SendRequestIPC(ScriptContext* context,
-                              mojom::RequestParamsPtr params) = 0;
+  virtual void SendRequestIPC(
+      ScriptContext* context,
+      mojom::RequestParamsPtr params,
+      bool sync = false,
+      bool* success = nullptr, ::base::Value::List* response = nullptr,
+      std::string* error = nullptr) = 0;
 
   // Handles sending any additional messages required after receiving a response
   // to a request.
diff -r -u --color up/chromium/extensions/renderer/module_system.cc nw/chromium/extensions/renderer/module_system.cc
--- up/chromium/extensions/renderer/module_system.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/module_system.cc	2023-01-28 02:49:29.311628610 +0000
@@ -528,11 +528,11 @@
   CHECK(v8_helpers::IsTrue(maybe));
 }
 
-void ModuleSystem::OnNativeBindingCreated(
+v8::Local<v8::Value> ModuleSystem::OnNativeBindingCreated(
     const std::string& api_name,
     v8::Local<v8::Value> api_bridge_value) {
   DCHECK(!get_internal_api_.IsEmpty());
-  v8::HandleScope scope(GetIsolate());
+  v8::EscapableHandleScope scope(GetIsolate());
   if (source_map_->Contains(api_name)) {
     // We need to load the custom bindings and store them in our modules.
     // Storing them is important so that calls through CallModuleMethod() route
@@ -542,7 +542,7 @@
                     &modules) ||
         !modules->IsObject()) {
       NOTREACHED();
-      return;
+      return v8::Undefined(GetIsolate());
     }
 
     NativesEnabledScope enabled(this);
@@ -550,7 +550,9 @@
         LoadModuleWithNativeAPIBridge(api_name, api_bridge_value);
     SetPrivateProperty(context()->v8_context(), modules.As<v8::Object>(),
                        gin::StringToSymbol(GetIsolate(), api_name), exports);
+    return scope.Escape(exports);
   }
+  return v8::Undefined(GetIsolate());
 }
 
 void ModuleSystem::SetGetInternalAPIHook(
diff -r -u --color up/chromium/extensions/renderer/module_system.h nw/chromium/extensions/renderer/module_system.h
--- up/chromium/extensions/renderer/module_system.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/module_system.h	2023-01-28 02:49:29.311628610 +0000
@@ -126,7 +126,7 @@
   // code to set up various hooks.
   // TODO(devlin): We can get rid of this once we convert all our custom
   // bindings.
-  void OnNativeBindingCreated(const std::string& api_name,
+  v8::Local<v8::Value> OnNativeBindingCreated(const std::string& api_name,
                               v8::Local<v8::Value> api_bridge_value);
 
   void SetGetInternalAPIHook(v8::Local<v8::FunctionTemplate> get_internal_api);
diff -r -u --color up/chromium/extensions/renderer/native_extension_bindings_system.cc nw/chromium/extensions/renderer/native_extension_bindings_system.cc
--- up/chromium/extensions/renderer/native_extension_bindings_system.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/native_extension_bindings_system.cc	2023-01-28 02:49:29.311628610 +0000
@@ -5,6 +5,7 @@
 #include "extensions/renderer/native_extension_bindings_system.h"
 
 #include <utility>
+#include "extensions/common/manifest_constants.h"
 
 #include "base/bind.h"
 #include "base/callback.h"
@@ -69,7 +70,7 @@
 namespace {
 
 const char kBindingsSystemPerContextKey[] = "extension_bindings_system";
-
+bool is_creating_hidden_binding = false;
 // Returns true if the given |api| is a "prefixed" api of the |root_api|; that
 // is, if the api begins with the root.
 // For example, 'app.runtime' is a prefixed api of 'app'.
@@ -104,6 +105,7 @@
   ~BindingsSystemPerContextData() override {}
 
   v8::Global<v8::Object> api_object;
+  v8::Global<v8::Object> hidden_apis;
   v8::Global<v8::Object> internal_apis;
   base::WeakPtr<NativeExtensionBindingsSystem> bindings_system;
 };
@@ -113,7 +115,7 @@
 // If a 'chrome' property exists but isn't an object, returns an empty Local.
 // If no 'chrome' property exists (or is undefined), creates a new
 // object, assigns it to Global().chrome, and returns it.
-v8::Local<v8::Object> GetOrCreateChrome(v8::Local<v8::Context> context) {
+v8::Local<v8::Object> GetOrCreateChrome(v8::Local<v8::Context> context, const char* name = nullptr, bool hidden = false) {
   // Ensure that the creation context for any new chrome object is |context|.
   v8::Context::Scope context_scope(context);
 
@@ -124,7 +126,8 @@
   // On the one hand, anyone writing that code is probably asking for trouble.
   // On the other, it'd be nice to avoid. I wonder if we can?
   v8::Local<v8::String> chrome_string =
-      gin::StringToSymbol(context->GetIsolate(), "chrome");
+    gin::StringToSymbol(context->GetIsolate(), name ? name : "chrome");
+  if (!hidden) {
   v8::Local<v8::Value> chrome_value;
   if (!context->Global()->Get(context, chrome_string).ToLocal(&chrome_value))
     return v8::Local<v8::Object>();
@@ -153,6 +156,26 @@
   }
 
   return chrome_object;
+  } else { //hidden
+    // MUST MATCH Private() in module_system.cc
+    v8::Local<v8::Object> global(context->Global());
+    v8::Local<v8::Value> privates;
+    ScriptContext* script_context = GetScriptContextFromV8ContextChecked(context);
+    if (!script_context->module_system()->GetPrivate(global, "privates", &privates) || !privates->IsObject()) {
+      privates = v8::Object::New(context->GetIsolate());
+      script_context->module_system()->SetPrivate(global, "privates", privates);
+    }
+    v8::Local<v8::Object> priv_obj = v8::Local<v8::Object>::Cast(privates);
+    v8::Local<v8::Value> chrome(priv_obj->Get(context, chrome_string).ToLocalChecked());
+    if (chrome->IsUndefined()) {
+      chrome = v8::Object::New(context->GetIsolate());
+      v8::Local<v8::String> hidden_key(
+                                       v8::String::NewFromUtf8(context->GetIsolate(), "__nw_is_hidden", v8::NewStringType::kNormal).ToLocalChecked());
+      std::ignore = chrome->ToObject(context).ToLocalChecked()->Set(context, hidden_key, v8::Boolean::New(context->GetIsolate(), true));
+      std::ignore = priv_obj->Set(context, chrome_string, chrome);
+    }
+    return chrome->IsObject() ? chrome.As<v8::Object>() : v8::Local<v8::Object>();
+  } //hidden
 }
 
 BindingsSystemPerContextData* GetBindingsDataFromContext(
@@ -199,6 +222,10 @@
 // |context|.
 bool IsAPIFeatureAvailable(v8::Local<v8::Context> context,
                            const std::string& name) {
+  if (is_creating_hidden_binding)
+    if (name.rfind("app.window", 0) == 0 || name.rfind("runtime", 0) == 0 ||
+        name.rfind("nw.Window", 0) == 0)
+    return true;
   ScriptContext* script_context = GetScriptContextFromV8ContextChecked(context);
   return script_context->GetAvailability(name).is_available();
 }
@@ -228,9 +255,20 @@
                            script_context->GetExtensionID(),
                            script_context->GetContextTypeDescription()));
   v8::Local<v8::Value> native_api_bridge = bridge_handle.ToV8();
-  script_context->module_system()->OnNativeBindingCreated(name,
+  v8::Local<v8::Value> exports =
+    script_context->module_system()->OnNativeBindingCreated(name,
                                                           native_api_bridge);
-
+  if (exports->IsObject()) {
+    v8::Local<v8::String> binding_name = gin::StringToSymbol(context->GetIsolate(), "binding");
+    v8::Local<v8::Object> exports_obj;
+    if (exports->ToObject(context).ToLocal(&exports_obj)) {
+      if (exports_obj->HasRealNamedProperty(context, binding_name).FromJust()) {
+        v8::Local<v8::Value> binding = exports_obj->GetRealNamedProperty(context, binding_name).ToLocalChecked();
+        DCHECK(binding->IsObject());
+        return binding.As<v8::Object>();
+      }
+    }
+  }
   return binding_object;
 }
 
@@ -253,11 +291,12 @@
     ScriptContext* script_context,
     APIBindingsSystem* bindings_system,
     const FeatureProvider* api_feature_provider,
-    const std::string& root_name) {
+    const std::string& root_name, bool hidden = false) {
   const FeatureMap& features = api_feature_provider->GetAllFeatures();
   auto lower = features.lower_bound(root_name);
   DCHECK(lower != features.end());
 
+  is_creating_hidden_binding = hidden;
   // Some bindings have a prefixed name, like app.runtime, where 'app' and
   // 'app.runtime' are, in fact, separate APIs. It's also possible for a
   // context to have access to 'app.runtime', but not to 'app'. For this, we
@@ -267,7 +306,8 @@
   if (lower->first == root_name) {
     const Feature* feature = lower->second.get();
     if (script_context->IsAnyFeatureAvailableToContext(
-            *feature, CheckAliasStatus::NOT_ALLOWED)) {
+        *feature, CheckAliasStatus::NOT_ALLOWED) ||
+        (hidden && (root_name == "app.window" || root_name == "runtime" || root_name == "nw.Window"))) {
       // If this feature is an alias for a different API, use the other binding
       // as the basis for the API contents.
       const std::string& source_name =
@@ -310,6 +350,8 @@
   // entered.
   for (auto iter = lower; iter != features.end() && iter->first < upper;
        ++iter) {
+    //if (iter->first.substr(0, 3) == "nw." && !nodejs_enabled)
+    //  continue;
     if (iter->second->IsInternal())
       continue;
 
@@ -329,7 +371,7 @@
 
     v8::Local<v8::Object> nested_binding =
         CreateFullBinding(context, script_context, bindings_system,
-                          api_feature_provider, std::string(binding_name));
+                          api_feature_provider, std::string(binding_name), hidden);
     // It's possible that we don't create a binding if no features or
     // prefixed features are available to the context.
     if (nested_binding.IsEmpty())
@@ -349,10 +391,13 @@
         gin::StringToSymbol(context->GetIsolate(), accessor_name);
     v8::Maybe<bool> success =
         root_binding->CreateDataProperty(context, nested_name, nested_binding);
-    if (!success.IsJust() || !success.FromJust())
+    if (!success.IsJust() || !success.FromJust()) {
+      is_creating_hidden_binding = false;
       return v8::Local<v8::Object>();
+    }
   }
 
+  is_creating_hidden_binding = false;
   return root_binding;
 }
 
@@ -498,7 +543,9 @@
   v8::Isolate* isolate = context->isolate();
   v8::HandleScope handle_scope(isolate);
   v8::Local<v8::Context> v8_context = context->v8_context();
-  v8::Local<v8::Object> chrome = GetOrCreateChrome(v8_context);
+  v8::Local<v8::Object> chrome = GetOrCreateChrome(v8_context, nullptr);
+  v8::Local<v8::Object> chrome_hidden = GetOrCreateChrome(v8_context, nullptr, true);
+  v8::Local<v8::Object> nw_obj;
   if (chrome.IsEmpty())
     return;
 
@@ -513,6 +560,42 @@
     return success.IsJust() && success.FromJust();
   };
 
+  auto set_accessor_hidden = [chrome_hidden, isolate,
+    v8_context](base::StringPiece accessor_name) {
+    v8::Local<v8::String> api_name =
+      gin::StringToSymbol(isolate, accessor_name);
+    v8::Maybe<bool> success = chrome_hidden->SetLazyDataProperty(
+      v8_context, api_name, &BindingAccessorHidden, api_name);
+    return success.IsJust() && success.FromJust();
+  };
+
+  bool nodejs_enabled = false;
+  if (context->extension()) {
+    nodejs_enabled = context->extension()->is_nwjs_app();
+    nodejs_enabled = context->extension()->manifest()->
+      FindBoolPath(manifest_keys::kNWJSEnableNode).value_or(nodejs_enabled);
+  }
+
+  const base::CommandLine& command_line = *base::CommandLine::ForCurrentProcess();
+  bool hidden_nw = true;
+  if (nodejs_enabled &&
+    (context->context_type() == Feature::BLESSED_EXTENSION_CONTEXT ||
+      context->context_type() == Feature::BLESSED_WEB_PAGE_CONTEXT ||
+     command_line.HasSwitch("nwjs-guest-nw")))
+    hidden_nw = false;
+  nw_obj = GetOrCreateChrome(v8_context, "nw", hidden_nw);
+
+  auto set_accessor_nw = [nw_obj, isolate,
+                          v8_context, hidden_nw](base::StringPiece accessor_name) {
+    v8::Local<v8::String> api_name =
+        gin::StringToSymbol(isolate, accessor_name);
+    v8::Local<v8::String> api_full_name =
+      gin::StringToSymbol(isolate, std::string("nw.") + std::string(accessor_name));
+    v8::Maybe<bool> success = nw_obj->SetLazyDataProperty(
+       v8_context, api_name, hidden_nw ? &BindingAccessorHidden : &BindingAccessor, api_full_name);
+    return success.IsJust() && success.FromJust();
+  };
+
   auto set_restricted_accessor = [chrome, isolate,
                                   v8_context](base::StringPiece accessor_name) {
     v8::Local<v8::String> api_name =
@@ -523,6 +606,7 @@
   };
 
   bool is_webpage = false;
+
   switch (context->context_type()) {
     case Feature::UNSPECIFIED_CONTEXT:
     case Feature::WEB_PAGE_CONTEXT:
@@ -558,6 +642,10 @@
     // Runtime is special (see IsRuntimeAvailableToContext()).
     if (IsRuntimeAvailableToContext(context) && !set_accessor("runtime"))
       LOG(ERROR) << "Failed to create API on Chrome object.";
+    
+    set_accessor_hidden("app");
+    set_accessor_hidden("runtime");
+    set_accessor_nw("Window");
 
     UpdateContentCapabilities(context);
     return;
@@ -585,6 +673,19 @@
     // as if we need to remove any existing APIs?
     base::StringPiece accessor_name =
         GetFirstDifferentAPIName(feature, base::StringPiece());
+    if (accessor_name.substr(0, 3) == "nw." && nw_obj.IsEmpty())
+      continue;
+    if (feature.substr(0, 3) == "nw.") {
+      if (hidden_nw && feature != "nw.Window")
+        continue;
+      std::string api_name = feature.substr(3);
+      accessor_name = api_name;
+      if (!set_accessor_nw(accessor_name)) {
+        LOG(ERROR) << "Failed to create API on NW object.";
+        return;
+      }
+      continue;
+    }
     last_accessor = accessor_name;
     if (!set_accessor(accessor_name)) {
       LOG(ERROR) << "Failed to create API on Chrome object.";
@@ -669,9 +770,9 @@
 
 v8::Local<v8::Object> NativeExtensionBindingsSystem::GetAPIObjectForTesting(
     ScriptContext* context,
-    const std::string& api_name) {
+    const std::string& api_name, bool hidden) {
   return GetAPIHelper(context->v8_context(),
-                      gin::StringToSymbol(context->isolate(), api_name));
+                      gin::StringToSymbol(context->isolate(), api_name), hidden);
 }
 
 void NativeExtensionBindingsSystem::BindingAccessor(
@@ -694,6 +795,26 @@
   if (!binding.IsEmpty())
     info.GetReturnValue().Set(binding);
 }
+void NativeExtensionBindingsSystem::BindingAccessorHidden(
+    v8::Local<v8::Name> name,
+    const v8::PropertyCallbackInfo<v8::Value>& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> context = info.Holder()->GetCreationContextChecked();
+
+  // Force binding creation in the owning context (even if another context is
+  // calling in). This is also important to ensure that objects created through
+  // the initialization process are all instantiated for the owning context.
+  // See https://crbug.com/819968.
+  v8::Context::Scope context_scope(context);
+
+  // We use info.Data() to store a real name here instead of using the provided
+  // one to handle any weirdness from the caller (non-existent strings, etc).
+  v8::Local<v8::String> api_name = info.Data().As<v8::String>();
+  v8::Local<v8::Object> binding = GetAPIHelper(context, api_name, true);
+  if (!binding.IsEmpty())
+    info.GetReturnValue().Set(binding);
+}
 
 void NativeExtensionBindingsSystem::ThrowDeveloperModeRestrictedError(
     v8::Local<v8::Name> name,
@@ -710,19 +831,28 @@
 // static
 v8::Local<v8::Object> NativeExtensionBindingsSystem::GetAPIHelper(
     v8::Local<v8::Context> context,
-    v8::Local<v8::String> api_name) {
+    v8::Local<v8::String> api_name, bool hidden) {
   BindingsSystemPerContextData* data = GetBindingsDataFromContext(context);
   if (!data)
     return v8::Local<v8::Object>();
 
   v8::Isolate* isolate = context->GetIsolate();
   v8::Local<v8::Object> apis;
+  if (hidden) {
+  if (data->hidden_apis.IsEmpty()) {
+    apis = v8::Object::New(isolate);
+    data->hidden_apis = v8::Global<v8::Object>(isolate, apis);
+  } else {
+    apis = data->hidden_apis.Get(isolate);
+  }
+  } else { //hidden
   if (data->api_object.IsEmpty()) {
     apis = v8::Object::New(isolate);
     data->api_object = v8::Global<v8::Object>(isolate, apis);
   } else {
     apis = data->api_object.Get(isolate);
   }
+  }
 
   v8::Maybe<bool> has_property = apis->HasRealNamedProperty(context, api_name);
   if (!has_property.IsJust())
@@ -743,7 +873,7 @@
   base::ElapsedTimer timer;
   v8::Local<v8::Object> root_binding = CreateFullBinding(
       context, script_context, &data->bindings_system->api_system_,
-      FeatureProvider::GetAPIFeatures(), api_name_string);
+      FeatureProvider::GetAPIFeatures(), api_name_string, hidden);
   if (root_binding.IsEmpty())
     return v8::Local<v8::Object>();
 
@@ -809,13 +939,14 @@
   std::string api_name = gin::V8ToString(isolate, info[0]);
   const Feature* feature = FeatureProvider::GetAPIFeature(api_name);
   ScriptContext* script_context = GetScriptContextFromV8ContextChecked(context);
+  if (api_name != "nw.Window")
   if (!feature || !script_context->IsAnyFeatureAvailableToContext(
                       *feature, CheckAliasStatus::NOT_ALLOWED)) {
     NOTREACHED();
     return;
   }
 
-  CHECK(feature->IsInternal());
+  //CHECK(feature->IsInternal());
 
   // We don't need to go through CreateFullBinding here because internal APIs
   // are always acquired through getInternalBinding and specified by full name,
@@ -862,7 +993,9 @@
   params->service_worker_version_id =
       blink::mojom::kInvalidServiceWorkerVersionId;
 
-  ipc_message_sender_->SendRequestIPC(script_context, std::move(params));
+  ipc_message_sender_->SendRequestIPC(script_context, std::move(params),
+                                      request->sync, request->success,
+                                      request->response, request->error);
 }
 
 void NativeExtensionBindingsSystem::OnEventListenerChanged(
diff -r -u --color up/chromium/extensions/renderer/native_extension_bindings_system.h nw/chromium/extensions/renderer/native_extension_bindings_system.h
--- up/chromium/extensions/renderer/native_extension_bindings_system.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/native_extension_bindings_system.h	2023-01-28 02:49:29.311628610 +0000
@@ -96,7 +96,7 @@
   // Returns the API with the given |name| for the given |context|. Used for
   // testing purposes.
   v8::Local<v8::Object> GetAPIObjectForTesting(ScriptContext* context,
-                                               const std::string& api_name);
+                                               const std::string& api_name, bool hidden = false);
 
  private:
   // Handles sending a given |request|, forwarding it on to the send_ipc_ after
@@ -115,6 +115,8 @@
   // Getter callback for an extension API, since APIs are constructed lazily.
   static void BindingAccessor(v8::Local<v8::Name> name,
                               const v8::PropertyCallbackInfo<v8::Value>& info);
+  static void BindingAccessorHidden(v8::Local<v8::Name> name,
+                              const v8::PropertyCallbackInfo<v8::Value>& info);
 
   // Callback for accessing a restricted extension API. Access to the API is
   // restricted to the developer mode only.
@@ -124,7 +126,7 @@
 
   // Creates and returns the API binding for the given |name|.
   static v8::Local<v8::Object> GetAPIHelper(v8::Local<v8::Context> context,
-                                            v8::Local<v8::String> name);
+                                            v8::Local<v8::String> name, bool hidden = false);
 
   // Gets the chrome.runtime API binding.
   static v8::Local<v8::Object> GetLastErrorParents(
diff -r -u --color up/chromium/extensions/renderer/object_backed_native_handler.cc nw/chromium/extensions/renderer/object_backed_native_handler.cc
--- up/chromium/extensions/renderer/object_backed_native_handler.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/object_backed_native_handler.cc	2023-01-28 02:49:29.311628610 +0000
@@ -107,7 +107,11 @@
         *v8::String::Utf8Value(isolate, feature_name_string);
     // TODO(devlin): Eventually, we should fail if either script_context is null
     // or feature_name is empty.
-    if (script_context && !feature_name.empty()) {
+
+    // remote pages need to call
+    // renderFrameObserverNatives.OnDocumentElementCreated() in
+    // the end of api_nw_window.js NWJS#5312
+    if (script_context && !feature_name.empty() && feature_name != "app.window") {
       Feature::Availability availability =
           script_context->GetAvailability(feature_name);
       if (!availability.is_available()) {
diff -r -u --color up/chromium/extensions/renderer/object_backed_native_handler.h nw/chromium/extensions/renderer/object_backed_native_handler.h
--- up/chromium/extensions/renderer/object_backed_native_handler.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/object_backed_native_handler.h	2023-01-28 02:49:29.311628610 +0000
@@ -79,6 +79,7 @@
                                      const v8::Local<v8::Object>& object,
                                      bool allow_null_context);
 
+ public:
   // The following methods are convenience wrappers for methods on v8::Object
   // with the corresponding names.
   // Returns whether or not setting privates was successful.
diff -r -u --color up/chromium/extensions/renderer/programmatic_script_injector.cc nw/chromium/extensions/renderer/programmatic_script_injector.cc
--- up/chromium/extensions/renderer/programmatic_script_injector.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/programmatic_script_injector.cc	2023-01-28 02:49:29.311628610 +0000
@@ -39,6 +39,10 @@
   return mojom::InjectionType::kProgrammaticScript;
 }
 
+bool ProgrammaticScriptInjector::ShouldExecuteInMainWorld() const {
+  return params_->in_main_world;
+}
+
 blink::mojom::UserActivationOption ProgrammaticScriptInjector::IsUserGesture()
     const {
   DCHECK(params_->injection->is_js());
diff -r -u --color up/chromium/extensions/renderer/programmatic_script_injector.h nw/chromium/extensions/renderer/programmatic_script_injector.h
--- up/chromium/extensions/renderer/programmatic_script_injector.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/programmatic_script_injector.h	2023-01-28 02:49:29.311628610 +0000
@@ -35,6 +35,7 @@
   // ScriptInjector implementation.
   mojom::InjectionType script_type() const override;
   blink::mojom::UserActivationOption IsUserGesture() const override;
+  bool ShouldExecuteInMainWorld() const override;
   mojom::ExecutionWorld GetExecutionWorld() const override;
   mojom::CSSOrigin GetCssOrigin() const override;
   mojom::CSSInjection::Operation GetCSSInjectionOperation() const override;
diff -r -u --color up/chromium/extensions/renderer/render_frame_observer_natives.cc nw/chromium/extensions/renderer/render_frame_observer_natives.cc
--- up/chromium/extensions/renderer/render_frame_observer_natives.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/render_frame_observer_natives.cc	2023-01-28 02:49:29.311628610 +0000
@@ -18,6 +18,8 @@
 #include "v8/include/v8-function.h"
 #include "v8/include/v8-primitive.h"
 
+#include "extensions/renderer/script_context_set.h"
+
 namespace extensions {
 
 namespace {
@@ -26,17 +28,24 @@
 class LoadWatcher : public content::RenderFrameObserver {
  public:
   LoadWatcher(content::RenderFrame* frame,
-              base::OnceCallback<void(bool)> callback)
-      : content::RenderFrameObserver(frame), callback_(std::move(callback)) {}
+              base::OnceCallback<void(bool, int)> callback, bool wait_for_next = false)
+    : content::RenderFrameObserver(frame), callback_(std::move(callback)), wait_for_next_(wait_for_next) {}
 
   LoadWatcher(const LoadWatcher&) = delete;
   LoadWatcher& operator=(const LoadWatcher&) = delete;
 
   void DidCreateDocumentElement() override {
+    if (wait_for_next_) {
+      base::ThreadTaskRunnerHandle::Get()->PostTask(FROM_HERE,
+                                             base::BindOnce(&LoadWatcher::DidCreateDocumentElement, base::Unretained(this)));
+      wait_for_next_ = false;
+      return;
+    }
     // Defer the callback instead of running it now to avoid re-entrancy caused
     // by the JavaScript callback.
+    int id = routing_id();
     ExtensionFrameHelper::Get(render_frame())
-        ->ScheduleAtDocumentStart(base::BindOnce(std::move(callback_), true));
+      ->ScheduleAtDocumentStart(base::BindOnce(std::move(callback_), true, id));
     delete this;
   }
 
@@ -44,14 +53,52 @@
     // Use PostTask to avoid running user scripts while handling this
     // DidFailProvisionalLoad notification.
     base::ThreadTaskRunnerHandle::Get()->PostTask(
-        FROM_HERE, base::BindOnce(std::move(callback_), false));
+                                                  FROM_HERE, base::BindOnce(std::move(callback_), false, routing_id()));
     delete this;
   }
 
   void OnDestruct() override { delete this; }
 
  private:
-  base::OnceCallback<void(bool)> callback_;
+  base::OnceCallback<void(bool, int)> callback_;
+  bool wait_for_next_;
+};
+
+class CloseWatcher : public content::RenderFrameObserver {
+ public:
+  CloseWatcher(ScriptContext* context,
+               content::RenderFrame* frame,
+               v8::Local<v8::Function> cb)
+      : content::RenderFrameObserver(frame),
+        context_(context->weak_factory_.GetWeakPtr()),
+        callback_(context->isolate(), cb)
+  {
+  }
+
+  void OnDestruct() override {
+    base::ThreadTaskRunnerHandle::Get()->PostTask(
+          FROM_HERE,
+          base::BindOnce(&CloseWatcher::CallbackAndDie, base::Unretained(this),
+                     routing_id()));
+  }
+
+ private:
+  void CallbackAndDie(int routing_id) {
+    if (context_ && context_->is_valid()) {
+      // context_ was deleted when running
+      // issue4007-reload-lost-app-window in test framework
+      v8::Isolate* isolate = context_->isolate();
+      v8::HandleScope handle_scope(isolate);
+      v8::Local<v8::Value> args[] = {v8::Integer::New(isolate, routing_id)};
+      context_->SafeCallFunction(v8::Local<v8::Function>::New(isolate, callback_),
+                                 std::size(args), args);
+    }
+    delete this;
+  }
+
+  base::WeakPtr<ScriptContext> context_;
+  v8::Global<v8::Function> callback_;
+
 };
 
 }  // namespace
@@ -66,6 +113,10 @@
       "OnDocumentElementCreated", "app.window",
       base::BindRepeating(&RenderFrameObserverNatives::OnDocumentElementCreated,
                           base::Unretained(this)));
+  RouteHandlerFunction(
+      "OnDestruct",
+      base::BindRepeating(&RenderFrameObserverNatives::OnDestruct,
+                 base::Unretained(this)));
 }
 
 void RenderFrameObserverNatives::Invalidate() {
@@ -75,9 +126,11 @@
 
 void RenderFrameObserverNatives::OnDocumentElementCreated(
     const v8::FunctionCallbackInfo<v8::Value>& args) {
-  CHECK(args.Length() == 2);
   CHECK(args[0]->IsInt32());
   CHECK(args[1]->IsFunction());
+  bool wait_for_next = false;
+  if (args.Length() > 2)
+    wait_for_next = args[2].As<v8::Boolean>()->Value();
 
   int frame_id = args[0].As<v8::Int32>()->Value();
 
@@ -92,14 +145,14 @@
   auto callback(base::BindOnce(&RenderFrameObserverNatives::InvokeCallback,
                                weak_ptr_factory_.GetWeakPtr(),
                                std::move(v8_callback)));
-  if (ExtensionFrameHelper::Get(frame)->did_create_current_document_element()) {
+  if (!wait_for_next && ExtensionFrameHelper::Get(frame)->did_create_current_document_element()) {
     // If the document element is already created, then we can call the callback
     // immediately (though use PostTask to ensure that the callback is called
     // asynchronously).
     base::ThreadTaskRunnerHandle::Get()->PostTask(
-        FROM_HERE, base::BindOnce(std::move(callback), true));
+                                                  FROM_HERE, base::BindOnce(std::move(callback), true, frame_id));
   } else {
-    new LoadWatcher(frame, std::move(callback));
+    new LoadWatcher(frame, std::move(callback), wait_for_next);
   }
 
   args.GetReturnValue().Set(true);
@@ -107,12 +160,37 @@
 
 void RenderFrameObserverNatives::InvokeCallback(
     v8::Global<v8::Function> callback,
-    bool succeeded) {
+    bool succeeded, int frame_id) {
   v8::Isolate* isolate = context()->isolate();
   v8::HandleScope handle_scope(isolate);
-  v8::Local<v8::Value> args[] = {v8::Boolean::New(isolate, succeeded)};
+  v8::Local<v8::Value> args[] = {v8::Boolean::New(isolate, succeeded), v8::Integer::New(isolate, frame_id)};
   context()->SafeCallFunction(v8::Local<v8::Function>::New(isolate, callback),
                               std::size(args), args);
 }
 
+void RenderFrameObserverNatives::OnDestruct(
+    const v8::FunctionCallbackInfo<v8::Value>& args) {
+  CHECK(args[0]->IsInt32());
+  CHECK(args[1]->IsFunction());
+  int frame_id = args[0].As<v8::Int32>()->Value();
+
+  content::RenderFrame* frame = content::RenderFrame::FromRoutingID(frame_id);
+  if (!frame) {
+    LOG(WARNING) << "No render frame found to register CloseWatcher. " << frame_id;
+    return;
+  }
+
+  v8::Local<v8::Function> func = args[1].As<v8::Function>();
+  v8::Local<v8::Context> v8_context;
+  if (!func->GetCreationContext().ToLocal(&v8_context)) {
+    args.GetReturnValue().Set(false);
+    return;
+  }
+  ScriptContext* context = ScriptContextSet::GetContextByV8Context(v8_context);
+  new CloseWatcher(context, frame, args[1].As<v8::Function>());
+
+  args.GetReturnValue().Set(true);
+}
+
+
 }  // namespace extensions
diff -r -u --color up/chromium/extensions/renderer/render_frame_observer_natives.h nw/chromium/extensions/renderer/render_frame_observer_natives.h
--- up/chromium/extensions/renderer/render_frame_observer_natives.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/render_frame_observer_natives.h	2023-01-28 02:49:29.311628610 +0000
@@ -35,9 +35,13 @@
   void OnDocumentElementCreated(
       const v8::FunctionCallbackInfo<v8::Value>& args);
 
-  void InvokeCallback(v8::Global<v8::Function> callback, bool succeeded);
+  void InvokeCallback(v8::Global<v8::Function> callback, bool succeeded, int frame_id);
 
   base::WeakPtrFactory<RenderFrameObserverNatives> weak_ptr_factory_{this};
+
+  void OnDestruct(
+      const v8::FunctionCallbackInfo<v8::Value>& args);
+
 };
 
 }  // namespace extensions
diff -r -u --color up/chromium/extensions/renderer/resources/app_window_custom_bindings.js nw/chromium/extensions/renderer/resources/app_window_custom_bindings.js
--- up/chromium/extensions/renderer/resources/app_window_custom_bindings.js	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/resources/app_window_custom_bindings.js	2023-01-28 02:49:29.311628610 +0000
@@ -20,8 +20,23 @@
 var Bounds = function(boundsKey) {
   privates(this).boundsKey_ = boundsKey;
 };
+
+var try_hidden = function (view) {
+  if (view.chrome.app.window)
+    return view;
+  return privates(view);
+};
+
+var try_nw = function (view) {
+  if (view.nw)
+    return view;
+  return privates(view);
+};
+
 Object.defineProperty(Bounds.prototype, 'left', {
   get: function() {
+    if (!privates(this)) //NWJS#6553
+      return 0;
     return appWindowData[privates(this).boundsKey_].left;
   },
   set: function(left) {
@@ -31,6 +46,8 @@
 });
 Object.defineProperty(Bounds.prototype, 'top', {
   get: function() {
+    if (!privates(this)) //NWJS#6553
+      return 0;
     return appWindowData[privates(this).boundsKey_].top;
   },
   set: function(top) {
@@ -40,6 +57,8 @@
 });
 Object.defineProperty(Bounds.prototype, 'width', {
   get: function() {
+    if (!privates(this)) //NWJS#6553
+      return 0;
     return appWindowData[privates(this).boundsKey_].width;
   },
   set: function(width) {
@@ -49,6 +68,8 @@
 });
 Object.defineProperty(Bounds.prototype, 'height', {
   get: function() {
+    if (!privates(this)) //NWJS#6553
+      return 0;
     return appWindowData[privates(this).boundsKey_].height;
   },
   set: function(height) {
@@ -58,36 +79,52 @@
 });
 Object.defineProperty(Bounds.prototype, 'minWidth', {
   get: function() {
+    if (!privates(this)) //NWJS#6553
+      return 0;
     return appWindowData[privates(this).boundsKey_].minWidth;
   },
   set: function(minWidth) {
+    if (!privates(this)) //NWJS#6553
+      return;
     updateSizeConstraints(privates(this).boundsKey_, { minWidth: minWidth });
   },
   enumerable: true
 });
 Object.defineProperty(Bounds.prototype, 'maxWidth', {
   get: function() {
+    if (!privates(this)) //NWJS#6553
+      return 0;
     return appWindowData[privates(this).boundsKey_].maxWidth;
   },
   set: function(maxWidth) {
+    if (!privates(this)) //NWJS#6553
+      return;
     updateSizeConstraints(privates(this).boundsKey_, { maxWidth: maxWidth });
   },
   enumerable: true
 });
 Object.defineProperty(Bounds.prototype, 'minHeight', {
   get: function() {
+    if (!privates(this)) //NWJS#6553
+      return 0;
     return appWindowData[privates(this).boundsKey_].minHeight;
   },
   set: function(minHeight) {
+    if (!privates(this)) //NWJS#6553
+      return;
     updateSizeConstraints(privates(this).boundsKey_, { minHeight: minHeight });
   },
   enumerable: true
 });
 Object.defineProperty(Bounds.prototype, 'maxHeight', {
   get: function() {
+    if (!privates(this)) //NWJS#6553
+      return 0;
     return appWindowData[privates(this).boundsKey_].maxHeight;
   },
   set: function(maxHeight) {
+    if (!privates(this)) //NWJS#6553
+      return;
     updateSizeConstraints(privates(this).boundsKey_, { maxHeight: maxHeight });
   },
   enumerable: true
@@ -128,7 +165,7 @@
     if (windowParams.existingWindow) {
       // Not creating a new window, but activating an existing one, so trigger
       // callback with existing window and don't do anything else.
-      let windowResult = view ? view.chrome.app.window.current() : undefined;
+      let windowResult = view ? try_hidden(view).chrome.app.window.current() : undefined;
       maybeCallback(windowResult);
       return;
     }
@@ -142,7 +179,7 @@
             ' The chrome.app.window.create callback will be called, but ' +
             'there will be no object provided for the sandboxed window.';
       }
-      console.warn(sandbox_window_message);
+      //console.warn(sandbox_window_message);
       maybeCallback(undefined);
       return;
     }
@@ -150,20 +187,27 @@
     // Handle error pages.
     // TODO(arthursonzogni): Figure out why view.chrome.app is defined for error
     // pages and stop doing it.
-    if (!view.chrome.app.window) {
+    if (!try_hidden(view).chrome.app.window) {
       maybeCallback(undefined);
       return;
     }
 
     // Initialize appWindowData in the newly created JS context
-    view.chrome.app.window.initializeAppWindow(windowParams);
+    try_hidden(view).chrome.app.window.initializeAppWindow(windowParams);
 
     var willCallback = renderFrameObserverNatives.OnDocumentElementCreated(
-        windowParams.frameId, function(success) {
-          let windowResult = success ? view.chrome.app.window.current()
-                                     : undefined;
-          maybeCallback(windowResult);
-        });
+      windowParams.frameId, function(success) {
+        if (success) {
+          var appwin = try_hidden(view).chrome.app.window.current();
+          if (!appwin) {
+            try_hidden(view).chrome.app.window.initializeAppWindow(windowParams);
+            appwin = try_hidden(view).chrome.app.window.current();
+          }
+        }
+        let windowResult = success ? appwin
+                : undefined;
+        maybeCallback(windowResult);
+      });
     appWindowNatives.ResumeParser(windowParams.frameId);
     if (!willCallback)
       maybeCallback(undefined);
@@ -171,8 +215,6 @@
 
   apiFunctions.setHandleRequest('current', function() {
     if (!currentAppWindow) {
-      console.error('The JavaScript context calling ' +
-                    'chrome.app.window.current() has no associated AppWindow.');
       return null;
     }
     return currentAppWindow;
@@ -196,7 +238,12 @@
       return true;
     });
     return $Array.map(views, function(win) {
-      return win.chrome.app.window.current();
+      try {
+        if (try_nw(win).nw) //check for undefined case in NWJS#5528
+          try_nw(win).nw.Window.get(); //construct the window object for NWJS#5294
+      } catch (e) { //NWJS#7310
+      }
+      return try_hidden(win).chrome.app.window.current();
     });
   });
 
@@ -253,6 +300,9 @@
     AppWindow.prototype.isFullscreen = function() {
       return appWindowData.fullscreen;
     };
+    AppWindow.prototype.isResizable = function() {
+      return appWindowData.resizable;
+    };
     AppWindow.prototype.isMinimized = function() {
       return appWindowData.minimized;
     };
@@ -314,6 +364,7 @@
       minimized: params.minimized,
       maximized: params.maximized,
       alwaysOnTop: params.alwaysOnTop,
+      resizable: params.resizable,
       hasFrameColor: params.hasFrameColor,
       activeFrameColor: params.activeFrameColor,
       inactiveFrameColor: params.inactiveFrameColor,
@@ -330,6 +381,18 @@
           bounds1.width == bounds2.width && bounds1.height == bounds2.height);
 }
 
+function sizeEqual(bounds1, bounds2) {
+  if (!bounds1 || !bounds2)
+    return false;
+  return (bounds1.width == bounds2.width && bounds1.height == bounds2.height);
+}
+
+function posEqual(bounds1, bounds2) {
+  if (!bounds1 || !bounds2)
+    return false;
+  return (bounds1.left == bounds2.left && bounds1.top == bounds2.top);
+}
+
 function dispatchEventIfExists(target, name) {
   // Sometimes apps like to put their own properties on the window which
   // break our assumptions.
@@ -350,8 +413,20 @@
 
   var currentWindow = currentAppWindow;
 
-  if (!boundsEqual(oldData.innerBounds, update.innerBounds))
+  if (!boundsEqual(oldData.innerBounds, update.innerBounds)) {
     dispatchEventIfExists(currentWindow, "onBoundsChanged");
+    if (!sizeEqual(oldData.innerBounds, update.innerBounds))
+      dispatchEventIfExists(currentWindow, "onResized");
+    if (!posEqual(oldData.innerBounds, update.innerBounds))
+      dispatchEventIfExists(currentWindow, "onMoved");
+  }
+
+  // NW fix: fire onRestored earlier than fullscreen/minimize/maximize
+  // events. See nwjs/nw.js#5388.
+  if ((oldData.fullscreen && !update.fullscreen) ||
+      (oldData.minimized && !update.minimized) ||
+      (oldData.maximized && !update.maximized))
+    dispatchEventIfExists(currentWindow, "onRestored");
 
   if (!oldData.fullscreen && update.fullscreen)
     dispatchEventIfExists(currentWindow, "onFullscreened");
@@ -360,11 +435,6 @@
   if (!oldData.maximized && update.maximized)
     dispatchEventIfExists(currentWindow, "onMaximized");
 
-  if ((oldData.fullscreen && !update.fullscreen) ||
-      (oldData.minimized && !update.minimized) ||
-      (oldData.maximized && !update.maximized))
-    dispatchEventIfExists(currentWindow, "onRestored");
-
   if (oldData.alphaEnabled !== update.alphaEnabled)
     dispatchEventIfExists(currentWindow, "onAlphaEnabledChanged");
 };
diff -r -u --color up/chromium/extensions/renderer/resources/extensions_renderer_resources.grd nw/chromium/extensions/renderer/resources/extensions_renderer_resources.grd
--- up/chromium/extensions/renderer/resources/extensions_renderer_resources.grd	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/resources/extensions_renderer_resources.grd	2023-01-28 02:49:29.315628647 +0000
@@ -73,6 +73,21 @@
 
       <!-- Extension styles. -->
       <include name="IDR_EXTENSION_FONTS_CSS" file="extension_fonts.css" type="BINDATA"/>
+
+      <include name="IDR_NW_PRE13_SHIM_JS"    file="../../../content/nw/src/resources/nw_pre13_shim.js" compress="false" type="BINDATA" />
+      <include name="IDR_NWAPI_APP_JS"    file="../../../content/nw/src/resources/api_nw_app.js" type="BINDATA" />
+      <include name="IDR_NWAPI_WINDOW_JS" file="../../../content/nw/src/resources/api_nw_window.js" type="BINDATA" />
+      <include name="IDR_NWAPI_WINDOW_INTERNAL_JS" file="../../../content/nw/src/resources/api_window_internal.js" type="BINDATA" />
+      <include name="IDR_NWAPI_NEWWIN_JS" file="../../../content/nw/src/resources/api_nw_newwin.js" type="BINDATA" />
+      <include name="IDR_NWAPI_CLIPBOARD_JS" file="../../../content/nw/src/resources/api_nw_clipboard.js" type="BINDATA" />
+      <include name="IDR_NWAPI_MENU_JS" file="../../../content/nw/src/resources/api_nw_menu.js" type="BINDATA" />
+      <include name="IDR_NWAPI_MENUITEM_JS" file="../../../content/nw/src/resources/api_nw_menuitem.js" type="BINDATA" />
+      <include name="IDR_NWAPI_SCREEN_JS" file="../../../content/nw/src/resources/api_nw_screen.js" type="BINDATA" />
+      <include name="IDR_NWAPI_SHORTCUT_JS" file="../../../content/nw/src/resources/api_nw_shortcut.js" type="BINDATA" />
+      <include name="IDR_NWAPI_SHELL_JS" file="../../../content/nw/src/resources/api_nw_shell.js" type="BINDATA" />
+      <include name="IDR_NWAPI_OBJECT_JS" file="../../../content/nw/src/resources/api_nw_object.js" type="BINDATA" />
+      <include name="IDR_NWAPI_TEST_JS" file="../../../content/nw/src/resources/api_nw_test.js" type="BINDATA" />
+      <include name="IDR_NWAPI_TRAY_JS" file="../../../content/nw/src/resources/api_nw_tray.js" type="BINDATA" />
     </includes>
     <structures>
       <!-- Platform app support. -->
diff -r -u --color up/chromium/extensions/renderer/resources/guest_view/guest_view_container_element.js nw/chromium/extensions/renderer/resources/guest_view/guest_view_container_element.js
--- up/chromium/extensions/renderer/resources/guest_view/guest_view_container_element.js	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/resources/guest_view/guest_view_container_element.js	2023-01-28 02:49:29.315628647 +0000
@@ -64,12 +64,17 @@
     GuestViewContainerElement.prototype.attributeChangedCallback =
         customElementCallbacks.attributeChangedCallback;
 
+    try {
     $CustomElementRegistry.define(
         window.customElements, $String.toLowerCase(elementName),
         containerElementType);
     $Object.defineProperty(window, elementName, {
       value: containerElementType,
     });
+    } catch (e) {
+       // GuestView is being registered in isolated world in
+       // content script sometimes //NWJS#7087
+    }
 
     delete GuestViewContainerElement.prototype.connectedCallback;
     delete GuestViewContainerElement.prototype.disconnectedCallback;
diff -r -u --color up/chromium/extensions/renderer/resources/guest_view/web_view/web_view.js nw/chromium/extensions/renderer/resources/guest_view/web_view/web_view.js
--- up/chromium/extensions/renderer/resources/guest_view/web_view/web_view.js	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/resources/guest_view/web_view/web_view.js	2023-01-28 02:49:29.315628647 +0000
@@ -28,6 +28,8 @@
 
 // Sets up all of the webview attributes.
 WebViewImpl.prototype.setupAttributes = function() {
+  this.attributes[WebViewConstants.ATTRIBUTE_ALLOWNW] =
+      new WebViewAttributes.AllowNWAttribute(this);
   this.attributes[WebViewConstants.ATTRIBUTE_ALLOWSCALING] =
       new WebViewAttributes.AllowScalingAttribute(this);
   this.attributes[WebViewConstants.ATTRIBUTE_ALLOWTRANSPARENCY] =
@@ -221,6 +223,28 @@
   return true;
 };
 
+WebViewImpl.prototype.getGuestId = function() {
+  return this.guest.getId();
+};
+
+WebViewImpl.prototype.showDevTools = function(show, container) {
+  if (!this.guest.getId()) {
+    return;
+  }
+  if (container)
+    WebViewInternal.showDevTools(this.guest.getId(), show, container.getProcessId(), container.getGuestId());
+  else
+    WebViewInternal.showDevTools(this.guest.getId(), show);
+};
+
+WebViewImpl.prototype.getCookieStoreId = function() {
+    return this.processId + "," + this.guest.getId();
+}
+
+WebViewImpl.prototype.inspectElementAt = function(x, y) {
+  WebViewInternal.inspectElementAt(this.guest.getId(), x, y);
+};
+
 WebViewImpl.prototype.loadDataWithBaseUrl = function(
     dataUrl, baseUrl, virtualUrl) {
   if (!this.guest.getId()) {
diff -r -u --color up/chromium/extensions/renderer/resources/guest_view/web_view/web_view_action_requests.js nw/chromium/extensions/renderer/resources/guest_view/web_view/web_view_action_requests.js
--- up/chromium/extensions/renderer/resources/guest_view/web_view/web_view_action_requests.js	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/resources/guest_view/web_view/web_view_action_requests.js	2023-01-28 02:49:29.315628647 +0000
@@ -21,8 +21,9 @@
 // The browser will kill us if we send it a bad instance ID.
 // TODO(780728): Remove once the cause of the bad ID is known.
 function CrashIfInvalidInstanceId(instanceId, culpritFunction) {
+  //NWJS: zero instance id is allowed in NW. 
   logging.CHECK(
-      instanceId > 0,
+      instanceId >= 0,
       'WebView: Invalid instance ID (' + instanceId + ') from ' +
           culpritFunction);
 }
@@ -137,13 +138,14 @@
     ok: $Function.bind(function(user_input) {
       this.validateCall();
       user_input = user_input || '';
-      CrashIfInvalidInstanceId(this.guestInstanceId, 'Dialog ok');
+      //NWJS: zero instance id is allowed in NW.
+      //CrashIfInvalidInstanceId(this.guestInstanceId, 'Dialog ok');
       WebViewInternal.setPermission(
           this.guestInstanceId, this.requestId, 'allow', user_input);
     }, this),
     cancel: $Function.bind(function() {
       this.validateCall();
-      CrashIfInvalidInstanceId(this.guestInstanceId, 'Dialog cancel');
+      //CrashIfInvalidInstanceId(this.guestInstanceId, 'Dialog cancel');
       WebViewInternal.setPermission(
           this.guestInstanceId, this.requestId, 'deny');
     }, this)
diff -r -u --color up/chromium/extensions/renderer/resources/guest_view/web_view/web_view_api_methods.js nw/chromium/extensions/renderer/resources/guest_view/web_view/web_view_api_methods.js
--- up/chromium/extensions/renderer/resources/guest_view/web_view/web_view_api_methods.js	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/resources/guest_view/web_view/web_view_api_methods.js	2023-01-28 02:49:29.315628647 +0000
@@ -34,11 +34,13 @@
 
   // Returns audio state.
   'getAudioState',
+  // Return storeId which can be used in chrome.cookies API
+  'getCookieStoreId',
 
   // Returns Chrome's internal process ID for the guest web page's current
   // process.
   'getProcessId',
-
+  'getGuestId',
   // Returns the user agent string used by the webview for guest page requests.
   'getUserAgent',
 
@@ -70,6 +72,8 @@
   // of the data URL.
   'loadDataWithBaseUrl',
 
+  'showDevTools',
+  'inspectElementAt',
   // Prints the contents of the webview.
   'print',
 
diff -r -u --color up/chromium/extensions/renderer/resources/guest_view/web_view/web_view_attributes.js nw/chromium/extensions/renderer/resources/guest_view/web_view/web_view_attributes.js
--- up/chromium/extensions/renderer/resources/guest_view/web_view/web_view_attributes.js	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/resources/guest_view/web_view/web_view_attributes.js	2023-01-28 02:49:29.315628647 +0000
@@ -52,6 +52,19 @@
                                        this.getValue());
 };
 
+function AllowNWAttribute(view) {
+  $Function.call(
+    GuestViewAttributes.BooleanAttribute,
+    this, WebViewConstants.ATTRIBUTE_ALLOWNW, view);
+}
+
+AllowNWAttribute.prototype.__proto__ =
+    GuestViewAttributes.BooleanAttribute.prototype;
+
+AllowNWAttribute.prototype.handleMutation = function(oldValue,
+                                                               newValue) {
+};
+
 // -----------------------------------------------------------------------------
 // AutosizeDimensionAttribute object.
 
@@ -257,6 +270,7 @@
 };
 
 var WebViewAttributes = {
+  AllowNWAttribute: AllowNWAttribute,
   AllowScalingAttribute: AllowScalingAttribute,
   AllowTransparencyAttribute: AllowTransparencyAttribute,
   AutosizeDimensionAttribute: AutosizeDimensionAttribute,
diff -r -u --color up/chromium/extensions/renderer/resources/guest_view/web_view/web_view_constants.js nw/chromium/extensions/renderer/resources/guest_view/web_view/web_view_constants.js
--- up/chromium/extensions/renderer/resources/guest_view/web_view/web_view_constants.js	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/resources/guest_view/web_view/web_view_constants.js	2023-01-28 02:49:29.315628647 +0000
@@ -17,6 +17,7 @@
   ATTRIBUTE_NAME: 'name',
   ATTRIBUTE_PARTITION: 'partition',
   ATTRIBUTE_SRC: 'src',
+  ATTRIBUTE_ALLOWNW:  'allownw',
 
   // Error/warning messages.
   ERROR_MSG_ALREADY_NAVIGATED: '<webview>: ' +
diff -r -u --color up/chromium/extensions/renderer/runtime_custom_bindings.cc nw/chromium/extensions/renderer/runtime_custom_bindings.cc
--- up/chromium/extensions/renderer/runtime_custom_bindings.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/runtime_custom_bindings.cc	2023-01-28 02:49:29.315628647 +0000
@@ -5,6 +5,7 @@
 #include "extensions/renderer/runtime_custom_bindings.h"
 
 #include <stdint.h>
+#include "extensions/renderer/script_context_set.h"
 
 #include <memory>
 
@@ -54,8 +55,13 @@
     CHECK_EQ("ALL", view_type_string);
 
   const std::string& extension_id = context()->GetExtensionID();
-  if (extension_id.empty())
-    return;
+  // id is empty while calling from external page. we want to do
+  // this for window controlling. note the case that there are
+  // multiple extensions in the process, e.g. the automation extension
+  // for chromedriver
+
+  // if (extension_id.empty())
+  //   return;
 
   // We ignore iframes here. (Returning subframes can cause broken behavior by
   // treating an app window's iframe as its main frame, and maybe other
diff -r -u --color up/chromium/extensions/renderer/script_context.cc nw/chromium/extensions/renderer/script_context.cc
--- up/chromium/extensions/renderer/script_context.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/script_context.cc	2023-01-28 02:49:29.315628647 +0000
@@ -202,7 +202,8 @@
       context_id_(base::UnguessableToken::Create()),
       safe_builtins_(this),
       isolate_(v8_context->GetIsolate()),
-      service_worker_version_id_(blink::mojom::kInvalidServiceWorkerVersionId) {
+      service_worker_version_id_(blink::mojom::kInvalidServiceWorkerVersionId),
+      weak_factory_(this) {
   VLOG(1) << "Created context:\n" << GetDebugString();
   v8_context_.AnnotateStrongRetainer("extensions::ScriptContext::v8_context_");
   if (web_frame_)
@@ -396,8 +397,10 @@
 GURL ScriptContext::GetAccessCheckedFrameURL(
     const blink::WebLocalFrame* frame) {
   const blink::WebURL& weburl = frame->GetDocument().Url();
-  if (weburl.IsEmpty()) {
+  if (weburl.IsEmpty() || GURL(weburl) == GURL("about:blank")) {
     blink::WebDocumentLoader* document_loader = CurrentDocumentLoader(frame);
+    // NWJS fix for iframe-remote race condition on win release
+    // against 79b64c3e741cc9c6afbb23885945831a45c6baa5
     if (document_loader &&
         frame->GetSecurityOrigin().CanAccess(
             blink::WebSecurityOrigin::Create(document_loader->GetUrl()))) {
@@ -481,6 +484,9 @@
     return false;
   }
 
+  if (extension() && extension()->is_nwjs_app())
+    return true;
+
   Feature::Availability availability = GetAvailability(name);
   if (!availability.is_available()) {
     isolate()->ThrowException(v8::Exception::Error(
diff -r -u --color up/chromium/extensions/renderer/script_context.h nw/chromium/extensions/renderer/script_context.h
--- up/chromium/extensions/renderer/script_context.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/script_context.h	2023-01-28 02:49:29.315628647 +0000
@@ -335,6 +335,10 @@
   int32_t id_counter = 1;
 
   base::ThreadChecker thread_checker_;
+
+ public:
+  base::WeakPtrFactory<ScriptContext> weak_factory_;
+
 };
 
 }  // namespace extensions
diff -r -u --color up/chromium/extensions/renderer/script_context_set.cc nw/chromium/extensions/renderer/script_context_set.cc
--- up/chromium/extensions/renderer/script_context_set.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/script_context_set.cc	2023-01-28 02:49:29.315628647 +0000
@@ -68,7 +68,7 @@
   GURL frame_url = ScriptContext::GetDocumentLoaderURLForFrame(frame);
   Feature::Context context_type = ClassifyJavaScriptContext(
       extension, world_id, frame_url, frame->GetDocument().GetSecurityOrigin(),
-      view_type);
+      view_type, frame);
   Feature::Context effective_context_type = ClassifyJavaScriptContext(
       effective_extension, world_id,
       ScriptContext::GetEffectiveDocumentURLForContext(frame, frame_url, true),
@@ -200,7 +200,9 @@
     int32_t world_id,
     const GURL& url,
     const blink::WebSecurityOrigin& origin,
-    mojom::ViewType view_type) {
+    mojom::ViewType view_type,
+    const blink::WebLocalFrame* frame
+                                                             ) {
   // WARNING: This logic must match ProcessMap::GetContextType, as much as
   // possible.
 
@@ -222,7 +224,7 @@
   //    before the SecurityContext is updated with the sandbox flags (after
   //    reading the CSP header), so the caller can't check if the context's
   //    security origin is unique yet.
-  if (ScriptContext::IsSandboxedPage(url))
+  if (ScriptContext::IsSandboxedPage(url) || (frame && frame->isNwDisabledChildFrame()))
     return Feature::WEB_PAGE_CONTEXT;
 
   if (extension && active_extension_ids_->count(extension->id()) > 0) {
diff -r -u --color up/chromium/extensions/renderer/script_context_set.h nw/chromium/extensions/renderer/script_context_set.h
--- up/chromium/extensions/renderer/script_context_set.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/script_context_set.h	2023-01-28 02:49:29.315628647 +0000
@@ -56,6 +56,7 @@
   // This may also include invalid contexts. TODO(kalman): Useful?
   size_t size() const { return contexts_.size(); }
 
+  const std::set<ScriptContext*>& contexts() const { return contexts_; }
   // Creates and starts managing a new ScriptContext. Ownership is held.
   // Returns a weak reference to the new ScriptContext.
   ScriptContext* Register(blink::WebLocalFrame* frame,
@@ -124,7 +125,9 @@
       int32_t world_id,
       const GURL& url,
       const blink::WebSecurityOrigin& origin,
-      mojom::ViewType view_type);
+      mojom::ViewType view_type,
+      const blink::WebLocalFrame* frame = nullptr
+                                             );
 
   // Weak reference to all installed Extensions that are also active in this
   // process.
diff -r -u --color up/chromium/extensions/renderer/script_injection.cc nw/chromium/extensions/renderer/script_injection.cc
--- up/chromium/extensions/renderer/script_injection.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/script_injection.cc	2023-01-28 02:49:29.315628647 +0000
@@ -326,6 +326,8 @@
       world_id = blink::kMainDOMWorldId;
       break;
   }
+  if (injector_->ShouldExecuteInMainWorld())
+    world_id = blink::kMainDOMWorldId;
   render_frame_->GetWebFrame()->RequestExecuteScript(
       world_id, sources, injector_->IsUserGesture(), execution_option,
       blink::mojom::LoadEventBlockingOption::kBlock,
diff -r -u --color up/chromium/extensions/renderer/script_injector.h nw/chromium/extensions/renderer/script_injector.h
--- up/chromium/extensions/renderer/script_injector.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/script_injector.h	2023-01-28 02:49:29.319628684 +0000
@@ -28,8 +28,8 @@
 namespace extensions {
 
 // The pseudo-delegate class for a ScriptInjection that provides all necessary
-// information about how to inject the script, including what code to inject and
-// when (run location), but without any injection logic.
+// information about how to inject the script, including what code to inject,
+// when (run location), and where (world), but without any injection logic.
 class ScriptInjector {
  public:
   // The possible reasons for not injecting the script.
@@ -53,6 +53,9 @@
   // Returns the associated `UserActivationOption` for script evaluation.
   virtual blink::mojom::UserActivationOption IsUserGesture() const = 0;
 
+  // Returns true if the script should execute in the main world.
+  virtual bool ShouldExecuteInMainWorld() const = 0;
+
   // Returns the world in which to execute the javascript code.
   virtual mojom::ExecutionWorld GetExecutionWorld() const = 0;
 
diff -r -u --color up/chromium/extensions/renderer/user_script_injector.cc nw/chromium/extensions/renderer/user_script_injector.cc
--- up/chromium/extensions/renderer/user_script_injector.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/user_script_injector.cc	2023-01-28 02:49:29.319628684 +0000
@@ -138,6 +138,10 @@
   return mojom::InjectionType::kContentScript;
 }
 
+bool UserScriptInjector::ShouldExecuteInMainWorld() const {
+  return script_->in_main_world();
+}
+
 blink::mojom::UserActivationOption UserScriptInjector::IsUserGesture() const {
   return blink::mojom::UserActivationOption::kDoNotActivate;
 }
diff -r -u --color up/chromium/extensions/renderer/user_script_injector.h nw/chromium/extensions/renderer/user_script_injector.h
--- up/chromium/extensions/renderer/user_script_injector.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/user_script_injector.h	2023-01-28 02:49:29.319628684 +0000
@@ -46,6 +46,7 @@
   // ScriptInjector implementation.
   mojom::InjectionType script_type() const override;
   blink::mojom::UserActivationOption IsUserGesture() const override;
+  bool ShouldExecuteInMainWorld() const override;
   mojom::ExecutionWorld GetExecutionWorld() const override;
   mojom::CSSOrigin GetCssOrigin() const override;
   mojom::CSSInjection::Operation GetCSSInjectionOperation() const override;
diff -r -u --color up/chromium/extensions/renderer/user_script_set.cc nw/chromium/extensions/renderer/user_script_set.cc
--- up/chromium/extensions/renderer/user_script_set.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/user_script_set.cc	2023-01-28 02:49:29.319628684 +0000
@@ -203,12 +203,28 @@
     injection_host = std::make_unique<WebUIInjectionHost>(host_id_);
   }
 
-  GURL effective_document_url =
+  // nwjs#6324: move the upstream logic of GetEffectiveDocumentURL() here
+  // in upstream is not matched first with empty invalid url for iframe
+  GURL effective_document_url;
+  bool match_about_blank = false; //copied from 6d96d3d1cb83d
+  switch (script->match_origin_as_fallback()) {
+  case MatchOriginAsFallbackBehavior::kAlways:
+  case MatchOriginAsFallbackBehavior::kMatchForAboutSchemeAndClimbTree:
+    match_about_blank = true;
+    break;
+  case MatchOriginAsFallbackBehavior::kNever:
+    break;  // `false` is correct for |match_about_blank|.
+  }
+
+  if (!match_about_blank || !document_url.SchemeIs(url::kAboutScheme))
+    effective_document_url = document_url;
+  else
+    effective_document_url =
       ScriptContext::GetEffectiveDocumentURLForInjection(
           web_frame, document_url, script->match_origin_as_fallback());
 
   bool is_subframe = !web_frame->IsOutermostMainFrame();
-  if (!script->MatchesDocument(effective_document_url, is_subframe))
+  if (!script->MatchesDocument(effective_document_url, is_subframe) || !effective_document_url.is_valid())
     return injection;
 
   // Extension dynamic scripts are treated as declarative scripts and should use
diff -r -u --color up/chromium/extensions/renderer/v8_context_native_handler.cc nw/chromium/extensions/renderer/v8_context_native_handler.cc
--- up/chromium/extensions/renderer/v8_context_native_handler.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/extensions/renderer/v8_context_native_handler.cc	2023-01-28 02:49:29.319628684 +0000
@@ -35,8 +35,21 @@
   v8::Isolate* isolate = args.GetIsolate();
   std::string api_name = *v8::String::Utf8Value(isolate, args[0]);
   Feature::Availability availability = context_->GetAvailability(api_name);
-
   v8::Local<v8::Context> context = context_->v8_context();
+
+  if (api_name == "app.window" || api_name == "nw.Window" ||
+      api_name == "runtime") {
+  v8::Local<v8::Object> ret = v8::Object::New(isolate);
+  ret->Set(context, v8::String::NewFromUtf8(isolate, "is_available", v8::NewStringType::kNormal).ToLocalChecked(),
+           v8::Boolean::New(isolate, true)).ToChecked();
+  ret->Set(context, v8::String::NewFromUtf8(isolate, "message", v8::NewStringType::kNormal).ToLocalChecked(),
+           v8::String::NewFromUtf8(isolate, "", v8::NewStringType::kNormal).ToLocalChecked()).ToChecked();
+  ret->Set(context, v8::String::NewFromUtf8(isolate, "result", v8::NewStringType::kNormal).ToLocalChecked(),
+           v8::Integer::New(isolate, Feature::IS_AVAILABLE)).ToChecked();
+  args.GetReturnValue().Set(ret);
+  return;
+  }
+
   v8::Local<v8::Object> ret = v8::Object::New(isolate);
   v8::Maybe<bool> maybe = ret->SetPrototype(context, v8::Null(isolate));
   CHECK(maybe.IsJust() && maybe.FromJust());
diff -r -u --color up/chromium/google_apis/gaia/gaia_auth_fetcher.cc nw/chromium/google_apis/gaia/gaia_auth_fetcher.cc
--- up/chromium/google_apis/gaia/gaia_auth_fetcher.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/google_apis/gaia/gaia_auth_fetcher.cc	2023-01-28 02:49:29.423629645 +0000
@@ -40,7 +40,7 @@
 
 namespace {
 
-const size_t kMaxMessageSize = 1024 * 1024;  // 1MB
+//const size_t kMaxMessageSize = 1024 * 1024;  // 1MB
 
 constexpr char kBadAuthenticationError[] = "BadAuthentication";
 constexpr char kBadAuthenticationShortError[] = "badauth";
@@ -260,6 +260,7 @@
     const GURL& gaia_gurl,
     network::mojom::CredentialsMode credentials_mode,
     const net::NetworkTrafficAnnotationTag& traffic_annotation) {
+#if 0
   DCHECK(!fetch_pending_) << "Tried to fetch two things at once!";
 
   auto resource_request = std::make_unique<network::ResourceRequest>();
@@ -314,6 +315,7 @@
       base::BindOnce(&GaiaAuthFetcher::OnURLLoadComplete,
                      base::Unretained(this)),
       kMaxMessageSize);
+#endif
 }
 
 // static
diff -r -u --color up/chromium/headless/BUILD.gn nw/chromium/headless/BUILD.gn
--- up/chromium/headless/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/headless/BUILD.gn	2023-01-28 02:49:29.531630643 +0000
@@ -647,8 +647,8 @@
   static_library("headless_renderer") {
     defines = []
     sources = [
-      "lib/browser/headless_web_contents_impl.cc",
-      "lib/browser/headless_web_contents_impl.h",
+      #"lib/browser/headless_web_contents_impl.cc",
+      #"lib/browser/headless_web_contents_impl.h",
       "lib/renderer/headless_content_renderer_client.cc",
       "lib/renderer/headless_content_renderer_client.h",
       "lib/utility/headless_content_utility_client.cc",
@@ -949,8 +949,8 @@
     sources += [
       "lib/browser/headless_content_browser_client.cc",
       "lib/browser/headless_content_browser_client.h",
-      "lib/utility/headless_content_utility_client.cc",
-      "lib/utility/headless_content_utility_client.h",
+      #"lib/utility/headless_content_utility_client.cc",
+      #"lib/utility/headless_content_utility_client.h",
     ]
   }
 
@@ -983,6 +983,13 @@
     deps += [ "//components/crash/content/browser" ]
   }
 
+  if ((is_linux || is_mac) && is_component_build) {
+    sources += [
+      "app/headless_shell_switches.cc",
+      "app/headless_shell_switches.h",
+    ]
+  }
+
   if (enable_printing) {
     deps += [
       "//components/printing/browser",
diff -r -u --color up/chromium/ipc/ipc_logging.cc nw/chromium/ipc/ipc_logging.cc
--- up/chromium/ipc/ipc_logging.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ipc/ipc_logging.cc	2023-01-28 02:49:30.359638295 +0000
@@ -242,7 +242,7 @@
       }
     }
   }
-  if (enabled_on_stderr_) {
+  if (enabled_on_stderr_ && !sender_) {
     std::string message_name;
     if (data.message_name.empty()) {
       message_name = base::StringPrintf("[unknown type %d]", data.type);
diff -r -u --color up/chromium/ipc/ipc_message_start.h nw/chromium/ipc/ipc_message_start.h
--- up/chromium/ipc/ipc_message_start.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ipc/ipc_message_start.h	2023-01-28 02:49:30.359638295 +0000
@@ -18,6 +18,7 @@
   NaClMsgStart,
   PpapiMsgStart,
   ExtensionMsgStart,
+  ShellMsgStart,
   NaClHostMsgStart,
   EncryptedMediaMsgStart,
   GinJavaBridgeMsgStart,
diff -r -u --color up/chromium/media/BUILD.gn nw/chromium/media/BUILD.gn
--- up/chromium/media/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/media/BUILD.gn	2023-01-28 02:49:30.363638332 +0000
@@ -12,7 +12,6 @@
 import("//media/media_options.gni")
 import("//testing/libfuzzer/fuzzer_test.gni")
 import("//testing/test.gni")
-import("//third_party/ffmpeg/ffmpeg_options.gni")
 
 if (enable_library_cdms) {
   import("//media/cdm/library_cdm/cdm_paths.gni")
@@ -68,15 +67,6 @@
   }
 }
 
-if (proprietary_codecs && media_use_ffmpeg) {
-  assert(
-      ffmpeg_branding != "Chromium",
-      "proprietary codecs and ffmpeg_branding set to Chromium are incompatible")
-}
-
-# Common configuration for targets in the media directory; these must not be
-# exported since things like USE_NEON and USE_CRAS have different meanings
-# elsewhere in the code base.
 config("media_config") {
   defines = []
   if (current_cpu == "arm64" || (current_cpu == "arm" && arm_use_neon)) {
diff -r -u --color up/chromium/media/audio/audio_manager_base.cc nw/chromium/media/audio/audio_manager_base.cc
--- up/chromium/media/audio/audio_manager_base.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/media/audio/audio_manager_base.cc	2023-01-28 02:49:30.371638406 +0000
@@ -111,9 +111,10 @@
 
 AudioManagerBase::~AudioManagerBase() {
   // All the output streams should have been deleted.
-  CHECK_EQ(0, num_output_streams_);
+  //disable the check for NWJS#5318
+  //CHECK_EQ(0, num_output_streams_);
   // All the input streams should have been deleted.
-  CHECK(input_streams_.empty());
+  //CHECK(input_streams_.empty());
 }
 
 void AudioManagerBase::GetAudioInputDeviceDescriptions(
diff -r -u --color up/chromium/media/base/feedback_signal_accumulator.h nw/chromium/media/base/feedback_signal_accumulator.h
--- up/chromium/media/base/feedback_signal_accumulator.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/media/base/feedback_signal_accumulator.h	2023-01-28 02:49:30.395638628 +0000
@@ -10,6 +10,7 @@
 #include <ostream>
 
 #include "base/time/time.h"
+#include <algorithm>
 
 namespace media {
 
diff -r -u --color up/chromium/media/ffmpeg/ffmpeg_common.cc nw/chromium/media/ffmpeg/ffmpeg_common.cc
--- up/chromium/media/ffmpeg/ffmpeg_common.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/media/ffmpeg/ffmpeg_common.cc	2023-01-28 02:49:30.455639182 +0000
@@ -149,6 +149,12 @@
       return AV_CODEC_ID_AAC;
     case AudioCodec::kALAC:
       return AV_CODEC_ID_ALAC;
+#if BUILDFLAG(ENABLE_PLATFORM_AC3_EAC3_AUDIO)
+    case AudioCodec::kAC3:
+      return AV_CODEC_ID_AC3;
+    case AudioCodec::kEAC3:
+      return AV_CODEC_ID_EAC3;
+#endif
     case AudioCodec::kMP3:
       return AV_CODEC_ID_MP3;
     case AudioCodec::kPCM:
diff -r -u --color up/chromium/mojo/public/cpp/base/message_pump_type_mojom_traits.cc nw/chromium/mojo/public/cpp/base/message_pump_type_mojom_traits.cc
--- up/chromium/mojo/public/cpp/base/message_pump_type_mojom_traits.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/mojo/public/cpp/base/message_pump_type_mojom_traits.cc	2023-01-28 02:49:30.815642509 +0000
@@ -20,6 +20,8 @@
       return mojo_base::mojom::MessagePumpType::kCustom;
     case base::MessagePumpType::IO:
       return mojo_base::mojom::MessagePumpType::kIo;
+    case base::MessagePumpType::NODE:
+      return mojo_base::mojom::MessagePumpType::kNode;
 #if BUILDFLAG(IS_ANDROID)
     case base::MessagePumpType::JAVA:
       return mojo_base::mojom::MessagePumpType::kJava;
@@ -50,6 +52,9 @@
     case mojo_base::mojom::MessagePumpType::kIo:
       *output = base::MessagePumpType::IO;
       return true;
+    case mojo_base::mojom::MessagePumpType::kNode:
+      *output = base::MessagePumpType::NODE;
+      return true;
 #if BUILDFLAG(IS_ANDROID)
     case mojo_base::mojom::MessagePumpType::kJava:
       *output = base::MessagePumpType::JAVA;
diff -r -u --color up/chromium/mojo/public/mojom/base/message_pump_type.mojom nw/chromium/mojo/public/mojom/base/message_pump_type.mojom
--- up/chromium/mojo/public/mojom/base/message_pump_type.mojom	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/mojo/public/mojom/base/message_pump_type.mojom	2023-01-28 02:49:30.883643137 +0000
@@ -16,4 +16,5 @@
   kNsRunloop,
   [EnableIf=is_ios]
   kNsRunloop,
+  kNode,
 };
diff -r -u --color up/chromium/net/cert/cert_verify_proc_mac.cc nw/chromium/net/cert/cert_verify_proc_mac.cc
--- up/chromium/net/cert/cert_verify_proc_mac.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/net/cert/cert_verify_proc_mac.cc	2023-01-28 02:49:31.155645651 +0000
@@ -5,6 +5,7 @@
 #include "net/cert/cert_verify_proc_mac.h"
 
 #include <CommonCrypto/CommonDigest.h>
+#include <CoreFoundation/CFArray.h>
 #include <CoreServices/CoreServices.h>
 #include <Security/Security.h>
 
@@ -568,6 +569,7 @@
                                 CFArrayRef sct_array_ref,
                                 int flags,
                                 CFArrayRef keychain_search_list,
+                                const CertificateList& additional_trust_anchors,
                                 ScopedCFTypeRef<SecTrustRef>* trust_ref,
                                 SecTrustResultType* trust_result,
                                 ScopedCFTypeRef<CFArrayRef>* verified_chain,
@@ -694,6 +696,7 @@
                          bool rev_checking_soft_fail,
                          CRLSet* crl_set,
                          CertVerifyResult* verify_result,
+                         const CertificateList& additional_trust_anchors,
                          CRLSetResult* completed_chain_crl_result) {
   ScopedCFTypeRef<CFArrayRef> trust_policies;
   OSStatus status = CreateTrustPolicies(flags, &trust_policies);
@@ -872,7 +875,7 @@
       int rv = BuildAndEvaluateSecTrustRef(
           cert_array, trust_policies, ocsp_response_ref.get(),
           sct_array_ref.get(), flags,
-          scoped_alternate_keychain_search_list.get(), &temp_ref,
+          scoped_alternate_keychain_search_list.get(), additional_trust_anchors, &temp_ref,
           &temp_trust_result, &temp_chain, &temp_chain_info);
       if (rv != OK)
         return rv;
@@ -1112,7 +1115,7 @@
 CertVerifyProcMac::~CertVerifyProcMac() = default;
 
 bool CertVerifyProcMac::SupportsAdditionalTrustAnchors() const {
-  return false;
+  return true;
 }
 
 int CertVerifyProcMac::VerifyInternal(
@@ -1136,7 +1139,7 @@
   CRLSetResult completed_chain_crl_result;
   int rv = VerifyWithGivenFlags(cert, hostname, ocsp_response, sct_list, flags,
                                 /*rev_checking_soft_fail=*/true, crl_set,
-                                verify_result, &completed_chain_crl_result);
+                                verify_result, additional_trust_anchors, &completed_chain_crl_result);
   if (rv != OK)
     return rv;
 
diff -r -u --color up/chromium/net/cert/cert_verify_proc_win.cc nw/chromium/net/cert/cert_verify_proc_win.cc
--- up/chromium/net/cert/cert_verify_proc_win.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/net/cert/cert_verify_proc_win.cc	2023-01-28 02:49:31.155645651 +0000
@@ -35,6 +35,7 @@
 #include "net/cert/test_root_certs.h"
 #include "net/cert/x509_certificate.h"
 #include "net/cert/x509_util_win.h"
+#include "net/cert/x509_util.h"
 
 #if !defined(CERT_TRUST_HAS_WEAK_SIGNATURE)
 // This was introduced in Windows 8 / Windows Server 2012, but retroactively
@@ -1060,7 +1061,7 @@
 CertVerifyProcWin::~CertVerifyProcWin() = default;
 
 bool CertVerifyProcWin::SupportsAdditionalTrustAnchors() const {
-  return false;
+  return true;
 }
 
 int CertVerifyProcWin::VerifyInternal(
@@ -1299,8 +1300,36 @@
 
   crypto::ScopedPCCERT_CHAIN_CONTEXT scoped_chain_context(chain_context);
 
+  DWORD errorStatus = chain_context->TrustStatus.dwErrorStatus;
+  bool skipPolicyCheck = false;
+  if (((errorStatus & CERT_TRUST_IS_UNTRUSTED_ROOT) || (errorStatus & (CERT_TRUST_IS_OFFLINE_REVOCATION | CERT_TRUST_REVOCATION_STATUS_UNKNOWN)))&&
+      !additional_trust_anchors.empty()) {
+    // check if the (untrusted) validated root is in the list of
+    // additional trust anchors
+    PCERT_SIMPLE_CHAIN first_chain = chain_context->rgpChain[0];
+    DWORD num_elements = first_chain->cElement;
+    if (num_elements >= 1) {
+      PCERT_CHAIN_ELEMENT* element = first_chain->rgpElement;
+      PCCERT_CONTEXT cert2 = element[num_elements - 1]->pCertContext;
+      for (size_t i=0; i<additional_trust_anchors.size(); i++) {
+	bssl::UniquePtr<CRYPTO_BUFFER> cert_handle(X509Certificate::CreateCertBufferFromBytes(base::as_bytes(base::make_span((const char*)(cert2->pbCertEncoded), cert2->cbCertEncoded))));
+        if (x509_util::CryptoBufferEqual(cert_handle.get(),
+            additional_trust_anchors[i]->cert_buffer())) {
+          LOG(INFO) << "Untrusted root \"" <<
+              additional_trust_anchors[i]->subject().GetDisplayName() <<
+              "\" found in additional anchors, assuming trusted.";
+          verify_result->is_issued_by_additional_trust_anchor = true;
+          errorStatus &= ~(CERT_TRUST_IS_UNTRUSTED_ROOT | CERT_TRUST_IS_OFFLINE_REVOCATION 
+            | CERT_TRUST_REVOCATION_STATUS_UNKNOWN | CERT_TRUST_IS_PARTIAL_CHAIN);
+          skipPolicyCheck = true;
+          break;
+        }
+      }
+    }
+  }
+
   verify_result->cert_status |= MapCertChainErrorStatusToCertStatus(
-      chain_context->TrustStatus.dwErrorStatus);
+      errorStatus);
 
   // Flag certificates that have a Subject common name with a NULL character.
   if (CertSubjectCommonNameHasNull(cert_list.get()))
@@ -1308,6 +1337,7 @@
 
   std::u16string hostname16 = base::ASCIIToUTF16(hostname);
 
+  if (!skipPolicyCheck) {
   SSL_EXTRA_CERT_CHAIN_POLICY_PARA extra_policy_para;
   memset(&extra_policy_para, 0, sizeof(extra_policy_para));
   extra_policy_para.cbSize = sizeof(extra_policy_para);
@@ -1340,6 +1370,7 @@
     verify_result->cert_status |= MapNetErrorToCertStatus(
         MapSecurityError(policy_status.dwError));
   }
+  }
 
   // Mask off revocation checking failures unless hard-fail revocation checking
   // for local anchors is enabled and the chain is issued by a local root.
diff -r -u --color up/chromium/net/cert/multi_threaded_cert_verifier.cc nw/chromium/net/cert/multi_threaded_cert_verifier.cc
--- up/chromium/net/cert/multi_threaded_cert_verifier.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/net/cert/multi_threaded_cert_verifier.cc	2023-01-28 02:49:31.159645688 +0000
@@ -71,7 +71,7 @@
     const std::string& sct_list,
     int flags,
     const scoped_refptr<CRLSet>& crl_set,
-    const CertificateList& additional_trust_anchors,
+    const CertificateList* additional_trust_anchors,
     const NetLogWithSource& net_log) {
   TRACE_EVENT0(NetTracingCategory(), "DoVerifyOnWorkerThread");
   auto verify_result = std::make_unique<ResultHelper>();
@@ -80,7 +80,7 @@
       allow_base_sync_primitives;
   verify_result->error = verify_proc->Verify(
       cert.get(), hostname, ocsp_response, sct_list, flags, crl_set.get(),
-      additional_trust_anchors, &verify_result->result, net_log);
+      *additional_trust_anchors, &verify_result->result, net_log);
   // The CertVerifyResult is created and populated on the worker thread and
   // then returned to the network thread. Detach now before returning the
   // result, since any further access will be on the network thread.
@@ -159,7 +159,7 @@
       base::BindOnce(&DoVerifyOnWorkerThread, verify_proc, params.certificate(),
                      params.hostname(), params.ocsp_response(),
                      params.sct_list(), flags, config.crl_set,
-                     config.additional_trust_anchors, net_log),
+                     &config.additional_trust_anchors, net_log),
       base::BindOnce(&MultiThreadedCertVerifier::InternalRequest::OnJobComplete,
                      weak_factory_.GetWeakPtr()));
 }
diff -r -u --color up/chromium/net/cert/test_root_certs.h nw/chromium/net/cert/test_root_certs.h
--- up/chromium/net/cert/test_root_certs.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/net/cert/test_root_certs.h	2023-01-28 02:49:31.167645762 +0000
@@ -74,6 +74,7 @@
   TestRootCerts();
   ~TestRootCerts();
 
+public:
   // Marks |certificate| as trusted in the effective trust store
   // used by CertVerifier::Verify(). Returns false if the
   // certificate could not be marked trusted.
diff -r -u --color up/chromium/net/cookies/cookie_monster.cc nw/chromium/net/cookies/cookie_monster.cc
--- up/chromium/net/cookies/cookie_monster.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/net/cookies/cookie_monster.cc	2023-01-28 02:49:31.175645836 +0000
@@ -582,6 +582,7 @@
 }
 
 const char* const CookieMonster::kDefaultCookieableSchemes[] = {"http", "https",
+                                                                "chrome-extension",
                                                                 "ws", "wss"};
 const int CookieMonster::kDefaultCookieableSchemesCount =
     std::size(kDefaultCookieableSchemes);
diff -r -u --color up/chromium/net/proxy_resolution/configured_proxy_resolution_service.cc nw/chromium/net/proxy_resolution/configured_proxy_resolution_service.cc
--- up/chromium/net/proxy_resolution/configured_proxy_resolution_service.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/net/proxy_resolution/configured_proxy_resolution_service.cc	2023-01-28 02:49:31.455648423 +0000
@@ -1299,6 +1299,23 @@
   return previous_state;
 }
 
+void ConfiguredProxyResolutionService::ResetConfigService(
+       std::unique_ptr<ProxyConfigService> new_proxy_config_service) {
+  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
+  State previous_state = ResetProxyConfig(true);
+
+  // Release the old configuration service.
+  if (config_service_.get())
+    config_service_->RemoveObserver(this);
+
+  // Set the new configuration service.
+  config_service_ = std::move(new_proxy_config_service);
+  config_service_->AddObserver(this);
+
+  if (previous_state != STATE_NONE)
+    ApplyProxyConfigIfAvailable();
+}
+
 void ConfiguredProxyResolutionService::ForceReloadProxyConfig() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   ResetProxyConfig(false);
diff -r -u --color up/chromium/net/proxy_resolution/configured_proxy_resolution_service.h nw/chromium/net/proxy_resolution/configured_proxy_resolution_service.h
--- up/chromium/net/proxy_resolution/configured_proxy_resolution_service.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/net/proxy_resolution/configured_proxy_resolution_service.h	2023-01-28 02:49:31.455648423 +0000
@@ -153,6 +153,15 @@
   // ProxyResolutionService
   void OnShutdown() override;
 
+  // Tells this ProxyResolutionService to start using a new
+  // ProxyConfigService
+  // to retrieve its ProxyConfig from. The new ProxyConfigService
+  // will
+  // immediately be queried for new config info which will be used
+  // for all
+  // subsequent ResolveProxy calls.
+  void ResetConfigService(
+                          std::unique_ptr<ProxyConfigService> new_proxy_config_service);
   // Returns the last configuration fetched from ProxyConfigService.
   const absl::optional<ProxyConfigWithAnnotation>& fetched_config() const {
     return fetched_config_;
diff -r -u --color up/chromium/ppapi/native_client/src/untrusted/pnacl_support_extension/BUILD.gn nw/chromium/ppapi/native_client/src/untrusted/pnacl_support_extension/BUILD.gn
--- up/chromium/ppapi/native_client/src/untrusted/pnacl_support_extension/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ppapi/native_client/src/untrusted/pnacl_support_extension/BUILD.gn	2023-01-28 02:49:31.607649828 +0000
@@ -35,7 +35,10 @@
   shim_cpu = nacl_target_cpu
 
   output_prefix = "$root_out_dir/pnacl/pnacl_public_"
-  outputs = [ "${output_prefix}pnacl_json" ]
+  outputs = [
+    "$root_out_dir/pnacl",
+    "${output_prefix}pnacl_json",
+  ]
 
   # Files that will be copied from the toolchain to output.
   outputs_from_toolchain = [
diff -r -u --color up/chromium/printing/buildflags/buildflags.gni nw/chromium/printing/buildflags/buildflags.gni
--- up/chromium/printing/buildflags/buildflags.gni	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/printing/buildflags/buildflags.gni	2023-01-28 02:49:31.647650197 +0000
@@ -44,7 +44,7 @@
 
   # Enable snapshotting a page when printing for its content to be analyzed for
   # sensitive content by enterprise users.
-  enable_print_content_analysis = is_chromeos || is_win || is_linux || is_mac
+  enable_print_content_analysis = false #is_chromeos || is_win || is_linux || is_mac
 }
 
 declare_args() {
diff -r -u --color up/chromium/remoting/remoting_enable.gni nw/chromium/remoting/remoting_enable.gni
--- up/chromium/remoting/remoting_enable.gni	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/remoting/remoting_enable.gni	2023-01-28 02:49:31.755651196 +0000
@@ -9,5 +9,5 @@
 }
 
 declare_args() {
-  enable_remoting = !is_castos && !is_cast_android && !is_fuchsia
+  enable_remoting = false
 }
diff -r -u --color up/chromium/sandbox/policy/linux/sandbox_linux.cc nw/chromium/sandbox/policy/linux/sandbox_linux.cc
--- up/chromium/sandbox/policy/linux/sandbox_linux.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/sandbox/policy/linux/sandbox_linux.cc	2023-01-28 02:49:31.795651565 +0000
@@ -157,9 +157,11 @@
 }
 
 SandboxLinux::~SandboxLinux() {
+#if 0
   if (pre_initialized_) {
     CHECK(initialize_sandbox_ran_);
   }
+#endif
 }
 
 SandboxLinux* SandboxLinux::GetInstance() {
diff -r -u --color up/chromium/services/network/BUILD.gn nw/chromium/services/network/BUILD.gn
--- up/chromium/services/network/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/services/network/BUILD.gn	2023-01-28 02:49:31.887652415 +0000
@@ -185,6 +185,8 @@
     "web_bundle/web_bundle_url_loader_factory.h",
     "web_transport.cc",
     "web_transport.h",
+    "../../content/nw/src/policy_cert_verifier.cc",
+    "../../content/nw/src/policy_cert_verifier.h",
   ]
 
   if (is_p2p_enabled) {
diff -r -u --color up/chromium/services/network/network_context.cc nw/chromium/services/network/network_context.cc
--- up/chromium/services/network/network_context.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/services/network/network_context.cc	2023-01-28 02:49:31.899652526 +0000
@@ -2,6 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#pragma clang diagnostic ignored "-Wunused-function"
 #include "services/network/network_context.h"
 
 #include <memory>
@@ -9,6 +10,9 @@
 #include <tuple>
 #include <utility>
 
+#include "content/nw/src/policy_cert_verifier.h"
+#include "net/cert/cert_verify_proc.h"
+
 #include "base/barrier_closure.h"
 #include "base/base64.h"
 #include "base/bind.h"
@@ -60,6 +64,7 @@
 #include "net/cert/caching_cert_verifier.h"
 #include "net/cert/cert_verifier.h"
 #include "net/cert/coalescing_cert_verifier.h"
+#include "net/cert_net/cert_net_fetcher_url_request.h"
 #include "net/cookies/cookie_access_delegate.h"
 #include "net/cookies/cookie_monster.h"
 #include "net/dns/host_cache.h"
@@ -634,6 +639,9 @@
   if (network_service_)
     network_service_->DeregisterNetworkContext(this);
 
+  if (cert_net_fetcher_)
+    cert_net_fetcher_->Shutdown();
+
   if (domain_reliability_monitor_)
     domain_reliability_monitor_->Shutdown();
   // Because of the order of declaration in the class,
@@ -1344,6 +1352,10 @@
   params_->enable_preconnect = enable_preconnect;
 }
 
+void NetworkContext::SetTrustAnchors(const net::CertificateList& anchors) {
+  nw_cert_verifier_->SetTrustAnchors(anchors);
+}
+
 #if BUILDFLAG(IS_CHROMEOS)
 void NetworkContext::UpdateAdditionalCertificates(
     mojom::AdditionalCertificatesPtr additional_certificates) {
@@ -2298,6 +2310,7 @@
         base::BindRepeating(
             &NetworkContext::CreateURLLoaderFactoryForCertNetFetcher,
             base::Unretained(this)));
+#if 0
 
 #if BUILDFLAG(IS_CT_SUPPORTED)
     std::vector<scoped_refptr<const net::CTLogVerifier>> ct_logs;
@@ -2333,6 +2346,14 @@
         std::move(cert_verifier));
     cert_verifier = base::WrapUnique(cert_verifier_with_trust_anchors_.get());
 #endif  // BUILDFLAG(IS_CHROMEOS)
+#endif
+    cert_verifier = std::make_unique<nw::PolicyCertVerifier>(base::RepeatingClosure());
+    nw_cert_verifier_ = (nw::PolicyCertVerifier*)cert_verifier.get();
+#if BUILDFLAG(IS_LINUX)
+    nw_cert_verifier_->InitializeOnIOThread(net::CertVerifyProc::CreateBuiltinVerifyProc(cert_net_fetcher_));
+#else
+    nw_cert_verifier_->InitializeOnIOThread(net::CertVerifyProc::CreateSystemVerifyProc(cert_net_fetcher_));
+#endif
   }
 
   builder.SetCertVerifier(IgnoreErrorsCertVerifier::MaybeWrapCertVerifier(
@@ -2736,6 +2757,9 @@
         result.url_request_context->proxy_resolution_service());
   }
 
+  if (cert_net_fetcher_)
+    cert_net_fetcher_->SetURLRequestContext(result.url_request_context.get());
+
   return result;
 }
 
diff -r -u --color up/chromium/services/network/network_context.h nw/chromium/services/network/network_context.h
--- up/chromium/services/network/network_context.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/services/network/network_context.h	2023-01-28 02:49:31.899652526 +0000
@@ -74,11 +74,17 @@
 #include "net/reporting/reporting_report.h"
 #endif  // BUILDFLAG(ENABLE_REPORTING)
 
+namespace nw {
+  class PolicyCertVerifier;
+}
+
 namespace base {
 class UnguessableToken;
 }  // namespace base
 
 namespace net {
+class CertNetFetcher;
+class CertNetFetcherURLRequest;
 class CertVerifier;
 class HostPortPair;
 class IsolationInfo;
@@ -303,6 +309,7 @@
   void SetAcceptLanguage(const std::string& new_accept_language) override;
   void SetEnableReferrers(bool enable_referrers) override;
   void SetEnablePreconnect(bool enable_preconnect) override;
+  void SetTrustAnchors(const net::CertificateList&) override;
 #if BUILDFLAG(IS_CHROMEOS)
   void UpdateAdditionalCertificates(
       mojom::AdditionalCertificatesPtr additional_certificates) override;
@@ -835,6 +842,7 @@
   std::unique_ptr<SCTAuditingHandler> sct_auditing_handler_;
 #endif  // BUILDFLAG(IS_CT_SUPPORTED)
 
+  nw::PolicyCertVerifier* nw_cert_verifier_ = nullptr;
 #if BUILDFLAG(IS_CHROMEOS)
   raw_ptr<CertVerifierWithTrustAnchors> cert_verifier_with_trust_anchors_ =
       nullptr;
@@ -846,6 +854,11 @@
   std::vector<base::OnceClosure> dismount_closures_;
 #endif  // BUILDFLAG(IS_DIRECTORY_TRANSFER_REQUIRED)
 
+  // CertNetFetcher used by the context's CertVerifier. May be nullptr if
+  // CertNetFetcher is not used by the current platform, or if the actual
+  // net::CertVerifier is instantiated outside of the network service.
+  scoped_refptr<net::CertNetFetcherURLRequest> cert_net_fetcher_;
+
   // Created on-demand. Null if unused.
   std::unique_ptr<HostResolver> internal_host_resolver_;
   // Map values set to non-null only if that HostResolver has its own private
diff -r -u --color up/chromium/services/network/network_service.cc nw/chromium/services/network/network_service.cc
--- up/chromium/services/network/network_service.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/services/network/network_service.cc	2023-01-28 02:49:31.899652526 +0000
@@ -8,6 +8,7 @@
 #include <utility>
 #include <vector>
 
+
 #include "base/bind.h"
 #include "base/callback.h"
 #include "base/check.h"
@@ -109,6 +110,7 @@
 class FirstPartySetEntry;
 }
 
+#include "net/cert/test_root_certs.h"
 namespace network {
 
 namespace {
@@ -448,6 +450,16 @@
   host_resolver_manager_->DisableSystemResolverForTesting();  // IN-TEST
 }
 
+void NetworkService::SetAdditionalTrustAnchors(const net::CertificateList& anchors) {
+  for (NetworkContext* nc : network_contexts_)
+    nc->SetTrustAnchors(anchors);
+#if defined(OS_MAC)
+  net::TestRootCerts* certs = net::TestRootCerts::GetInstance();
+  for (size_t i = 0; i < anchors.size(); i++)
+    certs->Add(anchors[i].get());
+#endif
+}
+
 std::unique_ptr<NetworkService> NetworkService::Create(
     mojo::PendingReceiver<mojom::NetworkService> receiver) {
   return std::make_unique<NetworkService>(nullptr, std::move(receiver));
@@ -646,6 +658,8 @@
   auto it = raw_headers_access_origins_by_pid_.find(process_id);
   if (it == raw_headers_access_origins_by_pid_.end())
     return false;
+  if (it->second.size() == 1 && (*it->second.begin()).opaque())
+    return true;
   return it->second.find(url::Origin::Create(resource_url)) != it->second.end();
 }
 
diff -r -u --color up/chromium/services/network/network_service.h nw/chromium/services/network/network_service.h
--- up/chromium/services/network/network_service.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/services/network/network_service.h	2023-01-28 02:49:31.899652526 +0000
@@ -141,6 +141,7 @@
 
   // mojom::NetworkService implementation:
   void SetParams(mojom::NetworkServiceParamsPtr params) override;
+  void SetAdditionalTrustAnchors(const net::CertificateList& anchors) override;
   void StartNetLog(base::File file,
                    net::NetLogCaptureMode capture_mode,
                    base::Value::Dict constants) override;
diff -r -u --color up/chromium/services/network/public/mojom/network_context.mojom nw/chromium/services/network/public/mojom/network_context.mojom
--- up/chromium/services/network/public/mojom/network_context.mojom	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/services/network/public/mojom/network_context.mojom	2023-01-28 02:49:31.927652785 +0000
@@ -1115,6 +1115,8 @@
   [EnableIf=is_chromeos]
   UpdateAdditionalCertificates(AdditionalCertificates? additional_certificates);
 
+  SetTrustAnchors(array<X509Certificate> trust_anchors);
+
   // Updates the CT policy to be used for requests. Only applies if the
   // NetworkContextParams set enforce_chrome_ct_policy to true.
   // TODO(rsleevi): Remove this once Chrome-specific policies are moved out
diff -r -u --color up/chromium/services/network/public/mojom/network_service.mojom nw/chromium/services/network/public/mojom/network_service.mojom
--- up/chromium/services/network/public/mojom/network_service.mojom	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/services/network/public/mojom/network_service.mojom	2023-01-28 02:49:31.927652785 +0000
@@ -165,6 +165,8 @@
   // Sets the parameters and initializes the service.
   SetParams(NetworkServiceParams params);
 
+  SetAdditionalTrustAnchors(array<X509Certificate> trust_anchors);
+
   // Starts observing the NetLog event stream and writing entries to |file|.
   // |constants| is a legend used for decoding constant values in the log; it
   // will be merged with the |GetNetConstants()| dictionary before being passed
diff -r -u --color up/chromium/services/preferences/tracked/tracked_persistent_pref_store_factory.cc nw/chromium/services/preferences/tracked/tracked_persistent_pref_store_factory.cc
--- up/chromium/services/preferences/tracked/tracked_persistent_pref_store_factory.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/services/preferences/tracked/tracked_persistent_pref_store_factory.cc	2023-01-28 02:49:31.947652970 +0000
@@ -104,6 +104,7 @@
 
   mojo::Remote<prefs::mojom::TrackedPreferenceValidationDelegate>
       validation_delegate;
+  if (config->validation_delegate)
   validation_delegate.Bind(std::move(config->validation_delegate));
   auto validation_delegate_ref = base::MakeRefCounted<base::RefCountedData<
       mojo::Remote<prefs::mojom::TrackedPreferenceValidationDelegate>>>(
@@ -113,13 +114,13 @@
                          GetExternalVerificationPrefHashStorePair(
                              *config, temp_scoped_dir_cleaner),
                          unprotected_configuration, mojo::NullRemote(),
-                         validation_delegate_ref, config->reporting_ids_count));
+                         nullptr, config->reporting_ids_count));
   std::unique_ptr<PrefHashFilter> protected_pref_hash_filter(new PrefHashFilter(
       CreatePrefHashStore(*config, true),
       GetExternalVerificationPrefHashStorePair(*config,
                                                temp_scoped_dir_cleaner),
       protected_configuration, std::move(config->reset_on_load_observer),
-      validation_delegate_ref, config->reporting_ids_count));
+      nullptr, config->reporting_ids_count));
 
   PrefHashFilter* raw_unprotected_pref_hash_filter =
       unprotected_pref_hash_filter.get();
diff -r -u --color up/chromium/storage/browser/file_system/isolated_context.cc nw/chromium/storage/browser/file_system/isolated_context.cc
--- up/chromium/storage/browser/file_system/isolated_context.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/storage/browser/file_system/isolated_context.cc	2023-01-28 02:49:32.015653598 +0000
@@ -206,6 +206,7 @@
       filesystem_id_(filesystem_id),
       file_info_(file_info),
       path_type_(path_type),
+      files_(),
       ref_counts_(0) {
   DCHECK(IsSinglePathIsolatedFileSystem(type_));
 }
diff -r -u --color up/chromium/testing/buildbot/trybot_analyze_config.json nw/chromium/testing/buildbot/trybot_analyze_config.json
--- up/chromium/testing/buildbot/trybot_analyze_config.json	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/testing/buildbot/trybot_analyze_config.json	2023-01-28 02:49:32.063654042 +0000
@@ -12,6 +12,7 @@
       "build/check_gn_headers_whitelist.txt",
       "build/get_landmines.py",
       "build/gn_helpers.py",
+      "build/gyp_chromium",
       "build/mac_toolchain.py",
       "build/toolchain/apple/.*py",
       "build/toolchain/get_concurrent_links.py",
diff -r -u --color up/chromium/testing/variations/fieldtrial_testing_config.json nw/chromium/testing/variations/fieldtrial_testing_config.json
--- up/chromium/testing/variations/fieldtrial_testing_config.json	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/testing/variations/fieldtrial_testing_config.json	2023-01-28 02:49:32.087654264 +0000
@@ -4029,24 +4029,6 @@
             ]
         }
     ],
-    "DestroySystemProfiles": [
-        {
-            "platforms": [
-                "fuchsia",
-                "linux",
-                "mac",
-                "windows"
-            ],
-            "experiments": [
-                {
-                    "name": "DestroySystemProfiles",
-                    "enable_features": [
-                        "DestroySystemProfiles"
-                    ]
-                }
-            ]
-        }
-    ],
     "DexFixer": [
         {
             "platforms": [
@@ -4768,27 +4750,6 @@
             ]
         }
     ],
-    "FirstPartySetsInitLatencyExperiment": [
-        {
-            "platforms": [
-                "android",
-                "chromeos",
-                "chromeos_lacros",
-                "fuchsia",
-                "linux",
-                "mac",
-                "windows"
-            ],
-            "experiments": [
-                {
-                    "name": "Enabled",
-                    "enable_features": [
-                        "FirstPartySets"
-                    ]
-                }
-            ]
-        }
-    ],
     "ForceGpuMainThreadToNormalPriorityDrDc": [
         {
             "platforms": [
@@ -6343,6 +6304,20 @@
             ]
         }
     ],
+    "InstanceID": [
+        {
+	  "platforms": [
+	    "linux",
+	    "mac",
+	    "windows"
+	  ],
+          "experiments": [
+	    {
+	      "name": "Enabled"
+	    }
+	  ]
+	}
+    ],
     "KeyboardAccessoryAddressIPH": [
         {
             "platforms": [
@@ -10394,26 +10369,6 @@
                     ]
                 }
             ]
-        }
-    ],
-    "SiteIsolationForWebViewTags": [
-        {
-            "platforms": [
-                "chromeos",
-                "chromeos_lacros",
-                "fuchsia",
-                "linux",
-                "mac",
-                "windows"
-            ],
-            "experiments": [
-                {
-                    "name": "Enabled",
-                    "enable_features": [
-                        "SiteIsolationForGuests"
-                    ]
-                }
-            ]
         }
     ],
     "SnoozeIPH": [
diff -r -u --color up/chromium/third_party/blink/common/features.cc nw/chromium/third_party/blink/common/features.cc
--- up/chromium/third_party/blink/common/features.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/common/features.cc	2023-01-28 02:49:32.287656112 +0000
@@ -1292,7 +1292,7 @@
              base::FEATURE_DISABLED_BY_DEFAULT);
 
 // Enables loading the response body earlier in navigation.
-BASE_FEATURE(kEarlyBodyLoad, "EarlyBodyLoad", base::FEATURE_ENABLED_BY_DEFAULT);
+BASE_FEATURE(kEarlyBodyLoad, "EarlyBodyLoad", base::FEATURE_DISABLED_BY_DEFAULT);
 
 // Enables fetching the code cache earlier in navigation.
 BASE_FEATURE(kEarlyCodeCache,
diff -r -u --color up/chromium/third_party/blink/common/privacy_budget/identifiability_study_settings.cc nw/chromium/third_party/blink/common/privacy_budget/identifiability_study_settings.cc
--- up/chromium/third_party/blink/common/privacy_budget/identifiability_study_settings.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/common/privacy_budget/identifiability_study_settings.cc	2023-01-28 02:49:32.299656223 +0000
@@ -71,7 +71,8 @@
   // Same restrictions as IdentifiabilityStudySettings::SetGlobalProvider().
   void SetProvider(
       std::unique_ptr<IdentifiabilityStudySettingsProvider> provider) {
-    DCHECK(!initialized_.IsSet());
+    if (initialized_.IsSet())
+      return;
     initialized_settings_.emplace(std::move(provider));
     initialized_.Set();
   }
diff -r -u --color up/chromium/third_party/blink/common/renderer_preferences/renderer_preferences_mojom_traits.cc nw/chromium/third_party/blink/common/renderer_preferences/renderer_preferences_mojom_traits.cc
--- up/chromium/third_party/blink/common/renderer_preferences/renderer_preferences_mojom_traits.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/common/renderer_preferences/renderer_preferences_mojom_traits.cc	2023-01-28 02:49:32.303656260 +0000
@@ -103,6 +103,11 @@
   out->selection_clipboard_buffer_available =
       data.selection_clipboard_buffer_available();
 #endif
+  if (!data.ReadNwInjectJsDocStart(&out->nw_inject_js_doc_start))
+    return false;
+  if (!data.ReadNwInjectJsDocEnd(&out->nw_inject_js_doc_end))
+    return false;
+
   out->plugin_fullscreen_allowed = data.plugin_fullscreen_allowed();
   out->caret_browsing_enabled = data.caret_browsing_enabled();
 
diff -r -u --color up/chromium/third_party/blink/public/common/renderer_preferences/renderer_preferences.h nw/chromium/third_party/blink/public/common/renderer_preferences/renderer_preferences.h
--- up/chromium/third_party/blink/public/common/renderer_preferences/renderer_preferences.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/public/common/renderer_preferences/renderer_preferences.h	2023-01-28 02:49:32.655659512 +0000
@@ -75,6 +75,8 @@
   bool plugin_fullscreen_allowed{true};
   bool caret_browsing_enabled{false};
   std::vector<uint16_t> explicitly_allowed_network_ports;
+  std::string nw_inject_js_doc_start;
+  std::string nw_inject_js_doc_end;
 
   RendererPreferences();
   RendererPreferences(const RendererPreferences& other);
diff -r -u --color up/chromium/third_party/blink/public/common/renderer_preferences/renderer_preferences_mojom_traits.h nw/chromium/third_party/blink/public/common/renderer_preferences/renderer_preferences_mojom_traits.h
--- up/chromium/third_party/blink/public/common/renderer_preferences/renderer_preferences_mojom_traits.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/public/common/renderer_preferences/renderer_preferences_mojom_traits.h	2023-01-28 02:49:32.655659512 +0000
@@ -171,6 +171,16 @@
   }
 #endif
 
+  static const std::string& nw_inject_js_doc_start(
+      const ::blink::RendererPreferences& data) {
+    return data.nw_inject_js_doc_start;
+  }
+
+  static const std::string& nw_inject_js_doc_end(
+      const ::blink::RendererPreferences& data) {
+    return data.nw_inject_js_doc_end;
+  }
+
 #if BUILDFLAG(IS_WIN)
   static const std::u16string& caption_font_family_name(
       const ::blink::RendererPreferences& data) {
diff -r -u --color up/chromium/third_party/blink/public/devtools_protocol/browser_protocol.pdl nw/chromium/third_party/blink/public/devtools_protocol/browser_protocol.pdl
--- up/chromium/third_party/blink/public/devtools_protocol/browser_protocol.pdl	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/public/devtools_protocol/browser_protocol.pdl	2023-01-28 02:49:32.663659586 +0000
@@ -7537,6 +7537,7 @@
       newTab
       newWindow
       download
+      nwignore
 
   experimental type InstallabilityErrorArgument extends object
     properties
diff -r -u --color up/chromium/third_party/blink/public/mojom/choosers/file_chooser.mojom nw/chromium/third_party/blink/public/mojom/choosers/file_chooser.mojom
--- up/chromium/third_party/blink/public/mojom/choosers/file_chooser.mojom	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/public/mojom/choosers/file_chooser.mojom	2023-01-28 02:49:32.667659623 +0000
@@ -33,10 +33,14 @@
   // Title to be used for the dialog. This may be empty for the default title,
   // which will be either "Open" or "Save" depending on the mode.
   mojo_base.mojom.String16 title;
+  mojo_base.mojom.FilePath initial_value;
 
   // Default file name to select in the dialog with kSave mode.
   mojo_base.mojom.FilePath default_file_name;
 
+  mojo_base.mojom.FilePath initial_path;
+  bool extract_directory = true;
+  bool save_as = false;
   // |selected_files| has filenames which a file upload control already
   // selected. A FileChooser implementation may ask a user to select
   //  - removing a file from the selected files,
diff -r -u --color up/chromium/third_party/blink/public/mojom/frame/frame.mojom nw/chromium/third_party/blink/public/mojom/frame/frame.mojom
--- up/chromium/third_party/blink/public/mojom/frame/frame.mojom	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/public/mojom/frame/frame.mojom	2023-01-28 02:49:32.671659660 +0000
@@ -1047,7 +1047,8 @@
   ShowCreatedWindow(blink.mojom.LocalFrameToken opener_frame_token,
                     ui.mojom.WindowOpenDisposition disposition,
                     blink.mojom.WindowFeatures window_features,
-                    bool opened_by_user_gesture) => ();
+                    bool opened_by_user_gesture,
+                    mojo_base.mojom.String16 manifest) => ();
 
   // Request that the browser change the bounds of the window.
   // This corresponds to the window.resizeTo() and window.moveTo() APIs, and the browser
diff -r -u --color up/chromium/third_party/blink/public/mojom/frame/frame_owner_properties.mojom nw/chromium/third_party/blink/public/mojom/frame/frame_owner_properties.mojom
--- up/chromium/third_party/blink/public/mojom/frame/frame_owner_properties.mojom	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/public/mojom/frame/frame_owner_properties.mojom	2023-01-28 02:49:32.671659660 +0000
@@ -18,8 +18,10 @@
   int32 margin_height;
   // True if the frame allows fullscreen.
   bool allow_fullscreen;
+  bool nwfaketop;
   // True if the frame allows payment request.
   bool allow_payment_request;
+  string nwuseragent;
   // True if the frame is display:none.
   bool is_display_none;
   // The used value of color-scheme for the frame element.
diff -r -u --color up/chromium/third_party/blink/public/mojom/renderer_preferences.mojom nw/chromium/third_party/blink/public/mojom/renderer_preferences.mojom
--- up/chromium/third_party/blink/public/mojom/renderer_preferences.mojom	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/public/mojom/renderer_preferences.mojom	2023-01-28 02:49:32.679659734 +0000
@@ -107,6 +107,9 @@
   // Whether or not caret browsing is enabled.
   bool caret_browsing_enabled = false;
 
+  string nw_inject_js_doc_start;
+  string nw_inject_js_doc_end;
+
   [EnableIf=renderer_pref_system_font_family_name]
   string system_font_family_name;
 
@@ -161,4 +164,5 @@
   bool selection_clipboard_buffer_available = false;
 
   array<uint16> explicitly_allowed_network_ports;
+
 };
diff -r -u --color up/chromium/third_party/blink/public/mojom/worker/shared_worker_info.mojom nw/chromium/third_party/blink/public/mojom/worker/shared_worker_info.mojom
--- up/chromium/third_party/blink/public/mojom/worker/shared_worker_info.mojom	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/public/mojom/worker/shared_worker_info.mojom	2023-01-28 02:49:32.687659808 +0000
@@ -8,12 +8,15 @@
 import "third_party/blink/public/mojom/loader/fetch_client_settings_object.mojom";
 import "third_party/blink/public/mojom/worker/worker_options.mojom";
 import "url/mojom/url.mojom";
+import "mojo/public/mojom/base/file_path.mojom";
 
 // Meta data that is necessary to create a new shared worker context. This
 // structure gets populated when a new SharedWorker object is created in the
 // parent context (e.g. Document), and passed onto the destination child
 // process where the shared worker runs.
 struct SharedWorkerInfo {
+  bool is_node_js;
+  mojo_base.mojom.FilePath root_path;
   url.mojom.Url url;
   WorkerOptions options;
   array<network.mojom.ContentSecurityPolicy> content_security_policies;
diff -r -u --color up/chromium/third_party/blink/public/platform/platform.h nw/chromium/third_party/blink/public/platform/platform.h
--- up/chromium/third_party/blink/public/platform/platform.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/public/platform/platform.h	2023-01-28 02:49:32.691659845 +0000
@@ -636,7 +636,7 @@
                                          const BrowserInterfaceBrokerProxy&);
   virtual void DidStartWorkerThread() {}
   virtual void WillStopWorkerThread() {}
-  virtual void WorkerContextCreated(const v8::Local<v8::Context>& worker) {}
+  virtual void WorkerContextCreated(const v8::Local<v8::Context>& worker, bool, const std::string&) {}
   virtual bool AllowScriptExtensionForServiceWorker(
       const WebSecurityOrigin& script_origin) {
     return false;
diff -r -u --color up/chromium/third_party/blink/public/platform/web_security_origin.h nw/chromium/third_party/blink/public/platform/web_security_origin.h
--- up/chromium/third_party/blink/public/platform/web_security_origin.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/public/platform/web_security_origin.h	2023-01-28 02:49:32.695659882 +0000
@@ -118,6 +118,8 @@
   // https://html.spec.whatwg.org/#same-origin
   bool IsSameOriginWith(const WebSecurityOrigin&) const;
 
+  BLINK_PLATFORM_EXPORT void grantUniversalAccess();
+
 #if INSIDE_BLINK
   WebSecurityOrigin(scoped_refptr<const SecurityOrigin>);
   WebSecurityOrigin& operator=(scoped_refptr<const SecurityOrigin>);
diff -r -u --color up/chromium/third_party/blink/public/web/blink.h nw/chromium/third_party/blink/public/web/blink.h
--- up/chromium/third_party/blink/public/web/blink.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/public/web/blink.h	2023-01-28 02:49:32.715660067 +0000
@@ -47,6 +47,7 @@
 
 class Platform;
 
+class WebLocalFrame;
 // Initialize the entire Blink (wtf, platform, core, modules and web).
 // If you just need wtf and platform, use Platform::Initialize instead.
 //
@@ -79,6 +80,10 @@
 // Alters whether the browser can handle focus events while running web tests.
 BLINK_EXPORT void SetBrowserCanHandleFocusForWebTest(bool);
 
+BLINK_EXPORT void set_web_worker_hooks(void*);
+
+BLINK_EXPORT void fix_gamepad_nw(WebLocalFrame*);
+
 // Alters the rendering of fonts for web tests.
 BLINK_EXPORT void SetFontAntialiasingEnabledForTest(bool);
 BLINK_EXPORT bool FontAntialiasingEnabledForTest();
diff -r -u --color up/chromium/third_party/blink/public/web/web_frame.h nw/chromium/third_party/blink/public/web/web_frame.h
--- up/chromium/third_party/blink/public/web/web_frame.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/public/web/web_frame.h	2023-01-28 02:49:32.719660104 +0000
@@ -90,6 +90,12 @@
       CrossVariantMojoAssociatedReceiver<mojom::RemoteFrameInterfaceBase>
           receiver,
       mojom::FrameReplicationStatePtr replicated_state);
+  virtual bool isNwFakeTop() const {return false;}
+  virtual void setNodeJS(bool) {}
+  virtual bool isNodeJS() const {return false;}
+  virtual bool isNwDisabledChildFrame() const {return false;}
+  virtual void setDevtoolsJail(WebFrame*) {}
+  virtual WebFrame* getDevtoolsJail() {return nullptr;}
 
   // This method closes and deletes the WebFrame. This is typically called by
   // the embedder in response to a frame detached callback to the WebFrame
@@ -187,8 +193,8 @@
   // RemoteFrame <--> RenderFrameProxyHost in the browser process.
   const FrameToken& GetFrameToken() const { return frame_token_; }
 
-#if INSIDE_BLINK
   static WebFrame* FromCoreFrame(Frame*);
+#if INSIDE_BLINK
   static Frame* ToCoreFrame(const WebFrame&);
 #endif
 
diff -r -u --color up/chromium/third_party/blink/public/web/web_frame_owner_properties.h nw/chromium/third_party/blink/public/web/web_frame_owner_properties.h
--- up/chromium/third_party/blink/public/web/web_frame_owner_properties.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/public/web/web_frame_owner_properties.h	2023-01-28 02:49:32.719660104 +0000
@@ -12,8 +12,10 @@
 namespace blink {
 
 struct WebFrameOwnerProperties {
+  WebString nwuseragent;
   WebString name;  // browsing context container's name
   mojom::ScrollbarMode scrollbar_mode{mojom::ScrollbarMode::kAuto};
+  bool nwFakeTop{false};
   int margin_width{-1};
   int margin_height{-1};
   bool allow_fullscreen{false};
@@ -35,6 +37,7 @@
                           mojom::ColorScheme color_scheme)
       : name(name),
         scrollbar_mode(scrollbar_mode),
+        nwFakeTop(false),
         margin_width(margin_width),
         margin_height(margin_height),
         allow_fullscreen(allow_fullscreen),
diff -r -u --color up/chromium/third_party/blink/public/web/web_local_frame_client.h nw/chromium/third_party/blink/public/web/web_local_frame_client.h
--- up/chromium/third_party/blink/public/web/web_local_frame_client.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/public/web/web_local_frame_client.h	2023-01-28 02:49:32.719660104 +0000
@@ -155,6 +155,8 @@
   virtual void BindToFrame(WebNavigationControl*) {}
 
   // Factory methods -----------------------------------------------------
+  virtual void willHandleNavigationPolicy(
+                                          WebFrame*, const WebURLRequest&, WebNavigationPolicy*, WebString* manifest = NULL, bool new_win = true) { }
 
   // May return null.
   virtual WebPlugin* CreatePlugin(const WebPluginParams&) { return nullptr; }
@@ -769,7 +771,8 @@
       const SessionStorageNamespaceId& session_storage_namespace_id,
       bool& consumed_user_gesture,
       const absl::optional<Impression>&,
-      const absl::optional<WebPictureInPictureWindowOptions>& pip_options) {
+      const absl::optional<WebPictureInPictureWindowOptions>& pip_options,
+				   WebString* manifest) {
     return nullptr;
   }
 };
diff -r -u --color up/chromium/third_party/blink/public/web/web_navigation_policy.h nw/chromium/third_party/blink/public/web/web_navigation_policy.h
--- up/chromium/third_party/blink/public/web/web_navigation_policy.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/public/web/web_navigation_policy.h	2023-01-28 02:49:32.719660104 +0000
@@ -34,6 +34,7 @@
 namespace blink {
 
 enum WebNavigationPolicy {
+  kWebNavigationPolicyIgnore,
   kWebNavigationPolicyDownload,
   kWebNavigationPolicyCurrentTab,
   kWebNavigationPolicyNewBackgroundTab,
diff -r -u --color up/chromium/third_party/blink/public/web/web_node.h nw/chromium/third_party/blink/public/web/web_node.h
--- up/chromium/third_party/blink/public/web/web_node.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/public/web/web_node.h	2023-01-28 02:49:32.719660104 +0000
@@ -120,8 +120,8 @@
   template <typename T>
   T DynamicTo() const;
 
-#if INSIDE_BLINK
   WebNode(Node*);
+#if INSIDE_BLINK
   WebNode& operator=(Node*);
   operator Node*() const;
 
diff -r -u --color up/chromium/third_party/blink/public/web/web_shared_worker.h nw/chromium/third_party/blink/public/web/web_shared_worker.h
--- up/chromium/third_party/blink/public/web/web_shared_worker.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/public/web/web_shared_worker.h	2023-01-28 02:49:32.723660141 +0000
@@ -51,6 +51,11 @@
 #include "third_party/blink/public/platform/web_policy_container.h"
 #include "third_party/blink/public/platform/web_security_origin.h"
 
+namespace base {
+class SingleThreadTaskRunner;
+class FilePath;
+}
+
 namespace blink {
 
 class MessagePortDescriptor;
@@ -70,6 +75,7 @@
   // starts a worker context.
   // WebSharedWorkerClient given here should own this instance.
   static std::unique_ptr<WebSharedWorker> CreateAndStart(
+      bool nodejs, const base::FilePath& root_path,
       const blink::SharedWorkerToken& token,
       const WebURL& script_url,
       mojom::ScriptType script_type,
diff -r -u --color up/chromium/third_party/blink/renderer/bindings/bindings.gni nw/chromium/third_party/blink/renderer/bindings/bindings.gni
--- up/chromium/third_party/blink/renderer/bindings/bindings.gni	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/bindings/bindings.gni	2023-01-28 02:49:32.727660178 +0000
@@ -23,6 +23,8 @@
                     "core/v8/callback_promise_adapter.h",
                     "core/v8/capture_source_location.cc",
                     "core/v8/capture_source_location.h",
+                    "core/v8/custom/v8_html_iframe_element_custom.cc",
+                    "core/v8/custom/v8_filelist_custom.cc",
                     "core/v8/custom/v8_custom_xpath_ns_resolver.cc",
                     "core/v8/custom/v8_custom_xpath_ns_resolver.h",
                     "core/v8/custom/v8_dev_tools_host_custom.cc",
diff -r -u --color up/chromium/third_party/blink/renderer/bindings/core/v8/binding_security.cc nw/chromium/third_party/blink/renderer/bindings/core/v8/binding_security.cc
--- up/chromium/third_party/blink/renderer/bindings/core/v8/binding_security.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/bindings/core/v8/binding_security.cc	2023-01-28 02:49:32.727660178 +0000
@@ -167,12 +167,14 @@
       // Assert that because the agent clusters are different than the
       // WindowAgentFactories must also be different unless they differ in
       // being explicitly origin keyed.
+      /* it's OK to disable the assertion in NW because the logic is
+         different, plus the access is disallowed.
       SECURITY_CHECK(
           !IsSameWindowAgentFactory(accessing_window, local_target_window) ||
           (accessing_window->GetAgent()->IsOriginKeyedForInheritance() !=
            local_target_window->GetAgent()->IsOriginKeyedForInheritance()) ||
           (WebTestSupport::IsRunningWebTest() &&
-           local_target_window->GetFrame()->PagePopupOwner()));
+          local_target_window->GetFrame()->PagePopupOwner())); */
 
       *cross_document_access =
           DOMWindow::CrossDocumentAccessPolicy::kDisallowed;
@@ -456,6 +458,10 @@
   if (wrapper_type_info->Equals(V8Location::GetWrapperTypeInfo()))
     return true;
 
+  v8::Isolate* isolate = creation_context.ToLocalChecked()->GetIsolate();
+  if (isolate->GetCurrentContext()->GetAlignedPointerFromEmbedderData(50) == (void*)0x08110800)
+    return true;
+
   ExceptionState exception_state(accessing_context->GetIsolate(),
                                  ExceptionState::kConstructionContext,
                                  wrapper_type_info->interface_name);
@@ -498,6 +504,9 @@
     return;
 
   auto* local_dom_window = CurrentDOMWindow(isolate);
+  auto* frame = local_dom_window->GetFrame();
+  if (frame && frame->isNodeJS())
+    return;
   // Determine if the access check failure was because of cross-origin or if the
   // WindowAgentFactory is different. If the WindowAgentFactories are different
   // so report the error as "restricted" instead of "cross-origin".
Only in nw/chromium/third_party/blink/renderer/bindings/core/v8/custom: v8_filelist_custom.cc
Only in nw/chromium/third_party/blink/renderer/bindings/core/v8/custom: v8_html_iframe_element_custom.cc
diff -r -u --color up/chromium/third_party/blink/renderer/bindings/core/v8/custom/v8_window_custom.cc nw/chromium/third_party/blink/renderer/bindings/core/v8/custom/v8_window_custom.cc
--- up/chromium/third_party/blink/renderer/bindings/core/v8/custom/v8_window_custom.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/bindings/core/v8/custom/v8_window_custom.cc	2023-01-28 02:49:32.727660178 +0000
@@ -60,6 +60,9 @@
 #include "third_party/blink/renderer/platform/bindings/v8_set_return_value.h"
 #include "third_party/blink/renderer/platform/instrumentation/use_counter.h"
 
+
+#include "third_party/blink/renderer/bindings/core/v8/v8_html_frame_element.h"
+
 namespace blink {
 
 template <typename CallbackInfo>
@@ -110,11 +113,90 @@
   LocationAttributeGet(info);
 }
 
+
+template <typename CallbackInfo>
+static void ParentAttributeGet(const CallbackInfo& info)
+{
+  v8::Local<v8::Object> v8_win = info.Holder();
+  DOMWindow* blink_win = V8Window::ToWrappableUnsafe(v8_win);
+  const char* const property_name = "parent";
+  blink_win->ReportCoopAccess(property_name);
+  DOMWindow* return_value = blink_win->parent();
+  if (blink_win->IsLocalDOMWindow()) {
+    LocalDOMWindow* imp = To<LocalDOMWindow>(V8Window::ToImpl(info.Holder()));
+    LocalFrame* frame = imp->GetFrame();
+    if (frame && frame->isNwFakeTop()) {
+      V8SetReturnValue(info, ToV8(imp, info.Holder(), info.GetIsolate()));
+      return;
+    }
+    V8SetReturnValue(info, ToV8(imp->parent(), info.Holder(), info.GetIsolate()));
+  } else {
+    V8SetReturnValue(info, return_value, blink_win,
+                     bindings::V8ReturnValue::kMaybeCrossOriginWindow);
+  }
+}
+
+template <typename CallbackInfo>
+static void TopAttributeGet(const CallbackInfo& info)
+{
+  v8::Local<v8::Object> v8_win = info.Holder();
+  DOMWindow* blink_win = V8Window::ToWrappableUnsafe(v8_win);
+  const char* const property_name = "top";
+  blink_win->ReportCoopAccess(property_name);
+  DOMWindow* return_value = blink_win->top();
+  if (blink_win->IsLocalDOMWindow()) {
+    LocalDOMWindow* imp = To<LocalDOMWindow>(V8Window::ToImpl(info.Holder()));
+    LocalFrame* frame = imp->GetFrame();
+    if (frame) {
+      for (LocalFrame* f = frame; f; ) {
+        if (f->isNwFakeTop()) {
+          V8SetReturnValue(info, ToV8(f->GetDocument()->domWindow(), info.Holder(), info.GetIsolate()));
+          return;
+        }
+        Frame* fr = f->Tree().Parent();
+        if (!fr || !fr->IsLocalFrame())
+          break;
+        f = DynamicTo<LocalFrame>(fr);
+      }
+    }
+    V8SetReturnValue(info, ToV8(imp->top(), info.Holder(), info.GetIsolate()));
+  } else {
+    V8SetReturnValue(info, return_value, blink_win,
+                     bindings::V8ReturnValue::kMaybeCrossOriginWindow);
+  }
+}
+
+void V8Window::ParentAttributeGetterCustom(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  ParentAttributeGet(info);
+}
+
+void V8Window::ParentAttributeGetterCustom(
+    const v8::PropertyCallbackInfo<v8::Value>& info) {
+  ParentAttributeGet(info);
+}
+
+void V8Window::TopAttributeGetterCustom(
+    const v8::FunctionCallbackInfo<v8::Value>& info) {
+  ParentAttributeGet(info);
+}
+
+void V8Window::TopAttributeGetterCustom(
+    const v8::PropertyCallbackInfo<v8::Value>& info) {
+  ParentAttributeGet(info);
+}
+
+
 void V8Window::FrameElementAttributeGetterCustom(
     const v8::FunctionCallbackInfo<v8::Value>& info) {
   LocalDOMWindow* impl = To<LocalDOMWindow>(V8Window::ToImpl(info.Holder()));
   Element* frameElement = impl->frameElement();
 
+  LocalFrame* frame = impl->GetFrame();
+  if (frame && frame->isNwFakeTop()) {
+    V8SetReturnValueNull(info);
+    return;
+  }
   if (!BindingSecurity::ShouldAllowAccessTo(
           CurrentDOMWindow(info.GetIsolate()), frameElement,
           BindingSecurity::ErrorReportOption::kDoNotReport)) {
diff -r -u --color up/chromium/third_party/blink/renderer/bindings/core/v8/scheduled_action.cc nw/chromium/third_party/blink/renderer/bindings/core/v8/scheduled_action.cc
--- up/chromium/third_party/blink/renderer/bindings/core/v8/scheduled_action.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/bindings/core/v8/scheduled_action.cc	2023-01-28 02:49:32.731660215 +0000
@@ -56,7 +56,9 @@
                                  const HeapVector<ScriptValue>& arguments)
     : script_state_(
           MakeGarbageCollected<ScriptStateProtectingContext>(script_state)) {
+  //NWJS#7554
   if (script_state->World().IsWorkerWorld() ||
+      script_state->GetIsolate()->GetEnteredOrMicrotaskContext()->GetAlignedPointerFromEmbedderData(50) == (void*)0x08110800 ||
       BindingSecurity::ShouldAllowAccessTo(
           EnteredDOMWindow(script_state->GetIsolate()),
           To<LocalDOMWindow>(target),
diff -r -u --color up/chromium/third_party/blink/renderer/bindings/core/v8/v8_initializer.cc nw/chromium/third_party/blink/renderer/bindings/core/v8/v8_initializer.cc
--- up/chromium/third_party/blink/renderer/bindings/core/v8/v8_initializer.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/bindings/core/v8/v8_initializer.cc	2023-01-28 02:49:32.743660326 +0000
@@ -27,6 +27,7 @@
 
 #include <algorithm>
 #include <limits>
+#include "third_party/node-nw/src/node_webkit.h"
 #include <memory>
 #include <utility>
 
@@ -102,6 +103,13 @@
 #include "gin/public/v8_snapshot_file_type.h"
 #endif
 
+#if defined(OS_WIN)
+#include <windows.h>
+#endif
+
+extern VoidHookFn g_promise_reject_callback_fn;
+
+
 namespace blink {
 
 static String ExtractMessageForConsole(v8::Isolate* isolate,
@@ -274,6 +282,12 @@
   v8::Isolate* isolate = script_state->GetIsolate();
   ExecutionContext* context = ExecutionContext::From(script_state);
 
+#if 0 //FIXME (#4577)
+  LocalDOMWindow* window = currentDOMWindow(isolate);
+  if (window->frame()->isNodeJS() && g_promise_reject_callback_fn)
+    g_promise_reject_callback_fn(&data);
+#endif
+
   v8::Local<v8::Value> exception = data.GetValue();
   if (V8DOMWrapper::IsWrapper(isolate, exception)) {
     // Try to get the stack & location from a wrapped exception object (e.g.
@@ -741,6 +755,10 @@
 }
 
 namespace {
+#if defined(OS_WIN)
+HANDLE _process_heap;
+#endif
+
 class ArrayBufferAllocator : public v8::ArrayBuffer::Allocator {
  public:
   ArrayBufferAllocator() : total_allocation_(0) {
@@ -792,6 +810,18 @@
     ArrayBufferContents::FreeMemory(data);
   }
 
+  void Free(void* data, size_t length, AllocationMode mode) override {
+    if (mode == AllocationMode::kNodeJS) {
+#if defined(OS_WIN)
+        ::HeapFree(_process_heap, 0, data);
+#else
+        free(data);
+#endif
+        return;
+    } else
+      Free(data, length);
+  }
+
  private:
   // Total memory allocated in bytes.
   std::atomic_size_t total_allocation_;
@@ -820,6 +850,9 @@
   DCHECK(IsMainThread());
 
   DEFINE_STATIC_LOCAL(ArrayBufferAllocator, array_buffer_allocator, ());
+#if defined(OS_WIN)
+  _process_heap = ::GetProcessHeap();
+#endif
   gin::IsolateHolder::Initialize(gin::IsolateHolder::kNonStrictMode,
                                  &array_buffer_allocator, reference_table,
                                  js_command_line_flags, ReportV8FatalError,
diff -r -u --color up/chromium/third_party/blink/renderer/bindings/core/v8/window_proxy.h nw/chromium/third_party/blink/renderer/bindings/core/v8/window_proxy.h
--- up/chromium/third_party/blink/renderer/bindings/core/v8/window_proxy.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/bindings/core/v8/window_proxy.h	2023-01-28 02:49:32.743660326 +0000
@@ -167,6 +167,7 @@
   virtual bool IsLocal() const { return false; }
 
   enum FrameReuseStatus { kFrameWillNotBeReused, kFrameWillBeReused };
+  bool ContextNotReady() const { return lifecycle_ == Lifecycle::kContextIsUninitialized;}
 
  protected:
   // Lifecycle represents the following four states.
@@ -262,7 +263,6 @@
 
   v8::Isolate* GetIsolate() const { return isolate_; }
   Frame* GetFrame() const { return frame_.Get(); }
-
 #if DCHECK_IS_ON()
   void DidAttachGlobalObject() { is_global_object_attached_ = true; }
   void DidDetachGlobalObject() { is_global_object_attached_ = false; }
diff -r -u --color up/chromium/third_party/blink/renderer/bindings/core/v8/window_proxy_manager.h nw/chromium/third_party/blink/renderer/bindings/core/v8/window_proxy_manager.h
--- up/chromium/third_party/blink/renderer/bindings/core/v8/window_proxy_manager.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/bindings/core/v8/window_proxy_manager.h	2023-01-28 02:49:32.743660326 +0000
@@ -42,6 +42,11 @@
   void ReleaseGlobalProxies(GlobalProxyVector&);
   void SetGlobalProxies(const GlobalProxyVector&);
 
+  bool ContextNotReady(DOMWrapperWorld& world) {
+    WindowProxy* window_proxy = WindowProxyMaybeUninitialized(world);
+    return window_proxy->ContextNotReady();
+  }
+
   WindowProxy* GetWindowProxy(DOMWrapperWorld& world) {
     WindowProxy* window_proxy = WindowProxyMaybeUninitialized(world);
     window_proxy->InitializeIfNeeded();
diff -r -u --color up/chromium/third_party/blink/renderer/bindings/scripts/bind_gen/interface.py nw/chromium/third_party/blink/renderer/bindings/scripts/bind_gen/interface.py
--- up/chromium/third_party/blink/renderer/bindings/scripts/bind_gen/interface.py	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/bindings/scripts/bind_gen/interface.py	2023-01-28 02:49:32.751660400 +0000
@@ -2131,7 +2131,12 @@
         EmptyNode(),
     ])
 
-    if "HTMLConstructor" in cg_context.constructor.extended_attributes:
+    if "Custom" in cg_context.constructor.extended_attributes:
+        body.append(T("// [Custom Constructor]"))
+        text = _format(
+            "${class_name}::ConstructorCustom(${info});")
+        body.append(T(text))
+    elif "HTMLConstructor" in cg_context.constructor.extended_attributes:
         body.append(T("// [HTMLConstructor]"))
         text = _format(
             "V8HTMLConstructor::HtmlConstructor("
@@ -7394,6 +7399,12 @@
             add_custom_callback_impl_decl(
                 operation_group=operation_group,
                 arg_decls=["const v8::FunctionCallbackInfo<v8::Value>&"])
+    for constructor_group in class_like.constructor_groups:
+        if "Custom" in constructor_group.extended_attributes:
+            add_custom_callback_impl_decl(
+                name="ConstructorCustom",
+                constructor_group=constructor_group,
+                arg_decls=["const v8::FunctionCallbackInfo<v8::Value>&"])
     if interface and interface.indexed_and_named_properties:
         props = interface.indexed_and_named_properties
         operation = props.own_named_getter
diff -r -u --color up/chromium/third_party/blink/renderer/core/BUILD.gn nw/chromium/third_party/blink/renderer/core/BUILD.gn
--- up/chromium/third_party/blink/renderer/core/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/BUILD.gn	2023-01-28 02:49:32.767660547 +0000
@@ -190,7 +190,7 @@
   output_name = "blink_core"
 
   visibility = []  # Allow re-assignment of list.
-  visibility = [ "//third_party/blink/*" ]
+  visibility = [ "//third_party/blink/*", "//content/nw/*" ]
 
   sources = [
     "core_initializer.cc",
diff -r -u --color up/chromium/third_party/blink/renderer/core/dom/document.cc nw/chromium/third_party/blink/renderer/core/dom/document.cc
--- up/chromium/third_party/blink/renderer/core/dom/document.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/dom/document.cc	2023-01-28 02:49:32.883661619 +0000
@@ -6057,14 +6057,14 @@
   if (!GetFrame())
     return scoped_refptr<const SecurityOrigin>();
 
-  return GetFrame()->Tree().Top().GetSecurityContext()->GetSecurityOrigin();
+  return GetFrame()->Tree().FindFrameByName("_top", true)->GetSecurityContext()->GetSecurityOrigin();
 }
 
 net::SiteForCookies Document::SiteForCookies() const {
   if (!GetFrame())
     return net::SiteForCookies();
 
-  Frame& top = GetFrame()->Tree().Top();
+  Frame& top = *GetFrame()->Tree().FindFrameByName("_top", true);
   const SecurityOrigin* origin = top.GetSecurityContext()->GetSecurityOrigin();
   // TODO(yhirano): Ideally |origin| should not be null here.
   if (!origin)
@@ -6088,6 +6088,8 @@
   }
 
   while (current_frame) {
+    if (current_frame->isNwFakeTop())
+      break;
     const url::Origin cur_security_origin =
         current_frame->GetSecurityContext()->GetSecurityOrigin()->ToUrlOrigin();
     if (!candidate.CompareWithFrameTreeOriginAndRevise(cur_security_origin))
diff -r -u --color up/chromium/third_party/blink/renderer/core/editing/commands/clipboard_commands.cc nw/chromium/third_party/blink/renderer/core/editing/commands/clipboard_commands.cc
--- up/chromium/third_party/blink/renderer/core/editing/commands/clipboard_commands.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/editing/commands/clipboard_commands.cc	2023-01-28 02:49:32.907661841 +0000
@@ -59,6 +59,8 @@
                                          EditorCommandSource source) {
   if (source == EditorCommandSource::kMenuOrKeyBinding)
     return true;
+  if (frame.isNodeJS())
+    return true;
   Settings* const settings = frame.GetSettings();
   const bool default_value = settings &&
                              settings->GetJavaScriptCanAccessClipboard() &&
@@ -73,6 +75,8 @@
                                           EditorCommandSource source) {
   if (source == EditorCommandSource::kMenuOrKeyBinding)
     return true;
+  if (frame.isNodeJS())
+    return true;
   Settings* const settings = frame.GetSettings();
   const bool default_value =
       (settings && settings->GetJavaScriptCanAccessClipboard()) ||
@@ -83,6 +87,8 @@
 }
 
 bool ClipboardCommands::CanSmartReplaceInClipboard(LocalFrame& frame) {
+  //if (frame.isNodeJS())
+  //  return true; //commented out for NWJS#7363
   return frame.GetEditor().SmartInsertDeleteEnabled() &&
          frame.GetSystemClipboard()->IsFormatAvailable(
              blink::mojom::ClipboardFormat::kSmartPaste);
diff -r -u --color up/chromium/third_party/blink/renderer/core/exported/web_shared_worker_impl.cc nw/chromium/third_party/blink/renderer/core/exported/web_shared_worker_impl.cc
--- up/chromium/third_party/blink/renderer/core/exported/web_shared_worker_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/exported/web_shared_worker_impl.cc	2023-01-28 02:49:32.955662285 +0000
@@ -40,6 +40,17 @@
 #include "third_party/blink/public/common/loader/worker_main_script_load_parameters.h"
 #include "third_party/blink/public/common/origin_trials/trial_token_validator.h"
 #include "third_party/blink/public/mojom/browser_interface_broker.mojom-blink.h"
+
+#include "third_party/node-nw/src/node_webkit.h"
+#define BLINK_HOOK_MAP(type, sym, fn) extern type fn;
+#if defined(COMPONENT_BUILD) && defined(WIN32)
+#define NW_HOOK_MAP(type, sym, fn) BASE_EXPORT type fn;
+#else
+#define NW_HOOK_MAP(type, sym, fn) extern type fn;
+#endif
+#include "content/nw/src/common/node_hooks.h"
+#undef NW_HOOK_MAP
+
 #include "third_party/blink/public/mojom/devtools/devtools_agent.mojom-blink.h"
 #include "third_party/blink/public/mojom/loader/fetch_client_settings_object.mojom-blink.h"
 #include "third_party/blink/public/mojom/script/script_type.mojom-blink.h"
@@ -189,7 +200,7 @@
   scope->Connect(std::move(channel));
 }
 
-void WebSharedWorkerImpl::StartWorkerContext(
+void WebSharedWorkerImpl::StartWorkerContext(bool nodejs, const base::FilePath& root_path,
     const WebURL& script_request_url,
     mojom::blink::ScriptType script_type,
     network::mojom::CredentialsMode credentials_mode,
@@ -217,6 +228,15 @@
   DCHECK(web_worker_fetch_context);
   CHECK(constructor_origin.Get()->CanAccessSharedWorkers());
 
+  nodejs_ = nodejs;
+  root_path_ = root_path;
+
+  std::string main_script = root_path_.AsUTF8Unsafe();
+  KURL req_url = script_request_url;
+  if (g_web_worker_start_thread_fn && nodejs_) {
+    (*g_web_worker_start_thread_fn)(nullptr, (void*)req_url.GetPath().Utf8().data(), &main_script, &nodejs_);
+  }
+
   // Creates 'outside settings' used in the "Processing model" algorithm in the
   // HTML spec:
   // https://html.spec.whatwg.org/C/#worker-processing-model
@@ -265,7 +285,7 @@
   // Some params (e.g. address space) passed to GlobalScopeCreationParams are
   // dummy values. They will be updated after worker script fetch on the worker
   // thread.
-  auto creation_params = std::make_unique<GlobalScopeCreationParams>(
+  auto creation_params = std::make_unique<GlobalScopeCreationParams>(nodejs_, main_script,
       script_request_url, script_type, name,
       full_ua_enabled ? full_user_agent
                       : (reduced_ua_enabled ? reduced_user_agent : user_agent),
@@ -342,6 +362,8 @@
 }
 
 std::unique_ptr<WebSharedWorker> WebSharedWorker::CreateAndStart(
+                                                                 bool nodejs,
+                                                                 const base::FilePath& main_script,
     const blink::SharedWorkerToken& token,
     const WebURL& script_request_url,
     mojom::blink::ScriptType script_type,
@@ -370,7 +392,7 @@
     ukm::SourceId ukm_source_id) {
   auto worker =
       base::WrapUnique(new WebSharedWorkerImpl(token, std::move(host), client));
-  worker->StartWorkerContext(
+  worker->StartWorkerContext(nodejs, main_script,
       script_request_url, script_type, credentials_mode, name,
       constructor_origin, is_constructor_secure_context, user_agent,
       full_user_agent, reduced_user_agent, ua_metadata,
diff -r -u --color up/chromium/third_party/blink/renderer/core/exported/web_shared_worker_impl.h nw/chromium/third_party/blink/renderer/core/exported/web_shared_worker_impl.h
--- up/chromium/third_party/blink/renderer/core/exported/web_shared_worker_impl.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/exported/web_shared_worker_impl.h	2023-01-28 02:49:32.955662285 +0000
@@ -35,6 +35,7 @@
 
 #include <memory>
 
+#include "base/files/file_path.h"
 #include "base/memory/scoped_refptr.h"
 #include "base/memory/weak_ptr.h"
 #include "mojo/public/cpp/bindings/remote.h"
@@ -96,6 +97,7 @@
       WebSharedWorkerClient*);
 
   void StartWorkerContext(
+                          bool, const base::FilePath&,
       const WebURL&,
       mojom::blink::ScriptType,
       network::mojom::CredentialsMode,
@@ -147,6 +149,8 @@
 
   bool running_ = false;
   bool asked_to_terminate_ = false;
+  bool nodejs_;
+  base::FilePath root_path_;
 
   base::WeakPtrFactory<WebSharedWorkerImpl> weak_ptr_factory_{this};
 };
diff -r -u --color up/chromium/third_party/blink/renderer/core/exported/web_view_impl.cc nw/chromium/third_party/blink/renderer/core/exported/web_view_impl.cc
--- up/chromium/third_party/blink/renderer/core/exported/web_view_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/exported/web_view_impl.cc	2023-01-28 02:49:32.955662285 +0000
@@ -398,6 +398,8 @@
     case kNavigationPolicyPictureInPicture:
       DCHECK(RuntimeEnabledFeatures::DocumentPictureInPictureAPIEnabled());
       return ui::mojom::blink::WindowOpenDisposition::NEW_PICTURE_IN_PICTURE;
+    case kNavigationPolicyIgnore:
+      return ui::mojom::blink::WindowOpenDisposition::IGNORE_ACTION;
   }
   NOTREACHED() << "Unexpected NavigationPolicy";
   return ui::mojom::blink::WindowOpenDisposition::IGNORE_ACTION;
@@ -2961,17 +2963,23 @@
                        NavigationPolicy policy,
                        const gfx::Rect& requested_rect,
                        const gfx::Rect& adjusted_rect,
-                       bool opened_by_user_gesture) {
+                       bool opened_by_user_gesture, WebString* manifest) {
   // This is only called on local main frames.
   DCHECK(local_main_frame_host_remote_);
   DCHECK(web_widget_);
   web_widget_->SetPendingWindowRect(adjusted_rect);
+  WTF::String mnft;
+  if (!manifest || manifest->IsNull())
+    mnft = "";
+  else
+    mnft = *manifest;
   mojom::blink::WindowFeaturesPtr window_features =
       mojom::blink::WindowFeatures::New();
   window_features->bounds = requested_rect;
   local_main_frame_host_remote_->ShowCreatedWindow(
       opener_frame_token, NavigationPolicyToDisposition(policy),
       std::move(window_features), opened_by_user_gesture,
+      mnft,
       WTF::BindOnce(&WebViewImpl::DidShowCreatedWindow, WTF::Unretained(this)));
 
   MainFrameDevToolsAgentImpl()->DidShowNewWindow();
diff -r -u --color up/chromium/third_party/blink/renderer/core/exported/web_view_impl.h nw/chromium/third_party/blink/renderer/core/exported/web_view_impl.h
--- up/chromium/third_party/blink/renderer/core/exported/web_view_impl.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/exported/web_view_impl.h	2023-01-28 02:49:32.955662285 +0000
@@ -579,7 +579,7 @@
             NavigationPolicy policy,
             const gfx::Rect& requested_rect,
             const gfx::Rect& adjusted_rect,
-            bool opened_by_user_gesture);
+            bool opened_by_user_gesture, WebString* manifest);
 
   // Send the window rect to the browser and call `ack_callback` when the
   // browser has processed it.
diff -r -u --color up/chromium/third_party/blink/renderer/core/exported/web_view_test.cc nw/chromium/third_party/blink/renderer/core/exported/web_view_test.cc
--- up/chromium/third_party/blink/renderer/core/exported/web_view_test.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/exported/web_view_test.cc	2023-01-28 02:49:32.955662285 +0000
@@ -3829,7 +3829,7 @@
       const SessionStorageNamespaceId&,
       bool& consumed_user_gesture,
       const absl::optional<Impression>&,
-      const absl::optional<WebPictureInPictureWindowOptions>&) override {
+      const absl::optional<WebPictureInPictureWindowOptions>&, WebString*) override {
     return web_view_helper_.InitializeWithOpener(Frame());
   }
   WebView* CreatedWebView() const { return web_view_helper_.GetWebView(); }
diff -r -u --color up/chromium/third_party/blink/renderer/core/fileapi/file.h nw/chromium/third_party/blink/renderer/core/fileapi/file.h
--- up/chromium/third_party/blink/renderer/core/fileapi/file.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/fileapi/file.h	2023-01-28 02:49:32.959662322 +0000
@@ -65,6 +65,10 @@
                       const HeapVector<Member<V8BlobPart>>& file_bits,
                       const String& file_name,
                       const FilePropertyBag* options);
+  static File* Create(ExecutionContext*, const String& path, const String& name)
+   {
+     return CreateForUserProvidedFile(path, name);
+   }
 
   // For deserialization.
   static File* CreateFromSerialization(
@@ -210,7 +214,7 @@
     return path_;
   }
   const String& name() const { return name_; }
-
+  const String& path() const { return path_; }
   // Getter for the lastModified IDL attribute,
   // http://dev.w3.org/2006/webapi/FileAPI/#file-attrs
   int64_t lastModified() const;
diff -r -u --color up/chromium/third_party/blink/renderer/core/fileapi/file.idl nw/chromium/third_party/blink/renderer/core/fileapi/file.idl
--- up/chromium/third_party/blink/renderer/core/fileapi/file.idl	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/fileapi/file.idl	2023-01-28 02:49:32.959662322 +0000
@@ -30,8 +30,10 @@
     Serializable
 ] interface File : Blob {
     [CallWith=ExecutionContext] constructor(sequence<BlobPart> fileBits, USVString fileName, optional FilePropertyBag options = {});
+    [CallWith=ExecutionContext] constructor(DOMString path, DOMString name);
     readonly attribute DOMString name;
     readonly attribute long long lastModified;
+    readonly attribute DOMString path;
 
     // Non-standard APIs
     [MeasureAs=FileGetLastModifiedDate, CallWith=ScriptState] readonly attribute object lastModifiedDate;
diff -r -u --color up/chromium/third_party/blink/renderer/core/fileapi/file_list.h nw/chromium/third_party/blink/renderer/core/fileapi/file_list.h
--- up/chromium/third_party/blink/renderer/core/fileapi/file_list.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/fileapi/file_list.h	2023-01-28 02:49:32.963662359 +0000
@@ -49,6 +49,7 @@
 
   bool IsEmpty() const { return files_.empty(); }
   void clear() { files_.clear(); }
+  void append(File* file) { Append(file); }
   void Append(File* file) { files_.push_back(file); }
   Vector<base::FilePath> PathsForUserVisibleFiles() const;
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/fileapi/file_list.idl nw/chromium/third_party/blink/renderer/core/fileapi/file_list.idl
--- up/chromium/third_party/blink/renderer/core/fileapi/file_list.idl	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/fileapi/file_list.idl	2023-01-28 02:49:32.963662359 +0000
@@ -29,6 +29,9 @@
     Exposed=(Window,Worker),
     Serializable
 ] interface FileList {
+    [Custom] constructor();
     getter File? item(unsigned long index);
     readonly attribute unsigned long length;
+    void clear();
+    void append(File item);
 };
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/csp/content_security_policy.cc nw/chromium/third_party/blink/renderer/core/frame/csp/content_security_policy.cc
--- up/chromium/third_party/blink/renderer/core/frame/csp/content_security_policy.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/csp/content_security_policy.cc	2023-01-28 02:49:32.967662396 +0000
@@ -1239,6 +1239,10 @@
   if (!context)
     return false;
 
+  if (const_cast<ExecutionContext*>(context)->GetSecurityOrigin() &&
+      const_cast<ExecutionContext*>(context)->GetSecurityOrigin()->hasUniversalAccess())
+    return true;
+
   return ShouldBypassMainWorldDeprecated(context->GetCurrentWorld().get());
 }
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/frame.cc nw/chromium/third_party/blink/renderer/core/frame/frame.cc
--- up/chromium/third_party/blink/renderer/core/frame/frame.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/frame.cc	2023-01-28 02:49:32.971662433 +0000
@@ -100,6 +100,8 @@
   visitor->Trace(navigation_rate_limiter_);
   visitor->Trace(window_agent_factory_);
   visitor->Trace(opened_frame_tracker_);
+  visitor->Trace(dev_jail_owner_);
+  visitor->Trace(devtools_jail_);
 }
 
 bool Frame::Detach(FrameDetachType type) {
@@ -172,6 +174,11 @@
   page_ = nullptr;
   embedding_token_ = absl::nullopt;
 
+  if (dev_jail_owner_) {
+    dev_jail_owner_->setDevtoolsJail(nullptr);
+    dev_jail_owner_ = nullptr;
+  }
+
   return true;
 }
 
@@ -276,6 +283,10 @@
   return window_proxy_manager_->GetWindowProxyMaybeUninitialized(world);
 }
 
+bool Frame::ContextNotReady(DOMWrapperWorld& world) const {
+  return window_proxy_manager_->ContextNotReady(world);
+}
+
 void Frame::DidChangeVisibilityState() {
   HeapVector<Member<Frame>> child_frames;
   for (Frame* child = Tree().FirstChild(); child;
@@ -498,7 +509,10 @@
       window_agent_factory_(inheriting_agent_factory
                                 ? inheriting_agent_factory
                                 : MakeGarbageCollected<WindowAgentFactory>(
-                                      page.GetAgentGroupScheduler())),
+									   page.GetAgentGroupScheduler())),
+      devtools_jail_(nullptr),
+      dev_jail_owner_(nullptr),
+      nodejs_(false),
       is_loading_(false),
       devtools_frame_token_(devtools_frame_token),
       frame_token_(frame_token) {
@@ -537,6 +551,8 @@
   // for frames with a remote owner.
   auto* owner = To<RemoteFrameOwner>(Owner());
 
+  owner->set_nwfaketop(properties->nwfaketop);
+  owner->set_nwuseragent(properties->nwuseragent);
   owner->SetBrowsingContextContainerName(properties->name);
   owner->SetScrollbarMode(properties->scrollbar_mode);
   owner->SetMarginWidth(properties->margin_width);
@@ -928,4 +944,42 @@
   Parent()->RemoveChild(this);
 }
 
-}  // namespace blink
+bool Frame::isNwDisabledChildFrame() const
+{
+  const Frame* current_frame = this;
+  const Frame* ancestor_frame = Tree().Parent();
+  do {
+    if (current_frame->owner_) {
+      if (current_frame->owner_->IsLocal())
+        if (DynamicTo<HTMLFrameOwnerElement>(current_frame->Owner())->FastHasAttribute(html_names::kNwdisableAttr))
+          return true;
+    }
+    current_frame = ancestor_frame;
+    if (ancestor_frame)
+      ancestor_frame = ancestor_frame->Tree().Parent();
+  } while (current_frame);
+  return false;
+}
+
+void Frame::setDevtoolsJail(Frame* iframe)
+{
+  devtools_jail_ = iframe;
+  if (iframe)
+    iframe->dev_jail_owner_ = this;
+  else if (devtools_jail_)
+    devtools_jail_->dev_jail_owner_ = nullptr;
+}
+
+bool Frame::isNwFakeTop() const
+{
+  if (owner_) {
+    if (owner_->IsLocal())
+      if (DynamicTo<HTMLFrameOwnerElement>(Owner())->FastHasAttribute(html_names::kNwfaketopAttr))
+        return true;
+  }
+  return false;
+}
+
+
+} // namespace blink
+
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/frame.h nw/chromium/third_party/blink/renderer/core/frame/frame.h
--- up/chromium/third_party/blink/renderer/core/frame/frame.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/frame.h	2023-01-28 02:49:32.971662433 +0000
@@ -105,6 +105,10 @@
   static Frame* ResolveFrame(const FrameToken& frame_token);
 
   virtual ~Frame();
+  void setNodeJS(bool node) { nodejs_ = node; }
+  bool isNodeJS() const { return nodejs_; }
+  bool isNwDisabledChildFrame() const;
+  bool isNwFakeTop() const;
 
   virtual void Trace(Visitor*) const;
 
@@ -127,6 +131,10 @@
   // on successful completion (e.g. `Detach()` runs all the way through to the
   // end), returns true.
   bool Detach(FrameDetachType);
+
+  void setDevtoolsJail(Frame* iframe);
+  Frame* getDevtoolsJail() { return devtools_jail_; }
+
   void DisconnectOwnerElement();
   virtual bool ShouldClose() = 0;
   virtual void HookBackForwardCacheEviction() = 0;
@@ -234,6 +242,7 @@
   }
   WindowProxy* GetWindowProxy(DOMWrapperWorld&);
   WindowProxy* GetWindowProxyMaybeUninitialized(DOMWrapperWorld&);
+  bool ContextNotReady(DOMWrapperWorld& world) const;
 
   virtual void DidChangeVisibilityState();
 
@@ -556,6 +565,9 @@
   Member<WindowAgentFactory> window_agent_factory_;
 
   // TODO(sashab): Investigate if this can be represented with m_lifecycle.
+  Member<Frame> devtools_jail_;
+  Member<Frame> dev_jail_owner_;
+  bool nodejs_;
   bool is_loading_;
   // Contains token to be used as a frame id in the devtools protocol.
   base::UnguessableToken devtools_frame_token_;
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/frame_owner.h nw/chromium/third_party/blink/renderer/core/frame/frame_owner.h
--- up/chromium/third_party/blink/renderer/core/frame/frame_owner.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/frame_owner.h	2023-01-28 02:49:32.971662433 +0000
@@ -51,6 +51,9 @@
   // child frame is occluded or has visual effects applied.
   virtual void SetNeedsOcclusionTracking(bool) = 0;
 
+  virtual AtomicString nwuseragent() const = 0;
+  virtual bool nwfaketop() const = 0;
+
   // Returns the 'name' content attribute value of the browsing context
   // container.
   // https://html.spec.whatwg.org/C/#browsing-context-container
@@ -137,6 +140,8 @@
   mojom::blink::ScrollbarMode ScrollbarMode() const override {
     return mojom::blink::ScrollbarMode::kAuto;
   }
+  AtomicString nwuseragent() const override { return AtomicString(); }
+  bool nwfaketop() const override { return false; }
   int MarginWidth() const override { return -1; }
   int MarginHeight() const override { return -1; }
   bool AllowFullscreen() const override { return false; }
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/local_frame.cc nw/chromium/third_party/blink/renderer/core/frame/local_frame.cc
--- up/chromium/third_party/blink/renderer/core/frame/local_frame.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/local_frame.cc	2023-01-28 02:49:32.975662470 +0000
@@ -2346,6 +2346,8 @@
 
 // static
 bool LocalFrame::HasTransientUserActivation(LocalFrame* frame) {
+  if (frame && frame->isNodeJS())
+    return true;
   return frame ? frame->Frame::HasTransientUserActivation() : false;
 }
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/local_frame_client.h nw/chromium/third_party/blink/renderer/core/frame/local_frame_client.h
--- up/chromium/third_party/blink/renderer/core/frame/local_frame_client.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/local_frame_client.h	2023-01-28 02:49:32.975662470 +0000
@@ -123,6 +123,7 @@
   virtual WebLocalFrame* GetWebFrame() const { return nullptr; }
 
   virtual bool HasWebView() const = 0;  // mainly for assertions
+  virtual void willHandleNavigationPolicy(const ResourceRequest& request, NavigationPolicy* policy, WebString* manifest = NULL, bool new_win = true) {}
 
   virtual base::UnguessableToken GetDevToolsFrameToken() const = 0;
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/local_frame_client_impl.cc nw/chromium/third_party/blink/renderer/core/frame/local_frame_client_impl.cc
--- up/chromium/third_party/blink/renderer/core/frame/local_frame_client_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/local_frame_client_impl.cc	2023-01-28 02:49:32.975662470 +0000
@@ -168,6 +168,14 @@
 LocalFrameClientImpl::LocalFrameClientImpl(WebLocalFrameImpl* frame)
     : web_frame_(frame) {}
 
+void LocalFrameClientImpl::willHandleNavigationPolicy(const ResourceRequest& request, NavigationPolicy* policy, WebString* manifest, bool new_win)
+{
+  if (web_frame_->Client()) {
+    WrappedResourceRequest webreq(request);
+    web_frame_->Client()->willHandleNavigationPolicy(web_frame_, webreq, (WebNavigationPolicy*)policy, manifest, new_win);
+  }
+}
+
 LocalFrameClientImpl::~LocalFrameClientImpl() = default;
 
 void LocalFrameClientImpl::Trace(Visitor* visitor) const {
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/local_frame_client_impl.h nw/chromium/third_party/blink/renderer/core/frame/local_frame_client_impl.h
--- up/chromium/third_party/blink/renderer/core/frame/local_frame_client_impl.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/local_frame_client_impl.h	2023-01-28 02:49:32.975662470 +0000
@@ -69,6 +69,7 @@
   // LocalFrameClient ----------------------------------------------
   WebContentCaptureClient* GetWebContentCaptureClient() const override;
   void DidCommitDocumentReplacementNavigation(DocumentLoader*) override;
+  void willHandleNavigationPolicy(const blink::ResourceRequest& request, blink::NavigationPolicy* policy, WebString* manifest = nullptr, bool new_win = true) override;
   // Notifies the WebView delegate that the JS window object has been cleared,
   // giving it a chance to bind native objects to the window before script
   // parsing begins.
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/location.cc nw/chromium/third_party/blink/renderer/core/frame/location.cc
--- up/chromium/third_party/blink/renderer/core/frame/location.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/location.cc	2023-01-28 02:49:32.979662507 +0000
@@ -108,7 +108,10 @@
        frame; frame = frame->Tree().Parent(FrameTreeBoundary::kFenced)) {
     origins->Append(
         frame->GetSecurityContext()->GetSecurityOrigin()->ToString());
+    if (dom_window_->GetFrame()->isNwFakeTop())
+      break;
   }
+
   return origins;
 }
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/platform_event_controller.h nw/chromium/third_party/blink/renderer/core/frame/platform_event_controller.h
--- up/chromium/third_party/blink/renderer/core/frame/platform_event_controller.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/platform_event_controller.h	2023-01-28 02:49:32.983662544 +0000
@@ -30,6 +30,7 @@
 
   void Trace(Visitor*) const override;
   LocalDOMWindow& GetWindow() const { return *window_; }
+  void SetWindow(LocalDOMWindow* win) { window_ = win; }
 
  protected:
   explicit PlatformEventController(LocalDOMWindow&);
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/remote_frame_owner.cc nw/chromium/third_party/blink/renderer/core/frame/remote_frame_owner.cc
--- up/chromium/third_party/blink/renderer/core/frame/remote_frame_owner.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/remote_frame_owner.cc	2023-01-28 02:49:32.983662544 +0000
@@ -26,6 +26,8 @@
       browsing_context_container_name_(
           static_cast<String>(frame_owner_properties.name)),
       scrollbar_(frame_owner_properties.scrollbar_mode),
+      nwfaketop_(frame_owner_properties.nwFakeTop),
+      nwuseragent_(frame_owner_properties.nwuseragent),
       margin_width_(frame_owner_properties.margin_width),
       margin_height_(frame_owner_properties.margin_height),
       allow_fullscreen_(frame_owner_properties.allow_fullscreen),
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/remote_frame_owner.h nw/chromium/third_party/blink/renderer/core/frame/remote_frame_owner.h
--- up/chromium/third_party/blink/renderer/core/frame/remote_frame_owner.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/remote_frame_owner.h	2023-01-28 02:49:32.983662544 +0000
@@ -79,6 +79,11 @@
 
   void Trace(Visitor*) const override;
 
+  bool nwfaketop() const override { return nwfaketop_; }
+  AtomicString nwuseragent() const override { return nwuseragent_; }
+  void set_nwfaketop(bool flag) { nwfaketop_ = flag; }
+  void set_nwuseragent(const WebString& agent) { nwuseragent_ = agent; }
+
  private:
   // Intentionally private to prevent redundant checks when the type is
   // already HTMLFrameOwnerElement.
@@ -89,6 +94,8 @@
   FramePolicy frame_policy_;
   AtomicString browsing_context_container_name_;
   mojom::blink::ScrollbarMode scrollbar_;
+  bool nwfaketop_;
+  WebString nwuseragent_;
   int margin_width_;
   int margin_height_;
   bool allow_fullscreen_;
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/web_frame_test.cc nw/chromium/third_party/blink/renderer/core/frame/web_frame_test.cc
--- up/chromium/third_party/blink/renderer/core/frame/web_frame_test.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/web_frame_test.cc	2023-01-28 02:49:32.991662617 +0000
@@ -7632,7 +7632,8 @@
       const SessionStorageNamespaceId&,
       bool& consumed_user_gesture,
       const absl::optional<Impression>&,
-      const absl::optional<WebPictureInPictureWindowOptions>&) override {
+      const absl::optional<WebPictureInPictureWindowOptions>&,
+			   WebString*) override {
     EXPECT_TRUE(false);
     return nullptr;
   }
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/web_local_frame_impl.cc nw/chromium/third_party/blink/renderer/core/frame/web_local_frame_impl.cc
--- up/chromium/third_party/blink/renderer/core/frame/web_local_frame_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/web_local_frame_impl.cc	2023-01-28 02:49:32.991662617 +0000
@@ -2304,6 +2304,8 @@
             std::move(policy_container),
             GetFrame()->DomWindow()->GetStorageKey());
   };
+  owner_properties.nwFakeTop = owner_element->FastHasAttribute(html_names::kNwfaketopAttr);
+  owner_properties.nwuseragent = owner_element->nwuseragent();
 
   // FIXME: Using subResourceAttributeName as fallback is not a perfect
   // solution. subResourceAttributeName returns just one attribute name. The
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/web_local_frame_impl.h nw/chromium/third_party/blink/renderer/core/frame/web_local_frame_impl.h
--- up/chromium/third_party/blink/renderer/core/frame/web_local_frame_impl.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/web_local_frame_impl.h	2023-01-28 02:49:32.991662617 +0000
@@ -506,6 +506,16 @@
 
   WebFrameWidgetImpl* FrameWidgetImpl() { return frame_widget_; }
 
+
+  void setNodeJS(bool node) override { GetFrame()->setNodeJS(node); }
+  bool isNodeJS() const override { return GetFrame()->isNodeJS(); }
+  bool isNwDisabledChildFrame() const override { return GetFrame()->isNwDisabledChildFrame(); }
+  bool isNwFakeTop() const override { return GetFrame()->isNwFakeTop(); }
+  void setDevtoolsJail(WebFrame* iframe) override {
+    GetFrame()->setDevtoolsJail(iframe ? static_cast<const WebLocalFrameImpl*>(iframe)->GetFrame() : nullptr);
+  }
+  WebFrame* getDevtoolsJail() override { return FromFrame((blink::LocalFrame*)GetFrame()->getDevtoolsJail()); }
+
   WebTextCheckClient* GetTextCheckerClient() const {
     return text_check_client_;
   }
diff -r -u --color up/chromium/third_party/blink/renderer/core/frame/window.idl nw/chromium/third_party/blink/renderer/core/frame/window.idl
--- up/chromium/third_party/blink/renderer/core/frame/window.idl	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/frame/window.idl	2023-01-28 02:49:32.995662654 +0000
@@ -58,10 +58,10 @@
     // other browsing contexts
     [Replaceable, CrossOrigin, CachedAccessor=kWindowProxy] readonly attribute Window frames;
     [Replaceable, CrossOrigin] readonly attribute unsigned long length;
-    [LegacyUnforgeable, CrossOrigin] readonly attribute Window? top;
+    [LegacyUnforgeable, CrossOrigin, Custom=Getter] readonly attribute Window? top;
     // FIXME: opener should be of type any.
     [CrossOrigin, Custom=Setter, ImplementedAs=OpenerWithMetrics] attribute Window opener;
-    [Replaceable, CrossOrigin] readonly attribute Window? parent;
+    [Replaceable, CrossOrigin, Custom=Getter] readonly attribute Window? parent;
     [CheckSecurity=ReturnValue, Custom=Getter] readonly attribute Element? frameElement;
 
     [CallWith=Isolate, RaisesException] Window? open(optional USVString url="", optional DOMString target = "_blank", optional [TreatNullAs=EmptyString] DOMString features = "");
diff -r -u --color up/chromium/third_party/blink/renderer/core/fullscreen/fullscreen.cc nw/chromium/third_party/blink/renderer/core/fullscreen/fullscreen.cc
--- up/chromium/third_party/blink/renderer/core/fullscreen/fullscreen.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/fullscreen/fullscreen.cc	2023-01-28 02:49:32.995662654 +0000
@@ -329,7 +329,7 @@
   // true:
 
   // The algorithm is triggered by a user activation.
-  if (LocalFrame::HasTransientUserActivation(document.GetFrame()))
+  if (LocalFrame::HasTransientUserActivation(document.GetFrame()) || document.GetFrame()->isNodeJS())
     return true;
 
   // The algorithm is triggered by a fullscreen request capability delegation.
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/canvas/html_canvas_element.cc nw/chromium/third_party/blink/renderer/core/html/canvas/html_canvas_element.cc
--- up/chromium/third_party/blink/renderer/core/html/canvas/html_canvas_element.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/canvas/html_canvas_element.cc	2023-01-28 02:49:32.999662691 +0000
@@ -1104,7 +1104,7 @@
 String HTMLCanvasElement::toDataURL(const String& mime_type,
                                     const ScriptValue& quality_argument,
                                     ExceptionState& exception_state) const {
-  if (!OriginClean()) {
+  if (!GetDocument().GetFrame()->isNodeJS() && !OriginClean()) {
     exception_state.ThrowSecurityError("Tainted canvases may not be exported.");
     return String();
   }
@@ -1122,7 +1122,7 @@
                                const String& mime_type,
                                const ScriptValue& quality_argument,
                                ExceptionState& exception_state) {
-  if (!OriginClean()) {
+  if (!GetDocument().GetFrame()->isNodeJS() && !OriginClean()) {
     exception_state.ThrowSecurityError("Tainted canvases may not be exported.");
     return;
   }
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/forms/chooser_only_temporal_input_type_view.cc nw/chromium/third_party/blink/renderer/core/html/forms/chooser_only_temporal_input_type_view.cc
--- up/chromium/third_party/blink/renderer/core/html/forms/chooser_only_temporal_input_type_view.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/forms/chooser_only_temporal_input_type_view.cc	2023-01-28 02:49:33.003662728 +0000
@@ -24,6 +24,7 @@
  */
 
 #include "third_party/blink/renderer/core/html/forms/chooser_only_temporal_input_type_view.h"
+#include "third_party/blink/renderer/core/frame/local_frame.h"
 
 #include "third_party/blink/renderer/core/dom/document.h"
 #include "third_party/blink/renderer/core/dom/events/event.h"
@@ -57,7 +58,7 @@
 void ChooserOnlyTemporalInputTypeView::HandleDOMActivateEvent(Event& event) {
   Document& document = GetElement().GetDocument();
   if (GetElement().IsDisabledOrReadOnly() || !GetElement().GetLayoutObject() ||
-      !LocalFrame::HasTransientUserActivation(document.GetFrame()) ||
+      (!LocalFrame::HasTransientUserActivation(document.GetFrame()) && !document.GetFrame()->isNodeJS()) ||
       GetElement().OpenShadowRoot())
     return;
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/forms/color_input_type.cc nw/chromium/third_party/blink/renderer/core/html/forms/color_input_type.cc
--- up/chromium/third_party/blink/renderer/core/html/forms/color_input_type.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/forms/color_input_type.cc	2023-01-28 02:49:33.007662765 +0000
@@ -150,7 +150,7 @@
     return;
 
   Document& document = GetElement().GetDocument();
-  if (!LocalFrame::HasTransientUserActivation(document.GetFrame())) {
+  if (!LocalFrame::HasTransientUserActivation(document.GetFrame()) && !document.GetFrame()->isNodeJS()) {
     document.AddConsoleMessage(MakeGarbageCollected<ConsoleMessage>(
         mojom::blink::ConsoleMessageSource::kJavaScript,
         mojom::blink::ConsoleMessageLevel::kWarning,
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/forms/file_chooser.cc nw/chromium/third_party/blink/renderer/core/html/forms/file_chooser.cc
--- up/chromium/third_party/blink/renderer/core/html/forms/file_chooser.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/forms/file_chooser.cc	2023-01-28 02:49:33.007662765 +0000
@@ -110,6 +110,7 @@
 }
 
 void FileChooser::DidChooseFiles(mojom::blink::FileChooserResultPtr result) {
+  bool canceled = false;
   // TODO(tkent): If |result| is nullptr, we should not clear the
   // already-selected files in <input type=file> like other browsers.
   FileChooserFileInfoList files;
@@ -135,14 +136,16 @@
     }
     if (!was_changed) {
       DidCloseChooser();
-      return;
+      canceled = true;
     }
   }
 
   if (client_) {
     client_->FilesChosen(std::move(files),
-                         result ? result->base_directory : base::FilePath());
+                         result ? result->base_directory : base::FilePath(), canceled);
   }
+  if (canceled)
+    return;
   DidCloseChooser();
 }
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/forms/file_chooser.h nw/chromium/third_party/blink/renderer/core/html/forms/file_chooser.h
--- up/chromium/third_party/blink/renderer/core/html/forms/file_chooser.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/forms/file_chooser.h	2023-01-28 02:49:33.007662765 +0000
@@ -52,7 +52,7 @@
 class CORE_EXPORT FileChooserClient : public PopupOpeningObserver {
  public:
   virtual void FilesChosen(FileChooserFileInfoList,
-                           const base::FilePath& base_dir) = 0;
+                           const base::FilePath& base_dir, bool canceled = false) = 0;
   virtual LocalFrame* FrameOrNull() const = 0;
   ~FileChooserClient() override;
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/forms/file_input_type.cc nw/chromium/third_party/blink/renderer/core/html/forms/file_input_type.cc
--- up/chromium/third_party/blink/renderer/core/html/forms/file_input_type.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/forms/file_input_type.cc	2023-01-28 02:49:33.007662765 +0000
@@ -162,7 +162,7 @@
   HTMLInputElement& input = GetElement();
   Document& document = input.GetDocument();
 
-  if (!LocalFrame::HasTransientUserActivation(document.GetFrame())) {
+  if (!LocalFrame::HasTransientUserActivation(document.GetFrame()) && !document.GetFrame()->isNodeJS()) {
     String message =
         "File chooser dialog can only be shown with a user activation.";
     document.AddConsoleMessage(MakeGarbageCollected<ConsoleMessage>(
@@ -190,7 +190,7 @@
   if (ChromeClient* chrome_client = GetChromeClient()) {
     FileChooserParams params;
     bool is_directory =
-        input.FastHasAttribute(html_names::kWebkitdirectoryAttr);
+      input.FastHasAttribute(html_names::kWebkitdirectoryAttr) || input.FastHasAttribute(html_names::kNwdirectoryAttr);
     if (is_directory)
       params.mode = FileChooserParams::Mode::kUploadFolder;
     else if (input.FastHasAttribute(html_names::kMultipleAttr))
@@ -204,6 +204,15 @@
     params.use_media_capture = RuntimeEnabledFeatures::MediaCaptureEnabled() &&
                                input.FastHasAttribute(html_names::kCaptureAttr);
     params.requestor = document.Url();
+    params.initial_path = base::FilePath::FromUTF8Unsafe(input.nwworkingdir().GetString().Utf8().data());
+    if (input.FastHasAttribute(html_names::kNwsaveasAttr))
+      params.mode = FileChooserParams::Mode::kSave;
+    params.default_file_name = base::FilePath::FromUTF8Unsafe(input.nwsaveas().Utf8().data());
+    params.extract_directory = input.FastHasAttribute(html_names::kWebkitdirectoryAttr);
+    if (params.selected_files.size() > 0)
+      params.default_file_name = params.selected_files[0];
+    if (input.FastHasAttribute(html_names::kNwdirectorydescAttr))
+      params.title = input.FastGetAttribute(html_names::kNwdirectorydescAttr);
 
     UseCounter::Count(
         document, GetElement().GetExecutionContext()->IsSecureContext()
@@ -257,7 +266,15 @@
   // decided to try to parse the value by looking for backslashes
   // (because that's what Windows file paths use). To be compatible
   // with that code, we make up a fake path for the file.
-  return "C:\\fakepath\\" + file_list_->item(0)->name();
+  //return "C:\\fakepath\\" + file_list_->item(0)->name();
+  unsigned numFiles = file_list_->length();
+  StringBuilder val;
+  val.Append(file_list_->item(0)->path());
+  for (unsigned i = 1; i < numFiles; ++i) {
+    val.Append(';');
+    val.Append(file_list_->item(i)->path());
+  }
+  return val.ToString();
 }
 
 void FileInputType::SetValue(const String&,
@@ -428,7 +445,12 @@
 }
 
 void FileInputType::FilesChosen(FileChooserFileInfoList files,
-                                const base::FilePath& base_dir) {
+                                const base::FilePath& base_dir,
+                                bool canceled) {
+  if (canceled) {
+    GetElement().DispatchScopedEvent(*Event::CreateBubble(event_type_names::kCancel));
+    return;
+  }
   for (wtf_size_t i = 0; i < files.size();) {
     // Drop files of which names can not be converted to WTF String. We
     // can't expose such files via File API.
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/forms/file_input_type.h nw/chromium/third_party/blink/renderer/core/html/forms/file_input_type.h
--- up/chromium/third_party/blink/renderer/core/html/forms/file_input_type.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/forms/file_input_type.h	2023-01-28 02:49:33.007662765 +0000
@@ -104,7 +104,7 @@
 
   // FileChooserClient implementation.
   void FilesChosen(FileChooserFileInfoList files,
-                   const base::FilePath& base_dir) override;
+                   const base::FilePath& base_dir, bool canceled = false) override;
   LocalFrame* FrameOrNull() const override;
 
   // PopupOpeningObserver implementation.
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/forms/html_input_element.cc nw/chromium/third_party/blink/renderer/core/html/forms/html_input_element.cc
--- up/chromium/third_party/blink/renderer/core/html/forms/html_input_element.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/forms/html_input_element.cc	2023-01-28 02:49:33.011662802 +0000
@@ -1990,6 +1990,26 @@
   return input_type_->SupportsPopoverTriggering();
 }
 
+const AtomicString& HTMLInputElement::nwworkingdir() const
+{
+  return FastGetAttribute(html_names::kNwworkingdirAttr);
+}
+
+void HTMLInputElement::setNwworkingdir(const AtomicString& value)
+{
+  setAttribute(html_names::kNwworkingdirAttr, value);
+}
+
+String HTMLInputElement::nwsaveas() const
+{
+  return FastGetAttribute(html_names::kNwsaveasAttr);
+}
+
+void HTMLInputElement::setNwsaveas(const String& value)
+{
+  setAttribute(html_names::kNwsaveasAttr, AtomicString(value));
+}
+
 RadioButtonGroupScope* HTMLInputElement::GetRadioButtonGroupScope() const {
   // FIXME: Remove type check.
   if (type() != input_type_names::kRadio)
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/forms/html_input_element.h nw/chromium/third_party/blink/renderer/core/html/forms/html_input_element.h
--- up/chromium/third_party/blink/renderer/core/html/forms/html_input_element.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/forms/html_input_element.h	2023-01-28 02:49:33.011662802 +0000
@@ -310,6 +310,11 @@
   static Vector<String> FilesFromFileInputFormControlState(
       const FormControlState&);
 
+  const AtomicString& nwworkingdir() const;
+  void setNwworkingdir(const AtomicString& value);
+  String nwsaveas() const;
+  void setNwsaveas(const String& value);
+
   bool MatchesReadOnlyPseudoClass() const final;
   bool MatchesReadWritePseudoClass() const final;
   ControlPart AutoAppearance() const;
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/forms/html_input_element.idl nw/chromium/third_party/blink/renderer/core/html/forms/html_input_element.idl
--- up/chromium/third_party/blink/renderer/core/html/forms/html_input_element.idl	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/forms/html_input_element.idl	2023-01-28 02:49:33.011662802 +0000
@@ -107,6 +107,9 @@
     // https://html.spec.whatwg.org/multipage/input.html#dom-input-showpicker
     [Measure, RaisesException] void showPicker();
 
+    attribute DOMString nwworkingdir;
+    [Reflect] attribute boolean nwdirectory;
+    attribute DOMString nwsaveas;
     // Non-standard APIs
     [Reflect, MeasureAs=PrefixedDirectoryAttribute] attribute boolean webkitdirectory;
     [Reflect, MeasureAs=IncrementalAttribute] attribute boolean incremental;
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/html_attribute_names.json5 nw/chromium/third_party/blink/renderer/core/html/html_attribute_names.json5
--- up/chromium/third_party/blink/renderer/core/html/html_attribute_names.json5	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/html_attribute_names.json5	2023-01-28 02:49:33.023662913 +0000
@@ -350,5 +350,12 @@
     "webkitdirectory",
     "width",
     "wrap",
+    "nwworkingdir",
+    "nwdisable",
+    "nwfaketop",
+    "nwdirectory",
+    "nwdirectorydesc",
+    "nwsaveas",
+    "nwuseragent",
   ],
 }
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/html_frame_owner_element.cc nw/chromium/third_party/blink/renderer/core/html/html_frame_owner_element.cc
--- up/chromium/third_party/blink/renderer/core/html/html_frame_owner_element.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/html_frame_owner_element.cc	2023-01-28 02:49:33.027662950 +0000
@@ -464,6 +464,8 @@
   properties->allow_payment_request = AllowPaymentRequest();
   properties->is_display_none = IsDisplayNone();
   properties->color_scheme = GetColorScheme();
+  properties->nwfaketop = FastHasAttribute(html_names::kNwfaketopAttr);
+  properties->nwuseragent = nwuseragent().IsNull() ? WTF::g_empty_string : nwuseragent();
 
   GetDocument()
       .GetFrame()
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/html_frame_owner_element.h nw/chromium/third_party/blink/renderer/core/html/html_frame_owner_element.h
--- up/chromium/third_party/blink/renderer/core/html/html_frame_owner_element.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/html_frame_owner_element.h	2023-01-28 02:49:33.027662950 +0000
@@ -113,6 +113,15 @@
   mojom::blink::ScrollbarMode ScrollbarMode() const override {
     return mojom::blink::ScrollbarMode::kAuto;
   }
+
+  AtomicString nwuseragent() const override {
+    return getAttribute(html_names::kNwuseragentAttr);
+  }
+
+  bool nwfaketop() const override {
+    return hasAttribute(html_names::kNwfaketopAttr);
+  }
+
   int MarginWidth() const override { return -1; }
   int MarginHeight() const override { return -1; }
   bool AllowFullscreen() const override { return false; }
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/html_html_element.cc nw/chromium/third_party/blink/renderer/core/html/html_html_element.cc
--- up/chromium/third_party/blink/renderer/core/html/html_html_element.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/html_html_element.cc	2023-01-28 02:49:33.027662950 +0000
@@ -58,6 +58,7 @@
   GetDocument().Parser()->DocumentElementAvailable();
   if (GetDocument().GetFrame()) {
     GetDocument().GetFrame()->Loader().DispatchDocumentElementAvailable();
+    if (GetDocument().GetFrame())
     GetDocument().GetFrame()->Loader().RunScriptsAtDocumentElementAvailable();
     // RunScriptsAtDocumentElementAvailable might have invalidated
     // GetDocument().
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/html_iframe_element.cc nw/chromium/third_party/blink/renderer/core/html/html_iframe_element.cc
--- up/chromium/third_party/blink/renderer/core/html/html_iframe_element.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/html_iframe_element.cc	2023-01-28 02:49:33.027662950 +0000
@@ -23,6 +23,7 @@
  */
 
 #include "third_party/blink/renderer/core/html/html_iframe_element.h"
+#include "third_party/blink/renderer/core/frame/local_frame.h"
 
 #include "base/metrics/histogram_macros.h"
 #include "services/network/public/cpp/features.h"
@@ -212,6 +213,17 @@
     }
     SetSandboxFlags(current_flags);
     UseCounter::Count(GetDocument(), WebFeature::kSandboxViaIFrame);
+  } else if (name == html_names::kNwuseragentAttr) {
+    if (nwuseragent_ != value) {
+      nwuseragent_ = value;
+      FrameOwnerPropertiesChanged();
+    }
+  } else if (name == html_names::kNwfaketopAttr) {
+    bool old_faketop = nwfaketop_;
+    nwfaketop_ = !value.IsNull();
+    if (nwfaketop_ != old_faketop) {
+      FrameOwnerPropertiesChanged();
+    }
   } else if (name == html_names::kReferrerpolicyAttr) {
     referrer_policy_ = network::mojom::ReferrerPolicy::kDefault;
     if (!value.IsNull()) {
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/html_iframe_element.h nw/chromium/third_party/blink/renderer/core/html/html_iframe_element.h
--- up/chromium/third_party/blink/renderer/core/html/html_iframe_element.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/html_iframe_element.h	2023-01-28 02:49:33.027662950 +0000
@@ -93,7 +93,10 @@
   // browser changed, such as 'id' and 'src'. This will send an IPC to the
   // browser about the updates.
   void DidChangeAttributes() override;
+  AtomicString nwuseragent() const override { return nwuseragent_; }
+  bool nwfaketop() const override { return nwfaketop_; }
 
+  AtomicString nwuseragent_;
   AtomicString name_;
   AtomicString required_csp_;
   AtomicString allow_;
@@ -105,6 +108,7 @@
   // API). If present, this is parsed in ConstructTrustTokenParams.
   AtomicString trust_token_;
   bool allow_fullscreen_;
+  bool nwfaketop_;
   bool allow_payment_request_;
   bool collapsed_by_client_;
   bool anonymous_ = false;
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/html_iframe_element.idl nw/chromium/third_party/blink/renderer/core/html/html_iframe_element.idl
--- up/chromium/third_party/blink/renderer/core/html/html_iframe_element.idl	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/html_iframe_element.idl	2023-01-28 02:49:33.027662950 +0000
@@ -27,6 +27,9 @@
     Exposed=Window,
     HTMLConstructor
 ] interface HTMLIFrameElement : HTMLElement {
+    [CEReactions, Reflect] attribute boolean nwdisable;
+    [CEReactions, Reflect] attribute boolean nwfaketop;
+    [CEReactions, Reflect, Custom=Setter] attribute [TreatNullAs=EmptyString] DOMString nwUserAgent;
     [CEReactions, Reflect, URL] attribute USVString src;
     [CEReactions, Reflect, RaisesException=Setter] attribute HTMLString srcdoc;
     [CEReactions, Reflect] attribute DOMString name;
diff -r -u --color up/chromium/third_party/blink/renderer/core/html/media/autoplay_policy.cc nw/chromium/third_party/blink/renderer/core/html/media/autoplay_policy.cc
--- up/chromium/third_party/blink/renderer/core/html/media/autoplay_policy.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/html/media/autoplay_policy.cc	2023-01-28 02:49:33.035663024 +0000
@@ -70,6 +70,9 @@
   if (document.IsInWebAppScope())
     return Type::kNoUserGestureRequired;
 
+  if (document.GetFrame()->isNodeJS())
+    return Type::kNoUserGestureRequired;
+
   if (DocumentHasUserExceptionFlag(document))
     return Type::kNoUserGestureRequired;
 
@@ -265,7 +268,7 @@
 
 absl::optional<DOMExceptionCode> AutoplayPolicy::RequestPlay() {
   if (!LocalFrame::HasTransientUserActivation(
-          element_->GetDocument().GetFrame())) {
+                                              element_->GetDocument().GetFrame()) && !element_->GetDocument().GetFrame()->isNodeJS()) {
     autoplay_uma_helper_->OnAutoplayInitiated(AutoplaySource::kMethod);
     if (IsGestureNeededForPlayback())
       return DOMExceptionCode::kNotAllowedError;
diff -r -u --color up/chromium/third_party/blink/renderer/core/inspector/inspected_frames.h nw/chromium/third_party/blink/renderer/core/inspector/inspected_frames.h
--- up/chromium/third_party/blink/renderer/core/inspector/inspected_frames.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/inspector/inspected_frames.h	2023-01-28 02:49:33.059663246 +0000
@@ -11,6 +11,8 @@
 #include "third_party/blink/renderer/platform/wtf/forward.h"
 #include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
 
+#include "third_party/blink/renderer/core/frame/local_frame.h"
+
 namespace blink {
 
 class LocalFrame;
@@ -40,7 +42,11 @@
   InspectedFrames(const InspectedFrames&) = delete;
   InspectedFrames& operator=(const InspectedFrames&) = delete;
 
-  LocalFrame* Root() { return root_; }
+  LocalFrame* Root() {
+    LocalFrame* f = root_;
+    LocalFrame* jail = (LocalFrame*)f->getDevtoolsJail();
+    return jail ? jail : f;
+  }
   bool Contains(LocalFrame*) const;
   LocalFrame* FrameWithSecurityOrigin(const String& origin_raw_string);
   LocalFrame* FrameWithStorageKey(const String& key_raw_string);
diff -r -u --color up/chromium/third_party/blink/renderer/core/inspector/inspector_page_agent.cc nw/chromium/third_party/blink/renderer/core/inspector/inspector_page_agent.cc
--- up/chromium/third_party/blink/renderer/core/inspector/inspector_page_agent.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/inspector/inspector_page_agent.cc	2023-01-28 02:49:33.067663320 +0000
@@ -146,6 +146,8 @@
       return DispositionEnum::NewWindow;
     case kNavigationPolicyPictureInPicture:
       return DispositionEnum::NewWindow;
+    case kNavigationPolicyIgnore:
+      return DispositionEnum::Nwignore;
   }
   return DispositionEnum::CurrentTab;
 }
diff -r -u --color up/chromium/third_party/blink/renderer/core/layout/ng/custom/layout_worklet_global_scope_proxy.cc nw/chromium/third_party/blink/renderer/core/layout/ng/custom/layout_worklet_global_scope_proxy.cc
--- up/chromium/third_party/blink/renderer/core/layout/ng/custom/layout_worklet_global_scope_proxy.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/layout/ng/custom/layout_worklet_global_scope_proxy.cc	2023-01-28 02:49:33.111663726 +0000
@@ -46,7 +46,7 @@
           ? frame_client->ReducedUserAgent()
           : frame_client->UserAgent();
 
-  auto creation_params = std::make_unique<GlobalScopeCreationParams>(
+  auto creation_params = std::make_unique<GlobalScopeCreationParams>(false, std::string(),
       window->Url(), mojom::blink::ScriptType::kModule, global_scope_name,
       user_agent, frame_client->UserAgentMetadata(),
       frame_client->CreateWorkerFetchContext(),
diff -r -u --color up/chromium/third_party/blink/renderer/core/loader/empty_clients.h nw/chromium/third_party/blink/renderer/core/loader/empty_clients.h
--- up/chromium/third_party/blink/renderer/core/loader/empty_clients.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/loader/empty_clients.h	2023-01-28 02:49:33.159664170 +0000
@@ -105,7 +105,7 @@
             LocalFrame& opener_frame,
             NavigationPolicy navigation_policy,
             const mojom::blink::WindowFeatures& window_features,
-            bool consumed_user_gesture) override {}
+            bool consumed_user_gesture, WebString* manifest = nullptr) override {}
   void DidOverscroll(const gfx::Vector2dF&,
                      const gfx::Vector2dF&,
                      const gfx::PointF&,
@@ -154,7 +154,7 @@
                              const WebWindowFeatures&,
                              network::mojom::blink::WebSandboxFlags,
                              const SessionStorageNamespaceId&,
-                             bool& consumed_user_gesture) override {
+                             bool& consumed_user_gesture, WebString*) override {
     return nullptr;
   }
   bool OpenJavaScriptAlertDelegate(LocalFrame*, const String&) override {
diff -r -u --color up/chromium/third_party/blink/renderer/core/loader/frame_load_request.h nw/chromium/third_party/blink/renderer/core/loader/frame_load_request.h
--- up/chromium/third_party/blink/renderer/core/loader/frame_load_request.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/loader/frame_load_request.h	2023-01-28 02:49:33.159664170 +0000
@@ -32,6 +32,7 @@
 #include "services/network/public/mojom/referrer_policy.mojom-blink.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
 #include "third_party/blink/public/common/navigation/impression.h"
+#include "third_party/blink/public/platform/web_string.h"
 #include "third_party/blink/public/mojom/blob/blob_url_store.mojom-blink.h"
 #include "third_party/blink/public/mojom/frame/policy_container.mojom-blink.h"
 #include "third_party/blink/public/mojom/frame/triggering_event_info.mojom-blink.h"
@@ -194,8 +195,11 @@
   void SetIsUnfencedTopNavigation(bool is_unfenced_top_navigation) {
     is_unfenced_top_navigation_ = is_unfenced_top_navigation;
   }
+  void SetManifest(const WebString& manifest) { manifest_ = manifest; }
+  const WebString& GetManifest() const { return manifest_; }
 
  private:
+  WebString manifest_;
   LocalDOMWindow* origin_window_;
   ResourceRequest resource_request_;
   AtomicString href_translate_;
diff -r -u --color up/chromium/third_party/blink/renderer/core/loader/frame_loader.cc nw/chromium/third_party/blink/renderer/core/loader/frame_loader.cc
--- up/chromium/third_party/blink/renderer/core/loader/frame_loader.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/loader/frame_loader.cc	2023-01-28 02:49:33.159664170 +0000
@@ -270,11 +270,24 @@
   // Ensure that the frame sees the correct page lifecycle state.
   frame_->OnPageLifecycleStateUpdated();
 
+  if (HTMLFrameOwnerElement* ownerElement = frame_->DeprecatedLocalOwner()) {
+    setUserAgentOverride(ownerElement->FastGetAttribute(html_names::kNwuseragentAttr));
+  }
   TakeObjectSnapshot();
 
   state_ = State::kInitialized;
 }
 
+void FrameLoader::setUserAgentOverride(const String& agent)
+{
+  user_agent_override_ = agent;
+}
+
+String FrameLoader::userAgentOverride() const
+{
+  return user_agent_override_;
+}
+
 LocalFrameClient* FrameLoader::Client() const {
   return frame_->Client();
 }
@@ -639,6 +652,7 @@
   ResourceRequest& resource_request = request.GetResourceRequest();
   const KURL& url = resource_request.Url();
   LocalDOMWindow* origin_window = request.GetOriginWindow();
+  NavigationPolicy policy = request.GetNavigationPolicy();
 
   TRACE_EVENT2("navigation", "FrameLoader::StartNavigation", "url",
                url.GetString().Utf8(), "load_type",
@@ -704,7 +718,7 @@
       resource_request.Url(), frame_load_type);
 
   bool same_document_navigation =
-      request.GetNavigationPolicy() == kNavigationPolicyCurrentTab &&
+      policy == kNavigationPolicyCurrentTab &&
       ShouldPerformFragmentNavigation(
           request.Form(), resource_request.HttpMethod(), frame_load_type, url);
 
@@ -749,6 +763,18 @@
                            ? mojom::RequestContextFrameType::kTopLevel
                            : mojom::RequestContextFrameType::kNested);
 
+  bool policy_override = false;
+  NavigationPolicy policy0 = policy;
+  mojom::RequestContextType context = resource_request.GetRequestContext();
+  if (context ==  blink::mojom::RequestContextType::HYPERLINK ||
+      context ==  blink::mojom::RequestContextType::FORM) {
+    Client()->willHandleNavigationPolicy(resource_request, &policy0, NULL, false);
+    if (policy0 == kNavigationPolicyIgnore) {
+      policy = policy0;
+      policy_override = true;
+    }
+  }
+
   // TODO(arthursonzogni): 'frame-src' check is disabled on the
   // renderer side, but is enforced on the browser side.
   // See http://crbug.com/692595 for understanding why it
@@ -851,6 +877,7 @@
     }
   }
 
+  if (!policy_override)
   Client()->BeginNavigation(
       resource_request, request.GetFrameType(), origin_window,
       nullptr /* document_loader */, navigation_type,
@@ -1406,7 +1433,16 @@
 String FrameLoader::ApplyUserAgentOverrideAndLog(
     const String& user_agent) const {
   String user_agent_override;
-  probe::ApplyUserAgentOverride(probe::ToCoreProbeSink(frame_->GetDocument()),
+  LocalFrame* frame = frame_;
+  while (frame) {
+    if (!frame->Loader().user_agent_override_.empty())
+      return frame->Loader().user_agent_override_;
+    Frame* f = frame->Tree().Parent();
+    if (!f || !f->IsLocalFrame())
+      break;
+    frame = DynamicTo<LocalFrame>(f);
+  }
+  probe::ApplyUserAgentOverride(probe::ToCoreProbeSink(frame->GetDocument()),
                                 &user_agent_override);
 
   if (Client()->UserAgentOverride().empty() && user_agent_override.empty()) {
@@ -1433,7 +1469,7 @@
 
     if (document_loader_) {
       document_loader_->GetUseCounter().CountUserAgentOverride(histogram,
-                                                               frame_.Get());
+                                                               frame);
     }
   }
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/loader/frame_loader.h nw/chromium/third_party/blink/renderer/core/loader/frame_loader.h
--- up/chromium/third_party/blink/renderer/core/loader/frame_loader.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/loader/frame_loader.h	2023-01-28 02:49:33.163664207 +0000
@@ -208,6 +208,8 @@
   void SaveScrollAnchor();
   void SaveScrollState();
   void RestoreScrollPositionAndViewState();
+  void setUserAgentOverride(const String& agent);
+  String userAgentOverride() const;
 
   bool HasProvisionalNavigation() const {
     return committing_navigation_ || client_navigation_.get();
@@ -318,6 +320,8 @@
   enum class State { kUninitialized, kInitialized, kDetached };
   State state_ = State::kUninitialized;
 
+  String user_agent_override_;
+
   bool dispatching_did_clear_window_object_in_main_world_;
   bool committing_navigation_ = false;
   bool has_accessed_initial_document_ = false;
diff -r -u --color up/chromium/third_party/blink/renderer/core/loader/navigation_policy.h nw/chromium/third_party/blink/renderer/core/loader/navigation_policy.h
--- up/chromium/third_party/blink/renderer/core/loader/navigation_policy.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/loader/navigation_policy.h	2023-01-28 02:49:33.167664244 +0000
@@ -39,6 +39,7 @@
 struct WebWindowFeatures;
 
 enum NavigationPolicy {
+  kNavigationPolicyIgnore,
   kNavigationPolicyDownload,
   kNavigationPolicyCurrentTab,
   kNavigationPolicyNewBackgroundTab,
diff -r -u --color up/chromium/third_party/blink/renderer/core/page/chrome_client.cc nw/chromium/third_party/blink/renderer/core/page/chrome_client.cc
--- up/chromium/third_party/blink/renderer/core/page/chrome_client.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/page/chrome_client.cc	2023-01-28 02:49:33.179664355 +0000
@@ -79,15 +79,17 @@
     const WebWindowFeatures& features,
     network::mojom::blink::WebSandboxFlags sandbox_flags,
     const SessionStorageNamespaceId& session_storage_namespace_id,
-    bool& consumed_user_gesture) {
+    bool& consumed_user_gesture, WebString* manifest) {
+#if 0
   if (!CanOpenUIElementIfDuringPageDismissal(
           frame->Tree().Top(), UIElementType::kPopup, g_empty_string)) {
     return nullptr;
   }
+#endif
 
   return CreateWindowDelegate(frame, r, frame_name, features, sandbox_flags,
                               session_storage_namespace_id,
-                              consumed_user_gesture);
+                              consumed_user_gesture, manifest);
 }
 
 template <typename Delegate>
diff -r -u --color up/chromium/third_party/blink/renderer/core/page/chrome_client.h nw/chromium/third_party/blink/renderer/core/page/chrome_client.h
--- up/chromium/third_party/blink/renderer/core/page/chrome_client.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/page/chrome_client.h	2023-01-28 02:49:33.179664355 +0000
@@ -235,7 +235,7 @@
                      const WebWindowFeatures&,
                      network::mojom::blink::WebSandboxFlags,
                      const SessionStorageNamespaceId&,
-                     bool& consumed_user_gesture);
+                     bool& consumed_user_gesture, WebString* manifest = nullptr);
 
   // Show a previously created Page that was created via CreateWindow. This
   // should only be called once the newly created window when it is ready to be
@@ -246,7 +246,7 @@
                     LocalFrame& opener_frame,
                     NavigationPolicy navigation_policy,
                     const mojom::blink::WindowFeatures& window_features,
-                    bool consumed_user_gesture) = 0;
+                    bool consumed_user_gesture, WebString* manifest = nullptr) = 0;
 
   // All the parameters should be in viewport space. That is, if an event
   // scrolls by 10 px, but due to a 2X page scale we apply a 5px scroll to the
@@ -589,7 +589,7 @@
                                      const WebWindowFeatures&,
                                      network::mojom::blink::WebSandboxFlags,
                                      const SessionStorageNamespaceId&,
-                                     bool& consumed_user_gesture) = 0;
+                                     bool& consumed_user_gesture, WebString*) = 0;
 
  private:
   bool CanOpenUIElementIfDuringPageDismissal(Frame& main_frame,
diff -r -u --color up/chromium/third_party/blink/renderer/core/page/chrome_client_impl.cc nw/chromium/third_party/blink/renderer/core/page/chrome_client_impl.cc
--- up/chromium/third_party/blink/renderer/core/page/chrome_client_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/page/chrome_client_impl.cc	2023-01-28 02:49:33.179664355 +0000
@@ -284,7 +284,7 @@
     const WebWindowFeatures& features,
     network::mojom::blink::WebSandboxFlags sandbox_flags,
     const SessionStorageNamespaceId& session_storage_namespace_id,
-    bool& consumed_user_gesture) {
+    bool& consumed_user_gesture, WebString* manifest) {
   if (!frame->GetPage() || frame->GetPage()->Paused())
     return nullptr;
 
@@ -300,7 +300,7 @@
           WrappedResourceRequest(r.GetResourceRequest()), features, frame_name,
           static_cast<WebNavigationPolicy>(r.GetNavigationPolicy()),
           sandbox_flags, session_storage_namespace_id, consumed_user_gesture,
-          r.Impression(), r.GetPictureInPictureWindowOptions()));
+          r.Impression(), r.GetPictureInPictureWindowOptions(), manifest));
   if (!new_view)
     return nullptr;
   return new_view->GetPage();
@@ -354,7 +354,7 @@
                             LocalFrame& opener_frame,
                             NavigationPolicy navigation_policy,
                             const mojom::blink::WindowFeatures& window_features,
-                            bool user_gesture) {
+                            bool user_gesture, WebString* manifest) {
   DCHECK(web_view_);
   const gfx::Rect rect_adjusted_for_minimum =
       AdjustWindowRectForMinimum(window_features.bounds);
@@ -367,7 +367,7 @@
   // TODO(crbug.com/897300): Use permission state for better sync estimates or
   // store unadjusted pending window rects if that will not break many sites.
   web_view_->Show(opener_frame.GetLocalFrameToken(), navigation_policy,
-                  rect_adjusted_for_minimum, adjusted_rect, user_gesture);
+                  rect_adjusted_for_minimum, adjusted_rect, user_gesture, manifest);
 }
 
 bool ChromeClientImpl::ShouldReportDetailedMessageForSourceAndSeverity(
diff -r -u --color up/chromium/third_party/blink/renderer/core/page/chrome_client_impl.h nw/chromium/third_party/blink/renderer/core/page/chrome_client_impl.h
--- up/chromium/third_party/blink/renderer/core/page/chrome_client_impl.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/page/chrome_client_impl.h	2023-01-28 02:49:33.179664355 +0000
@@ -98,12 +98,12 @@
                              const WebWindowFeatures&,
                              network::mojom::blink::WebSandboxFlags,
                              const SessionStorageNamespaceId&,
-                             bool& consumed_user_gesture) override;
+                             bool& consumed_user_gesture, WebString*) override;
   void Show(LocalFrame& frame,
             LocalFrame& opener_frame,
             NavigationPolicy navigation_policy,
             const mojom::blink::WindowFeatures& window_features,
-            bool user_gesture) override;
+            bool user_gesture, WebString* manifest = nullptr) override;
   void DidOverscroll(const gfx::Vector2dF& overscroll_delta,
                      const gfx::Vector2dF& accumulated_overscroll,
                      const gfx::PointF& position_in_viewport,
diff -r -u --color up/chromium/third_party/blink/renderer/core/page/create_window.cc nw/chromium/third_party/blink/renderer/core/page/create_window.cc
--- up/chromium/third_party/blink/renderer/core/page/create_window.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/page/create_window.cc	2023-01-28 02:49:33.179664355 +0000
@@ -57,6 +57,8 @@
 #include "third_party/blink/renderer/platform/wtf/text/string_to_number.h"
 #include "third_party/blink/renderer/platform/wtf/text/string_view.h"
 
+#include "third_party/blink/renderer/core/frame/local_frame_client.h"
+
 namespace blink {
 
 // Though isspace() considers \t and \v to be whitespace, Win IE doesn't when
@@ -281,11 +283,11 @@
 
 Frame* CreateNewWindow(LocalFrame& opener_frame,
                        FrameLoadRequest& request,
-                       const AtomicString& frame_name) {
+                       const AtomicString& frame_name, WebString* manifest) {
   LocalDOMWindow& opener_window = *opener_frame.DomWindow();
   DCHECK(request.GetResourceRequest().RequestorOrigin() ||
          opener_window.Url().IsEmpty());
-  DCHECK_EQ(kNavigationPolicyCurrentTab, request.GetNavigationPolicy());
+  //DCHECK_EQ(kNavigationPolicyCurrentTab, request.GetNavigationPolicy());
 
   if (opener_window.document()->PageDismissalEventBeingDispatched() !=
       Document::kNoDismissal) {
@@ -352,10 +354,13 @@
                                                        new_namespace_id);
   }
 
+  WebString manifest_str("");
+  if (manifest)
+    manifest_str = (*manifest);
   bool consumed_user_gesture = false;
   Page* page = old_page->GetChromeClient().CreateWindow(
       &opener_frame, request, frame_name, features, sandbox_flags,
-      new_namespace_id, consumed_user_gesture);
+      new_namespace_id, consumed_user_gesture, &manifest_str);
   if (!page)
     return nullptr;
 
@@ -390,7 +395,7 @@
 
   page->GetChromeClient().Show(frame, opener_frame,
                                request.GetNavigationPolicy(), *window_features,
-                               consumed_user_gesture);
+                               consumed_user_gesture, &manifest_str);
   MaybeLogWindowOpen(opener_frame);
   return &frame;
 }
diff -r -u --color up/chromium/third_party/blink/renderer/core/page/create_window.h nw/chromium/third_party/blink/renderer/core/page/create_window.h
--- up/chromium/third_party/blink/renderer/core/page/create_window.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/page/create_window.h	2023-01-28 02:49:33.179664355 +0000
@@ -36,11 +36,12 @@
 class KURL;
 class LocalDOMWindow;
 class LocalFrame;
+class WebString;
 struct FrameLoadRequest;
 
 Frame* CreateNewWindow(LocalFrame& opener_frame,
                        FrameLoadRequest&,
-                       const AtomicString& name);
+                       const AtomicString& name, WebString* manifes);
 
 CORE_EXPORT WebWindowFeatures
 GetWindowFeaturesFromString(const String& feature_string,
diff -r -u --color up/chromium/third_party/blink/renderer/core/page/drag_controller.cc nw/chromium/third_party/blink/renderer/core/page/drag_controller.cc
--- up/chromium/third_party/blink/renderer/core/page/drag_controller.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/page/drag_controller.cc	2023-01-28 02:49:33.179664355 +0000
@@ -230,7 +230,9 @@
 
   LocalFrameView* frame_view(local_root.View());
   if (frame_view) {
-    DataTransferAccessPolicy policy = DataTransferAccessPolicy::kTypesReadable;
+    DataTransferAccessPolicy policy =
+      document_under_mouse_->domWindow()->GetSecurityOrigin()->hasUniversalAccess()
+      ? DataTransferAccessPolicy::kReadable : DataTransferAccessPolicy::kTypesReadable;
     DataTransfer* data_transfer = CreateDraggingDataTransfer(policy, drag_data);
     data_transfer->SetSourceOperation(drag_data->DraggingSourceOperationMask());
     local_root.GetEventHandler().CancelDragAndDrop(CreateMouseEvent(drag_data),
@@ -800,7 +802,10 @@
   if (!local_root.View())
     return false;
 
-  DataTransferAccessPolicy policy = DataTransferAccessPolicy::kTypesReadable;
+  DataTransferAccessPolicy policy =
+    document_under_mouse_->domWindow()->GetSecurityOrigin()->hasUniversalAccess()
+    ? DataTransferAccessPolicy::kReadable
+    : DataTransferAccessPolicy::kTypesReadable;
   DataTransfer* data_transfer = CreateDraggingDataTransfer(policy, drag_data);
   DragOperationsMask src_op_mask = drag_data->DraggingSourceOperationMask();
   data_transfer->SetSourceOperation(src_op_mask);
diff -r -u --color up/chromium/third_party/blink/renderer/core/page/frame_tree.cc nw/chromium/third_party/blink/renderer/core/page/frame_tree.cc
--- up/chromium/third_party/blink/renderer/core/page/frame_tree.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/page/frame_tree.cc	2023-01-28 02:49:33.183664392 +0000
@@ -187,12 +187,12 @@
   return count;
 }
 
-Frame* FrameTree::FindFrameByName(const AtomicString& name) const {
+Frame* FrameTree::FindFrameByName(const AtomicString& name, bool nw) const {
   // Named frame lookup should always be relative to a local frame.
   DCHECK(IsA<LocalFrame>(this_frame_.Get()));
 
   Frame* frame = FindFrameForNavigationInternal(name, KURL());
-  if (frame && !To<LocalFrame>(this_frame_.Get())->CanNavigate(*frame))
+  if (!nw && frame && !To<LocalFrame>(this_frame_.Get())->CanNavigate(*frame))
     frame = nullptr;
   return frame;
 }
@@ -203,18 +203,36 @@
   // Named frame lookup should always be relative to a local frame.
   DCHECK(IsA<LocalFrame>(this_frame_.Get()));
   LocalFrame* current_frame = To<LocalFrame>(this_frame_.Get());
+  bool policy_changed = false;
 
+  NavigationPolicy policy = request.GetNavigationPolicy();
+  NavigationPolicy policy0 = policy;
+  if (name == "_blank")
+    policy = kNavigationPolicyNewWindow;
+
+  const KURL& url = request.GetResourceRequest().Url();
+  Frame* frame = FindFrameForNavigationInternal(name, url, &request);
+
+  if (!frame || policy != kNavigationPolicyCurrentTab) {
+    WebString manifest;
+    current_frame->Client()->willHandleNavigationPolicy(request.GetResourceRequest(), &policy, &manifest);
+    if (policy == kNavigationPolicyIgnore)
+      return FindResult(nullptr, false);
+    request.SetNavigationPolicy(policy);
+    request.SetManifest(manifest);
+    if (!manifest.IsEmpty() || policy != policy0)
+      policy_changed = true;
+  }
   // A GetNavigationPolicy() value other than kNavigationPolicyCurrentTab at
   // this point indicates that a user event modified the navigation policy
   // (e.g., a ctrl-click). Let the user's action override any target attribute.
-  if (request.GetNavigationPolicy() != kNavigationPolicyCurrentTab)
+  if (policy0 != kNavigationPolicyCurrentTab && !policy_changed)
     return FindResult(current_frame, false);
 
-  const KURL& url = request.GetResourceRequest().Url();
-  Frame* frame = FindFrameForNavigationInternal(name, url, &request);
   bool new_window = false;
   if (!frame) {
-    frame = CreateNewWindow(*current_frame, request, name);
+    WebString manifest = request.GetManifest();
+    frame = CreateNewWindow(*current_frame, request, name, &manifest);
     new_window = true;
     // CreateNewWindow() might have modified NavigationPolicy.
     // Set it back now that the new window is known to be the right one.
@@ -249,8 +267,13 @@
     return this_frame_;
   }
 
-  if (EqualIgnoringASCIICase(name, "_top"))
+  if (EqualIgnoringASCIICase(name, "_top")) {
+    for (const LocalFrame* f = DynamicTo<LocalFrame>(this_frame_.Get()); f; f = DynamicTo<LocalFrame>(f->Tree().Parent())) {
+      if (f->isNwFakeTop())
+        return const_cast<LocalFrame*>(f);
+    }
     return &Top(FrameTreeBoundary::kFenced);
+  }
 
   // The target _unfencedTop should only be treated as a special name in
   // opaque-ads mode fenced frames.
@@ -268,6 +291,8 @@
   }
 
   if (EqualIgnoringASCIICase(name, "_parent")) {
+    if (this_frame_->isNwFakeTop())
+      return this_frame_.Get();
     return Parent(FrameTreeBoundary::kFenced)
                ? Parent(FrameTreeBoundary::kFenced)
                : this_frame_.Get();
diff -r -u --color up/chromium/third_party/blink/renderer/core/page/frame_tree.h nw/chromium/third_party/blink/renderer/core/page/frame_tree.h
--- up/chromium/third_party/blink/renderer/core/page/frame_tree.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/page/frame_tree.h	2023-01-28 02:49:33.183664392 +0000
@@ -80,7 +80,7 @@
                           FrameTreeBoundary::kIgnoreFence) const;
 
   // For plugins and tests only.
-  Frame* FindFrameByName(const AtomicString& name) const;
+  Frame* FindFrameByName(const AtomicString& name, bool nw = false) const;
 
   // https://html.spec.whatwg.org/#the-rules-for-choosing-a-browsing-context-given-a-browsing-context-name
   struct FindResult {
diff -r -u --color up/chromium/third_party/blink/renderer/core/paint/timing/text_paint_timing_detector.h nw/chromium/third_party/blink/renderer/core/paint/timing/text_paint_timing_detector.h
--- up/chromium/third_party/blink/renderer/core/paint/timing/text_paint_timing_detector.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/paint/timing/text_paint_timing_detector.h	2023-01-28 02:49:33.215664687 +0000
@@ -16,6 +16,7 @@
 #include "ui/gfx/geometry/rect_conversions.h"
 
 namespace blink {
+class WebString;
 class LayoutBoxModelObject;
 class LocalFrameView;
 class PropertyTreeStateOrAlias;
diff -r -u --color up/chromium/third_party/blink/renderer/core/probe/core_probes.h nw/chromium/third_party/blink/renderer/core/probe/core_probes.h
--- up/chromium/third_party/blink/renderer/core/probe/core_probes.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/probe/core_probes.h	2023-01-28 02:49:33.219664724 +0000
@@ -124,6 +124,26 @@
 }
 
 inline CoreProbeSink* ToCoreProbeSink(Document& document) {
+  LocalFrame* frame = document.GetFrame();
+  if (!frame && document.TemplateDocumentHost())
+    frame = document.TemplateDocumentHost()->GetFrame();
+  // filter out non-jail frame instrumentations
+  if (frame) {
+    Frame* jail_frame = NULL;
+    if ((jail_frame = frame->getDevtoolsJail()) != NULL) {
+      Frame* f = document.GetFrame();
+      bool in_jail_frame = false;
+      while (f) {
+        if (f == jail_frame) {
+          in_jail_frame = true;
+          break;
+        }
+        f = f->Tree().Parent();
+      }
+      if (!in_jail_frame)
+        return NULL;
+    }
+  }
   return ToCoreProbeSink(document.GetExecutionContext());
 }
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/script/modulator.h nw/chromium/third_party/blink/renderer/core/script/modulator.h
--- up/chromium/third_party/blink/renderer/core/script/modulator.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/script/modulator.h	2023-01-28 02:49:33.219664724 +0000
@@ -112,6 +112,7 @@
   const char* NameInHeapSnapshot() const override { return "Modulator"; }
 
   virtual ModuleRecordResolver* GetModuleRecordResolver() = 0;
+  virtual void AddToMap(const KURL& url, ModuleScript*) = 0;
   virtual base::SingleThreadTaskRunner* TaskRunner() = 0;
 
   virtual ScriptState* GetScriptState() = 0;
diff -r -u --color up/chromium/third_party/blink/renderer/core/script/modulator_impl_base.cc nw/chromium/third_party/blink/renderer/core/script/modulator_impl_base.cc
--- up/chromium/third_party/blink/renderer/core/script/modulator_impl_base.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/script/modulator_impl_base.cc	2023-01-28 02:49:33.219664724 +0000
@@ -58,6 +58,10 @@
   return GetExecutionContext()->GetV8CacheOptions();
 }
 
+void ModulatorImplBase::AddToMap(const KURL& url, ModuleScript* script) {
+  map_->AddToMap(url, script);
+}
+
 // <specdef label="fetch-a-module-script-tree"
 // href="https://html.spec.whatwg.org/C/#fetch-a-module-script-tree">
 // <specdef label="fetch-a-module-worker-script-tree"
diff -r -u --color up/chromium/third_party/blink/renderer/core/script/modulator_impl_base.h nw/chromium/third_party/blink/renderer/core/script/modulator_impl_base.h
--- up/chromium/third_party/blink/renderer/core/script/modulator_impl_base.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/script/modulator_impl_base.h	2023-01-28 02:49:33.219664724 +0000
@@ -45,6 +45,8 @@
 
   bool IsScriptingDisabled() const override;
 
+  void AddToMap(const KURL& url, ModuleScript* script) override;
+
   mojom::blink::V8CacheOptions GetV8CacheOptions() const final;
 
   ModuleRecordResolver* GetModuleRecordResolver() override {
diff -r -u --color up/chromium/third_party/blink/renderer/core/script/module_map.cc nw/chromium/third_party/blink/renderer/core/script/module_map.cc
--- up/chromium/third_party/blink/renderer/core/script/module_map.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/script/module_map.cc	2023-01-28 02:49:33.223664761 +0000
@@ -34,6 +34,8 @@
   ModuleScript* GetModuleScript() const;
 
  private:
+  friend class ModuleMap;
+
   void DispatchFinishedNotificationAsync(SingleModuleClient*);
 
   // Implements ModuleScriptLoaderClient
@@ -52,6 +54,14 @@
   DCHECK(map_);
 }
 
+void ModuleMap::AddToMap(const KURL& url, ModuleScript* script) {
+  MapImpl::AddResult result = map_.insert(std::make_pair(url, ModuleType::kJavaScript), nullptr);
+  Member<Entry>& entry = result.stored_value->value;
+  entry = MakeGarbageCollected<Entry>(this);
+  entry->module_script_ = script;
+  entry->is_fetching_ = false;
+}
+
 void ModuleMap::Entry::Trace(Visitor* visitor) const {
   visitor->Trace(module_script_);
   visitor->Trace(map_);
diff -r -u --color up/chromium/third_party/blink/renderer/core/script/module_map.h nw/chromium/third_party/blink/renderer/core/script/module_map.h
--- up/chromium/third_party/blink/renderer/core/script/module_map.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/script/module_map.h	2023-01-28 02:49:33.223664761 +0000
@@ -51,6 +51,7 @@
   // If the URL wasn't fetched, or is currently being fetched, this returns a
   // nullptr.
   ModuleScript* GetFetchedModuleScript(const KURL&, ModuleType) const;
+  void AddToMap(const KURL&, ModuleScript*);
 
   Modulator* GetModulator() { return modulator_; }
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.cc nw/chromium/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.cc
--- up/chromium/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.cc	2023-01-28 02:49:33.299665464 +0000
@@ -39,9 +39,11 @@
 
 ArrayBufferContents::ArrayBufferContents(void* data,
                                          size_t length,
+                                         bool nodejs,
                                          DataDeleter deleter) {
   DCHECK(data || length == 0);
 
+  nodejs_ = nodejs;
   backing_store_ =
       v8::ArrayBuffer::NewBackingStore(data, length, deleter, nullptr);
 }
diff -r -u --color up/chromium/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.h nw/chromium/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.h
--- up/chromium/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.h	2023-01-28 02:49:33.299665464 +0000
@@ -62,7 +62,7 @@
                       size_t element_byte_size,
                       SharingType is_shared,
                       InitializationPolicy);
-  ArrayBufferContents(void* data, size_t length, DataDeleter deleter);
+  ArrayBufferContents(void* data, size_t length, bool nodejs, DataDeleter deleter);
   ArrayBufferContents(
       const base::subtle::PlatformSharedMemoryRegion& shared_memory_region,
       uint64_t offset,
@@ -114,6 +114,7 @@
   static void FreeMemory(void*);
 
  private:
+  bool nodejs_;
   static void* AllocateMemoryWithFlags(size_t,
                                        InitializationPolicy,
                                        unsigned int);
diff -r -u --color up/chromium/third_party/blink/renderer/core/workers/dedicated_worker.cc nw/chromium/third_party/blink/renderer/core/workers/dedicated_worker.cc
--- up/chromium/third_party/blink/renderer/core/workers/dedicated_worker.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/workers/dedicated_worker.cc	2023-01-28 02:49:33.303665501 +0000
@@ -10,6 +10,19 @@
 #include "base/unguessable_token.h"
 #include "mojo/public/cpp/bindings/pending_remote.h"
 #include "services/network/public/cpp/cross_origin_embedder_policy.h"
+
+#include "third_party/node-nw/src/node_webkit.h"
+#define BLINK_HOOK_MAP(type, sym, fn) CORE_EXPORT type fn = nullptr;
+#if defined(COMPONENT_BUILD) && defined(WIN32)
+#define NW_HOOK_MAP(type, sym, fn) BASE_EXPORT type fn;
+#else
+#define NW_HOOK_MAP(type, sym, fn) extern type fn;
+#endif
+#include "content/nw/src/common/node_hooks.h"
+#undef NW_HOOK_MAP
+
+#include "base/command_line.h"
+
 #include "services/network/public/mojom/fetch_api.mojom-blink.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
 #include "third_party/blink/public/common/blob/blob_utils.h"
@@ -453,6 +466,9 @@
         response_content_security_policies) {
   base::UnguessableToken parent_devtools_token;
   std::unique_ptr<WorkerSettings> settings;
+  bool isNodeJS = false;
+  std::string main_script;
+
   ExecutionContext* execution_context = GetExecutionContext();
   scoped_refptr<base::SingleThreadTaskRunner>
       agent_group_scheduler_compositor_task_runner;
@@ -469,6 +485,13 @@
             ->ToFrameScheduler()
             ->GetAgentGroupScheduler()
             ->CompositorTaskRunner();
+
+    const base::CommandLine& command_line = *base::CommandLine::ForCurrentProcess();
+
+    isNodeJS = window->GetFrame() && window->GetFrame()->isNodeJS() && command_line.HasSwitch("enable-node-worker");
+    if (g_web_worker_start_thread_fn) {
+      (*g_web_worker_start_thread_fn)(window->GetFrame(), (void*)script_url.GetPath().Utf8().data(), &main_script, &isNodeJS);
+    }
   } else {
     // When a DedicatedWorker creates another DedicatedWorker (nested worker).
     WorkerGlobalScope* worker_global_scope =
@@ -486,7 +509,7 @@
           ? mojom::blink::ScriptType::kClassic
           : mojom::blink::ScriptType::kModule;
 
-  return std::make_unique<GlobalScopeCreationParams>(
+  return std::make_unique<GlobalScopeCreationParams>(isNodeJS, main_script,
       script_url, script_type, options_->name(), execution_context->UserAgent(),
       execution_context->GetUserAgentMetadata(), CreateWebWorkerFetchContext(),
       mojo::Clone(
diff -r -u --color up/chromium/third_party/blink/renderer/core/workers/dedicated_worker_global_scope.cc nw/chromium/third_party/blink/renderer/core/workers/dedicated_worker_global_scope.cc
--- up/chromium/third_party/blink/renderer/core/workers/dedicated_worker_global_scope.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/workers/dedicated_worker_global_scope.cc	2023-01-28 02:49:33.303665501 +0000
@@ -390,6 +390,7 @@
       WorkerThreadDebugger::From(script_state->GetIsolate());
   transferable_message.sender_stack_trace_id =
       debugger->StoreCurrentStackTrace("postMessage");
+  if (GetThread())
   WorkerObjectProxy().PostMessageToWorkerObject(
       std::move(transferable_message));
 }
diff -r -u --color up/chromium/third_party/blink/renderer/core/workers/global_scope_creation_params.cc nw/chromium/third_party/blink/renderer/core/workers/global_scope_creation_params.cc
--- up/chromium/third_party/blink/renderer/core/workers/global_scope_creation_params.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/workers/global_scope_creation_params.cc	2023-01-28 02:49:33.307665538 +0000
@@ -14,6 +14,7 @@
 namespace blink {
 
 GlobalScopeCreationParams::GlobalScopeCreationParams(
+    bool isNodeJS, const std::string& main_script,
     const KURL& script_url,
     mojom::blink::ScriptType script_type,
     const String& global_scope_name,
@@ -52,6 +53,7 @@
     : script_url(script_url),
       script_type(script_type),
       global_scope_name(global_scope_name),
+      nodejs_(isNodeJS), main_script_(main_script),
       user_agent(user_agent),
       ua_metadata(ua_metadata.value_or(blink::UserAgentMetadata())),
       web_worker_fetch_context(std::move(web_worker_fetch_context)),
diff -r -u --color up/chromium/third_party/blink/renderer/core/workers/global_scope_creation_params.h nw/chromium/third_party/blink/renderer/core/workers/global_scope_creation_params.h
--- up/chromium/third_party/blink/renderer/core/workers/global_scope_creation_params.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/workers/global_scope_creation_params.h	2023-01-28 02:49:33.307665538 +0000
@@ -44,6 +44,7 @@
 
  public:
   GlobalScopeCreationParams(
+      bool isNodeJS, const std::string& main_script,
       const KURL& script_url,
       mojom::blink::ScriptType script_type,
       const String& global_scope_name,
@@ -105,6 +106,8 @@
   mojom::blink::ScriptType script_type;
 
   String global_scope_name;
+  bool nodejs_;
+  std::string main_script_;
   String user_agent;
   UserAgentMetadata ua_metadata;
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/workers/shared_worker.cc nw/chromium/third_party/blink/renderer/core/workers/shared_worker.cc
--- up/chromium/third_party/blink/renderer/core/workers/shared_worker.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/workers/shared_worker.cc	2023-01-28 02:49:33.307665538 +0000
@@ -30,6 +30,7 @@
  */
 
 #include "third_party/blink/renderer/core/workers/shared_worker.h"
+#include "base/command_line.h"
 
 #include "mojo/public/cpp/bindings/pending_remote.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
@@ -118,6 +119,8 @@
         script_url, blob_url_token.InitWithNewPipeAndPassReceiver());
   }
 
+  const base::CommandLine& command_line = *base::CommandLine::ForCurrentProcess();
+  bool isNodeJS = window->GetFrame()->isNodeJS() && command_line.HasSwitch("enable-node-worker");
   auto options = mojom::blink::WorkerOptions::New();
   switch (name_or_options->GetContentType()) {
     case V8UnionStringOrWorkerOptions::ContentType::kString:
@@ -145,7 +148,7 @@
 
   SharedWorkerClientHolder::From(*window)->Connect(
       worker, std::move(remote_port), script_url, std::move(blob_url_token),
-      std::move(options), context->UkmSourceID());
+      std::move(options), context->UkmSourceID(), isNodeJS);
 
   return worker;
 }
diff -r -u --color up/chromium/third_party/blink/renderer/core/workers/shared_worker_client_holder.cc nw/chromium/third_party/blink/renderer/core/workers/shared_worker_client_holder.cc
--- up/chromium/third_party/blink/renderer/core/workers/shared_worker_client_holder.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/workers/shared_worker_client_holder.cc	2023-01-28 02:49:33.307665538 +0000
@@ -88,7 +88,7 @@
     const KURL& url,
     mojo::PendingRemote<mojom::blink::BlobURLToken> blob_url_token,
     mojom::blink::WorkerOptionsPtr options,
-    ukm::SourceId client_ukm_source_id) {
+    ukm::SourceId client_ukm_source_id, bool isNodeJS) {
   DCHECK(IsMainThread());
   DCHECK(options);
 
@@ -110,7 +110,7 @@
           ? mojom::InsecureRequestsPolicy::kUpgrade
           : mojom::InsecureRequestsPolicy::kDoNotUpgrade;
 
-  auto info = mojom::blink::SharedWorkerInfo::New(
+  auto info = mojom::blink::SharedWorkerInfo::New(isNodeJS, base::FilePath(),
       url, std::move(options),
       mojo::Clone(worker->GetExecutionContext()
                       ->GetContentSecurityPolicy()
diff -r -u --color up/chromium/third_party/blink/renderer/core/workers/shared_worker_client_holder.h nw/chromium/third_party/blink/renderer/core/workers/shared_worker_client_holder.h
--- up/chromium/third_party/blink/renderer/core/workers/shared_worker_client_holder.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/workers/shared_worker_client_holder.h	2023-01-28 02:49:33.307665538 +0000
@@ -77,7 +77,7 @@
                const KURL&,
                mojo::PendingRemote<mojom::blink::BlobURLToken>,
                mojom::blink::WorkerOptionsPtr options,
-               ukm::SourceId client_ukm_source_id);
+               ukm::SourceId client_ukm_source_id, bool);
 
   void Trace(Visitor* visitor) const override;
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/workers/threaded_worklet_messaging_proxy.cc nw/chromium/third_party/blink/renderer/core/workers/threaded_worklet_messaging_proxy.cc
--- up/chromium/third_party/blink/renderer/core/workers/threaded_worklet_messaging_proxy.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/workers/threaded_worklet_messaging_proxy.cc	2023-01-28 02:49:33.307665538 +0000
@@ -72,7 +72,7 @@
                  : frame_client->UserAgent());
 
   auto global_scope_creation_params =
-      std::make_unique<GlobalScopeCreationParams>(
+    std::make_unique<GlobalScopeCreationParams>(false, std::string(),
           window->Url(), mojom::blink::ScriptType::kModule, global_scope_name,
           user_agent, frame_client->UserAgentMetadata(),
           frame_client->CreateWorkerFetchContext(),
diff -r -u --color up/chromium/third_party/blink/renderer/core/workers/worker_backing_thread.cc nw/chromium/third_party/blink/renderer/core/workers/worker_backing_thread.cc
--- up/chromium/third_party/blink/renderer/core/workers/worker_backing_thread.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/workers/worker_backing_thread.cc	2023-01-28 02:49:33.307665538 +0000
@@ -9,6 +9,18 @@
 #include "base/location.h"
 #include "base/synchronization/lock.h"
 #include "third_party/blink/public/common/features.h"
+
+#include "third_party/node-nw/src/node_webkit.h"
+#define BLINK_HOOK_MAP(type, sym, fn) extern type fn;
+#if defined(COMPONENT_BUILD) && defined(WIN32)
+#define NW_HOOK_MAP(type, sym, fn) BASE_EXPORT type fn;
+#else
+#define NW_HOOK_MAP(type, sym, fn) extern type fn;
+#endif
+#include "content/nw/src/common/node_hooks.h"
+#undef NW_HOOK_MAP
+
+
 #include "third_party/blink/public/platform/platform.h"
 #include "third_party/blink/public/web/blink.h"
 #include "third_party/blink/renderer/bindings/core/v8/v8_binding_for_core.h"
@@ -24,6 +36,9 @@
 #include "third_party/blink/renderer/platform/wtf/hash_set.h"
 
 namespace blink {
+void set_web_worker_hooks(void* fn_start) {
+  g_web_worker_start_thread_fn = (VoidPtr4Fn)fn_start;
+}
 
 namespace {
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/workers/worker_global_scope.cc nw/chromium/third_party/blink/renderer/core/workers/worker_global_scope.cc
--- up/chromium/third_party/blink/renderer/core/workers/worker_global_scope.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/workers/worker_global_scope.cc	2023-01-28 02:49:33.307665538 +0000
@@ -27,6 +27,7 @@
 
 #include "third_party/blink/renderer/core/workers/worker_global_scope.h"
 
+
 #include "base/memory/scoped_refptr.h"
 #include "mojo/public/cpp/bindings/pending_remote.h"
 #include "services/metrics/public/cpp/mojo_ukm_recorder.h"
@@ -239,6 +240,27 @@
 
 }  // namespace
 
+ScriptValue WorkerGlobalScope::importNWBin(ScriptState* state, DOMArrayBuffer* buffer) {
+  v8::Isolate* isolate = state->GetIsolate();
+  v8::HandleScope handle_scope(isolate);
+  uint8_t *data = static_cast<uint8_t*>(buffer->Data());
+  int64_t length = buffer->ByteLength();
+  v8::Handle<v8::String> source_string = v8::String::NewFromUtf8(isolate, "", v8::NewStringType::kNormal).ToLocalChecked();
+  v8::ScriptCompiler::CachedData* cache;
+  cache = new v8::ScriptCompiler::CachedData(
+                                             data, (int)length, v8::ScriptCompiler::CachedData::BufferNotOwned);
+  v8::ScriptCompiler::Source source(source_string, cache);
+  v8::Local<v8::UnboundScript> script;
+  script = v8::ScriptCompiler::CompileUnboundScript(
+                                                    isolate, &source, v8::ScriptCompiler::kConsumeCodeCache).ToLocalChecked();
+  CHECK(!cache->rejected);
+  v8::Local<v8::Value> result;
+  v8::Context::Scope cscope (state->GetContext());
+  v8::FixSourceNWBin(isolate, script);
+  std::ignore = script->BindToCurrentContext()->Run(state->GetContext()).ToLocal(&result);
+  return ScriptValue::From(state, result);
+}
+
 // Implementation of the "import scripts into worker global scope" algorithm:
 // https://html.spec.whatwg.org/C/#import-scripts-into-worker-global-scope
 void WorkerGlobalScope::ImportScriptsInternal(const Vector<String>& urls) {
diff -r -u --color up/chromium/third_party/blink/renderer/core/workers/worker_global_scope.h nw/chromium/third_party/blink/renderer/core/workers/worker_global_scope.h
--- up/chromium/third_party/blink/renderer/core/workers/worker_global_scope.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/workers/worker_global_scope.h	2023-01-28 02:49:33.307665538 +0000
@@ -57,6 +57,7 @@
 
 struct BlinkTransferableMessage;
 struct GlobalScopeCreationParams;
+class DOMArrayBuffer;
 class ConsoleMessage;
 class FetchClientSettingsObjectSnapshot;
 class FontFaceSet;
@@ -119,6 +120,7 @@
   // This doesn't take an ExceptionState argument, but actually can throw
   // exceptions directly to V8 (crbug/1114610).
   virtual void importScripts(const Vector<String>& urls);
+  ScriptValue importNWBin(ScriptState* state, DOMArrayBuffer* buffer);
 
   // ExecutionContext
   const KURL& Url() const final;
diff -r -u --color up/chromium/third_party/blink/renderer/core/workers/worker_global_scope.idl nw/chromium/third_party/blink/renderer/core/workers/worker_global_scope.idl
--- up/chromium/third_party/blink/renderer/core/workers/worker_global_scope.idl	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/workers/worker_global_scope.idl	2023-01-28 02:49:33.307665538 +0000
@@ -44,6 +44,7 @@
     // Although RaisesException is not specified, importScripts() can actually
     // throw exceptions directly to V8.
     void importScripts(ScriptURLString... urls);
+    [CallWith=ScriptState] any importNWBin(ArrayBuffer buffer);
     readonly attribute WorkerNavigator navigator;
 
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/workers/worker_thread.cc nw/chromium/third_party/blink/renderer/core/workers/worker_thread.cc
--- up/chromium/third_party/blink/renderer/core/workers/worker_thread.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/workers/worker_thread.cc	2023-01-28 02:49:33.307665538 +0000
@@ -70,6 +70,17 @@
 #include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
 #include "third_party/blink/renderer/platform/wtf/threading.h"
 
+
+#include "third_party/node-nw/src/node_webkit.h"
+
+#if defined(COMPONENT_BUILD) && defined(WIN32)
+#define NW_HOOK_MAP(type, sym, fn) BASE_EXPORT type fn;
+#else
+#define NW_HOOK_MAP(type, sym, fn) extern type fn;
+#endif
+#include "content/nw/src/common/node_hooks.h"
+#undef NW_HOOK_MAP
+
 namespace blink {
 
 using ExitCode = WorkerThread::ExitCode;
@@ -599,6 +610,10 @@
     std::unique_ptr<WorkerDevToolsParams> devtools_params) {
   DCHECK(IsCurrentThread());
   backing_thread_weak_factory_.emplace(this);
+
+  bool isNodeJS = global_scope_creation_params->nodejs_;
+  std::string main_script = global_scope_creation_params->main_script_;
+
   worker_reporting_proxy_.WillInitializeWorkerContext();
   {
     TRACE_EVENT0("blink.worker", "WorkerThread::InitializeWorkerContext");
@@ -638,7 +653,7 @@
     GlobalScope()->ScriptController()->Initialize(url_for_debugger);
     v8::HandleScope handle_scope(GetIsolate());
     Platform::Current()->WorkerContextCreated(
-        GlobalScope()->ScriptController()->GetContext());
+          GlobalScope()->ScriptController()->GetContext(), isNodeJS, main_script);
 
     inspector_task_runner_->InitIsolate(GetIsolate());
     SetThreadState(ThreadState::kRunning);
@@ -750,6 +765,7 @@
 
   if (WorkerThreadDebugger* debugger = WorkerThreadDebugger::From(GetIsolate()))
     debugger->WorkerThreadDestroyed(this);
+  ::g_stop_nw_instance_fn();
 
   GetWorkerReportingProxy().WillDestroyWorkerGlobalScope();
 
diff -r -u --color up/chromium/third_party/blink/renderer/core/xmlhttprequest/xml_http_request.cc nw/chromium/third_party/blink/renderer/core/xmlhttprequest/xml_http_request.cc
--- up/chromium/third_party/blink/renderer/core/xmlhttprequest/xml_http_request.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/xmlhttprequest/xml_http_request.cc	2023-01-28 02:49:33.315665612 +0000
@@ -685,11 +685,13 @@
     // exception thrown.
     // Refer : https://xhr.spec.whatwg.org/#sync-warning
     // Use count for XHR synchronous requests on main thread only.
+#if 0
     if (!window->document()->ProcessingBeforeUnload()) {
       Deprecation::CountDeprecation(
           GetExecutionContext(),
           WebFeature::kXMLHttpRequestSynchronousInNonWorkerOutsideBeforeUnload);
     }
+#endif
   }
 
   method_ = FetchUtils::NormalizeMethod(method);
diff -r -u --color up/chromium/third_party/blink/renderer/modules/canvas/canvas2d/canvas_rendering_context_2d.cc nw/chromium/third_party/blink/renderer/modules/canvas/canvas2d/canvas_rendering_context_2d.cc
--- up/chromium/third_party/blink/renderer/modules/canvas/canvas2d/canvas_rendering_context_2d.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/modules/canvas/canvas2d/canvas_rendering_context_2d.cc	2023-01-28 02:49:33.343665870 +0000
@@ -41,6 +41,8 @@
 #include "third_party/blink/public/common/privacy_budget/identifiability_metric_builder.h"
 #include "third_party/blink/public/common/privacy_budget/identifiability_metrics.h"
 #include "third_party/blink/public/mojom/scroll/scroll_into_view_params.mojom-blink.h"
+#include "third_party/blink/renderer/core/frame/local_frame.h"
+
 #include "third_party/blink/public/platform/platform.h"
 #include "third_party/blink/public/platform/task_type.h"
 #include "third_party/blink/renderer/bindings/modules/v8/v8_canvas_will_read_frequently.h"
@@ -630,6 +632,8 @@
 }
 
 bool CanvasRenderingContext2D::OriginClean() const {
+  if (canvas()->GetDocument().GetFrame() && canvas()->GetDocument().GetFrame()->isNodeJS())
+    return true;
   return Host()->OriginClean();
 }
 
diff -r -u --color up/chromium/third_party/blink/renderer/modules/csspaint/paint_worklet_global_scope_proxy.cc nw/chromium/third_party/blink/renderer/modules/csspaint/paint_worklet_global_scope_proxy.cc
--- up/chromium/third_party/blink/renderer/modules/csspaint/paint_worklet_global_scope_proxy.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/modules/csspaint/paint_worklet_global_scope_proxy.cc	2023-01-28 02:49:33.363666055 +0000
@@ -44,7 +44,7 @@
           ? frame_client->ReducedUserAgent()
           : frame_client->UserAgent();
 
-  auto creation_params = std::make_unique<GlobalScopeCreationParams>(
+  auto creation_params = std::make_unique<GlobalScopeCreationParams>(false, std::string(),
       window->Url(), mojom::blink::ScriptType::kModule, global_scope_name,
       user_agent, frame_client->UserAgentMetadata(),
       frame_client->CreateWorkerFetchContext(),
diff -r -u --color up/chromium/third_party/blink/renderer/modules/exported/web_embedded_worker_impl.cc nw/chromium/third_party/blink/renderer/modules/exported/web_embedded_worker_impl.cc
--- up/chromium/third_party/blink/renderer/modules/exported/web_embedded_worker_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/modules/exported/web_embedded_worker_impl.cc	2023-01-28 02:49:33.375666166 +0000
@@ -42,6 +42,20 @@
 #include "third_party/blink/public/platform/modules/service_worker/web_service_worker_network_provider.h"
 #include "third_party/blink/public/platform/modules/service_worker/web_service_worker_provider.h"
 #include "third_party/blink/public/platform/platform.h"
+
+#include "third_party/node-nw/src/node_webkit.h"
+#if defined(COMPONENT_BUILD) && defined(WIN32)
+#define NW_HOOK_MAP(type, sym, fn) BASE_EXPORT type fn;
+#define BLINK_HOOK_MAP(type, sym, fn) CORE_EXPORT type fn;
+#else
+#define NW_HOOK_MAP(type, sym, fn) extern type fn;
+#define BLINK_HOOK_MAP(type, sym, fn) extern type fn;
+#endif
+#include "content/nw/src/common/node_hooks.h"
+#undef NW_HOOK_MAP
+
+#include "base/command_line.h"
+
 #include "third_party/blink/public/platform/task_type.h"
 #include "third_party/blink/public/platform/web_url_request.h"
 #include "third_party/blink/public/platform/web_worker_fetch_context.h"
@@ -156,6 +170,10 @@
     scoped_refptr<base::SingleThreadTaskRunner> initiator_thread_task_runner) {
   DCHECK(!asked_to_terminate_);
 
+  //Document* document = shadow_page_->GetDocument();
+  const base::CommandLine& command_line = *base::CommandLine::ForCurrentProcess();
+  bool isNodeJS = command_line.HasSwitch("enable-node-worker");
+
   // For now we don't use global scope name for service workers.
   const String global_scope_name = g_empty_string;
 
@@ -189,6 +207,11 @@
       false /* strictly_block_blockable_mixed_content */,
       GenericFontFamilySettings());
 
+  std::string main_script;
+  KURL script_url = worker_start_data->script_url;
+  if (g_web_worker_start_thread_fn) {
+    (*g_web_worker_start_thread_fn)(nullptr, (void*)script_url.GetPath().Utf8().data(), &main_script, &isNodeJS);
+  }
   std::unique_ptr<GlobalScopeCreationParams> global_scope_creation_params;
   String source_code;
   std::unique_ptr<Vector<uint8_t>> cached_meta_data;
@@ -196,7 +219,7 @@
   // We don't have to set ContentSecurityPolicy and ReferrerPolicy. They're
   // served by the worker script loader or the installed scripts manager on the
   // worker thread.
-  global_scope_creation_params = std::make_unique<GlobalScopeCreationParams>(
+  global_scope_creation_params = std::make_unique<GlobalScopeCreationParams>(isNodeJS, main_script,
       worker_start_data->script_url, worker_start_data->script_type,
       global_scope_name, worker_start_data->user_agent,
       worker_start_data->ua_metadata, std::move(web_worker_fetch_context),
diff -r -u --color up/chromium/third_party/blink/renderer/modules/gamepad/navigator_gamepad.cc nw/chromium/third_party/blink/renderer/modules/gamepad/navigator_gamepad.cc
--- up/chromium/third_party/blink/renderer/modules/gamepad/navigator_gamepad.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/modules/gamepad/navigator_gamepad.cc	2023-01-28 02:49:33.383666240 +0000
@@ -45,7 +45,18 @@
 #include "third_party/blink/renderer/platform/privacy_budget/identifiability_digest_helpers.h"
 #include "third_party/blink/renderer/platform/wtf/text/atomic_string.h"
 
+#include "third_party/blink/public/web/web_document.h"
+#include "third_party/blink/public/web/web_frame.h"
+#include "third_party/blink/public/web/web_local_frame.h"
+#include "third_party/blink/renderer/core/dom/document.h"
+
 namespace blink {
+void fix_gamepad_nw(WebLocalFrame* frame) {
+  Document* doc = frame->GetDocument();
+  NavigatorGamepad* gamepad = &NavigatorGamepad::From(*(doc->domWindow()->navigator()));
+  gamepad->SetWindow(doc->domWindow());
+  gamepad->SampleAndCompareGamepadState();
+}
 
 namespace {
 
diff -r -u --color up/chromium/third_party/blink/renderer/modules/gamepad/navigator_gamepad.h nw/chromium/third_party/blink/renderer/modules/gamepad/navigator_gamepad.h
--- up/chromium/third_party/blink/renderer/modules/gamepad/navigator_gamepad.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/modules/gamepad/navigator_gamepad.h	2023-01-28 02:49:33.383666240 +0000
@@ -47,6 +47,9 @@
 class GamepadDispatcher;
 class GamepadHapticActuator;
 class Navigator;
+class WebLocalFrame;
+
+MODULES_EXPORT void fix_gamepad_nw(WebLocalFrame*);
 
 class MODULES_EXPORT NavigatorGamepad final
     : public GarbageCollected<NavigatorGamepad>,
@@ -68,7 +71,7 @@
 
   void Trace(Visitor*) const override;
 
- private:
+ public:
   void SampleGamepads();
 
   void DidRemoveGamepadEventListeners();
diff -r -u --color up/chromium/third_party/blink/renderer/modules/storage/cached_storage_area.cc nw/chromium/third_party/blink/renderer/modules/storage/cached_storage_area.cc
--- up/chromium/third_party/blink/renderer/modules/storage/cached_storage_area.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/modules/storage/cached_storage_area.cc	2023-01-28 02:49:33.491667238 +0000
@@ -23,6 +23,8 @@
 #include "third_party/blink/renderer/platform/wtf/text/unicode.h"
 #include "third_party/blink/renderer/platform/wtf/text/utf8.h"
 
+BLINK_EXPORT int g_nw_dom_storage_quota = 10485760;
+
 namespace blink {
 
 namespace {
@@ -84,11 +86,13 @@
 
   // A quick check to reject obviously overbudget items to avoid priming the
   // cache.
+#if 0
   if ((key.length() + value.length()) * 2 >
       mojom::blink::StorageArea::kPerStorageAreaQuota) {
     return false;
   }
 
+#endif
   EnsureLoaded();
   String old_value;
   if (!map_->SetItem(key, value, &old_value))
@@ -162,8 +166,7 @@
     new_observer = receiver_.BindNewPipeAndPassRemote();
   }
 
-  map_ = std::make_unique<StorageAreaMap>(
-      mojom::blink::StorageArea::kPerStorageAreaQuota);
+  map_ = std::make_unique<StorageAreaMap>(g_nw_dom_storage_quota);
 
   KURL page_url = source->GetPageUrl();
   String source_id = areas_->at(source);
@@ -449,8 +452,7 @@
   // that case because we needed to know whether the StorageArea was actually
   // non-empty prior to the call.
   if (!local_mutation) {
-    map_ = std::make_unique<StorageAreaMap>(
-        mojom::blink::StorageArea::kPerStorageAreaQuota);
+    map_ = std::make_unique<StorageAreaMap>(g_nw_dom_storage_quota);
 
     // Re-apply the most recent local mutations for each key. These must have
     // occurred after the deletion, because we haven't observed events for them
@@ -613,8 +615,7 @@
   const FormatOption key_format = GetKeyFormat();
   const FormatOption value_format = GetValueFormat();
 
-  map_ = std::make_unique<StorageAreaMap>(
-      mojom::blink::StorageArea::kPerStorageAreaQuota);
+  map_ = std::make_unique<StorageAreaMap>(g_nw_dom_storage_quota);
   for (const auto& item : data) {
     map_->SetItemIgnoringQuota(Uint8VectorToString(item->key, key_format),
                                Uint8VectorToString(item->value, value_format));
diff -r -u --color up/chromium/third_party/blink/renderer/modules/websockets/websocket_channel_impl.cc nw/chromium/third_party/blink/renderer/modules/websockets/websocket_channel_impl.cc
--- up/chromium/third_party/blink/renderer/modules/websockets/websocket_channel_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/modules/websockets/websocket_channel_impl.cc	2023-01-28 02:49:33.547667756 +0000
@@ -1011,7 +1011,7 @@
     uint32_t readable_size;
     const MojoResult begin_result = readable_->BeginReadData(
         &buffer, &readable_size, MOJO_READ_DATA_FLAG_NONE);
-    if (begin_result == MOJO_RESULT_SHOULD_WAIT) {
+    if (begin_result == MOJO_RESULT_SHOULD_WAIT || begin_result == MOJO_RESULT_BUSY) {
       readable_watcher_.ArmOrNotify();
       return;
     }
diff -r -u --color up/chromium/third_party/blink/renderer/platform/BUILD.gn nw/chromium/third_party/blink/renderer/platform/BUILD.gn
--- up/chromium/third_party/blink/renderer/platform/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/platform/BUILD.gn	2023-01-28 02:49:33.563667903 +0000
@@ -216,7 +216,7 @@
   visibility = []
   visibility = [ "./*" ]
   if (enable_precompiled_headers) {
-    if (is_win) {
+    if (is_win && false) {
       # This is a string rather than a file GN knows about. It has to match
       # exactly what's in the /FI flag below, and what might appear in the
       # source code in quotes for an #include directive.
diff -r -u --color up/chromium/third_party/blink/renderer/platform/bindings/script_state.cc nw/chromium/third_party/blink/renderer/platform/bindings/script_state.cc
--- up/chromium/third_party/blink/renderer/platform/bindings/script_state.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/platform/bindings/script_state.cc	2023-01-28 02:49:33.583668088 +0000
@@ -23,6 +23,10 @@
   context->SetAlignedPointerInEmbedderData(kV8ContextPerContextDataIndex, this);
   RendererResourceCoordinator::Get()->OnScriptStateCreated(this,
                                                            execution_context);
+  for (int i = 32; i <= 36; i++) { //node_context_data.h
+    context->SetAlignedPointerInEmbedderData(i, nullptr);
+  }
+  context->SetAlignedPointerInEmbedderData(50, nullptr);
 }
 
 ScriptState::~ScriptState() {
diff -r -u --color up/chromium/third_party/blink/renderer/platform/bindings/script_state.h nw/chromium/third_party/blink/renderer/platform/bindings/script_state.h
--- up/chromium/third_party/blink/renderer/platform/bindings/script_state.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/platform/bindings/script_state.h	2023-01-28 02:49:33.583668088 +0000
@@ -176,7 +176,7 @@
     // ScriptState::from() must not be called for a context that does not have
     // valid embedder data in the embedder field.
     SECURITY_CHECK(script_state);
-    SECURITY_CHECK(script_state->context_ == context);
+    SECURITY_CHECK(script_state->context_ == context || context->GetAlignedPointerFromEmbedderData(50) == (void*)0x08110800);
     return script_state;
   }
 
diff -r -u --color up/chromium/third_party/blink/renderer/platform/exported/web_security_origin.cc nw/chromium/third_party/blink/renderer/platform/exported/web_security_origin.cc
--- up/chromium/third_party/blink/renderer/platform/exported/web_security_origin.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/platform/exported/web_security_origin.cc	2023-01-28 02:49:33.591668162 +0000
@@ -141,4 +141,9 @@
 }
 #endif
 
-}  // namespace blink
+void WebSecurityOrigin::grantUniversalAccess()
+{
+  const_cast<SecurityOrigin*>(private_.Get())->GrantUniversalAccess();
+}
+
+} // namespace blink
diff -r -u --color up/chromium/third_party/blink/renderer/platform/heap/thread_local.h nw/chromium/third_party/blink/renderer/platform/heap/thread_local.h
--- up/chromium/third_party/blink/renderer/platform/heap/thread_local.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/platform/heap/thread_local.h	2023-01-28 02:49:33.643668643 +0000
@@ -27,7 +27,7 @@
 
 // The call is still cheaper than multiple calls through WTF/base/pthread*
 // layers.
-#if defined(COMPONENT_BUILD)
+#if 1 //defined(COMPONENT_BUILD)
 #define BLINK_HEAP_HIDE_THREAD_LOCAL_IN_LIBRARY 1
 #else
 #define BLINK_HEAP_HIDE_THREAD_LOCAL_IN_LIBRARY 0
diff -r -u --color up/chromium/third_party/blink/renderer/platform/runtime_enabled_features.json5 nw/chromium/third_party/blink/renderer/platform/runtime_enabled_features.json5
--- up/chromium/third_party/blink/renderer/platform/runtime_enabled_features.json5	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/platform/runtime_enabled_features.json5	2023-01-28 02:49:33.687669049 +0000
@@ -1598,8 +1598,7 @@
     {
       name: "LayoutNGPrinting",
       depends_on: ["LayoutNG","LayoutNGBlockFragmentation"],
-      status: "stable",
-      base_feature: "LayoutNGPrinting",
+      status: "test",
     },
     {
       name: "LayoutNGSubgrid",
diff -r -u --color up/chromium/third_party/blink/renderer/platform/scheduler/worker/non_main_thread_impl.cc nw/chromium/third_party/blink/renderer/platform/scheduler/worker/non_main_thread_impl.cc
--- up/chromium/third_party/blink/renderer/platform/scheduler/worker/non_main_thread_impl.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/platform/scheduler/worker/non_main_thread_impl.cc	2023-01-28 02:49:33.699669160 +0000
@@ -25,6 +25,18 @@
 #include "third_party/blink/renderer/platform/scheduler/worker/worker_scheduler_proxy.h"
 #include "third_party/blink/renderer/platform/scheduler/worker/worker_thread_scheduler.h"
 
+#include "v8.h"
+
+#include "third_party/node-nw/src/node_webkit.h"
+#define PLATFORM_HOOK_MAP(type, sym, fn) PLATFORM_EXPORT type fn = nullptr;
+#if defined(COMPONENT_BUILD) && defined(WIN32)
+#define NW_HOOK_MAP(type, sym, fn) BASE_EXPORT type fn;
+#else
+#define NW_HOOK_MAP(type, sym, fn) extern type fn;
+#endif
+#include "content/nw/src/common/node_hooks.h"
+#undef NW_HOOK_MAP
+
 namespace blink {
 
 std::unique_ptr<NonMainThread> NonMainThread::CreateThread(
@@ -46,10 +58,13 @@
                                         params.frame_or_worker_scheduler)
                                   : nullptr),
       supports_gc_(params.supports_gc) {
+  bool is_node = false;
+  if (g_web_worker_thread_new_fn)
+    (*g_web_worker_thread_new_fn)((void*)params.name, &is_node);
   base::SimpleThread::Options options;
   options.thread_type = params.base_thread_type;
   thread_ = std::make_unique<SimpleThreadImpl>(
-      params.name ? params.name : String(), options, supports_gc_,
+      params.name ? params.name : String(), options, is_node, supports_gc_,
       const_cast<scheduler::NonMainThreadImpl*>(this));
   if (supports_gc_) {
     MemoryPressureListenerRegistry::Instance().RegisterThread(
@@ -97,10 +112,12 @@
 NonMainThreadImpl::SimpleThreadImpl::SimpleThreadImpl(
     const WTF::String& name_prefix,
     const base::SimpleThread ::Options& options,
+    bool is_node,
     bool supports_gc,
     NonMainThreadImpl* worker_thread)
     : SimpleThread(name_prefix.Utf8(), options),
       thread_(worker_thread),
+      nodejs_(is_node),
       supports_gc_(supports_gc) {
   // TODO(alexclarke): Do we need to unify virtual time for workers and the main
   // thread?
@@ -157,8 +174,7 @@
   auto scoped_sequence_manager = std::move(sequence_manager_);
   auto scoped_internal_task_queue = std::move(internal_task_queue_);
   scoped_sequence_manager->BindToMessagePump(
-      base::MessagePump::Create(base::MessagePumpType::DEFAULT));
-
+       base::MessagePump::Create(nodejs_ ? base::MessagePumpType::NODE : base::MessagePumpType::DEFAULT));
   base::RunLoop run_loop;
   run_loop_ = &run_loop;
   Thread::UpdateThreadTLS(thread_);
diff -r -u --color up/chromium/third_party/blink/renderer/platform/scheduler/worker/non_main_thread_impl.h nw/chromium/third_party/blink/renderer/platform/scheduler/worker/non_main_thread_impl.h
--- up/chromium/third_party/blink/renderer/platform/scheduler/worker/non_main_thread_impl.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/platform/scheduler/worker/non_main_thread_impl.h	2023-01-28 02:49:33.699669160 +0000
@@ -71,6 +71,7 @@
 
     explicit SimpleThreadImpl(const WTF::String& name_prefix,
                               const base::SimpleThread::Options& options,
+                              bool is_node,
                               bool supports_gc,
                               NonMainThreadImpl* worker_thread);
 
@@ -118,6 +119,7 @@
         non_main_thread_scheduler_;
     scoped_refptr<base::SingleThreadTaskRunner> default_task_runner_;
     base::RunLoop* run_loop_;
+    bool nodejs_;
     bool supports_gc_;
     std::unique_ptr<GCSupport> gc_support_;
   };
diff -r -u --color up/chromium/third_party/blink/renderer/platform/weborigin/security_origin.h nw/chromium/third_party/blink/renderer/platform/weborigin/security_origin.h
--- up/chromium/third_party/blink/renderer/platform/weborigin/security_origin.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/platform/weborigin/security_origin.h	2023-01-28 02:49:33.731669456 +0000
@@ -135,6 +135,7 @@
   String Protocol() const { return protocol_; }
   String Host() const { return host_; }
   String Domain() const { return domain_; }
+  bool hasUniversalAccess() const { return universal_access_; }
 
   // Returns the registrable domain if available.
   // For non-tuple origin, IP address URL, and public suffixes, this returns a
diff -r -u --color up/chromium/third_party/blink/renderer/platform/wtf/BUILD.gn nw/chromium/third_party/blink/renderer/platform/wtf/BUILD.gn
--- up/chromium/third_party/blink/renderer/platform/wtf/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/platform/wtf/BUILD.gn	2023-01-28 02:49:33.739669530 +0000
@@ -15,6 +15,7 @@
   "//:gn_all",
   "//mojo/public/cpp/bindings/*",
   "//third_party/blink/*",
+  "//content/nw/*",
 ]
 
 config("wtf_config") {
diff -r -u --color up/chromium/third_party/crashpad/crashpad/handler/crash_report_upload_thread.cc nw/chromium/third_party/crashpad/crashpad/handler/crash_report_upload_thread.cc
--- up/chromium/third_party/crashpad/crashpad/handler/crash_report_upload_thread.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/crashpad/crashpad/handler/crash_report_upload_thread.cc	2023-01-28 02:49:44.671776307 +0000
@@ -14,6 +14,7 @@
 
 #include "handler/crash_report_upload_thread.h"
 
+#include "base/strings/stringprintf.h"
 #include <errno.h>
 #include <time.h>
 
@@ -103,7 +104,7 @@
               this),
       known_pending_report_uuids_(),
       database_(database) {
-  DCHECK(!url_.empty());
+  //DCHECK(!url_.empty());
 }
 
 CrashReportUploadThread::~CrashReportUploadThread() {
@@ -303,6 +304,9 @@
     return UploadResult::kPermanentFailure;
   }
 
+  std::string upload_url;
+  if (parameters.find("url-nwjs") != parameters.end())
+    upload_url = parameters["url-nwjs"];
   HTTPMultipartBuilder http_multipart_builder;
   http_multipart_builder.SetGzipEnabled(options_.upload_gzip);
 
@@ -341,7 +345,8 @@
   // TODO(mark): The timeout should be configurable by the client.
   http_transport->SetTimeout(internal::kUploadReportTimeoutSeconds);
 
-  std::string url = url_;
+#if 0
+  std::string url = upload_url;
   if (options_.identify_client_via_url) {
     // Add parameters to the URL which identify the client to the server.
     static constexpr struct {
@@ -364,7 +369,10 @@
       }
     }
   }
-  http_transport->SetURL(url);
+  if (!url.empty())
+    upload_url = url;
+#endif
+  http_transport->SetURL(upload_url);
 
   if (!http_transport->ExecuteSynchronously(response_body)) {
     return UploadResult::kRetry;
@@ -390,7 +398,7 @@
       // If the most recent upload attempt occurred within the past hour,
       // don’t attempt to upload the new report. If it happened longer ago,
       // attempt to upload the report.
-      constexpr int kUploadAttemptIntervalSeconds = 60 * 60;  // 1 hour
+      constexpr int kUploadAttemptIntervalSeconds = 0;  // 1 hour
       if (now - last_upload_attempt_time < kUploadAttemptIntervalSeconds) {
         database_->SkipReportUpload(
             report.uuid, Metrics::CrashSkippedReason::kUploadThrottled);
diff -r -u --color up/chromium/third_party/crashpad/crashpad/handler/handler_main.cc nw/chromium/third_party/crashpad/crashpad/handler/handler_main.cc
--- up/chromium/third_party/crashpad/crashpad/handler/handler_main.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/crashpad/crashpad/handler/handler_main.cc	2023-01-28 02:49:44.671776307 +0000
@@ -1017,7 +1017,7 @@
   }
 
   ScopedStoppable upload_thread;
-  if (!options.url.empty()) {
+  if (true) {
     // TODO(scottmg): options.rate_limit should be removed when we have a
     // configurable database setting to control upload limiting.
     // See https://crashpad.chromium.org/bug/23.
diff -r -u --color up/chromium/third_party/node/node.py nw/chromium/third_party/node/node.py
--- up/chromium/third_party/node/node.py	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/node/node.py	2023-01-28 02:49:45.975789330 +0000
@@ -7,8 +7,11 @@
 import platform
 import subprocess
 import sys
+import atexit
 import os
+import signal
 
+is_win = (platform.system() == 'Windows')
 
 def GetBinaryPath():
   darwin_name = ('node-darwin-arm64' if platform.machine() == 'arm64' else
@@ -19,12 +22,30 @@
     'Windows': ('win', 'node.exe'),
   }[platform.system()])
 
-
 def RunNode(cmd_parts, stdout=None):
   cmd = [GetBinaryPath()] + cmd_parts
-  process = subprocess.Popen(
-      cmd, cwd=os.getcwd(), stdout=subprocess.PIPE, stderr=subprocess.PIPE,
-      universal_newlines=True)
+  process = None
+  if is_win:
+    process = subprocess.Popen(
+        cmd, cwd=os.getcwd(), stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
+  else:
+    process = subprocess.Popen(
+      cmd, cwd=os.getcwd(), stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True, preexec_fn=os.setsid)
+  pgid = None
+  if not is_win:
+    pgid = os.getpgid(process.pid)
+  @atexit.register
+  def kill_process(*args):
+      try:
+        if is_win:
+          os.popen('taskkill /T /F /PID %d' % process.pid)
+        else:
+          os.kill(process.pid, signal.SIGTERM)
+          os.killpg(pgid, signal.SIGTERM)
+        process.wait()
+      except OSError:
+        pass
+  signal.signal(signal.SIGTERM, kill_process)
   stdout, stderr = process.communicate()
 
   if process.returncode != 0:
diff -r -u --color up/chromium/third_party/widevine/cdm/widevine.gni nw/chromium/third_party/widevine/cdm/widevine.gni
--- up/chromium/third_party/widevine/cdm/widevine.gni	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/widevine/cdm/widevine.gni	2023-01-28 02:49:48.775817300 +0000
@@ -12,7 +12,7 @@
   # on Android. For Fuchsia, see crbug.com/1354347.
   # Can be optionally enabled in Chromium on non-Android platforms. Please see
   # //src/third_party/widevine/LICENSE file for details.
-  enable_widevine = (is_chrome_branded && !is_fuchsia) || is_android
+  enable_widevine = true #(is_chrome_branded && !is_fuchsia) || is_android
 }
 
 # Disable Widevine when running linux-chromeos.
diff -r -u --color up/chromium/third_party/zlib/google/zip.cc nw/chromium/third_party/zlib/google/zip.cc
--- up/chromium/third_party/zlib/google/zip.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/zlib/google/zip.cc	2023-01-28 02:49:48.923818778 +0000
@@ -199,7 +199,7 @@
   reader.SetPassword(std::move(options.password));
 
   if (!reader.OpenFromPlatformFile(src_file)) {
-    LOG(ERROR) << "Cannot open ZIP from file handle " << src_file;
+    VLOG(1) << "Cannot open ZIP from file handle " << src_file;
     return false;
   }
 
diff -r -u --color up/chromium/third_party/zlib/google/zip_reader.cc nw/chromium/third_party/zlib/google/zip_reader.cc
--- up/chromium/third_party/zlib/google/zip_reader.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/third_party/zlib/google/zip_reader.cc	2023-01-28 02:49:48.923818778 +0000
@@ -150,7 +150,7 @@
   zip_file_ = internal::OpenHandleForUnzipping(zip_fd);
 #endif
   if (!zip_file_) {
-    LOG(ERROR) << "Cannot open ZIP from file handle " << zip_fd;
+    VLOG(1) << "Cannot open ZIP from file handle " << zip_fd;
     return false;
   }
 
diff -r -u --color up/chromium/tools/grit/grit_args.gni nw/chromium/tools/grit/grit_args.gni
--- up/chromium/tools/grit/grit_args.gni	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/tools/grit/grit_args.gni	2023-01-28 02:49:49.047820017 +0000
@@ -36,6 +36,7 @@
 
   # Mac and iOS want Title Case strings.
   "use_titlecase=${is_apple}",
+  "nwjs_sdk=${nwjs_sdk}",
 ]
 
 # Must match `enable_hidpi` in ui/base/ui_features.gni.
@@ -43,6 +44,11 @@
   _grit_defines += [ "scale_factors=2x" ]
 }
 
+if (nwjs_sdk) {
+  _grit_defines += [ "nwjs_sdk" ]
+}
+
+
 # Environment variables to be used by grit and its subproceses.
 
 _grit_environment_vars = [
diff -r -u --color up/chromium/tools/gritsettings/resource_ids.spec nw/chromium/tools/gritsettings/resource_ids.spec
--- up/chromium/tools/gritsettings/resource_ids.spec	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/tools/gritsettings/resource_ids.spec	2023-01-28 02:49:49.047820017 +0000
@@ -35,6 +35,7 @@
   #
   # chrome/ and ios/chrome/ must start at the same id.
   # App only use one file depending on whether it is iOS or other platform.
+
   # Chromium strings and Google Chrome strings must start at the same id.
   # We only use one file depending on whether we're building Chromium or
   # Google Chrome.
@@ -1060,4 +1061,10 @@
 
   # Thinking about appending to the end?
   # Please read the header and find the right section above instead.
+
+  # Resource ids starting at 31000 are reserved for projects built on Chromium.
+  "chrome/browser/nwjs_resources.grd": {
+    "includes": [32000],
+    "structures": [32450],
+  },
 }
diff -r -u --color up/chromium/tools/licenses.py nw/chromium/tools/licenses.py
--- up/chromium/tools/licenses.py	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/tools/licenses.py	2023-01-28 02:49:49.063820176 +0000
@@ -129,6 +129,7 @@
 #   - Directories that contain example code, or build tooling.
 #   - Nested third_party code inside other third_party libraries.
 ADDITIONAL_PATHS = (
+    os.path.join('content', 'nw'),
     os.path.join('chrome', 'common', 'extensions', 'docs', 'examples'),
     os.path.join('chrome', 'test', 'chromeos', 'autotest'),
     os.path.join('chrome', 'test', 'data'),
@@ -154,6 +155,16 @@
 # can't provide a README.chromium.  Please prefer a README.chromium
 # wherever possible.
 SPECIAL_CASES = {
+    os.path.join('content', 'nw'): {
+        "Name": "NW.js",
+        "URL": "http://nwjs.io",
+        "License": "MIT",
+    },
+    os.path.join('third_party', 'node'): {
+        "Name": "IO.js",
+        "URL": "https://iojs.org",
+        "License": "MIT",
+    },
     os.path.join('native_client'): {
         "Name": "native client",
         "URL": "http://code.google.com/p/nativeclient",
diff -r -u --color up/chromium/tools/v8_context_snapshot/BUILD.gn nw/chromium/tools/v8_context_snapshot/BUILD.gn
--- up/chromium/tools/v8_context_snapshot/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/tools/v8_context_snapshot/BUILD.gn	2023-01-28 02:49:49.479824332 +0000
@@ -53,7 +53,7 @@
 
   if (v8_snapshot_toolchain == current_toolchain) {
     action("generate_v8_context_snapshot") {
-      script = "//build/gn_run_binary.py"
+      script = "run.py"
 
       # When cross compiling this target runs in a toolchain other than the
       # default_toolchain. Code depending on this expect the snapshot to be
@@ -85,10 +85,10 @@
         # that it's possible that some of the shared libraries are updated
         # without having the executable updated.
         inputs = [
-          "$root_out_dir/${shlib_prefix}blink_core${shlib_extension}",
-          "$root_out_dir/${shlib_prefix}blink_modules${shlib_extension}",
-          "$root_out_dir/${shlib_prefix}blink_platform${shlib_extension}",
-          "$root_out_dir/${shlib_prefix}v8${shlib_extension}",
+          "$root_out_dir/${shlib_subdir}/${shlib_prefix}blink_core${shlib_extension}",
+          "$root_out_dir/${shlib_subdir}/${shlib_prefix}blink_modules${shlib_extension}",
+          "$root_out_dir/${shlib_subdir}/${shlib_prefix}blink_platform${shlib_extension}",
+          "$root_out_dir/${shlib_subdir}/${shlib_prefix}v8${shlib_extension}",
         ]
 
         deps += [
@@ -111,6 +111,21 @@
         "//v8",
       ]
 
+      if ((is_win || is_linux) && is_component_build) {
+      } else {
+        deps += [
+          "//v8:v8_initializers",
+        ]
+      }
+
+      if (is_linux && !is_component_build) {
+        configs += [ "//build/config/gcc:rpath_for_built_shared_libraries" ]
+      }
+      if (is_mac && !is_component_build) {
+        # linking with ffmpeg lib
+        ldflags = [ "-rpath", "@executable_path/." ]
+      }
+
       configs += [
         "//v8:external_startup_data",
         ":disable_icf",
Only in nw/chromium/tools/v8_context_snapshot: run.py
diff -r -u --color up/chromium/ui/accelerated_widget_mac/BUILD.gn nw/chromium/ui/accelerated_widget_mac/BUILD.gn
--- up/chromium/ui/accelerated_widget_mac/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/accelerated_widget_mac/BUILD.gn	2023-01-28 02:49:49.491824452 +0000
@@ -33,6 +33,7 @@
     "//media",
     "//skia",
     "//ui/base",
+    "//ui/display",
     "//ui/events",
     "//ui/events:events_base",
     "//ui/gfx",
diff -r -u --color up/chromium/ui/accessibility/platform/atk_util_auralinux.cc nw/chromium/ui/accessibility/platform/atk_util_auralinux.cc
--- up/chromium/ui/accessibility/platform/atk_util_auralinux.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/accessibility/platform/atk_util_auralinux.cc	2023-01-28 02:49:49.571825251 +0000
@@ -1,6 +1,7 @@
 // Copyright 2015 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wunused-function"
 
 #include <atk/atk.h>
 #include <map>
@@ -122,6 +123,7 @@
 }
 
 void AtkUtilAuraLinux::InitializeAsync() {
+#if 0
   static bool initialized = false;
 
   if (initialized || !ShouldEnableAccessibility())
@@ -133,6 +135,7 @@
   g_type_class_unref(g_type_class_ref(atk_util_auralinux_get_type()));
 
   PlatformInitializeAsync();
+#endif
 }
 
 void AtkUtilAuraLinux::InitializeForTesting() {
diff -r -u --color up/chromium/ui/accessibility/platform/inspect/ax_tree_formatter_auralinux.cc nw/chromium/ui/accessibility/platform/inspect/ax_tree_formatter_auralinux.cc
--- up/chromium/ui/accessibility/platform/inspect/ax_tree_formatter_auralinux.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/accessibility/platform/inspect/ax_tree_formatter_auralinux.cc	2023-01-28 02:49:49.583825371 +0000
@@ -239,6 +239,7 @@
       DCHECK_GE(index_in_parent, 0);
 #endif
 
+      link = atk_hypertext_get_link(hypertext, link_index);
       int utf8_offset = atk_hyperlink_get_start_index(link);
       gchar* link_start = g_utf8_offset_to_pointer(character_text, utf8_offset);
       int offset = link_start - character_text;
diff -r -u --color up/chromium/ui/aura/window_tree_host.cc nw/chromium/ui/aura/window_tree_host.cc
--- up/chromium/ui/aura/window_tree_host.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/aura/window_tree_host.cc	2023-01-28 02:49:49.619825730 +0000
@@ -269,6 +269,12 @@
                                window_->GetLocalSurfaceId());
 }
 
+#if defined(OS_WIN)
+void WindowTreeHost::SetPositionInPixels(const gfx::Point& pos_in_pixels) {
+
+}
+#endif
+
 void WindowTreeHost::ConvertDIPToScreenInPixels(gfx::Point* point) const {
   ConvertDIPToPixels(point);
   gfx::Point location = GetLocationOnScreenInPixels();
diff -r -u --color up/chromium/ui/aura/window_tree_host.h nw/chromium/ui/aura/window_tree_host.h
--- up/chromium/ui/aura/window_tree_host.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/aura/window_tree_host.h	2023-01-28 02:49:49.619825730 +0000
@@ -223,6 +223,9 @@
   // depending on the platform. The |local_surface_id| takes effect when (and
   // if) the new size is confirmed (potentially asynchronously) by the platform.
   virtual void SetBoundsInPixels(const gfx::Rect& bounds_in_pixels) = 0;
+#if defined(OS_WIN)
+  virtual void SetPositionInPixels(const gfx::Point& pos_in_pixels);
+#endif
   virtual gfx::Rect GetBoundsInPixels() const = 0;
 
   // Gets the bounds in DIP.
diff -r -u --color up/chromium/ui/base/accelerators/accelerator.cc nw/chromium/ui/base/accelerators/accelerator.cc
--- up/chromium/ui/base/accelerators/accelerator.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/base/accelerators/accelerator.cc	2023-01-28 02:49:49.623825770 +0000
@@ -6,6 +6,7 @@
 
 #include <stdint.h>
 #include <tuple>
+#include "base/strings/stringprintf.h"
 
 #include "base/check_op.h"
 #include "base/i18n/rtl.h"
@@ -237,7 +238,9 @@
   shortcut = KeyCodeToName();
 #endif
 
-  if (shortcut.empty()) {
+  if (shortcut.empty() && key_code_ >= VKEY_F1 && key_code_ <= VKEY_F12)
+    shortcut = base::UTF8ToUTF16(base::StringPrintf("F%d", key_code_ - VKEY_F1 + 1));
+  else if (shortcut.empty()) {
 #if BUILDFLAG(IS_WIN)
     // Our fallback is to try translate the key code to a regular character
     // unless it is one of digits (VK_0 to VK_9). Some keyboard
@@ -453,7 +456,7 @@
   // more information.
   if (IsCtrlDown())
     result = ApplyModifierToAcceleratorString(result, IDS_APP_CTRL_KEY);
-  else if (IsAltDown())
+  if (IsAltDown())
     result = ApplyModifierToAcceleratorString(result, IDS_APP_ALT_KEY);
 
   if (IsCmdDown()) {
@@ -463,6 +466,8 @@
     result = ApplyModifierToAcceleratorString(result, IDS_APP_SEARCH_KEY);
 #elif BUILDFLAG(IS_WIN)
     result = ApplyModifierToAcceleratorString(result, IDS_APP_WINDOWS_KEY);
+#elif defined(OS_LINUX)
+    result = ApplyModifierToAcceleratorString(result, IDS_APP_SUPER_MODIFIER);
 #else
     NOTREACHED();
 #endif
diff -r -u --color up/chromium/ui/base/base_window.cc nw/chromium/ui/base/base_window.cc
--- up/chromium/ui/base/base_window.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/base/base_window.cc	2023-01-28 02:49:49.623825770 +0000
@@ -12,5 +12,9 @@
      !window.IsFullscreen();
 }
 
+void BaseWindow::ForceClose() {
+  Close();
+}
+
 }  // namespace ui
 
diff -r -u --color up/chromium/ui/base/base_window.h nw/chromium/ui/base/base_window.h
--- up/chromium/ui/base/base_window.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/base/base_window.h	2023-01-28 02:49:49.623825770 +0000
@@ -67,6 +67,7 @@
   // Closes the window as soon as possible. The close action may be delayed
   // if an operation is in progress (e.g. a drag operation).
   virtual void Close() = 0;
+  virtual void ForceClose();
 
   // Activates (brings to front) the window. Restores the window from minimized
   // state if necessary.
diff -r -u --color up/chromium/ui/base/clipboard/clipboard.h nw/chromium/ui/base/clipboard/clipboard.h
--- up/chromium/ui/base/clipboard/clipboard.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/base/clipboard/clipboard.h	2023-01-28 02:49:49.623825770 +0000
@@ -273,7 +273,7 @@
       ClipboardBuffer buffer,
       const DataTransferEndpoint* data_dst) const;
 
- protected:
+ public:
   // PortableFormat designates the type of data to be stored in the clipboard.
   // This designation is shared across all OSes. The system-specific designation
   // is defined by ClipboardFormatType. A single PortableFormat might be
diff -r -u --color up/chromium/ui/base/models/simple_menu_model.cc nw/chromium/ui/base/models/simple_menu_model.cc
--- up/chromium/ui/base/models/simple_menu_model.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/base/models/simple_menu_model.cc	2023-01-28 02:49:49.655826090 +0000
@@ -60,6 +60,10 @@
 
 void SimpleMenuModel::Delegate::OnMenuWillShow(SimpleMenuModel* /*source*/) {}
 
+bool SimpleMenuModel::Delegate::HasIcon(int command_id) {
+  return false;
+}
+
 void SimpleMenuModel::Delegate::MenuClosed(SimpleMenuModel* /*source*/) {
 }
 
diff -r -u --color up/chromium/ui/base/models/simple_menu_model.h nw/chromium/ui/base/models/simple_menu_model.h
--- up/chromium/ui/base/models/simple_menu_model.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/base/models/simple_menu_model.h	2023-01-28 02:49:49.655826090 +0000
@@ -72,6 +72,8 @@
     bool GetAcceleratorForCommandId(
         int command_id,
         ui::Accelerator* accelerator) const override;
+
+    virtual bool HasIcon(int command_id);
   };
 
   // The Delegate can be NULL, though if it is items can't be checked or
diff -r -u --color up/chromium/ui/base/resource/resource_bundle.cc nw/chromium/ui/base/resource/resource_bundle.cc
--- up/chromium/ui/base/resource/resource_bundle.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/base/resource/resource_bundle.cc	2023-01-28 02:49:49.659826130 +0000
@@ -4,6 +4,8 @@
 
 #include "ui/base/resource/resource_bundle.h"
 
+#include "base/strings/string_util.h"
+
 #include <stdint.h>
 
 #include <limits>
@@ -99,6 +101,8 @@
 ResourceBundle* g_shared_instance_ = nullptr;
 
 #if !BUILDFLAG(IS_CHROMEOS_LACROS)
+std::u16string *chromium_name, *nwjs_name;
+
 base::FilePath GetResourcesPakFilePath(const std::string& pak_name) {
   base::FilePath path;
   if (base::PathService::Get(base::DIR_ASSETS, &path))
@@ -922,6 +926,8 @@
   DCHECK(g_shared_instance_ == nullptr) << "ResourceBundle initialized twice";
   g_shared_instance_ = new ResourceBundle(delegate);
   std::vector<ResourceScaleFactor> supported_scale_factors;
+  chromium_name = new std::u16string(u"Chromium");
+  nwjs_name     = new std::u16string(u"NW.js");
 #if BUILDFLAG(IS_IOS)
   display::Display display = display::Screen::GetScreen()->GetPrimaryDisplay();
   if (display.device_scale_factor() > 2.0) {
@@ -957,13 +963,13 @@
   // 2x images. The 1x data pack only has 1x images, thus passes in an accurate
   // scale factor to gfx::ImageSkia::AddRepresentation.
   if (IsScaleFactorSupported(k100Percent)) {
-    AddDataPackFromPath(GetResourcesPakFilePath("chrome_100_percent.pak"),
+    AddDataPackFromPath(GetResourcesPakFilePath("nw_100_percent.pak"),
                         k100Percent);
   }
 
   if (IsScaleFactorSupported(k200Percent)) {
     AddOptionalDataPackFromPath(
-        GetResourcesPakFilePath("chrome_200_percent.pak"), k200Percent);
+        GetResourcesPakFilePath("nw_200_percent.pak"), k200Percent);
   }
 }
 #endif  // !BUILDFLAG(IS_CHROMEOS_LACROS)
@@ -1136,8 +1142,10 @@
 
 std::u16string ResourceBundle::GetLocalizedStringImpl(int resource_id) const {
   std::u16string string;
-  if (delegate_ && delegate_->GetLocalizedString(resource_id, &string))
+  if (delegate_ && delegate_->GetLocalizedString(resource_id, &string)) {
+    base::ReplaceSubstringsAfterOffset(&string, 0, *chromium_name, *nwjs_name);
     return MaybeMangleLocalizedString(string);
+  }
 
   // Ensure that ReloadLocaleResources() doesn't drop the resources while
   // we're using them.
@@ -1191,6 +1199,7 @@
   } else if (encoding == ResourceHandle::UTF8) {
     msg = base::UTF8ToUTF16(data);
   }
+  base::ReplaceSubstringsAfterOffset(&msg, 0, *chromium_name, *nwjs_name);
   return MaybeMangleLocalizedString(msg);
 }
 
diff -r -u --color up/chromium/ui/base/resource/resource_bundle_mac.mm nw/chromium/ui/base/resource/resource_bundle_mac.mm
--- up/chromium/ui/base/resource/resource_bundle_mac.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/base/resource/resource_bundle_mac.mm	2023-01-28 02:49:49.659826130 +0000
@@ -51,13 +51,13 @@
 }  // namespace
 
 void ResourceBundle::LoadCommonResources() {
-  AddDataPackFromPath(GetResourcesPakFilePath(@"chrome_100_percent", nil),
+  AddDataPackFromPath(GetResourcesPakFilePath(@"nw_100_percent", nil),
                       k100Percent);
 
   // On Mac we load 1x and 2x resources and we let the UI framework decide
   // which one to use.
   if (IsScaleFactorSupported(k200Percent)) {
-    AddDataPackFromPath(GetResourcesPakFilePath(@"chrome_200_percent", nil),
+    AddDataPackFromPath(GetResourcesPakFilePath(@"nw_200_percent", nil),
                         k200Percent);
   }
 }
diff -r -u --color up/chromium/ui/base/ui_base_types.h nw/chromium/ui/base/ui_base_types.h
--- up/chromium/ui/base/ui_base_types.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/base/ui_base_types.h	2023-01-28 02:49:49.663826170 +0000
@@ -29,7 +29,8 @@
   SHOW_STATE_MAXIMIZED = 3,
   SHOW_STATE_INACTIVE = 4,  // Views only, not persisted.
   SHOW_STATE_FULLSCREEN = 5,
-  SHOW_STATE_END = 6  // The end of show state enum.
+  SHOW_STATE_HIDDEN = 6,
+  SHOW_STATE_END = 7  // The end of show state enum.
 };
 
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)
diff -r -u --color up/chromium/ui/base/x/visual_picker_glx.cc nw/chromium/ui/base/x/visual_picker_glx.cc
--- up/chromium/ui/base/x/visual_picker_glx.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/base/x/visual_picker_glx.cc	2023-01-28 02:49:49.667826210 +0000
@@ -296,6 +296,9 @@
   if (configs) {
     system_visual_ = PickBestSystemVisual(*configs.reply);
     rgba_visual_ = PickBestRgbaVisual(*configs.reply);
+  } else {
+    system_visual_ = x11::VisualId{};
+    rgba_visual_   = x11::VisualId{};
   }
 }
 
diff -r -u --color up/chromium/ui/base/x/x11_global_shortcut_listener.cc nw/chromium/ui/base/x/x11_global_shortcut_listener.cc
--- up/chromium/ui/base/x/x11_global_shortcut_listener.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/base/x/x11_global_shortcut_listener.cc	2023-01-28 02:49:49.671826250 +0000
@@ -31,10 +31,11 @@
 
 x11::ModMask GetNativeModifiers(bool is_alt_down,
                                 bool is_ctrl_down,
-                                bool is_shift_down) {
+                                bool is_shift_down, bool is_cmd_down) {
   constexpr auto kNoMods = x11::ModMask{};
   return (is_shift_down ? x11::ModMask::Shift : kNoMods) |
          (is_ctrl_down ? x11::ModMask::Control : kNoMods) |
+    (is_cmd_down ? x11::ModMask::c_4 : kNoMods) |
          (is_alt_down ? x11::ModMask::c_1 : kNoMods);
 }
 
@@ -81,8 +82,9 @@
 bool XGlobalShortcutListener::RegisterAccelerator(KeyboardCode key_code,
                                                   bool is_alt_down,
                                                   bool is_ctrl_down,
-                                                  bool is_shift_down) {
-  auto modifiers = GetNativeModifiers(is_alt_down, is_ctrl_down, is_shift_down);
+                                                  bool is_shift_down,
+                                                  bool is_cmd_down) {
+  auto modifiers = GetNativeModifiers(is_alt_down, is_ctrl_down, is_shift_down, is_cmd_down);
   auto keysym = XKeysymForWindowsKeyCode(key_code, false);
   auto keycode = connection_->KeysymToKeycode(keysym);
 
@@ -115,8 +117,9 @@
 void XGlobalShortcutListener::UnregisterAccelerator(KeyboardCode key_code,
                                                     bool is_alt_down,
                                                     bool is_ctrl_down,
-                                                    bool is_shift_down) {
-  auto modifiers = GetNativeModifiers(is_alt_down, is_ctrl_down, is_shift_down);
+                                                    bool is_shift_down,
+                                                    bool is_cmd_down) {
+  auto modifiers = GetNativeModifiers(is_alt_down, is_ctrl_down, is_shift_down, is_cmd_down);
   auto keysym = XKeysymForWindowsKeyCode(key_code, false);
   auto keycode = connection_->KeysymToKeycode(keysym);
 
diff -r -u --color up/chromium/ui/base/x/x11_global_shortcut_listener.h nw/chromium/ui/base/x/x11_global_shortcut_listener.h
--- up/chromium/ui/base/x/x11_global_shortcut_listener.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/base/x/x11_global_shortcut_listener.h	2023-01-28 02:49:49.671826250 +0000
@@ -48,11 +48,13 @@
   bool RegisterAccelerator(KeyboardCode key_code,
                            bool is_alt_down,
                            bool is_ctrl_down,
-                           bool is_shift_down);
+                           bool is_shift_down,
+                           bool is_cmd_down);
   void UnregisterAccelerator(KeyboardCode key_code,
                              bool is_alt_down,
                              bool is_ctrl_down,
-                             bool is_shift_down);
+                             bool is_shift_down,
+                             bool is_cmd_down);
 
  private:
   // Due to how system key grabbing works on X11, we have to be a bit greedy and
diff -r -u --color up/chromium/ui/display/display.cc nw/chromium/ui/display/display.cc
--- up/chromium/ui/display/display.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/display/display.cc	2023-01-28 02:49:50.247832004 +0000
@@ -21,6 +21,16 @@
 #include "ui/gfx/geometry/transform.h"
 #include "ui/gfx/icc_profile.h"
 
+namespace content {
+
+// Switch to enable / disable code for window's transparency
+DISPLAY_EXPORT bool g_support_transparency = true;
+
+// Switch to force cpu drawing, is used to enable click through on alpha pixels
+extern bool g_force_cpu_draw;
+bool g_force_cpu_draw = false;
+}
+
 namespace display {
 namespace {
 
diff -r -u --color up/chromium/ui/display/display.h nw/chromium/ui/display/display.h
--- up/chromium/ui/display/display.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/display/display.h	2023-01-28 02:49:50.247832004 +0000
@@ -14,6 +14,11 @@
 #include "ui/gfx/display_color_spaces.h"
 #include "ui/gfx/geometry/rect.h"
 
+namespace content {
+  DISPLAY_EXPORT extern bool g_support_transparency;
+  DISPLAY_EXPORT extern bool g_force_cpu_draw;
+}
+
 namespace display {
 
 namespace mojom {
diff -r -u --color up/chromium/ui/gfx/BUILD.gn nw/chromium/ui/gfx/BUILD.gn
--- up/chromium/ui/gfx/BUILD.gn	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/gfx/BUILD.gn	2023-01-28 02:49:50.343832962 +0000
@@ -393,6 +393,7 @@
 
   if (is_mac) {
     frameworks = [
+      "ApplicationServices.framework",
       "AppKit.framework",
       "CoreFoundation.framework",
       "CoreGraphics.framework",
diff -r -u --color up/chromium/ui/gfx/icon_util.cc nw/chromium/ui/gfx/icon_util.cc
--- up/chromium/ui/gfx/icon_util.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/gfx/icon_util.cc	2023-01-28 02:49:50.363833162 +0000
@@ -226,6 +226,21 @@
   return icon;
 }
 
+// NW fix: copied and modified from chrome/browser/ui/views/frame/glass_browser_frame_view.cc
+// Converts the |image| to a Windows icon and returns the corresponding HICON
+// handle. |image| is resized to desired |width| and |height| if needed.
+base::win::ScopedHICON IconUtil::CreateHICONFromSkBitmapSizedTo(
+  const SkBitmap& bitmap,
+  int width,
+  int height) {
+  return CreateHICONFromSkBitmap(
+    width == bitmap.width() && height == bitmap.height()
+    ? bitmap
+    : skia::ImageOperations::Resize(bitmap,
+    skia::ImageOperations::RESIZE_BEST,
+    width, height));
+}
+
 SkBitmap IconUtil::CreateSkBitmapFromHICON(HICON icon, const gfx::Size& s) {
   // We start with validating parameters.
   if (!icon || s.IsEmpty())
diff -r -u --color up/chromium/ui/gfx/icon_util.h nw/chromium/ui/gfx/icon_util.h
--- up/chromium/ui/gfx/icon_util.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/gfx/icon_util.h	2023-01-28 02:49:50.363833162 +0000
@@ -87,6 +87,10 @@
   // icon and returns the corresponding HICON handle if conversion succeeds.
   static base::win::ScopedHICON CreateHICONFromSkBitmap(const SkBitmap& bitmap);
 
+  static base::win::ScopedHICON CreateHICONFromSkBitmapSizedTo(const SkBitmap& bitmap,
+    int width,
+    int height);
+
   // Given a valid HICON handle representing an icon, this function converts
   // the icon into an SkBitmap object containing an ARGB bitmap using the
   // dimensions specified in |s|. |s| must specify valid dimensions (both
diff -r -u --color up/chromium/ui/gfx/mac/nswindow_frame_controls.h nw/chromium/ui/gfx/mac/nswindow_frame_controls.h
--- up/chromium/ui/gfx/mac/nswindow_frame_controls.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/gfx/mac/nswindow_frame_controls.h	2023-01-28 02:49:50.371833242 +0000
@@ -29,6 +29,7 @@
                                              const gfx::Size& max_size,
                                              bool can_resize,
                                              bool can_fullscreen);
+GFX_EXPORT void SetNSWindowShowInTaskbar(NSWindow* window, bool show);
 
 }  // namespace gfx
 
diff -r -u --color up/chromium/ui/gfx/mac/nswindow_frame_controls.mm nw/chromium/ui/gfx/mac/nswindow_frame_controls.mm
--- up/chromium/ui/gfx/mac/nswindow_frame_controls.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/gfx/mac/nswindow_frame_controls.mm	2023-01-28 02:49:50.371833242 +0000
@@ -37,6 +37,22 @@
   [window setCollectionBehavior:behavior];
 }
 
+void SetNSWindowShowInTaskbar(NSWindow* window, bool show) {
+  ProcessSerialNumber psn = { 0, kCurrentProcess };
+  if (!show) {
+    NSArray* windowList = [[NSArray alloc] init];
+    windowList = [NSWindow windowNumbersWithOptions:NSWindowNumberListAllSpaces];
+    for (unsigned int i = 0; i < [windowList count]; ++i) {
+      NSWindow *win = [NSApp windowWithWindowNumber:[[windowList objectAtIndex:i] integerValue]];
+      [win setCanHide:NO];
+    }
+    TransformProcessType(&psn, kProcessTransformToUIElementApplication);
+  }
+  else {
+    TransformProcessType(&psn, kProcessTransformToForegroundApplication);
+  }
+}
+
 void SetNSWindowVisibleOnAllWorkspaces(NSWindow* window, bool always_visible) {
   NSWindowCollectionBehavior behavior = [window collectionBehavior];
   if (always_visible)
diff -r -u --color up/chromium/ui/gl/gl_features.cc nw/chromium/ui/gl/gl_features.cc
--- up/chromium/ui/gl/gl_features.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/gl/gl_features.cc	2023-01-28 02:49:50.407833602 +0000
@@ -75,7 +75,7 @@
              base::FEATURE_DISABLED_BY_DEFAULT);
 #endif
 
-#if !defined(PASSTHROUGH_COMMAND_DECODER_LAUNCHED)
+#if !defined(PASSTHROUGH_COMMAND_DECODER_LAUNCHED) || BUILDFLAG(IS_LINUX)
 // Use the passthrough command decoder by default.  This can be overridden with
 // the --use-cmd-decoder=passthrough or --use-cmd-decoder=validating flags.
 // Feature lives in ui/gl because it affects the GL binding initialization on
diff -r -u --color up/chromium/ui/gtk/select_file_dialog_linux_gtk.cc nw/chromium/ui/gtk/select_file_dialog_linux_gtk.cc
--- up/chromium/ui/gtk/select_file_dialog_linux_gtk.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/gtk/select_file_dialog_linux_gtk.cc	2023-01-28 02:49:50.423833762 +0000
@@ -421,12 +421,12 @@
   std::string title_string = title;
   if (title_string.empty()) {
     title_string =
-        (type == SELECT_UPLOAD_FOLDER)
+      (false)
             ? l10n_util::GetStringUTF8(IDS_SELECT_UPLOAD_FOLDER_DIALOG_TITLE)
             : l10n_util::GetStringUTF8(IDS_SELECT_FOLDER_DIALOG_TITLE);
   }
   std::string accept_button_label =
-      (type == SELECT_UPLOAD_FOLDER)
+    (false)
           ? l10n_util::GetStringUTF8(
                 IDS_SELECT_UPLOAD_FOLDER_DIALOG_UPLOAD_BUTTON)
           : GetOpenLabel();
diff -r -u --color up/chromium/ui/message_center/public/cpp/notification.h nw/chromium/ui/message_center/public/cpp/notification.h
--- up/chromium/ui/message_center/public/cpp/notification.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/message_center/public/cpp/notification.h	2023-01-28 02:49:50.427833802 +0000
@@ -468,8 +468,7 @@
   }
 
   bool should_show_settings_button() const {
-    return optional_fields_.settings_button_handler !=
-           SettingsButtonHandler::NONE;
+    return false;
   }
 
   void set_settings_button_handler(SettingsButtonHandler handler) {
diff -r -u --color up/chromium/ui/native_theme/native_theme_win.cc nw/chromium/ui/native_theme/native_theme_win.cc
--- up/chromium/ui/native_theme/native_theme_win.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/native_theme/native_theme_win.cc	2023-01-28 02:49:50.431833842 +0000
@@ -57,7 +57,7 @@
 // Windows system color IDs cached and updated by the native theme.
 const int kSysColors[] = {
     COLOR_BTNFACE,       COLOR_BTNTEXT,    COLOR_GRAYTEXT,      COLOR_HIGHLIGHT,
-    COLOR_HIGHLIGHTTEXT, COLOR_HOTLIGHT,   COLOR_MENUHIGHLIGHT, COLOR_SCROLLBAR,
+    COLOR_HIGHLIGHTTEXT, COLOR_HOTLIGHT,   COLOR_MENU, COLOR_MENUHIGHLIGHT, COLOR_SCROLLBAR,
     COLOR_WINDOW,        COLOR_WINDOWTEXT,
 };
 
diff -r -u --color up/chromium/ui/ozone/common/egl_util.cc nw/chromium/ui/ozone/common/egl_util.cc
--- up/chromium/ui/ozone/common/egl_util.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/ozone/common/egl_util.cc	2023-01-28 02:49:50.435833881 +0000
@@ -130,7 +130,7 @@
     if (!base::PathService::Get(base::DIR_MODULE, &module_path))
       return false;
 #endif
-
+    module_path = module_path.Append("lib/");
     glesv2_path = module_path.Append(kAngleGlesSoname);
     egl_path = module_path.Append(kAngleEglSoname);
   } else {
diff -r -u --color up/chromium/ui/ozone/platform/x11/x11_global_shortcut_listener_ozone.cc nw/chromium/ui/ozone/platform/x11/x11_global_shortcut_listener_ozone.cc
--- up/chromium/ui/ozone/platform/x11/x11_global_shortcut_listener_ozone.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/ozone/platform/x11/x11_global_shortcut_listener_ozone.cc	2023-01-28 02:49:50.471834241 +0000
@@ -26,18 +26,20 @@
 bool X11GlobalShortcutListenerOzone::RegisterAccelerator(KeyboardCode key_code,
                                                          bool is_alt_down,
                                                          bool is_ctrl_down,
-                                                         bool is_shift_down) {
+                                                         bool is_shift_down,
+                                                         bool is_cmd_down) {
   return XGlobalShortcutListener::RegisterAccelerator(
-      key_code, is_alt_down, is_ctrl_down, is_shift_down);
+                                                      key_code, is_alt_down, is_ctrl_down, is_shift_down, is_cmd_down);
 }
 
 void X11GlobalShortcutListenerOzone::UnregisterAccelerator(
     KeyboardCode key_code,
     bool is_alt_down,
     bool is_ctrl_down,
-    bool is_shift_down) {
+    bool is_shift_down,
+    bool is_cmd_down) {
   return XGlobalShortcutListener::UnregisterAccelerator(
-      key_code, is_alt_down, is_ctrl_down, is_shift_down);
+                                                        key_code, is_alt_down, is_ctrl_down, is_shift_down, is_cmd_down);
 }
 
 void X11GlobalShortcutListenerOzone::OnKeyPressed(KeyboardCode key_code,
diff -r -u --color up/chromium/ui/ozone/platform/x11/x11_global_shortcut_listener_ozone.h nw/chromium/ui/ozone/platform/x11/x11_global_shortcut_listener_ozone.h
--- up/chromium/ui/ozone/platform/x11/x11_global_shortcut_listener_ozone.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/ozone/platform/x11/x11_global_shortcut_listener_ozone.h	2023-01-28 02:49:50.471834241 +0000
@@ -28,11 +28,13 @@
   bool RegisterAccelerator(KeyboardCode key_code,
                            bool is_alt_down,
                            bool is_ctrl_down,
-                           bool is_shift_down) override;
+                           bool is_shift_down,
+                           bool is_cmd_down) override;
   void UnregisterAccelerator(KeyboardCode key_code,
                              bool is_alt_down,
                              bool is_ctrl_down,
-                             bool is_shift_down) override;
+                             bool is_shift_down,
+                             bool is_cmd_down) override;
 
   // ui::XGlobalShortcutListener:
   void OnKeyPressed(KeyboardCode key_code,
diff -r -u --color up/chromium/ui/ozone/public/platform_global_shortcut_listener.h nw/chromium/ui/ozone/public/platform_global_shortcut_listener.h
--- up/chromium/ui/ozone/public/platform_global_shortcut_listener.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/ozone/public/platform_global_shortcut_listener.h	2023-01-28 02:49:50.475834281 +0000
@@ -52,11 +52,13 @@
   virtual bool RegisterAccelerator(KeyboardCode key_code,
                                    bool is_alt_down,
                                    bool is_ctrl_down,
-                                   bool is_shift_down) = 0;
+                                   bool is_shift_down,
+                                   bool is_cmd_down) = 0;
   virtual void UnregisterAccelerator(KeyboardCode key_code,
                                      bool is_alt_down,
                                      bool is_ctrl_down,
-                                     bool is_shift_down) = 0;
+                                     bool is_shift_down,
+                                     bool is_cmd_down) = 0;
 
  protected:
   PlatformGlobalShortcutListenerDelegate* delegate() { return delegate_; }
diff -r -u --color up/chromium/ui/qt/qt.gni nw/chromium/ui/qt/qt.gni
--- up/chromium/ui/qt/qt.gni	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/qt/qt.gni	2023-01-28 02:49:50.479834321 +0000
@@ -5,5 +5,5 @@
 import("//build/config/chromecast_build.gni")
 
 declare_args() {
-  use_qt = is_linux && !is_castos
+  use_qt = false #is_linux && !is_castos
 }
diff -r -u --color up/chromium/ui/shell_dialogs/execute_select_file_win.cc nw/chromium/ui/shell_dialogs/execute_select_file_win.cc
--- up/chromium/ui/shell_dialogs/execute_select_file_win.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/shell_dialogs/execute_select_file_win.cc	2023-01-28 02:49:50.487834401 +0000
@@ -277,11 +277,12 @@
   }
 
   std::u16string ok_button_label;
+#if 0
   if (type == SelectFileDialog::SELECT_UPLOAD_FOLDER) {
     ok_button_label = l10n_util::GetStringUTF16(
         IDS_SELECT_UPLOAD_FOLDER_DIALOG_UPLOAD_BUTTON);
   }
-
+#endif
   DWORD dialog_options = FOS_PICKFOLDERS;
 
   std::vector<FileFilterSpec> no_filter;
diff -r -u --color up/chromium/ui/strings/ui_strings.grd nw/chromium/ui/strings/ui_strings.grd
--- up/chromium/ui/strings/ui_strings.grd	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/strings/ui_strings.grd	2023-01-28 02:49:50.547835000 +0000
@@ -750,6 +750,12 @@
       <message name="IDS_APP_ACCELERATOR_WITH_MODIFIER" desc="Accelerator with a modifier key">
         <ph name="KEY_MODIFIER_NAME">$1<ex>Ctrl</ex></ph>+<ph name="KEY_COMBO_NAME">$2<ex>C</ex></ph>
       </message>
+      <message name="IDS_APP_WINDOWS_MODIFIER" desc="Command key shortcut modifier">
+        Win+<ph name="KEY_COMBO_NAME">$1<ex>C</ex></ph>
+      </message>
+      <message name="IDS_APP_SUPER_MODIFIER" desc="Command key shortcut modifier">
+        Super+<ph name="KEY_COMBO_NAME">$1<ex>C</ex></ph>
+      </message>
 
       <!-- Byte size units -->
       <message name="IDS_APP_BYTES" desc="Units tag indicating a quantity of bytes">
diff -r -u --color up/chromium/ui/views/accessibility/view_ax_platform_node_delegate_auralinux.cc nw/chromium/ui/views/accessibility/view_ax_platform_node_delegate_auralinux.cc
--- up/chromium/ui/views/accessibility/view_ax_platform_node_delegate_auralinux.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/views/accessibility/view_ax_platform_node_delegate_auralinux.cc	2023-01-28 02:49:50.555835080 +0000
@@ -4,6 +4,8 @@
 
 #include "ui/views/accessibility/view_ax_platform_node_delegate_auralinux.h"
 
+#include "content/public/browser/browser_thread.h"
+
 #include <memory>
 #include <vector>
 
diff -r -u --color up/chromium/ui/views/cocoa/native_widget_mac_ns_window_host.h nw/chromium/ui/views/cocoa/native_widget_mac_ns_window_host.h
--- up/chromium/ui/views/cocoa/native_widget_mac_ns_window_host.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/views/cocoa/native_widget_mac_ns_window_host.h	2023-01-28 02:49:50.563835160 +0000
@@ -237,6 +237,7 @@
   std::unique_ptr<NativeWidgetMacEventMonitor> AddEventMonitor(
       NativeWidgetMacEventMonitor::Client* client);
   void RemoveEventMonitor(NativeWidgetMacEventMonitor*);
+  bool IsMaximized() const;
 
   // Used by NativeWidgetPrivate::GetGlobalCapture.
   static NSView* GetGlobalCaptureView();
diff -r -u --color up/chromium/ui/views/cocoa/native_widget_mac_ns_window_host.mm nw/chromium/ui/views/cocoa/native_widget_mac_ns_window_host.mm
--- up/chromium/ui/views/cocoa/native_widget_mac_ns_window_host.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/views/cocoa/native_widget_mac_ns_window_host.mm	2023-01-28 02:49:50.563835160 +0000
@@ -536,6 +536,12 @@
     GetNSWindowMojo()->ExitFullscreen();
 }
 
+bool NativeWidgetMacNSWindowHost::IsMaximized() const {
+  bool maximized = false;
+  GetNSWindowMojo()->IsMaximized(&maximized);
+  return maximized && !is_miniaturized_;
+}
+
 void NativeWidgetMacNSWindowHost::SetRootView(views::View* root_view) {
   root_view_ = root_view;
   if (root_view_) {
@@ -672,6 +678,11 @@
 gfx::Rect NativeWidgetMacNSWindowHost::GetRestoredBounds() const {
   if (target_fullscreen_state_ || in_fullscreen_transition_)
     return window_bounds_before_fullscreen_;
+  if (IsMaximized()) {
+    gfx::Rect ret;
+    if (GetNSWindowMojo()->GetRestoredBounds(&ret))
+      return ret;
+  }
   return window_bounds_in_screen_;
 }
 
@@ -1305,6 +1316,10 @@
 bool NativeWidgetMacNSWindowHost::OnWindowCloseRequested(
     bool* can_window_close) {
   *can_window_close = true;
+  if (root_view_ && !root_view_->GetWidget()->NWCanClose()) {
+    *can_window_close = false;
+    return true;
+  }
   views::NonClientView* non_client_view =
       root_view_ ? root_view_->GetWidget()->non_client_view() : nullptr;
   if (non_client_view)
diff -r -u --color up/chromium/ui/views/controls/menu/native_menu_win.cc nw/chromium/ui/views/controls/menu/native_menu_win.cc
--- up/chromium/ui/views/controls/menu/native_menu_win.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/views/controls/menu/native_menu_win.cc	2023-01-28 02:49:50.575835280 +0000
@@ -53,7 +53,9 @@
                   !system_menu_for),
       system_menu_for_(system_menu_for),
       first_item_index_(0),
-      parent_(nullptr) {}
+      parent_(nullptr),
+      is_popup_menu_(true) {
+}
 
 NativeMenuWin::~NativeMenuWin() {
   items_.clear();
@@ -221,14 +223,18 @@
   } else {
     if (menu_)
       DestroyMenu(menu_);
-    menu_ = CreatePopupMenu();
+    if (is_popup_menu_)
+      menu_ = CreatePopupMenu();
+    else
+      menu_ = CreateMenu();
     // Rather than relying on the return value of TrackPopupMenuEx, which is
     // always a command identifier, instead we tell the menu to notify us via
     // our host window and the WM_MENUCOMMAND message.
     MENUINFO mi = {0};
     mi.cbSize = sizeof(mi);
     mi.fMask = MIM_STYLE | MIM_MENUDATA;
-    mi.dwStyle = MNS_NOTIFYBYPOS;
+    if (is_popup_menu_)
+      mi.dwStyle = MNS_NOTIFYBYPOS;
     mi.dwMenuData = reinterpret_cast<ULONG_PTR>(this);
     SetMenuInfo(menu_, &mi);
   }
diff -r -u --color up/chromium/ui/views/controls/menu/native_menu_win.h nw/chromium/ui/views/controls/menu/native_menu_win.h
--- up/chromium/ui/views/controls/menu/native_menu_win.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/views/controls/menu/native_menu_win.h	2023-01-28 02:49:50.575835280 +0000
@@ -37,6 +37,9 @@
   void Rebuild(MenuInsertionDelegateWin* delegate);
   void UpdateStates();
 
+  void set_is_popup_menu(bool flag) { is_popup_menu_ = flag; }
+  HMENU menu() const { return menu_; }
+
  private:
   // IMPORTANT: Note about indices.
   //            Functions in this class deal in two index spaces:
@@ -103,6 +106,9 @@
 
   // If we're a submenu, this is our parent.
   raw_ptr<NativeMenuWin> parent_;
+
+  // A flag to indicate whether to create a menubar or popupmenu.
+  bool is_popup_menu_;
 };
 
 }  // namespace views
diff -r -u --color up/chromium/ui/views/widget/desktop_aura/desktop_native_widget_aura.cc nw/chromium/ui/views/widget/desktop_aura/desktop_native_widget_aura.cc
--- up/chromium/ui/views/widget/desktop_aura/desktop_native_widget_aura.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/views/widget/desktop_aura/desktop_native_widget_aura.cc	2023-01-28 02:49:50.619835719 +0000
@@ -864,6 +864,14 @@
   desktop_window_tree_host_->SetBoundsInDIP(bounds);
 }
 
+#if defined(OS_WIN)
+void DesktopNativeWidgetAura::SetPosition(const gfx::Point& pos) {
+  if (!content_window_)
+    return;
+  desktop_window_tree_host_->SetPositionInDIP(pos);
+}
+#endif
+
 void DesktopNativeWidgetAura::SetBoundsConstrained(const gfx::Rect& bounds) {
   if (!content_window_)
     return;
diff -r -u --color up/chromium/ui/views/widget/desktop_aura/desktop_native_widget_aura.h nw/chromium/ui/views/widget/desktop_aura/desktop_native_widget_aura.h
--- up/chromium/ui/views/widget/desktop_aura/desktop_native_widget_aura.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/views/widget/desktop_aura/desktop_native_widget_aura.h	2023-01-28 02:49:50.619835719 +0000
@@ -152,6 +152,9 @@
   gfx::Rect GetRestoredBounds() const override;
   std::string GetWorkspace() const override;
   void SetBounds(const gfx::Rect& bounds) override;
+#if defined(OS_WIN)
+  void SetPosition(const gfx::Point& pos) override;
+#endif
   void SetBoundsConstrained(const gfx::Rect& bounds) override;
   void SetSize(const gfx::Size& size) override;
   void StackAbove(gfx::NativeView native_view) override;
diff -r -u --color up/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host.cc nw/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host.cc
--- up/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host.cc	2023-01-28 02:49:50.619835719 +0000
@@ -5,6 +5,10 @@
 #include "ui/views/widget/desktop_aura/desktop_window_tree_host.h"
 
 #include "build/build_config.h"
+#if defined(OS_WIN)
+#include "ui/display/win/screen_win.h"
+#endif
+
 #include "ui/aura/window.h"
 #include "ui/aura/window_tree_host.h"
 #include "ui/display/screen.h"
@@ -20,6 +24,14 @@
 void DesktopWindowTreeHost::UpdateWindowShapeIfNeeded(
     const ui::PaintContext& context) {}
 
+#if defined(OS_WIN)
+void DesktopWindowTreeHost::SetPositionInDIP(const gfx::Point& pos) {
+  const gfx::Point pos_in_pixels =
+    display::win::ScreenWin::DIPToScreenPoint(pos);
+  AsWindowTreeHost()->SetPositionInPixels(pos_in_pixels);
+}
+#endif
+
 std::unique_ptr<aura::client::ScreenPositionClient>
 DesktopWindowTreeHost::CreateScreenPositionClient() {
   return std::make_unique<DesktopScreenPositionClient>(
diff -r -u --color up/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host.h nw/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host.h
--- up/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host.h	2023-01-28 02:49:50.619835719 +0000
@@ -212,6 +212,11 @@
   virtual void UpdateWindowShapeIfNeeded(const ui::PaintContext& context);
 
   virtual DesktopNativeCursorManager* GetSingletonDesktopNativeCursorManager();
+
+#if defined(OS_WIN)
+  virtual void SetPositionInDIP(const gfx::Point& pos);
+#endif
+
 };
 
 }  // namespace views
diff -r -u --color up/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host_win.cc nw/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host_win.cc
--- up/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host_win.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host_win.cc	2023-01-28 02:49:50.619835719 +0000
@@ -542,7 +542,7 @@
   // but merely of the content Chrome draws, so even when the system titlebars
   // appear opaque (Win 8+), the content above them needs to be transparent, or
   // they'll be covered by a black (undrawn) region.
-  return ShouldUseNativeFrame() && !IsFullscreen();
+  return ShouldUseNativeFrame() && (content::g_support_transparency || !IsFullscreen());
 }
 
 void DesktopWindowTreeHostWin::FrameTypeChanged() {
@@ -655,6 +655,10 @@
   return without_expansion;
 }
 
+void DesktopWindowTreeHostWin::SetPositionInPixels(const gfx::Point& pos) {
+  message_handler_->SetPosition(pos);
+}
+
 void DesktopWindowTreeHostWin::SetBoundsInPixels(const gfx::Rect& bounds) {
   // If the window bounds have to be expanded we need to subtract the
   // window_expansion_top_left_delta_ from the origin and add the
@@ -919,6 +923,15 @@
              : nullptr;
 }
 
+bool DesktopWindowTreeHostWin::ShouldHandleOnSize() const {
+  return GetWidget()->widget_delegate()->ShouldHandleOnSize();
+}
+
+bool DesktopWindowTreeHostWin::HandleSize(UINT param, const gfx::Size& new_size) {
+  return GetWidget()->widget_delegate() &&
+      GetWidget()->widget_delegate()->HandleSize(param, new_size);
+}
+
 void DesktopWindowTreeHostWin::HandleActivationChanged(bool active) {
   // This can be invoked from HWNDMessageHandler::Init(), at which point we're
   // not in a good state and need to ignore it.
@@ -933,7 +946,7 @@
   // We treat APPCOMMAND ids as an extension of our command namespace, and just
   // let the delegate figure out what to do...
   return GetWidget()->widget_delegate() &&
-         GetWidget()->widget_delegate()->ExecuteWindowsCommand(command);
+      GetWidget()->widget_delegate()->ExecuteAppCommand(command);
 }
 
 void DesktopWindowTreeHostWin::HandleCancelMode() {
@@ -946,6 +959,9 @@
 
 void DesktopWindowTreeHostWin::HandleClose() {
   GetWidget()->Close();
+  //bugfix where transparent window size is getting smaller during closing
+  if (content::g_support_transparency && message_handler_->is_translucent())
+    window_enlargement_ = gfx::Vector2d(0, 0);
 }
 
 bool DesktopWindowTreeHostWin::HandleCommand(int command) {
diff -r -u --color up/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host_win.h nw/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host_win.h
--- up/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host_win.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/views/widget/desktop_aura/desktop_window_tree_host_win.h	2023-01-28 02:49:50.619835719 +0000
@@ -171,6 +171,7 @@
   gfx::Rect GetBoundsInPixels() const override;
   void SetBoundsInPixels(const gfx::Rect& bounds) override;
   gfx::Rect GetBoundsInAcceleratedWidgetPixelCoordinates() override;
+  void SetPositionInPixels(const gfx::Point& pos) override;
   gfx::Point GetLocationOnScreenInPixels() const override;
   void SetCapture() override;
   void ReleaseCapture() override;
@@ -196,6 +197,8 @@
 
   // Overridden from HWNDMessageHandlerDelegate:
   ui::InputMethod* GetHWNDMessageDelegateInputMethod() override;
+  bool ShouldHandleOnSize() const override;
+  bool HandleSize(UINT param, const gfx::Size& new_size) override;
   bool HasNonClientView() const override;
   FrameMode GetFrameMode() const override;
   bool HasFrame() const override;
diff -r -u --color up/chromium/ui/views/widget/native_widget_delegate.h nw/chromium/ui/views/widget/native_widget_delegate.h
--- up/chromium/ui/views/widget/native_widget_delegate.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/views/widget/native_widget_delegate.h	2023-01-28 02:49:50.623835759 +0000
@@ -40,6 +40,7 @@
  public:
   virtual ~NativeWidgetDelegate() = default;
 
+  virtual bool NWCanClose(bool user_force = false) const = 0;
   // Returns true if the window is modal.
   virtual bool IsModal() const = 0;
 
diff -r -u --color up/chromium/ui/views/widget/native_widget_mac.mm nw/chromium/ui/views/widget/native_widget_mac.mm
--- up/chromium/ui/views/widget/native_widget_mac.mm	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/views/widget/native_widget_mac.mm	2023-01-28 02:49:50.623835759 +0000
@@ -47,6 +47,10 @@
 
 using remote_cocoa::mojom::WindowVisibilityState;
 
+namespace content {
+  extern bool g_support_transparency;
+}
+
 namespace views {
 
 namespace {
@@ -417,6 +421,8 @@
     *show_state = ui::SHOW_STATE_FULLSCREEN;
   else if (IsMinimized())
     *show_state = ui::SHOW_STATE_MINIMIZED;
+  else if (IsMaximized())
+    *show_state = ui::SHOW_STATE_MAXIMIZED;
   else
     *show_state = ui::SHOW_STATE_NORMAL;
 }
@@ -606,8 +612,9 @@
     case ui::SHOW_STATE_NORMAL:
     case ui::SHOW_STATE_INACTIVE:
     case ui::SHOW_STATE_MINIMIZED:
-      break;
+    case ui::SHOW_STATE_HIDDEN:
     case ui::SHOW_STATE_MAXIMIZED:
+      break;
     case ui::SHOW_STATE_FULLSCREEN:
       NOTIMPLEMENTED();
       break;
@@ -626,6 +633,8 @@
                        : WindowVisibilityState::kShowInactive;
   }
   GetNSWindowMojo()->SetVisibilityState(window_state);
+  if (show_state == ui::SHOW_STATE_MAXIMIZED)
+    GetNSWindowMojo()->SetRestoredBounds(restore_bounds);
 
   // Ignore the SetInitialFocus() result. BridgedContentView should get
   // firstResponder status regardless.
@@ -681,7 +690,9 @@
 void NativeWidgetMac::Maximize() {
   if (!GetNSWindowMojo())
     return;
-  GetNSWindowMojo()->SetZoomed(true);
+  if (IsFullscreen())
+    return;
+  GetNSWindowMojo()->SetMaximized(true);
 }
 
 void NativeWidgetMac::Minimize() {
@@ -693,7 +704,7 @@
 bool NativeWidgetMac::IsMaximized() const {
   if (!ns_window_host_)
     return false;
-  return ns_window_host_->IsZoomed();
+  return ns_window_host_->IsMaximized();
 }
 
 bool NativeWidgetMac::IsMinimized() const {
@@ -707,7 +718,7 @@
     return;
   GetNSWindowMojo()->ExitFullscreen();
   GetNSWindowMojo()->SetMiniaturized(false);
-  GetNSWindowMojo()->SetZoomed(false);
+  GetNSWindowMojo()->SetMaximized(false);
 }
 
 void NativeWidgetMac::SetFullscreen(bool fullscreen,
@@ -864,7 +875,7 @@
 }
 
 bool NativeWidgetMac::IsTranslucentWindowOpacitySupported() const {
-  return false;
+  return content::g_support_transparency;
 }
 
 ui::GestureRecognizer* NativeWidgetMac::GetGestureRecognizer() {
diff -r -u --color up/chromium/ui/views/widget/native_widget_private.cc nw/chromium/ui/views/widget/native_widget_private.cc
--- up/chromium/ui/views/widget/native_widget_private.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/views/widget/native_widget_private.cc	2023-01-28 02:49:50.623835759 +0000
@@ -10,6 +10,11 @@
 
 namespace views::internal {
 
+#if defined(OS_WIN)
+void NativeWidgetPrivate::SetPosition(const gfx::Point& pos) {
+
+}
+#endif
 // static
 gfx::Rect NativeWidgetPrivate::ConstrainBoundsToDisplayWorkArea(
     const gfx::Rect& bounds) {
diff -r -u --color up/chromium/ui/views/widget/native_widget_private.h nw/chromium/ui/views/widget/native_widget_private.h
--- up/chromium/ui/views/widget/native_widget_private.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/views/widget/native_widget_private.h	2023-01-28 02:49:50.623835759 +0000
@@ -174,6 +174,9 @@
   virtual gfx::Rect GetRestoredBounds() const = 0;
   virtual std::string GetWorkspace() const = 0;
   virtual void SetBounds(const gfx::Rect& bounds) = 0;
+#if defined(OS_WIN)
+  virtual void SetPosition(const gfx::Point& pos);
+#endif
   virtual void SetBoundsConstrained(const gfx::Rect& bounds) = 0;
   virtual void SetSize(const gfx::Size& size) = 0;
   virtual void StackAbove(gfx::NativeView native_view) = 0;
diff -r -u --color up/chromium/ui/views/widget/widget.cc nw/chromium/ui/views/widget/widget.cc
--- up/chromium/ui/views/widget/widget.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/views/widget/widget.cc	2023-01-28 02:49:50.623835759 +0000
@@ -469,6 +469,8 @@
     } else if (show_state == ui::SHOW_STATE_MINIMIZED) {
       Minimize();
       saved_show_state_ = ui::SHOW_STATE_MINIMIZED;
+    } else if (show_state == ui::SHOW_STATE_FULLSCREEN) {
+      SetFullscreen(true);
     }
   } else if (delegate) {
     SetContentsView(delegate->TransferOwnershipOfContentsView());
@@ -648,6 +650,12 @@
     native_widget_->SetBounds(bounds);
 }
 
+#if defined(OS_WIN)
+void Widget::SetPosition(const gfx::Point& pos) {
+  native_widget_->SetPosition(pos);
+}
+#endif
+
 void Widget::SetSize(const gfx::Size& size) {
   if (native_widget_)
     native_widget_->SetSize(size);
@@ -721,13 +729,18 @@
     native_widget_->SetShape(std::move(shape));
 }
 
-void Widget::CloseWithReason(ClosedReason closed_reason) {
+void Widget::CloseWithReason(ClosedReason closed_reason, bool force) {
   if (widget_closed_) {
     // It appears we can hit this code path if you close a modal dialog then
     // close the last browser before the destructor is hit, which triggers
     // invoking Close again.
     return;
   }
+  if (!force && !force_closing_ && !NWCanClose())
+    return;
+  if (force)
+    force_closing_ = true; //for reentering this function after force close
+
   if (block_close_) {
     return;
   }
@@ -735,6 +748,7 @@
                               CloseRequestResult::kCannotClose) {
     return;
   }
+
   // This is the last chance to cancel closing.
   if (widget_delegate_ && !widget_delegate_->OnCloseRequested(closed_reason))
     return;
@@ -768,8 +782,8 @@
     native_widget_->Close();
 }
 
-void Widget::Close() {
-  CloseWithReason(ClosedReason::kUnspecified);
+void Widget::Close(bool force) {
+  CloseWithReason(ClosedReason::kUnspecified, force);
 }
 
 void Widget::CloseNow() {
@@ -1467,6 +1481,10 @@
   return native_widget_initialized_;
 }
 
+bool Widget::NWCanClose(bool user_force) const {
+  return widget_delegate_->NWCanClose(user_force);
+}
+
 bool Widget::OnNativeWidgetActivationChanged(bool active) {
   if (!ShouldHandleNativeWidgetActivationChanged(active))
     return false;
@@ -1620,6 +1638,8 @@
   NotifyCaretBoundsChanged(GetInputMethod());
   SaveWindowPlacementIfInitialized();
 
+  widget_delegate_->OnWidgetResize();
+
   for (WidgetObserver& observer : observers_)
     observer.OnWidgetBoundsChanged(this, GetWindowBoundsInScreen());
 }
diff -r -u --color up/chromium/ui/views/widget/widget.h nw/chromium/ui/views/widget/widget.h
--- up/chromium/ui/views/widget/widget.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/views/widget/widget.h	2023-01-28 02:49:50.623835759 +0000
@@ -632,6 +632,9 @@
 
   // Sizes and/or places the widget to the specified bounds, size or position.
   void SetBounds(const gfx::Rect& bounds);
+#if defined(OS_WIN)
+  void SetPosition(const gfx::Point& position);
+#endif
   void SetSize(const gfx::Size& size);
 
   // Sizes the window to the specified size and centers it.
@@ -681,13 +684,13 @@
 
   // Equivalent to CloseWithReason(ClosedReason::kUnspecified).
   // DEPRECATED: Please use CloseWithReason() instead.
-  void Close();
+  void Close(bool force = false);
 
   // Hides the widget, then closes it after a return to the message loop,
   // specifying the reason for it having been closed.
   // Note that while you can pass ClosedReason::kUnspecified, it is highly
   // discouraged and only supported for backwards-compatibility with Close().
-  void CloseWithReason(ClosedReason closed_reason);
+  void CloseWithReason(ClosedReason closed_reason, bool force = false);
 
   // A UI test which tries to asynchronously examine a widget (e.g. the pixel
   // tests) will fail if the widget is closed before that.  This can happen
@@ -1072,6 +1075,7 @@
 
   base::WeakPtr<Widget> GetWeakPtr();
 
+  bool NWCanClose(bool user_force = false) const override;
   // Overridden from NativeWidgetDelegate:
   bool IsModal() const override;
   bool IsDialogBox() const override;
@@ -1337,6 +1341,7 @@
   // Note that this may be ClosedReason::kUnspecified if the deprecated Close()
   // method was called rather than CloseWithReason().
   ClosedReason closed_reason_ = ClosedReason::kUnspecified;
+  bool force_closing_ = false;
 
   // The saved "show" state for this window. See note in SetInitialBounds
   // that explains why we save this.
diff -r -u --color up/chromium/ui/views/widget/widget_delegate.cc nw/chromium/ui/views/widget/widget_delegate.cc
--- up/chromium/ui/views/widget/widget_delegate.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/views/widget/widget_delegate.cc	2023-01-28 02:49:50.623835759 +0000
@@ -68,6 +68,8 @@
 
 void WidgetDelegate::OnWidgetMove() {}
 
+void WidgetDelegate::OnWidgetResize() {}
+
 void WidgetDelegate::OnDisplayChanged() {}
 
 void WidgetDelegate::OnWorkAreaChanged() {}
@@ -108,6 +110,10 @@
   return can_activate_;
 }
 
+bool WidgetDelegate::NWCanClose(bool user_force) const {
+  return true;
+}
+
 ui::ModalType WidgetDelegate::GetModalType() const {
   return params_.modal_type;
 }
@@ -141,6 +147,10 @@
   return params_.show_close_button;
 }
 
+bool WidgetDelegate::ShouldHandleOnSize() const {
+  return false;
+}
+
 ui::ImageModel WidgetDelegate::GetWindowAppIcon() {
   // Prefer app icon if available.
   if (!params_.app_icon.isNull())
@@ -162,6 +172,14 @@
   return false;
 }
 
+bool WidgetDelegate::ExecuteAppCommand(int command_id) {
+  return ExecuteWindowsCommand(command_id);
+}
+
+bool WidgetDelegate::HandleSize(unsigned int param, const gfx::Size& size) {
+  return false;
+}
+
 std::string WidgetDelegate::GetWindowName() const {
   return std::string();
 }
diff -r -u --color up/chromium/ui/views/widget/widget_delegate.h nw/chromium/ui/views/widget/widget_delegate.h
--- up/chromium/ui/views/widget/widget_delegate.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/views/widget/widget_delegate.h	2023-01-28 02:49:50.623835759 +0000
@@ -129,6 +129,7 @@
 
   // Called whenever the widget's position changes.
   virtual void OnWidgetMove();
+  virtual void OnWidgetResize();
 
   // Called with the display changes (color depth or resolution).
   virtual void OnDisplayChanged();
@@ -158,7 +159,7 @@
   virtual DialogDelegate* AsDialogDelegate();
 
   // Returns true if the window can be resized.
-  bool CanResize() const;
+  virtual bool CanResize() const;
 
   // Returns true if the window can be maximized.
   virtual bool CanMaximize() const;
@@ -168,6 +169,7 @@
 
   // Returns true if the window can be activated.
   virtual bool CanActivate() const;
+  virtual bool NWCanClose(bool user_force = false) const;
 
   // Returns the modal type that applies to the widget. Default is
   // ui::MODAL_TYPE_NONE (not modal).
@@ -187,6 +189,8 @@
   // Returns true if the window should show a close button in the title bar.
   virtual bool ShouldShowCloseButton() const;
 
+  virtual bool ShouldHandleOnSize() const;
+
   // Returns the app icon for the window. On Windows, this is the ICON_BIG used
   // in Alt-Tab list and Win7's taskbar.
   virtual ui::ImageModel GetWindowAppIcon();
@@ -201,6 +205,10 @@
   // was handled, false if it was not.
   virtual bool ExecuteWindowsCommand(int command_id);
 
+  virtual bool ExecuteAppCommand(int command_id);
+
+  virtual bool HandleSize(unsigned int param, const gfx::Size& size);
+
   // Returns the window's name identifier. Used to identify this window for
   // state restoration.
   virtual std::string GetWindowName() const;
diff -r -u --color up/chromium/ui/views/widget/widget_hwnd_utils.cc nw/chromium/ui/views/widget/widget_hwnd_utils.cc
--- up/chromium/ui/views/widget/widget_hwnd_utils.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/views/widget/widget_hwnd_utils.cc	2023-01-28 02:49:50.623835759 +0000
@@ -11,6 +11,7 @@
 #include "ui/base/l10n/l10n_util_win.h"
 #include "ui/base/ui_base_features.h"
 #include "ui/base/ui_base_switches.h"
+#include "ui/display/display.h"
 #include "ui/views/widget/widget_delegate.h"
 #include "ui/views/win/hwnd_message_handler.h"
 
@@ -86,8 +87,19 @@
           native_widget_delegate->IsDialogBox() ? WS_EX_DLGMODALFRAME : 0;
 
       // See layered window comment below.
-      if (is_translucent)
-        *style &= static_cast<DWORD>(~(WS_THICKFRAME | WS_CAPTION));
+      if (content::g_support_transparency && is_translucent) {
+        if (params.remove_standard_frame) {
+          *style &= static_cast<DWORD>(~(WS_CAPTION));
+        }
+        if (!native_widget_delegate->IsDialogBox() && !native_widget_delegate->IsModal()) {
+          if (content::g_force_cpu_draw)
+            *ex_style |= WS_EX_LAYERED;
+        }
+      } else {
+        if (is_translucent)
+          *style &= static_cast<DWORD>(~(WS_THICKFRAME | WS_CAPTION));
+      }
+
       break;
     }
     case Widget::InitParams::TYPE_CONTROL:
@@ -165,9 +177,10 @@
   //
   // This doesn't work when Aero is disabled, so disable it in that case.
   // Software composited windows can continue to use WS_EX_LAYERED.
-  bool is_translucent =
+  bool is_translucent = !content::g_support_transparency ?
       (params.opacity == Widget::InitParams::WindowOpacity::kTranslucent &&
-       (ui::win::IsAeroGlassEnabled() || params.force_software_compositing));
+       (ui::win::IsAeroGlassEnabled() || params.force_software_compositing)) :
+    (params.opacity == Widget::InitParams::WindowOpacity::kTranslucent || params.force_software_compositing);
 
   CalculateWindowStylesFromInitParams(params, widget_delegate,
                                       native_widget_delegate, is_translucent,
diff -r -u --color up/chromium/ui/views/win/hwnd_message_handler.cc nw/chromium/ui/views/win/hwnd_message_handler.cc
--- up/chromium/ui/views/win/hwnd_message_handler.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/views/win/hwnd_message_handler.cc	2023-01-28 02:49:50.627835799 +0000
@@ -401,6 +401,8 @@
 LONG HWNDMessageHandler::last_touch_or_pen_message_time_ = 0;
 bool HWNDMessageHandler::is_pen_active_in_client_area_ = false;
 
+#define TRANSPARENCY(original, addition) content::g_support_transparency ? original addition : original
+
 HWNDMessageHandler::HWNDMessageHandler(HWNDMessageHandlerDelegate* delegate,
                                        const std::string& debugging_id)
     : WindowImpl(debugging_id),
@@ -452,6 +454,16 @@
 
   // Create the window.
   WindowImpl::Init(parent, bounds);
+  if (content::g_support_transparency && is_translucent_ && !content::g_force_cpu_draw) {
+    //WS_CAPTION style is somehow applied, during window creation, needs to update the style
+	  set_window_style((DWORD)GetWindowLong(hwnd(), GWL_STYLE));
+    //copied from WindowImpl::Init, see "First nccalcszie" comment
+    if (window_style() & WS_CAPTION) {
+      SetWindowPos(hwnd(), NULL, 0, 0, 0, 0,
+        SWP_FRAMECHANGED | SWP_NOMOVE | SWP_NOSIZE |
+        SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOREDRAW);
+    }
+  }
 
   if (!called_enable_non_client_dpi_scaling_ && delegate_->HasFrame() &&
       base::win::IsProcessPerMonitorDpiAware()) {
@@ -956,13 +968,16 @@
                                         const gfx::ImageSkia& app_icon) {
   if (!window_icon.isNull()) {
     base::win::ScopedHICON previous_icon = std::move(window_icon_);
-    window_icon_ = IconUtil::CreateHICONFromSkBitmap(*window_icon.bitmap());
+    window_icon_ =
+        IconUtil::CreateHICONFromSkBitmapSizedTo(*window_icon.bitmap(),
+          GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON));
     SendMessage(hwnd(), WM_SETICON, ICON_SMALL,
                 reinterpret_cast<LPARAM>(window_icon_.get()));
   }
   if (!app_icon.isNull()) {
     base::win::ScopedHICON previous_icon = std::move(app_icon_);
-    app_icon_ = IconUtil::CreateHICONFromSkBitmap(*app_icon.bitmap());
+    app_icon_ = IconUtil::CreateHICONFromSkBitmapSizedTo(*app_icon.bitmap(),
+          GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON));
     SendMessage(hwnd(), WM_SETICON, ICON_BIG,
                 reinterpret_cast<LPARAM>(app_icon_.get()));
   }
@@ -1026,7 +1041,7 @@
 
   // Windows cannot have WS_THICKFRAME set if translucent.
   // See CalculateWindowStylesFromInitParams().
-  if (delegate_->CanResize() && !is_translucent_) {
+  if (delegate_->CanResize() && (content::g_support_transparency || !is_translucent_)) {
     style |= WS_THICKFRAME | WS_MAXIMIZEBOX;
     if (!delegate_->CanMaximize())
       style &= ~WS_MAXIMIZEBOX;
@@ -1038,6 +1053,10 @@
   } else {
     style &= ~WS_MINIMIZEBOX;
   }
+  if (content::g_support_transparency && is_translucent_ && !content::g_force_cpu_draw) {
+    //WS_CAPTION needs to be removed on transparent window, or else the Title bar will be rendered
+    style &= ~WS_CAPTION;
+  }
   SetWindowLong(hwnd(), GWL_STYLE, style);
 }
 
@@ -1527,6 +1546,10 @@
     if (!delegate_->HasFrame())
       frame_thickness -= 1;
     *insets = gfx::Insets(frame_thickness);
+    if (content::g_force_cpu_draw && is_translucent_ && !delegate_->HasFrame()) {
+      //part of maximize_hack code
+      insets->set_top_bottom(0, -1).set_left_right(0, -1);
+    }
     return true;
   }
 
@@ -1543,7 +1566,7 @@
   // allow for a custom hit mask.
   if (!is_translucent_ && !custom_window_region_.is_valid() &&
       (IsFrameSystemDrawn() || !delegate_->HasNonClientView())) {
-    if (force)
+    if (force || content::g_force_cpu_draw)
       SetWindowRgn(hwnd(), nullptr, redraw);
     return;
   }
@@ -1568,6 +1591,10 @@
     RECT work_rect = mi.rcWork;
     OffsetRect(&work_rect, -window_rect.left, -window_rect.top);
     new_region.reset(CreateRectRgnIndirect(&work_rect));
+  } else if (content::g_support_transparency && is_translucent_) {
+    RECT work_rect = window_rect;
+    OffsetRect(&work_rect, -window_rect.left, -window_rect.top);
+    new_region.reset(CreateRectRgnIndirect(&work_rect));
   } else {
     SkPath window_mask;
     delegate_->GetWindowMask(gfx::Size(window_rect.right - window_rect.left,
@@ -1719,7 +1746,7 @@
   SendMessage(hwnd(), WM_CHANGEUISTATE, MAKELPARAM(UIS_CLEAR, UISF_HIDEFOCUS),
               0);
 
-  if (!delegate_->HasFrame()) {
+  if (TRANSPARENCY(!delegate_->HasFrame(), && !(is_translucent_))) {
     SetWindowLong(hwnd(), GWL_STYLE,
                   GetWindowLong(hwnd(), GWL_STYLE) & ~WS_CAPTION);
     SendFrameChanged();
@@ -1905,15 +1932,17 @@
   if (delegate_->WidgetSizeIsClientSize()) {
     RECT client_rect, window_rect;
     GetClientRect(hwnd(), &client_rect);
-    GetWindowRect(hwnd(), &window_rect);
-    CR_DEFLATE_RECT(&window_rect, &client_rect);
-    min_window_size.Enlarge(window_rect.right - window_rect.left,
-                            window_rect.bottom - window_rect.top);
-    // Either axis may be zero, so enlarge them independently.
-    if (max_window_size.width())
-      max_window_size.Enlarge(window_rect.right - window_rect.left, 0);
-    if (max_window_size.height())
-      max_window_size.Enlarge(0, window_rect.bottom - window_rect.top);
+	if (client_rect.right > client_rect.left) {
+		GetWindowRect(hwnd(), &window_rect);
+		CR_DEFLATE_RECT(&window_rect, &client_rect);
+		min_window_size.Enlarge(window_rect.right - window_rect.left,
+			window_rect.bottom - window_rect.top);
+		// Either axis may be zero, so enlarge them independently.
+		if (max_window_size.width())
+			max_window_size.Enlarge(window_rect.right - window_rect.left, 0);
+		if (max_window_size.height())
+			max_window_size.Enlarge(0, window_rect.bottom - window_rect.top);
+	}
   }
   minmax_info->ptMinTrackSize.x = min_window_size.width();
   minmax_info->ptMinTrackSize.y = min_window_size.height();
@@ -2299,9 +2328,11 @@
     }
   }
 
+  const LONG noTitleBar = (is_translucent_) && !delegate_->HasFrame();
   gfx::Insets insets;
   bool got_insets = GetClientAreaInsets(&insets, monitor);
-  if (!got_insets && !IsFullscreen() && !(mode && !delegate_->HasFrame())) {
+  if (TRANSPARENCY(!got_insets && !IsFullscreen() &&
+                   !(mode && !delegate_->HasFrame()), && !noTitleBar)) {
     SetMsgHandled(FALSE);
     return 0;
   }
@@ -2687,6 +2718,8 @@
   // ResetWindowRegion is going to trigger WM_NCPAINT. By doing it after we've
   // invoked OnSize we ensure the RootView has been laid out.
   ResetWindowRegion(false, true);
+  if (delegate_->ShouldHandleOnSize())
+    delegate_->HandleSize(param, size);
 }
 
 void HWNDMessageHandler::OnSizing(UINT param, RECT* rect) {
@@ -2702,6 +2735,15 @@
   *rect = window_rect.ToRECT();
 }
 
+void HWNDMessageHandler::OnStyleChanging(UINT nStyleType, LPSTYLESTRUCT lpStyleStruct) {
+  if (!content::g_support_transparency)
+    return;
+  if (nStyleType == (UINT)GWL_EXSTYLE)
+    set_window_ex_style(lpStyleStruct->styleNew);
+  else if (nStyleType == (UINT)GWL_STYLE)
+    set_window_style(lpStyleStruct->styleNew);
+}
+
 void HWNDMessageHandler::OnSysCommand(UINT notification_code,
                                       const gfx::Point& point) {
   // Windows uses the 4 lower order bits of |notification_code| for type-
@@ -2935,12 +2977,13 @@
           expected_maximized_bounds.Inset(
               gfx::ScaleToCeiledInsets(client_area_insets, -1));
       }
+      const bool maximize_hack = content::g_force_cpu_draw && is_translucent_;
       // Sometimes Windows incorrectly changes bounds of maximized windows after
       // attaching or detaching additional displays. In this case user can see
       // non-client area of the window (that should be hidden in normal case).
       // We should restore window position if problem occurs.
       const bool incorrect_maximized_bounds =
-          IsMaximized() && have_new_window_rect &&
+          IsMaximized() && (maximize_hack || have_new_window_rect) &&
           (expected_maximized_bounds.x() != window_pos->x ||
            expected_maximized_bounds.y() != window_pos->y ||
            expected_maximized_bounds.width() != window_pos->cx ||
@@ -2988,7 +3031,7 @@
         // Now ignore all immediately-following SetWindowPos() changes.  Windows
         // likes to (incorrectly) recalculate what our position/size should be
         // and send us further updates.
-        ignore_window_pos_changes_ = true;
+        ignore_window_pos_changes_ = !maximize_hack;
         base::ThreadTaskRunnerHandle::Get()->PostTask(
             FROM_HERE,
             base::BindOnce(&HWNDMessageHandler::StopIgnoringPosChanges,
@@ -3485,6 +3528,11 @@
 
 void HWNDMessageHandler::PerformDwmTransition() {
   dwm_transition_desired_ = false;
+  if (content::g_support_transparency && !content::g_force_cpu_draw && is_translucent_) {
+    const int im = ui::win::IsAeroGlassEnabled() ? -1 : 0;
+    MARGINS m = { im, im, im, im };
+    DwmExtendFrameIntoClientArea(hwnd(), &m);
+  }
 
   UpdateDwmNcRenderingPolicy();
   // Don't redraw the window here, because we need to hide and show the window
@@ -3496,7 +3544,7 @@
   // composition state changes.
   UpdateDwmFrame();
 
-  if (IsVisible() && IsFrameSystemDrawn()) {
+  if (IsVisible() && IsFrameSystemDrawn() && !content::g_force_cpu_draw) {
     // For some reason, we need to hide the window after we change from a custom
     // frame to a native frame.  If we don't, the client area will be filled
     // with black.  This seems to be related to an interaction between DWM and
@@ -3636,6 +3684,11 @@
   return handled;
 }
 
+void HWNDMessageHandler::SetPosition(const gfx::Point& pos_in_pixels) {
+  SetWindowPos(hwnd(), nullptr, pos_in_pixels.x(), pos_in_pixels.y(),
+    0, 0, SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE);
+}
+
 void HWNDMessageHandler::SetBoundsInternal(const gfx::Rect& bounds_in_pixels,
                                            bool force_size_changed) {
   gfx::Size old_size = GetClientAreaBounds().size();
diff -r -u --color up/chromium/ui/views/win/hwnd_message_handler.h nw/chromium/ui/views/win/hwnd_message_handler.h
--- up/chromium/ui/views/win/hwnd_message_handler.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/views/win/hwnd_message_handler.h	2023-01-28 02:49:50.627835799 +0000
@@ -458,6 +458,7 @@
     CR_MSG_WM_SETTINGCHANGE(OnSettingChange)
     CR_MSG_WM_SIZE(OnSize)
     CR_MSG_WM_SIZING(OnSizing)
+    CR_MSG_WM_STYLECHANGING(OnStyleChanging)
     CR_MSG_WM_SYSCOMMAND(OnSysCommand)
     CR_MSG_WM_THEMECHANGED(OnThemeChanged)
     CR_MSG_WM_TIMECHANGE(OnTimeChange)
@@ -519,6 +520,7 @@
   void OnSettingChange(UINT flags, const wchar_t* section);
   void OnSize(UINT param, const gfx::Size& size);
   void OnSizing(UINT param, RECT* rect);
+  void OnStyleChanging(UINT nStyleType, LPSTYLESTRUCT lpStyleStruct);
   void OnSysCommand(UINT notification_code, const gfx::Point& point);
   void OnThemeChanged();
   void OnTimeChange();
@@ -596,6 +598,7 @@
   // please refer to the SetBounds() function.
   void SetBoundsInternal(const gfx::Rect& bounds_in_pixels,
                          bool force_size_changed);
+  void SetPosition(const gfx::Point& pos_in_pixels);
 
   // Checks if there is a full screen window on the same monitor as the
   // |window| which is becoming active. If yes then we reduce the size of the
diff -r -u --color up/chromium/ui/views/win/hwnd_message_handler_delegate.h nw/chromium/ui/views/win/hwnd_message_handler_delegate.h
--- up/chromium/ui/views/win/hwnd_message_handler_delegate.h	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/views/win/hwnd_message_handler_delegate.h	2023-01-28 02:49:50.627835799 +0000
@@ -113,6 +113,10 @@
 
   virtual gfx::NativeViewAccessible GetNativeViewAccessible() = 0;
 
+  // on windows, maximizing sometime is sent through WM_SIZE, not
+  // WM_SYSCOMMAND, see node-webkit#753
+  virtual bool ShouldHandleOnSize() const = 0;
+
   // TODO(beng): Investigate migrating these methods to On* prefixes once
   // HWNDMessageHandler is the WindowImpl.
 
@@ -137,6 +141,8 @@
   // true if the command was handled.
   virtual bool HandleCommand(int command) = 0;
 
+  virtual bool HandleSize(UINT param, const gfx::Size& size) = 0;
+
   // Called when an accelerator is invoked.
   virtual void HandleAccelerator(const ui::Accelerator& accelerator) = 0;
 
diff -r -u --color up/chromium/ui/views/window/custom_frame_view.cc nw/chromium/ui/views/window/custom_frame_view.cc
--- up/chromium/ui/views/window/custom_frame_view.cc	2023-01-06 21:50:08.000000000 +0000
+++ nw/chromium/ui/views/window/custom_frame_view.cc	2023-01-28 02:49:50.627835799 +0000
@@ -7,6 +7,8 @@
 #include <algorithm>
 #include <utility>
 #include <vector>
+#include "ui/gfx/image/image_skia_operations.h"
+#include "ui/base/models/image_model.h"
 
 #include "base/containers/adapters.h"
 #include "base/strings/utf_string_conversions.h"
@@ -76,7 +78,7 @@
     : frame_(frame), frame_background_(new FrameBackground()) {
   close_button_ = InitWindowCaptionButton(
       base::BindRepeating(&Widget::CloseWithReason, base::Unretained(frame_),
-                          views::Widget::ClosedReason::kCloseButtonClicked),
+                          views::Widget::ClosedReason::kCloseButtonClicked, false),
       IDS_APP_ACCNAME_CLOSE, IDR_CLOSE, IDR_CLOSE_H, IDR_CLOSE_P);
   minimize_button_ = InitWindowCaptionButton(
       base::BindRepeating(&Widget::Minimize, base::Unretained(frame_)),
@@ -89,10 +91,13 @@
       IDS_APP_ACCNAME_RESTORE, IDR_RESTORE, IDR_RESTORE_H, IDR_RESTORE_P);
 
   if (frame_->widget_delegate()->ShouldShowWindowIcon()) {
-    window_icon_ =
-        AddChildView(std::make_unique<ImageButton>(Button::PressedCallback()));
+    ui::ImageModel icon;
+    icon = frame_->widget_delegate()->GetWindowAppIcon();
+    window_icon_ = new ImageButton(Button::PressedCallback());
+    window_icon_->SetImage(Button::STATE_NORMAL, icon.GetImage().ToImageSkia());
     // `window_icon_` does not need to be focusable as it is not used here as a
     // button and is not interactive.
+    AddChildView(window_icon_.get());
     window_icon_->SetFocusBehavior(FocusBehavior::NEVER);
   }
 }
@@ -173,8 +178,16 @@
 }
 
 void CustomFrameView::UpdateWindowIcon() {
-  if (window_icon_)
+  if (window_icon_) {
+    ui::ImageModel icon;
+    icon = frame_->widget_delegate()->GetWindowAppIcon();
+    int size = IconSize();
+    gfx::ImageSkia icon2 = gfx::ImageSkiaOperations::CreateResizedImage(*icon.GetImage().ToImageSkia(),
+                               skia::ImageOperations::RESIZE_BEST,
+                               gfx::Size(size, size));
+    window_icon_->SetImage(Button::STATE_NORMAL, &icon2);
     window_icon_->SchedulePaint();
+  }
 }
 
 void CustomFrameView::UpdateWindowTitle() {
