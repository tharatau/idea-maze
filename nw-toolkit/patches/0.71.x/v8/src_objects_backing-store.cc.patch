diff --git a/src/objects/backing-store.cc b/src/objects/backing-store.cc
index 1265accb24..d51ea306da 100644
--- a/src/objects/backing-store.cc
+++ b/src/objects/backing-store.cc
@@ -164,6 +164,7 @@ BackingStore::BackingStore(void* buffer_start, size_t byte_length,
       is_shared_(shared == SharedFlag::kShared),
       is_resizable_by_js_(resizable == ResizableFlag::kResizable),
       is_wasm_memory_(is_wasm_memory),
+      is_nodejs_(false),
       holds_shared_ptr_to_allocator_(false),
       free_on_destruct_(free_on_destruct),
       has_guard_regions_(has_guard_regions),
@@ -222,6 +223,17 @@ BackingStore::~BackingStore() {
     Clear();
     return;
   }
+
+  if (is_nodejs_) {
+    // JSArrayBuffer backing store. Deallocate through the embedder's allocator.
+    auto allocator = reinterpret_cast<v8::ArrayBuffer::Allocator*>(
+        get_v8_api_array_buffer_allocator());
+    TRACE_BS("BSn:free   bs=%p mem=%p (length=%zu, capacity=%zu)\n", this,
+             buffer_start_, byte_length(), byte_capacity_);
+    allocator->Free(buffer_start_, byte_length_, v8::ArrayBuffer::Allocator::AllocationMode::kNodeJS);
+    Clear();
+    return;
+  }
   if (free_on_destruct_) {
     // JSArrayBuffer backing store. Deallocate through the embedder's allocator.
     auto allocator = get_v8_api_array_buffer_allocator();
@@ -714,7 +726,7 @@ BackingStore::ResizeOrGrowResult BackingStore::GrowInPlace(
 
 std::unique_ptr<BackingStore> BackingStore::WrapAllocation(
     Isolate* isolate, void* allocation_base, size_t allocation_length,
-    SharedFlag shared, bool free_on_destruct) {
+    SharedFlag shared, bool free_on_destruct, bool is_nodejs) {
   auto result = new BackingStore(allocation_base,               // start
                                  allocation_length,             // length
                                  allocation_length,             // max length
@@ -727,6 +739,7 @@ std::unique_ptr<BackingStore> BackingStore::WrapAllocation(
                                  false,             // custom_deleter
                                  false);            // empty_deleter
   result->SetAllocatorFromIsolate(isolate);
+  result->is_nodejs_ = is_nodejs;
   TRACE_BS("BS:wrap   bs=%p mem=%p (length=%zu)\n", result,
            result->buffer_start(), result->byte_length());
   return std::unique_ptr<BackingStore>(result);
@@ -735,7 +748,7 @@ std::unique_ptr<BackingStore> BackingStore::WrapAllocation(
 std::unique_ptr<BackingStore> BackingStore::WrapAllocation(
     void* allocation_base, size_t allocation_length,
     v8::BackingStore::DeleterCallback deleter, void* deleter_data,
-    SharedFlag shared) {
+    SharedFlag shared, bool is_nodejs) {
   bool is_empty_deleter = (deleter == v8::BackingStore::EmptyDeleter);
   auto result = new BackingStore(allocation_base,               // start
                                  allocation_length,             // length
@@ -748,6 +761,7 @@ std::unique_ptr<BackingStore> BackingStore::WrapAllocation(
                                  false,              // has_guard_regions
                                  true,               // custom_deleter
                                  is_empty_deleter);  // empty_deleter
+  result->is_nodejs_ = is_nodejs;
   result->type_specific_data_.deleter = {deleter, deleter_data};
   TRACE_BS("BS:wrap   bs=%p mem=%p (length=%zu)\n", result,
            result->buffer_start(), result->byte_length());
