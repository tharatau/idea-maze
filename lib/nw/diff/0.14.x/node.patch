Only in nw/node: .git
diff -r -u --color up/node/CHANGELOG.md nw/node/CHANGELOG.md
--- up/node/CHANGELOG.md	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/CHANGELOG.md	2023-02-21 04:37:42.860351415 +0000
@@ -1,5 +1,25 @@
 # Node.js ChangeLog
 
+## 2016-06-23, Version 5.12.0 (Stable), @evanlucas
+
+### Notable changes
+
+This is a security release. All Node.js users should consult the security release summary at https://nodejs.org/en/blog/vulnerability/june-2016-security-releases for details on patched vulnerabilities.
+
+* **buffer**
+  * backport allocUnsafeSlow (Сковорода Никита Андреевич) [#7169](https://github.com/nodejs/node/pull/7169)
+  * ignore negative allocation lengths (Anna Henningsen) [#7221](https://github.com/nodejs/node/pull/7221)
+* **deps**: backport 3a9bfec from v8 upstream (Ben Noordhuis) [nodejs/node-private#40](https://github.com/nodejs/node-private/pull/40)
+  * Fixes a Buffer overflow vulnerability discovered in v8. More details can be found in the CVE (CVE-2016-1699).
+
+### Commits
+
+* [[`0ca0827b71`](https://github.com/nodejs/node/commit/0ca0827b71)] - **(SEMVER-MINOR)** **buffer**: backport allocUnsafeSlow (Сковорода Никита Андреевич) [#7169](https://github.com/nodejs/node/pull/7169)
+* [[`27785aeb37`](https://github.com/nodejs/node/commit/27785aeb37)] - **buffer**: ignore negative allocation lengths (Anna Henningsen) [#7221](https://github.com/nodejs/node/pull/7221)
+* [[`34b96c1322`](https://github.com/nodejs/node/commit/34b96c1322)] - **deps**: backport 3a9bfec from v8 upstream (Ben Noordhuis) [nodejs/node-private#40](https://github.com/nodejs/node-private/pull/40)
+* [[`2ebeb82852`](https://github.com/nodejs/node/commit/2ebeb82852)] - **test**: fix test-net-* error code check for getaddrinfo(3) (Natanael Copa) [#5099](https://github.com/nodejs/node/pull/5099)
+* [[`03d36aea4f`](https://github.com/nodejs/node/commit/03d36aea4f)] - **(SEMVER-MINOR)** **test**: add buffer testcase for resetting kZeroFill (Сковорода Никита Андреевич) [#7169](https://github.com/nodejs/node/pull/7169)
+
 ## 2016-05-05, Version 5.11.1 (Stable), @evanlucas
 
 ### Notable changes
@@ -30,7 +50,7 @@
   * update to http-parser 2.7.0 (Fedor Indutny) [#6279](https://github.com/nodejs/node/pull/6279)
   * update ESLint to 2.7.0 (silverwind) [#6132](https://github.com/nodejs/node/pull/6132)
 * **net**:
-  * adds support for passing DNS lookup hints to `createConnection()` (Colin Ihrig) [#6000](https://github.com/nodejs/node/pull/6000) 
+  * adds support for passing DNS lookup hints to `createConnection()` (Colin Ihrig) [#6000](https://github.com/nodejs/node/pull/6000)
 * **node**:
   * Make the builtin libraries available for the `--eval` and `--print` CLI options (Anna Henningsen) [#6207](https://github.com/nodejs/node/pull/6207)
 * **npm**:
@@ -199,10 +219,10 @@
 * **fs**: add the fs.mkdtemp() function. (Florian MARGAINE) [#5333](https://github.com/nodejs/node/pull/5333)
 * **net**: emit host in lookup event (HUANG Wei) [#5598](https://github.com/nodejs/node/pull/5598)
 * **node**: --no-browser-globals configure flag (Fedor Indutny) [#5853](https://github.com/nodejs/node/pull/5853)
-* **npm**: Upgrade to v3.8.3. Fixes a security flaw in the use of authentication tokens in HTTP requests that 
-  would allow an attacker to set up a server that could collect tokens from users of the command-line interface. 
-  Authentication tokens have previously been sent with every request made by the CLI for logged-in users, 
-  regardless of the destination of the request. This update fixes this by only including those tokens for requests 
+* **npm**: Upgrade to v3.8.3. Fixes a security flaw in the use of authentication tokens in HTTP requests that
+  would allow an attacker to set up a server that could collect tokens from users of the command-line interface.
+  Authentication tokens have previously been sent with every request made by the CLI for logged-in users,
+  regardless of the destination of the request. This update fixes this by only including those tokens for requests
   made against the registry or registries used for the current install. (Forrest L Norvell) [npm/node#6](https://github.com/npm/node/pull/6)
 * **repl**: support standalone blocks (Prince J Wesley) [#5581](https://github.com/nodejs/node/pull/5581)
 * **src**: override v8 thread defaults using cli options (Tom Gallacher) [#4344](https://github.com/nodejs/node/pull/4344)
@@ -222,7 +242,7 @@
 * [[`5ee5fa292f`](https://github.com/nodejs/node/commit/5ee5fa292f)] - **build**: add missing `openssl_fips%` to common.gypi (Fedor Indutny) [#5919](https://github.com/nodejs/node/pull/5919)
 * [[`5681ffecf7`](https://github.com/nodejs/node/commit/5681ffecf7)] - **build**: enable compilation for linuxOne (Michael Dawson) [#5941](https://github.com/nodejs/node/pull/5941)
 * [[`660ec9f889`](https://github.com/nodejs/node/commit/660ec9f889)] - **child_process**: refactor self=this in socket_list (Benjamin Gruenbaum) [#5860](https://github.com/nodejs/node/pull/5860)
-* [[`e1a012f277`](https://github.com/nodejs/node/commit/e1a012f277)] - **deps**: upgrade npm to 3.8.3 (Forrest L Norvell) 
+* [[`e1a012f277`](https://github.com/nodejs/node/commit/e1a012f277)] - **deps**: upgrade npm to 3.8.3 (Forrest L Norvell)
 * [[`ec1813199d`](https://github.com/nodejs/node/commit/ec1813199d)] - **deps**: backport 8d00c2c from v8 upstream (Ben Noordhuis) [#5577](https://github.com/nodejs/node/pull/5577)
 * [[`2a5c6d7006`](https://github.com/nodejs/node/commit/2a5c6d7006)] - **dns**: Refactor forEach to map (Benjamin Gruenbaum) [#5803](https://github.com/nodejs/node/pull/5803)
 * [[`6a6112a2f3`](https://github.com/nodejs/node/commit/6a6112a2f3)] - **dns**: Use object without protoype for map (Benjamin Gruenbaum) [#5843](https://github.com/nodejs/node/pull/5843)
Only in nw/node: config.gypi
diff -r -u --color up/node/deps/cares/cares.gyp nw/node/deps/cares/cares.gyp
--- up/node/deps/cares/cares.gyp	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/deps/cares/cares.gyp	2023-02-21 04:37:42.868351492 +0000
@@ -1,4 +1,7 @@
 {
+  'variables': {
+    'library%': 'static_library',
+  },
   'target_defaults': {
     'conditions': [
       ['OS!="win"', {
@@ -108,6 +111,7 @@
         }],
         [ 'OS=="win"', {
           'include_dirs': [ 'config/win32' ],
+          'msvs_disabled_warnings': [4133],
           'sources': [
             'src/config-win32.h',
             'src/windows_port.c',
diff -r -u --color up/node/deps/cares/src/ares_create_query.c nw/node/deps/cares/src/ares_create_query.c
--- up/node/deps/cares/src/ares_create_query.c	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/deps/cares/src/ares_create_query.c	2023-02-21 04:37:42.868351492 +0000
@@ -16,6 +16,11 @@
 
 #include "ares_setup.h"
 
+#ifndef _WIN32
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Warray-bounds"
+#endif
+
 #ifdef HAVE_NETINET_IN_H
 #  include <netinet/in.h>
 #endif
@@ -206,3 +211,7 @@
 
   return ARES_SUCCESS;
 }
+
+#ifndef _WIN32
+#pragma clang diagnostic pop
+#endif
diff -r -u --color up/node/deps/cares/src/ares_process.c nw/node/deps/cares/src/ares_process.c
--- up/node/deps/cares/src/ares_process.c	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/deps/cares/src/ares_process.c	2023-02-21 04:37:42.876351569 +0000
@@ -460,7 +460,7 @@
           else
             fromlen = sizeof(from.sa6);
           count = (ssize_t)recvfrom(server->udp_socket, (void *)buf,
-                                    sizeof(buf), 0, &from.sa, &fromlen);
+                                    sizeof(buf), 0, &from.sa, (socklen_t *)&fromlen);
 #else
           count = sread(server->udp_socket, buf, sizeof(buf));
 #endif
diff -r -u --color up/node/deps/http_parser/http_parser.c nw/node/deps/http_parser/http_parser.c
--- up/node/deps/http_parser/http_parser.c	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/deps/http_parser/http_parser.c	2023-02-21 04:37:42.880351608 +0000
@@ -2391,7 +2391,7 @@
         break;
 
       default:
-        assert(!"Unexpected state");
+        assert(!(int)"Unexpected state");
         return 1;
     }
 
diff -r -u --color up/node/deps/http_parser/http_parser.gyp nw/node/deps/http_parser/http_parser.gyp
--- up/node/deps/http_parser/http_parser.gyp	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/deps/http_parser/http_parser.gyp	2023-02-21 04:37:42.880351608 +0000
@@ -13,20 +13,10 @@
       'Debug': {
         'defines': [ 'DEBUG', '_DEBUG' ],
         'cflags': [ '-Wall', '-Wextra', '-O0', '-g', '-ftrapv' ],
-        'msvs_settings': {
-          'VCCLCompilerTool': {
-            'RuntimeLibrary': 1, # static debug
-          },
-        },
       },
       'Release': {
         'defines': [ 'NDEBUG' ],
         'cflags': [ '-Wall', '-Wextra', '-O3' ],
-        'msvs_settings': {
-          'VCCLCompilerTool': {
-            'RuntimeLibrary': 0, # static release
-          },
-        },
       }
     },
     'msvs_settings': {
@@ -39,6 +29,9 @@
       },
     },
     'conditions': [
+      ['clang==1', {
+        'cflags': ['-Wno-error=string-conversion'],
+      }],
       ['OS == "win"', {
         'defines': [
           'WIN32'
diff -r -u --color up/node/deps/openssl/masm_compile.gypi nw/node/deps/openssl/masm_compile.gypi
--- up/node/deps/openssl/masm_compile.gypi	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/deps/openssl/masm_compile.gypi	2023-02-21 04:37:43.084353583 +0000
@@ -16,7 +16,7 @@
             '/Fo', '<(INTERMEDIATE_DIR)/<(RULE_INPUT_ROOT).obj',
             '/c', '<(RULE_INPUT_PATH)',
           ],
-          'process_outputs_as_sources': 0,
+          'process_outputs_as_sources': 1,
           'message': 'Assembling <(RULE_INPUT_PATH) to <(INTERMEDIATE_DIR)/<(RULE_INPUT_ROOT).obj.',
         }
       ],
@@ -35,7 +35,7 @@
             '/Fo', '<(INTERMEDIATE_DIR)/<(RULE_INPUT_ROOT).obj',
             '/c', '<(RULE_INPUT_PATH)',
           ],
-          'process_outputs_as_sources': 0,
+          'process_outputs_as_sources': 1,
           'message': 'Assembling <(RULE_INPUT_PATH) to <(INTERMEDIATE_DIR)/<(RULE_INPUT_ROOT).obj.',
         }
       ],
diff -r -u --color up/node/deps/openssl/openssl/ssl/d1_srvr.c nw/node/deps/openssl/openssl/ssl/d1_srvr.c
--- up/node/deps/openssl/openssl/ssl/d1_srvr.c	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/deps/openssl/openssl/ssl/d1_srvr.c	2023-02-21 04:37:43.256355246 +0000
@@ -126,6 +126,7 @@
 # include <openssl/dh.h>
 #endif
 
+
 static const SSL_METHOD *dtls1_get_server_method(int ver);
 static int dtls1_send_hello_verify_request(SSL *s);
 
diff -r -u --color up/node/deps/openssl/openssl/ssl/s3_srvr.c nw/node/deps/openssl/openssl/ssl/s3_srvr.c
--- up/node/deps/openssl/openssl/ssl/s3_srvr.c	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/deps/openssl/openssl/ssl/s3_srvr.c	2023-02-21 04:37:43.260355285 +0000
@@ -170,6 +170,7 @@
 #endif
 #include <openssl/md5.h>
 
+
 #ifndef OPENSSL_NO_SSL3_METHOD
 static const SSL_METHOD *ssl3_get_server_method(int ver);
 
diff -r -u --color up/node/deps/openssl/openssl.gyp nw/node/deps/openssl/openssl.gyp
--- up/node/deps/openssl/openssl.gyp	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/deps/openssl/openssl.gyp	2023-02-21 04:37:43.084353583 +0000
@@ -4,18 +4,22 @@
 
 {
   'variables': {
-    'is_clang': 0,
+    'is_clang': 1,
     'gcc_version': 0,
     'openssl_no_asm%': 0,
     'llvm_version%': 0,
     'xcode_version%': 0,
     'gas_version%': 0,
-    'openssl_fips%': 'false',
+    'openssl_fips%': '',
+    'node_byteorder%': 'little',
+    'conditions': [
+      ['OS=="mac"', { 'openssl_no_asm%': 1 } ],
+    ],
   },
   'targets': [
     {
       'target_name': 'openssl',
-      'type': '<(library)',
+      'type': 'static_library',
       'includes': ['openssl.gypi'],
       'sources': ['<@(openssl_sources)'],
       'sources/': [
@@ -142,6 +146,8 @@
     'includes': ['openssl.gypi'],
     'include_dirs': ['<@(openssl_default_include_dirs)'],
     'defines': ['<@(openssl_default_defines_all)'],
+    'cflags!': ['-fvisibility=hidden'],
+    'cflags_cc!': ['-fvisibility-inlines-hidden'],
     'conditions': [
       ['OS=="win"', {
         'defines': ['<@(openssl_default_defines_win)'],
@@ -160,7 +166,7 @@
         ]
       }],
       ['is_clang==1 or gcc_version>=43', {
-        'cflags': ['-Wno-old-style-declaration'],
+        'cflags': ['-Wno-error=unused-command-line-argument', '-Wno-error=parentheses-equality'],
       }],
       ['OS=="solaris"', {
         'defines': ['__EXTENSIONS__'],
diff -r -u --color up/node/deps/uv/include/uv.h nw/node/deps/uv/include/uv.h
--- up/node/deps/uv/include/uv.h	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/deps/uv/include/uv.h	2023-02-21 04:37:43.284355515 +0000
@@ -28,6 +28,8 @@
 #endif
 
 #ifdef _WIN32
+#pragma warning(push)
+#pragma warning(disable: 4201)
   /* Windows - set up dll import/export decorators. */
 # if defined(BUILDING_UV_SHARED)
     /* Building shared library. */
@@ -764,6 +766,9 @@
                             uv_async_t* async,
                             uv_async_cb async_cb);
 UV_EXTERN int uv_async_send(uv_async_t* async);
+#ifdef _WIN32
+UV_EXTERN int uv_async_send_nw(uv_async_t* async);
+#endif
 
 
 /*
@@ -1452,6 +1457,7 @@
   void* active_reqs[2];
   /* Internal flag to signal loop stop. */
   unsigned int stop_flag;
+  void* keventfunc;
   UV_LOOP_PRIVATE_FIELDS
 };
 
@@ -1476,6 +1482,10 @@
 #undef UV_LOOP_PRIVATE_FIELDS
 #undef UV_LOOP_PRIVATE_PLATFORM_FIELDS
 
+#ifdef _WIN32
+#pragma warning(pop)
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff -r -u --color up/node/deps/uv/src/unix/fs.c nw/node/deps/uv/src/unix/fs.c
--- up/node/deps/uv/src/unix/fs.c	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/deps/uv/src/unix/fs.c	2023-02-21 04:37:43.284355515 +0000
@@ -45,6 +45,9 @@
 #include <utime.h>
 #include <poll.h>
 
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Warray-bounds"
+
 #if defined(__DragonFly__)  ||                                            \
     defined(__FreeBSD__)    ||                                            \
     defined(__OpenBSD__)    ||                                            \
@@ -1308,3 +1311,4 @@
     uv__free(req->ptr);
   req->ptr = NULL;
 }
+#pragma clang diagnostic pop
diff -r -u --color up/node/deps/uv/src/unix/getaddrinfo.c nw/node/deps/uv/src/unix/getaddrinfo.c
--- up/node/deps/uv/src/unix/getaddrinfo.c	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/deps/uv/src/unix/getaddrinfo.c	2023-02-21 04:37:43.284355515 +0000
@@ -88,7 +88,7 @@
   case EAI_SYSTEM: return -errno;
 #endif
   }
-  assert(!"unknown EAI_* error code");
+  assert(!(int)("unknown EAI_* error code"));
   abort();
   return 0;  /* Pacify compiler. */
 }
diff -r -u --color up/node/deps/uv/src/unix/kqueue.c nw/node/deps/uv/src/unix/kqueue.c
--- up/node/deps/uv/src/unix/kqueue.c	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/deps/uv/src/unix/kqueue.c	2023-02-21 04:37:43.284355515 +0000
@@ -36,6 +36,8 @@
 
 static void uv__fs_event(uv_loop_t* loop, uv__io_t* w, unsigned int fflags);
 
+typedef  int (*keventfunc_t)(int kq, const struct kevent *changelist, int nchanges,
+                    struct kevent *eventlist, int nevents, const struct timespec *timeout);
 
 int uv__kqueue_init(uv_loop_t* loop) {
   loop->backend_fd = kqueue();
@@ -68,6 +70,8 @@
   int op;
   int i;
 
+  keventfunc_t keventfunc = loop->keventfunc ? (keventfunc_t)loop->keventfunc : &kevent;
+
   if (loop->nfds == 0) {
     assert(QUEUE_EMPTY(&loop->watcher_queue));
     return;
@@ -100,7 +104,7 @@
       EV_SET(events + nevents, w->fd, filter, op, fflags, 0, 0);
 
       if (++nevents == ARRAY_SIZE(events)) {
-        if (kevent(loop->backend_fd, events, nevents, NULL, 0, NULL))
+        if (keventfunc(loop->backend_fd, events, nevents, NULL, 0, NULL))
           abort();
         nevents = 0;
       }
@@ -110,7 +114,7 @@
       EV_SET(events + nevents, w->fd, EVFILT_WRITE, EV_ADD, 0, 0, 0);
 
       if (++nevents == ARRAY_SIZE(events)) {
-        if (kevent(loop->backend_fd, events, nevents, NULL, 0, NULL))
+        if (keventfunc(loop->backend_fd, events, nevents, NULL, 0, NULL))
           abort();
         nevents = 0;
       }
@@ -139,7 +143,7 @@
     if (pset != NULL)
       pthread_sigmask(SIG_BLOCK, pset, NULL);
 
-    nfds = kevent(loop->backend_fd,
+    nfds = keventfunc(loop->backend_fd,
                   events,
                   nevents,
                   events,
@@ -156,7 +160,7 @@
     SAVE_ERRNO(uv__update_time(loop));
 
     if (nfds == 0) {
-      assert(timeout != -1);
+      //assert(timeout != -1);
       return;
     }
 
@@ -193,7 +197,7 @@
         struct kevent events[1];
 
         EV_SET(events + 0, fd, ev->filter, EV_DELETE, 0, 0, 0);
-        if (kevent(loop->backend_fd, events, 1, NULL, 0, NULL))
+        if (keventfunc(loop->backend_fd, events, 1, NULL, 0, NULL))
           if (errno != EBADF && errno != ENOENT)
             abort();
 
@@ -218,7 +222,7 @@
           /* TODO batch up */
           struct kevent events[1];
           EV_SET(events + 0, fd, ev->filter, EV_DELETE, 0, 0, 0);
-          if (kevent(loop->backend_fd, events, 1, NULL, 0, NULL))
+          if (keventfunc(loop->backend_fd, events, 1, NULL, 0, NULL))
             if (errno != ENOENT)
               abort();
         }
@@ -232,7 +236,7 @@
           /* TODO batch up */
           struct kevent events[1];
           EV_SET(events + 0, fd, ev->filter, EV_DELETE, 0, 0, 0);
-          if (kevent(loop->backend_fd, events, 1, NULL, 0, NULL))
+          if (keventfunc(loop->backend_fd, events, 1, NULL, 0, NULL))
             if (errno != ENOENT)
               abort();
         }
@@ -305,7 +309,8 @@
   /* MAXPATHLEN == PATH_MAX but the former is what XNU calls it internally. */
   char pathbuf[MAXPATHLEN];
 #endif
-
+  keventfunc_t keventfunc = loop->keventfunc ? (keventfunc_t)loop->keventfunc : &kevent;
+  
   handle = container_of(w, uv_fs_event_t, event_watcher);
 
   if (fflags & (NOTE_ATTRIB | NOTE_EXTEND))
@@ -333,7 +338,7 @@
 
   EV_SET(&ev, w->fd, EVFILT_VNODE, EV_ADD | EV_ONESHOT, fflags, 0, 0);
 
-  if (kevent(loop->backend_fd, &ev, 1, NULL, 0, NULL))
+  if (keventfunc(loop->backend_fd, &ev, 1, NULL, 0, NULL))
     abort();
 }
 
diff -r -u --color up/node/deps/uv/src/unix/loop.c nw/node/deps/uv/src/unix/loop.c
--- up/node/deps/uv/src/unix/loop.c	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/deps/uv/src/unix/loop.c	2023-02-21 04:37:43.288355554 +0000
@@ -56,6 +56,8 @@
   loop->backend_fd = -1;
   loop->emfile_fd = -1;
 
+  loop->keventfunc = NULL;
+
   loop->timer_counter = 0;
   loop->stop_flag = 0;
 
diff -r -u --color up/node/deps/uv/src/unix/proctitle.c nw/node/deps/uv/src/unix/proctitle.c
--- up/node/deps/uv/src/unix/proctitle.c	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/deps/uv/src/unix/proctitle.c	2023-02-21 04:37:43.288355554 +0000
@@ -35,6 +35,14 @@
 
 
 char** uv_setup_args(int argc, char** argv) {
+  if (argc > 0) {
+    process_title.len = strlen(argv[0]);
+    process_title.str = uv__malloc(process_title.len + 1);
+    memcpy(process_title.str, argv[0], process_title.len + 1);
+  }
+  return argv;
+#if 0
+    
   char** new_argv;
   size_t size;
   char* s;
@@ -71,6 +79,7 @@
   new_argv[i] = NULL;
 
   return new_argv;
+#endif
 }
 
 
diff -r -u --color up/node/deps/uv/src/win/async.c nw/node/deps/uv/src/win/async.c
--- up/node/deps/uv/src/win/async.c	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/deps/uv/src/win/async.c	2023-02-21 04:37:43.288355554 +0000
@@ -84,6 +84,24 @@
 }
 
 
+int uv_async_send_nw(uv_async_t* handle) {
+  uv_loop_t* loop = handle->loop;
+
+  if (handle->type != UV_ASYNC) {
+    /* Can't set errno because that's not thread-safe. */
+    return -1;
+  }
+
+  /* The user should make sure never to call uv_async_send to a closing */
+  /* or closed handle. */
+  assert(!(handle->flags & UV__HANDLE_CLOSING));
+
+  POST_COMPLETION_FOR_REQ(loop, &handle->async_req);
+
+  return 0;
+}
+
+
 void uv_process_async_wakeup_req(uv_loop_t* loop, uv_async_t* handle,
     uv_req_t* req) {
   assert(handle->type == UV_ASYNC);
diff -r -u --color up/node/deps/uv/src/win/core.c nw/node/deps/uv/src/win/core.c
--- up/node/deps/uv/src/win/core.c	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/deps/uv/src/win/core.c	2023-02-21 04:37:43.288355554 +0000
@@ -98,7 +98,7 @@
    * FDs even though they return the proper error code in the release build.
    */
 #if defined(_DEBUG) && (defined(_MSC_VER) || defined(__MINGW64_VERSION_MAJOR))
-  _CrtSetReportHook(uv__crt_dbg_report_handler);
+  //_CrtSetReportHook(uv__crt_dbg_report_handler);
 #endif
 
   /* Fetch winapi function pointers. This must be done first because other
@@ -338,10 +338,11 @@
   int r;
   int ran_pending;
   void (*poll)(uv_loop_t* loop, DWORD timeout);
-
+#if 1
   if (pGetQueuedCompletionStatusEx)
     poll = &uv_poll_ex;
   else
+#endif
     poll = &uv_poll;
 
   r = uv__loop_alive(loop);
diff -r -u --color up/node/deps/uv/src/win/process.c nw/node/deps/uv/src/win/process.c
--- up/node/deps/uv/src/win/process.c	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/deps/uv/src/win/process.c	2023-02-21 04:37:43.288355554 +0000
@@ -1075,6 +1075,8 @@
     process_flags |= DETACHED_PROCESS | CREATE_NEW_PROCESS_GROUP;
   }
 
+  process_flags |= CREATE_NO_WINDOW;
+
   if (!CreateProcessW(application_path,
                      arguments,
                      NULL,
diff -r -u --color up/node/deps/uv/src/win/req-inl.h nw/node/deps/uv/src/win/req-inl.h
--- up/node/deps/uv/src/win/req-inl.h	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/deps/uv/src/win/req-inl.h	2023-02-21 04:37:43.288355554 +0000
@@ -81,6 +81,7 @@
 
 INLINE static void uv_req_init(uv_loop_t* loop, uv_req_t* req) {
   req->type = UV_UNKNOWN_REQ;
+  req->next_req = NULL;
   SET_REQ_SUCCESS(req);
 }
 
@@ -91,7 +92,8 @@
 
 
 INLINE static void uv_insert_pending_req(uv_loop_t* loop, uv_req_t* req) {
-  req->next_req = NULL;
+  if (req->next_req)
+    return;
   if (loop->pending_reqs_tail) {
 #ifdef _DEBUG
     /* Ensure the request is not already in the queue, or the queue
@@ -156,6 +158,7 @@
   while (next != NULL) {
     req = next;
     next = req->next_req != first ? req->next_req : NULL;
+    req->next_req = NULL;
 
     switch (req->type) {
       case UV_READ:
diff -r -u --color up/node/deps/uv/uv.gyp nw/node/deps/uv/uv.gyp
--- up/node/deps/uv/uv.gyp	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/deps/uv/uv.gyp	2023-02-21 04:37:43.300355669 +0000
@@ -1,4 +1,7 @@
 {
+  'variables': {
+    'uv_library%': 'static_library',
+  },
   'target_defaults': {
     'conditions': [
       ['OS != "win"', {
@@ -17,9 +20,10 @@
       }],
     ],
     'xcode_settings': {
-      'WARNING_CFLAGS': [ '-Wall', '-Wextra', '-Wno-unused-parameter' ],
+      'WARNING_CFLAGS': [ '-Wall', '-Wextra', '-Wno-unused-parameter' , '-Wno-error=gnu-folding-constant'],
       'OTHER_CFLAGS': [ '-g', '--std=gnu89', '-pedantic' ],
-    }
+    },
+    'msvs_disabled_warnings': [4267],
   },
 
   'targets': [
@@ -30,6 +34,7 @@
         'include',
         'src/',
       ],
+      'defines': [ 'BUILDING_UV_SHARED=1' ],
       'direct_dependent_settings': {
         'include_dirs': [ 'include' ],
         'conditions': [
@@ -271,7 +276,7 @@
         [ 'OS in "ios mac freebsd dragonflybsd openbsd netbsd".split()', {
           'sources': [ 'src/unix/kqueue.c' ],
         }],
-        ['uv_library=="shared_library"', {
+        ['component=="shared_library"', {
           'defines': [ 'BUILDING_UV_SHARED=1' ]
         }],
       ]
diff -r -u --color up/node/deps/v8/include/v8-version.h nw/node/deps/v8/include/v8-version.h
--- up/node/deps/v8/include/v8-version.h	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/deps/v8/include/v8-version.h	2023-02-21 04:37:43.308355746 +0000
@@ -11,7 +11,7 @@
 #define V8_MAJOR_VERSION 4
 #define V8_MINOR_VERSION 6
 #define V8_BUILD_NUMBER 85
-#define V8_PATCH_LEVEL 31
+#define V8_PATCH_LEVEL 32
 
 // Use 1 for candidates and 0 otherwise.
 // (Boolean macro values are not supported by all preprocessors.)
diff -r -u --color up/node/deps/v8/src/zone.cc nw/node/deps/v8/src/zone.cc
--- up/node/deps/v8/src/zone.cc	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/deps/v8/src/zone.cc	2023-02-21 04:37:43.460357207 +0000
@@ -105,7 +105,10 @@
   Address result = position_;
 
   const size_t size_with_redzone = size + kASanRedzoneBytes;
-  if (limit_ < position_ + size_with_redzone) {
+  const uintptr_t limit = reinterpret_cast<uintptr_t>(limit_);
+  const uintptr_t position = reinterpret_cast<uintptr_t>(position_);
+  // position_ > limit_ can be true after the alignment correction above.
+  if (limit < position || size_with_redzone > limit - position) {
     result = NewExpand(size_with_redzone);
   } else {
     position_ += size_with_redzone;
@@ -222,7 +225,10 @@
   // Make sure the requested size is already properly aligned and that
   // there isn't enough room in the Zone to satisfy the request.
   DCHECK_EQ(size, RoundDown(size, kAlignment));
-  DCHECK_LT(limit_, position_ + size);
+  DCHECK(limit_ < position_ ||
+         reinterpret_cast<uintptr_t>(limit_) -
+                 reinterpret_cast<uintptr_t>(position_) <
+             size);
 
   // Compute the new segment size. We use a 'high water mark'
   // strategy, where we increase the segment size every time we expand
diff -r -u --color up/node/doc/api/buffer.md nw/node/doc/api/buffer.md
--- up/node/doc/api/buffer.md	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/doc/api/buffer.md	2023-02-21 04:37:43.856361013 +0000
@@ -87,25 +87,27 @@
   containing a *copy* of the provided string.
 * [`Buffer.alloc(size[, fill[, encoding]])`][buffer_alloc] returns a "filled"
   `Buffer` instance of the specified size. This method can be significantly
-  slower than [`Buffer.allocUnsafe(size)`][buffer_allocunsafe] but ensures that
-  newly created `Buffer` instances never contain old and potentially sensitive
-  data.
-* [`Buffer.allocUnsafe(size)`][buffer_allocunsafe] returns a new `Buffer` of
-  the specified `size` whose content *must* be initialized using either
-  [`buf.fill(0)`][] or written to completely.
+  slower than [`Buffer.allocUnsafe(size)`][buffer_allocunsafe] but ensures
+  that newly created `Buffer` instances never contain old and potentially
+  sensitive data.
+* [`Buffer.allocUnsafe(size)`][buffer_allocunsafe] and
+  [`Buffer.allocUnsafeSlow(size)`][buffer_allocunsafeslow] each return a
+  new `Buffer` of the specified `size` whose content *must* be initialized
+  using either [`buf.fill(0)`][] or written to completely.
 
 `Buffer` instances returned by `Buffer.allocUnsafe(size)` *may* be allocated
-off a shared internal memory pool if the `size` is less than or equal to half
-`Buffer.poolSize`.
-
-### What makes `Buffer.allocUnsafe(size)` "unsafe"?
-
-When calling `Buffer.allocUnsafe()`, the segment of allocated memory is
-*uninitialized* (it is not zeroed-out). While this design makes the allocation
-of memory quite fast, the allocated segment of memory might contain old data
-that is potentially sensitive. Using a `Buffer` created by
-`Buffer.allocUnsafe(size)` without *completely* overwriting the memory can
-allow this old data to be leaked when the `Buffer` memory is read.
+off a shared internal memory pool if `size` is less than or equal to half
+`Buffer.poolSize`. Instances returned by `Buffer.allocUnsafeSlow(size)` *never*
+use the shared internal memory pool.
+
+### What makes `Buffer.allocUnsafe(size)` and `Buffer.allocUnsafeSlow(size)` "unsafe"?
+
+When calling `Buffer.allocUnsafe()` (and `Buffer.allocUnsafeSlow()`), the
+segment of allocated memory is *uninitialized* (it is not zeroed-out). While
+this design makes the allocation of memory quite fast, the allocated segment of
+memory might contain old data that is potentially sensitive. Using a `Buffer`
+created by `Buffer.allocUnsafe()` without *completely* overwriting the memory
+can allow this old data to be leaked when the `Buffer` memory is read.
 
 While there are clear performance advantages to using `Buffer.allocUnsafe()`,
 extra care *must* be taken in order to avoid introducing security
@@ -240,7 +242,8 @@
 
 Node.js can be started using the `--zero-fill-buffers` command line option to
 force all newly allocated `Buffer` and `SlowBuffer` instances created using
-either `new Buffer(size)` and `new SlowBuffer(size)` to be *automatically
+either `new Buffer(size)`, `Buffer.allocUnsafe(size)`,
+`Buffer.allocUnsafeSlow(size)` or `new SlowBuffer(size)` to be *automatically
 zero-filled* upon creation. Use of this flag *changes the default behavior* of
 these methods and *can have a significant impact* on performance. Use of the
 `--zero-fill-buffers` option is recommended only when absolutely necessary to
@@ -449,6 +452,52 @@
 difference is subtle but can be important when an application requires the
 additional performance that `Buffer.allocUnsafe(size)` provides.
 
+### Class Method: Buffer.allocUnsafeSlow(size)
+
+* `size` {Number}
+
+Allocates a new *non-zero-filled* and non-pooled `Buffer` of `size` bytes.  The
+`size` must be less than or equal to the value of
+`require('buffer').kMaxLength` (on 64-bit architectures, `kMaxLength` is
+`(2^31)-1`). Otherwise, a [`RangeError`][] is thrown. If a `size` less than 0
+is specified, a zero-length `Buffer` will be created.
+
+The underlying memory for `Buffer` instances created in this way is *not
+initialized*. The contents of the newly created `Buffer` are unknown and
+*may contain sensitive data*. Use [`buf.fill(0)`][] to initialize such
+`Buffer` instances to zeroes.
+
+When using `Buffer.allocUnsafe()` to allocate new `Buffer` instances,
+allocations under 4KB are, by default, sliced from a single pre-allocated
+`Buffer`. This allows applications to avoid the garbage collection overhead of
+creating many individually allocated Buffers. This approach improves both
+performance and memory usage by eliminating the need to track and cleanup as
+many `Persistent` objects.
+
+However, in the case where a developer may need to retain a small chunk of
+memory from a pool for an indeterminate amount of time, it may be appropriate
+to create an un-pooled Buffer instance using `Buffer.allocUnsafeSlow()` then
+copy out the relevant bits.
+
+```js
+// need to keep around a few small chunks of memory
+const store = [];
+
+socket.on('readable', () => {
+  const data = socket.read();
+  // allocate for retained data
+  const sb = Buffer.allocUnsafeSlow(10);
+  // copy the data into the new allocation
+  data.copy(sb, 0, 0, 10);
+  store.push(sb);
+});
+```
+
+Use of `Buffer.allocUnsafeSlow()` should be used only as a last resort *after*
+a developer has observed undue memory retention in their applications.
+
+A `TypeError` will be thrown if `size` is not a number.
+
 ### Class Method: Buffer.byteLength(string[, encoding])
 
 * `string` {String | Buffer | TypedArray | DataView | ArrayBuffer}
@@ -1787,7 +1836,8 @@
 [buffer_from_buffer]: #buffer_class_method_buffer_from_buffer
 [buffer_from_arraybuf]: #buffer_class_method_buffer_from_arraybuffer_byteoffset_length
 [buffer_from_string]: #buffer_class_method_buffer_from_str_encoding
-[buffer_allocunsafe]: #buffer_class_method_buffer_allocraw_size
+[buffer_allocunsafe]: #buffer_class_method_buffer_allocunsafe_size
+[buffer_allocunsafeslow]: #buffer_class_method_buffer_allocunsafeslow_size
 [buffer_alloc]: #buffer_class_method_buffer_alloc_size_fill_encoding
 [`TypedArray.from()`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from
 [`DataView`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView
diff -r -u --color up/node/lib/buffer.js nw/node/lib/buffer.js
--- up/node/lib/buffer.js	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/lib/buffer.js	2023-02-21 04:37:43.868361128 +0000
@@ -152,6 +152,20 @@
   return allocate(size);
 };
 
+/**
+ * Equivalent to SlowBuffer(num), by default creates a non-zero-filled
+ * Buffer instance that is not allocated off the pre-initialized pool.
+ * If `--zero-fill-buffers` is set, will zero-fill the buffer.
+ **/
+Buffer.allocUnsafeSlow = function(size) {
+  if (typeof size !== 'number')
+    throw new TypeError('"size" argument must be a number');
+  return createBuffer(size, true);
+};
+
+// If --zero-fill-buffers command line argument is set, a zero-filled
+// buffer is returned.
+
 function SlowBuffer(length) {
   if (+length != length)
     length = 0;
@@ -163,8 +177,8 @@
 
 
 function allocate(size) {
-  if (size === 0) {
-    return createBuffer(size);
+  if (size <= 0) {
+    return createBuffer(0);
   }
   if (size < (Buffer.poolSize >>> 1)) {
     if (size > (poolSize - poolOffset))
Only in nw/node/lib: dummystream.js
diff -r -u --color up/node/lib/internal/bootstrap_node.js nw/node/lib/internal/bootstrap_node.js
--- up/node/lib/internal/bootstrap_node.js	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/lib/internal/bootstrap_node.js	2023-02-21 04:37:43.868361128 +0000
@@ -31,7 +31,10 @@
     setupGlobalVariables();
     if (!process._noBrowserGlobals) {
       setupGlobalTimeouts();
+      if (process.__nwjs) {
+      }else{
       setupGlobalConsole();
+      }
     }
 
     const _process = NativeModule.require('internal/process');
@@ -52,6 +55,20 @@
 
     process.argv[0] = process.execPath;
 
+    if (process.__nwjs) {
+      var Module = NativeModule.require('module');
+      var module = new Module('.', null);
+      global.process.mainModule = module;
+      module._compile('global.module = module;\n' +
+                      'global.require = global.__nw_require = require;\n', 'nw-emulate-node');
+      if (process.argv[1]) {
+        var path = NativeModule.require('path');
+        process.argv[1] = path.resolve(process.argv[1]);
+        preloadModules();
+        Module.runMain();
+      }
+      return;
+    }
     // There are various modes that Node can run in. The most common two
     // are running from a script and running the REPL - but there are a few
     // others like the debugger or running --eval arguments. Here we decide
@@ -239,15 +256,6 @@
       // If someone handled it, then great.  otherwise, die in C++ land
       // since that means that we'll exit the process, emit the 'exit' event
       if (!caught) {
-        try {
-          if (!process._exiting) {
-            process._exiting = true;
-            process.emit('exit', 1);
-          }
-        } catch (er) {
-          // nothing to be done about it at this point.
-        }
-
       // if we handled an error, then make sure any ticks get processed
       } else {
         NativeModule.require('timers').setImmediate(process._tickCallback);
diff -r -u --color up/node/lib/internal/process/stdio.js nw/node/lib/internal/process/stdio.js
--- up/node/lib/internal/process/stdio.js	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/lib/internal/process/stdio.js	2023-02-21 04:37:43.868361128 +0000
@@ -7,7 +7,10 @@
 
   process.__defineGetter__('stdout', function() {
     if (stdout) return stdout;
-    stdout = createWritableStdioStream(1);
+    if (process.platform === 'win32')
+      stdout = createWritableDummyStream(1);
+    else
+      stdout = createWritableStdioStream(1);
     stdout.destroy = stdout.destroySoon = function(er) {
       er = er || new Error('process.stdout cannot be closed.');
       stdout.emit('error', er);
@@ -22,7 +25,10 @@
 
   process.__defineGetter__('stderr', function() {
     if (stderr) return stderr;
-    stderr = createWritableStdioStream(2);
+    if (process.platform === 'win32')
+      stderr = createWritableDummyStream(2);
+    else
+      stderr = createWritableStdioStream(2);
     stderr.destroy = stderr.destroySoon = function(er) {
       er = er || new Error('process.stderr cannot be closed.');
       stderr.emit('error', er);
@@ -117,6 +123,18 @@
   };
 }
 
+function createWritableDummyStream(fd) {
+  var DummyStream = require('dummystream');
+  var stream = new DummyStream();
+  stream.fd = fd;
+
+  stream._isStdio = true;
+  stream.isTTY = false;
+
+  return stream;
+
+}
+
 function createWritableStdioStream(fd) {
   var stream;
   var tty_wrap = process.binding('tty_wrap');
diff -r -u --color up/node/lib/module.js nw/node/lib/module.js
--- up/node/lib/module.js	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/lib/module.js	2023-02-21 04:37:43.868361128 +0000
@@ -15,6 +15,19 @@
 const isIndexRe = /^index\.\w+?$/;
 const shebangRe = /^\#\!.*/;
 
+function extensionUrl(str) {
+  if (typeof str !== 'string') {
+    throw new Error('Expected a string');
+  }
+
+  var pathName = path.resolve(str).replace(/\\/g, '/');
+
+  var relative = path.relative(global.__dirname, pathName);
+
+  var ret = encodeURI('chrome-extension://' + global.__nwjs_ext_id + '/' + relative);
+  return ret;
+};
+
 // If obj.hasOwnProperty has been overridden, then calling
 // obj.hasOwnProperty(prop) will break.
 // See: https://github.com/joyent/node/issues/1707
@@ -85,6 +98,12 @@
   }
 
   var jsonPath = path.resolve(requestPath, 'package.json');
+  if (global.__nwjs_cv) {
+    var url = extensionUrl(jsonPath);
+    var request = new global.XMLHttpRequest();
+    request.open('GET', url, false);
+    request.send(null);
+  }
   var json = internalModuleReadFile(path._makeLong(jsonPath));
 
   if (json === undefined) {
@@ -304,6 +323,11 @@
   if (isMain) {
     process.mainModule = module;
     module.id = '.';
+    if (process.__nwjs) {
+      // require() in DOM needs this module as parent
+      module._compile('global.module = module;\n' +
+                      'global.require = require;\n', 'nw-emulate-node');
+    }
   }
 
   Module._cache[filename] = module;
@@ -418,6 +442,12 @@
 
 // Native extension for .js
 Module._extensions['.js'] = function(module, filename) {
+  if (global.__nwjs_cv) {
+    var url = extensionUrl(filename);
+    var request = new global.XMLHttpRequest();
+    request.open('GET', url, false);
+    request.send(null);
+  }
   var content = fs.readFileSync(filename, 'utf8');
   module._compile(internalModule.stripBOM(content), filename);
 };
@@ -425,6 +455,12 @@
 
 // Native extension for .json
 Module._extensions['.json'] = function(module, filename) {
+  if (global.__nwjs_cv) {
+    var url = extensionUrl(filename);
+    var request = new global.XMLHttpRequest();
+    request.open('GET', url, false);
+    request.send(null);
+  }
   var content = fs.readFileSync(filename, 'utf8');
   try {
     module.exports = JSON.parse(internalModule.stripBOM(content));
@@ -437,6 +473,12 @@
 
 //Native extension for .node
 Module._extensions['.node'] = function(module, filename) {
+  if (global.__nwjs_cv) {
+    var url = extensionUrl(filename);
+    var request = new global.XMLHttpRequest();
+    request.open('GET', url, false);
+    request.send(null);
+  }
   return process.dlopen(module, path._makeLong(filename));
 };
 
diff -r -u --color up/node/node.gyp nw/node/node.gyp
--- up/node/node.gyp	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/node.gyp	2023-02-21 04:37:43.872361167 +0000
@@ -11,10 +11,18 @@
     'node_shared_libuv%': 'false',
     'node_use_openssl%': 'true',
     'node_shared_openssl%': 'false',
+    'openssl_fips%': '',
     'node_v8_options%': '',
     'node_enable_v8_vtunejit%': 'false',
-    'node_target_type%': 'executable',
     'node_core_target_name%': 'node',
+    'node_target_type%': 'shared_library',
+    'node_tag%': '',
+    'node_release_urlbase%': '',
+    'node_byteorder%': 'little',
+    'python%': 'python',
+    'icu_small%': 'false',
+    'v8_postmortem_support%' : 'false',
+    'V8_BASE%': '<(PRODUCT_DIR)/obj/v8/tools/gyp/libv8_base.a',
     'library_files': [
       'lib/internal/bootstrap_node.js',
       'lib/_debug_agent.js',
@@ -29,6 +37,7 @@
       'lib/dgram.js',
       'lib/dns.js',
       'lib/domain.js',
+      'lib/dummystream.js',
       'lib/events.js',
       'lib/freelist.js',
       'lib/fs.js',
@@ -99,26 +108,52 @@
     ],
   },
 
+  'includes': [
+    '../../build/util/version.gypi',
+  ],
+
   'targets': [
     {
       'target_name': '<(node_core_target_name)',
       'type': '<(node_target_type)',
-
       'dependencies': [
         'node_js2c#host',
         'deps/cares/cares.gyp:cares',
-        'deps/v8/tools/gyp/v8.gyp:v8',
-        'deps/v8/tools/gyp/v8.gyp:v8_libplatform'
+        #'../../v8/tools/gyp/v8.gyp:v8',
+        '../../v8/tools/gyp/v8.gyp:v8_libplatform',
+        '../../chrome/chrome.gyp:chrome_dll',
       ],
 
+      'msvs_disabled_warnings': [4146, 4267, 4003, 4065],
+
+      'xcode_settings': {
+        'WARNING_CFLAGS': [ '-Wno-error=deprecated-declarations' ],
+        'LD_RUNPATH_SEARCH_PATHS': [ '@loader_path/../../../../../../..', ],
+      },
+
       'include_dirs': [
         'src',
+        'deps/openssl/openssl/include',
+        #'../boringssl/src/include',
         'tools/msvs/genfiles',
         'deps/uv/src/ares',
         '<(SHARED_INTERMEDIATE_DIR)', # for node_natives.h
-        'deps/v8' # include/v8_platform.h
+        '../../v8', # include/v8_platform.h
+        '../../v8/include'
       ],
 
+      'direct_dependent_settings': {
+        'include_dirs': [
+          '../../v8/include',
+          'deps/uv/include',
+          'deps/cares/include',
+        ],
+        'defines': [
+          'BUILDING_NW_NODE=1',
+        ],
+
+      },
+
       'sources': [
         'src/debug-agent.cc',
         'src/async-wrap.cc',
@@ -194,8 +229,8 @@
         'src/util.cc',
         'src/string_search.cc',
         'deps/http_parser/http_parser.h',
-        'deps/v8/include/v8.h',
-        'deps/v8/include/v8-debug.h',
+        #'deps/v8/include/v8.h',
+        #'deps/v8/include/v8-debug.h',
         '<(SHARED_INTERMEDIATE_DIR)/node_natives.h',
         # javascript files to make for an even more pleasant IDE experience
         '<@(library_files)',
@@ -209,6 +244,9 @@
         'NODE_WANT_INTERNALS=1',
         # Warn when using deprecated V8 APIs.
         'V8_DEPRECATION_WARNINGS=1',
+        'BUILDING_NW_NODE=1',
+        'V8_SHARED',
+        'USING_V8_SHARED',
       ],
 
 
@@ -230,6 +268,17 @@
             'NODE_RELEASE_URLBASE="<(node_release_urlbase)"',
           ]
         }],
+        ['node_target_type=="shared_library"', {
+          'direct_dependent_settings': {
+            'defines': [
+              'USING_UV_SHARED=1',
+              'BUILDING_NODE_EXTENSION=1',
+            ],
+          },
+        }],
+        ['clang==1', {
+          'cflags': ['-Wno-error=missing-declarations', '-Wno-error=array-bounds'],
+        }],
         [ 'v8_enable_i18n_support==1', {
           'defines': [ 'NODE_HAVE_I18N_SUPPORT=1' ],
           'dependencies': [
@@ -267,9 +316,9 @@
             [ 'node_shared_openssl=="false"', {
               'dependencies': [
                 './deps/openssl/openssl.gyp:openssl',
-
+                #'../boringssl/boringssl.gyp:boringssl', 
                 # For tests
-                './deps/openssl/openssl.gyp:openssl-cli',
+                #'./deps/openssl/openssl.gyp:openssl-cli',
               ],
               # Do not let unused OpenSSL symbols to slip away
               'conditions': [
@@ -278,14 +327,14 @@
                 [ 'node_target_type!="static_library"', {
                   'xcode_settings': {
                     'OTHER_LDFLAGS': [
-                      '-Wl,-force_load,<(PRODUCT_DIR)/<(OPENSSL_PRODUCT)',
+                      #'-Wl,-force_load,<(PRODUCT_DIR)/<(OPENSSL_PRODUCT)',
                     ],
                   },
                   'conditions': [
                     ['OS in "linux freebsd"', {
                       'ldflags': [
-                        '-Wl,--whole-archive <(PRODUCT_DIR)/<(OPENSSL_PRODUCT)',
-                        '-Wl,--no-whole-archive',
+                        #'-Wl,--whole-archive <(PRODUCT_DIR)/<(OPENSSL_PRODUCT)',
+                        #'-Wl,--no-whole-archive',
                       ],
                     }],
                   ],
@@ -370,7 +419,7 @@
           'defines': [ 'NODE_NO_BROWSER_GLOBALS' ],
         } ],
         [ 'v8_postmortem_support=="true"', {
-          'dependencies': [ 'deps/v8/tools/gyp/v8.gyp:postmortem-metadata' ],
+          'dependencies': [ '../../v8/tools/gyp/v8.gyp:postmortem-metadata' ],
           'conditions': [
             # -force_load is not applicable for the static library
             [ 'node_target_type!="static_library"', {
@@ -383,7 +432,7 @@
           ],
         }],
         [ 'node_shared_zlib=="false"', {
-          'dependencies': [ 'deps/zlib/zlib.gyp:zlib' ],
+          'dependencies': [ '../zlib/zlib.gyp:zlib' ],
         }],
 
         [ 'node_shared_http_parser=="false"', {
@@ -396,7 +445,7 @@
 
         [ 'OS=="win"', {
           'sources': [
-            'src/res/node.rc',
+            #'src/res/node.rc',
           ],
           'defines!': [
             'NODE_PLATFORM="win"',
@@ -422,6 +471,18 @@
             # we need to use node's preferred "darwin" rather than gyp's preferred "mac"
             'NODE_PLATFORM="darwin"',
           ],
+          'postbuilds': [
+            {
+              'postbuild_name': 'Fix Framework Link',
+              'action': [
+                'install_name_tool',
+                '-change',
+                '@executable_path/../Versions/<(version_full)/<(mac_product_name) Framework.framework/<(mac_product_name) Framework',
+                '@executable_path/../../../<(mac_product_name) Framework.framework/<(mac_product_name) Framework',
+                '${BUILT_PRODUCTS_DIR}/${EXECUTABLE_PATH}'
+              ],
+            },
+          ],
         }],
         [ 'OS=="freebsd"', {
           'libraries': [
@@ -449,9 +510,9 @@
           ],
         }],
         [ 'OS=="freebsd" or OS=="linux"', {
-          'ldflags': [ '-Wl,-z,noexecstack',
-                       '-Wl,--whole-archive <(V8_BASE)',
-                       '-Wl,--no-whole-archive' ]
+          #'ldflags': [ '-Wl,-z,noexecstack',
+          #             '-Wl,--whole-archive <(V8_BASE)',
+          #             '-Wl,--no-whole-archive' ]
         }],
         [ 'OS=="sunos"', {
           'ldflags': [ '-Wl,-M,/usr/lib/ld/map.noexstk' ],
@@ -684,13 +745,13 @@
       'target_name': 'cctest',
       'type': 'executable',
       'dependencies': [
-        'deps/gtest/gtest.gyp:gtest',
-        'deps/v8/tools/gyp/v8.gyp:v8',
-        'deps/v8/tools/gyp/v8.gyp:v8_libplatform'
+        '../../testing/gtest.gyp:gtest',
+        '../../v8/tools/gyp/v8.gyp:v8',
+        '../../v8/tools/gyp/v8.gyp:v8_libplatform'
       ],
       'include_dirs': [
         'src',
-        'deps/v8/include'
+        '../../v8/include'
       ],
       'defines': [
         # gtest's ASSERT macros conflict with our own.
diff -r -u --color up/node/src/env.cc nw/node/src/env.cc
--- up/node/src/env.cc	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/src/env.cc	2023-02-21 04:37:43.872361167 +0000
@@ -64,4 +64,27 @@
   fflush(stderr);
 }
 
+
+bool Environment::KickNextTick(Environment::AsyncCallbackScope* scope) {
+  TickInfo* info = tick_info();
+
+  if (scope->in_makecallback()) {
+    return true;
+  }
+
+  if (info->length() == 0) {
+    isolate()->RunMicrotasks();
+  }
+
+  if (info->length() == 0) {
+    info->set_index(0);
+    return true;
+  }
+
+  Local<Value> ret =
+    tick_callback_function()->Call(process_object(), 0, nullptr);
+
+  return !ret.IsEmpty();
+}
+
 }  // namespace node
diff -r -u --color up/node/src/env.h nw/node/src/env.h
--- up/node/src/env.h	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/src/env.h	2023-02-21 04:37:43.872361167 +0000
@@ -468,6 +468,8 @@
 
   inline int64_t get_async_wrap_uid();
 
+  bool KickNextTick(AsyncCallbackScope* scope);
+
   inline uint32_t* heap_statistics_buffer() const;
   inline void set_heap_statistics_buffer(uint32_t* pointer);
 
diff -r -u --color up/node/src/node.cc nw/node/src/node.cc
--- up/node/src/node.cc	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/src/node.cc	2023-02-21 04:37:43.872361167 +0000
@@ -8,6 +8,9 @@
 #include "node_internals.h"
 #include "node_revert.h"
 
+#include <vector>
+#include "node_webkit.h"
+
 #if defined HAVE_PERFCTR
 #include "node_counters.h"
 #endif
@@ -98,6 +101,27 @@
 namespace node { template <typename T> using atomic = std::atomic<T>; }
 #endif
 
+NODE_MODULE_REF(cares_wrap)
+NODE_MODULE_REF(fs_event_wrap)
+NODE_MODULE_REF(buffer)
+NODE_MODULE_REF(contextify)
+NODE_MODULE_REF(crypto)
+NODE_MODULE_REF(fs)
+NODE_MODULE_REF(http_parser)
+NODE_MODULE_REF(os)
+NODE_MODULE_REF(v8)
+NODE_MODULE_REF(zlib)
+NODE_MODULE_REF(pipe_wrap)
+NODE_MODULE_REF(process_wrap)
+NODE_MODULE_REF(signal_wrap)
+NODE_MODULE_REF(spawn_sync)
+NODE_MODULE_REF(tcp_wrap)
+NODE_MODULE_REF(timer_wrap)
+NODE_MODULE_REF(tls_wrap)
+NODE_MODULE_REF(tty_wrap)
+NODE_MODULE_REF(udp_wrap)
+NODE_MODULE_REF(uv)
+
 namespace node {
 
 using v8::Array;
@@ -152,11 +176,20 @@
 static bool prof_process = false;
 static bool v8_is_profiling = false;
 static bool node_is_initialized = false;
+static bool node_is_nwjs = false;
 static node_module* modpending;
 static node_module* modlist_builtin;
 static node_module* modlist_linked;
 static node_module* modlist_addon;
 
+
+NODE_EXTERN Environment* g_env = nullptr;
+NODE_EXTERN v8::Persistent<Context> g_context;
+NODE_EXTERN v8::Persistent<Context> g_dom_context;
+static UVRunFn g_nw_uv_run = nullptr;
+static NWTickCallback g_nw_tick_callback = nullptr;
+static const char* g_native_blob_path = nullptr;
+
 #if defined(NODE_HAVE_I18N_SUPPORT)
 // Path to ICU data (for i18n / Intl)
 static const char* icu_data_dir = nullptr;
@@ -963,6 +996,7 @@
   return malloc(size);
 }
 
+#if 0
 static bool DomainHasErrorHandler(const Environment* env,
                                   const Local<Object>& domain) {
   HandleScope scope(env->isolate());
@@ -1008,8 +1042,10 @@
 
   return false;
 }
+#endif
 
 
+#if 0
 static bool ShouldAbortOnUncaughtException(Isolate* isolate) {
   HandleScope scope(isolate);
 
@@ -1022,7 +1058,7 @@
 
   return isEmittingTopLevelDomainError || !DomainsStackHasErrorHandler(env);
 }
-
+#endif
 
 void SetupDomainUse(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
@@ -1129,7 +1165,7 @@
 
   CHECK(args[0]->IsFunction());
 
-  isolate->SetPromiseRejectCallback(PromiseRejectCallback);
+  //isolate->SetPromiseRejectCallback(PromiseRejectCallback);
   env->set_promise_reject_function(args[0].As<Function>());
 
   env->process_object()->Delete(
@@ -1228,23 +1264,7 @@
     }
   }
 
-  if (callback_scope.in_makecallback()) {
-    return ret;
-  }
-
-  Environment::TickInfo* tick_info = env->tick_info();
-
-  if (tick_info->length() == 0) {
-    env->isolate()->RunMicrotasks();
-  }
-
-  Local<Object> process = env->process_object();
-
-  if (tick_info->length() == 0) {
-    tick_info->set_index(0);
-  }
-
-  if (env->tick_callback_function()->Call(process, 0, nullptr).IsEmpty()) {
+  if (!env->KickNextTick(&callback_scope)) {
     return Undefined(env->isolate());
   }
 
@@ -2334,6 +2354,8 @@
   HandleScope scope(isolate);
 
   Environment* env = Environment::GetCurrent(isolate);
+  if (!env)
+    return;
   Local<Object> process_object = env->process_object();
   Local<String> fatal_exception_string = env->fatal_exception_string();
   Local<Function> fatal_exception_function =
@@ -2343,6 +2365,7 @@
     // failed before the process._fatalException function was added!
     // this is probably pretty bad.  Nothing to do but report and exit.
     ReportException(env, error, message);
+    if (!node_is_nwjs)
     exit(6);
   }
 
@@ -2358,11 +2381,13 @@
   if (fatal_try_catch.HasCaught()) {
     // the fatal exception function threw, so we must exit
     ReportException(env, fatal_try_catch);
+    if (!node_is_nwjs)
     exit(7);
   }
 
   if (false == caught->BooleanValue()) {
     ReportException(env, error, message);
+    if (!node_is_nwjs)
     exit(1);
   }
 }
@@ -2376,7 +2401,7 @@
 }
 
 
-void OnMessage(Local<Message> message, Local<Value> error) {
+NODE_EXTERN void OnMessage(Local<Message> message, Local<Value> error) {
   // The current version of V8 sends messages for errors only
   // (thus `error` is always set).
   FatalException(Isolate::GetCurrent(), error, message);
@@ -2851,6 +2876,9 @@
                        ProcessTitleSetter,
                        env->as_external());
 
+  if (node_is_nwjs)
+    READONLY_PROPERTY(process, "__nwjs", Integer::New(env->isolate(), 1));
+
   // process.version
   READONLY_PROPERTY(process,
                     "version",
@@ -3206,7 +3234,8 @@
   HandleScope handle_scope(env->isolate());
 
   env->isolate()->SetFatalErrorHandler(node::OnFatalError);
-  env->isolate()->AddMessageListener(OnMessage);
+  //if (!node_is_nwjs)
+    env->isolate()->AddMessageListener(OnMessage);
 
   // Compile, execute the src/node.js file. (Which was included as static C
   // string in node_natives.h. 'native_node' is the string containing that
@@ -3895,6 +3924,7 @@
   // Initialize prog_start_time to get relative uptime.
   prog_start_time = static_cast<double>(uv_now(uv_default_loop()));
 
+  if (!node_is_nwjs) {
   // Make inherited handles noninheritable.
   uv_disable_stdio_inheritance();
 
@@ -3905,6 +3935,8 @@
                 DispatchDebugMessagesAsyncCallback);
   uv_unref(reinterpret_cast<uv_handle_t*>(&dispatch_debug_messages_async));
 
+  } //node_is_nwjs
+
 #if defined(NODE_V8_OPTIONS)
   // Should come before the call to V8::SetFlagsFromCommandLine()
   // so the user can disable a flag --foo at run-time by passing
@@ -3976,9 +4008,11 @@
   const char no_typed_array_heap[] = "--typed_array_max_size_in_heap=0";
   V8::SetFlagsFromString(no_typed_array_heap, sizeof(no_typed_array_heap) - 1);
 
+  if (!node_is_nwjs) {
   if (!use_debug_agent) {
     RegisterDebugSignalHandler();
   }
+  } //node_is_nwjs
 
   // We should set node_is_initialized here instead of in node::Start,
   // otherwise embedders using node::Init to initialize everything will not be
@@ -4178,8 +4212,10 @@
 static void StartNodeInstance(void* arg) {
   NodeInstanceData* instance_data = static_cast<NodeInstanceData*>(arg);
   Isolate::CreateParams params;
-  ArrayBufferAllocator* array_buffer_allocator = new ArrayBufferAllocator();
-  params.array_buffer_allocator = array_buffer_allocator;
+  if (!node_is_nwjs) {
+    ArrayBufferAllocator* array_buffer_allocator = new ArrayBufferAllocator();
+    params.array_buffer_allocator = array_buffer_allocator;
+  }
 #ifdef NODE_ENABLE_VTUNE_PROFILING
   params.code_event_handler = vTune::GetVtuneCodeEventHandler();
 #endif
@@ -4199,12 +4235,12 @@
     HandleScope handle_scope(isolate);
     Local<Context> context = Context::New(isolate);
     Environment* env = CreateEnvironment(isolate, context, instance_data);
-    array_buffer_allocator->set_env(env);
+    //array_buffer_allocator->set_env(env);
     Context::Scope context_scope(context);
-
+#if 0
     isolate->SetAbortOnUncaughtExceptionCallback(
         ShouldAbortOnUncaughtException);
-
+#endif
     // Start debug agent when argv has --debug
     if (instance_data->use_debug_agent())
       StartDebug(env, debug_wait_connect);
@@ -4251,7 +4287,7 @@
     __lsan_do_leak_check();
 #endif
 
-    array_buffer_allocator->set_env(nullptr);
+    //array_buffer_allocator->set_env(nullptr);
     env->Dispose();
     env = nullptr;
   }
@@ -4264,9 +4300,118 @@
   CHECK_NE(isolate, nullptr);
   isolate->Dispose();
   isolate = nullptr;
-  delete array_buffer_allocator;
+  //delete array_buffer_allocator;
+}
+
+#ifdef V8_USE_EXTERNAL_STARTUP_DATA
+// Helper class to load the startup data files from disk.
+//
+// This is meant as a convenience for stand-alone binaries like d8, cctest,
+// unittest. A V8 embedder would likely either handle startup data on their
+// own or just disable the feature if they don't want to handle it at all,
+// while tools like cctest need to work in either configuration. Hence this is
+// not meant for inclusion in the general v8 library.
+class StartupDataHandler {
+ public:
+  // Load startup data, and call the v8::V8::Set*DataBlob API functions.
+  //
+  // natives_blob and snapshot_blob will be loaded realitive to exec_path,
+  // which would usually be the equivalent of argv[0].
+  StartupDataHandler(const char* exec_path, const char* natives_blob,
+                     const char* snapshot_blob);
+  ~StartupDataHandler();
+
+ private:
+  static char* RelativePath(char** buffer, const char* exec_path,
+                            const char* name);
+
+  void LoadFromFiles(const char* natives_blob, const char* snapshot_blob);
+
+  void Load(const char* blob_file, v8::StartupData* startup_data,
+            void (*setter_fn)(v8::StartupData*));
+
+  v8::StartupData natives_;
+  v8::StartupData snapshot_;
+
+  // Disallow copy & assign.
+  StartupDataHandler(const StartupDataHandler& other);
+  void operator=(const StartupDataHandler& other);
+};
+
+StartupDataHandler::StartupDataHandler(const char* exec_path,
+                                       const char* natives_blob,
+                                       const char* snapshot_blob) {
+  // If we have (at least one) explicitly given blob, use those.
+  // If not, use the default blob locations next to the d8 binary.
+  if (natives_blob || snapshot_blob) {
+    LoadFromFiles(natives_blob, snapshot_blob);
+  } else {
+    char* natives;
+    char* snapshot;
+    LoadFromFiles(RelativePath(&natives, exec_path, "natives_blob.bin"),
+                  RelativePath(&snapshot, exec_path, "snapshot_blob.bin"));
+
+    free(natives);
+    free(snapshot);
+  }
 }
 
+
+StartupDataHandler::~StartupDataHandler() {
+  delete[] natives_.data;
+  delete[] snapshot_.data;
+}
+
+
+char* StartupDataHandler::RelativePath(char** buffer, const char* exec_path,
+                                       const char* name) {
+  const char* last_slash = strrchr(exec_path, '/');
+  if (last_slash) {
+    int after_slash = last_slash - exec_path + 1;
+    int name_length = static_cast<int>(strlen(name));
+    *buffer = reinterpret_cast<char*>(calloc(after_slash + name_length + 1, 1));
+    strncpy(*buffer, exec_path, after_slash);
+    strncat(*buffer, name, name_length);
+  } else {
+    *buffer = strdup(name);
+  }
+  return *buffer;
+}
+
+
+void StartupDataHandler::LoadFromFiles(const char* natives_blob,
+                                       const char* snapshot_blob) {
+  Load(natives_blob, &natives_, v8::V8::SetNativesDataBlob);
+  Load(snapshot_blob, &snapshot_, v8::V8::SetSnapshotDataBlob);
+}
+
+
+void StartupDataHandler::Load(const char* blob_file,
+                              v8::StartupData* startup_data,
+                              void (*setter_fn)(v8::StartupData*)) {
+  startup_data->data = NULL;
+  startup_data->raw_size = 0;
+
+  if (!blob_file) return;
+
+  FILE* file = fopen(blob_file, "rb");
+  if (!file) return;
+
+  fseek(file, 0, SEEK_END);
+  startup_data->raw_size = ftell(file);
+  rewind(file);
+
+  startup_data->data = new char[startup_data->raw_size];
+  int read_size = static_cast<int>(fread(const_cast<char*>(startup_data->data),
+                                         1, startup_data->raw_size, file));
+  fclose(file);
+
+  if (startup_data->raw_size == read_size) (*setter_fn)(startup_data);
+}
+
+#endif  // V8_USE_EXTERNAL_STARTUP_DATA
+
+
 int Start(int argc, char** argv) {
   PlatformInit();
 
@@ -4287,7 +4432,17 @@
   V8::SetEntropySource(crypto::EntropySource);
 #endif
 
+#ifdef V8_USE_EXTERNAL_STARTUP_DATA
+  //StartupDataHandler startup_data(argv[0], nullptr, nullptr);
+#if defined(__APPLE__)
+  V8::InitializeExternalStartupData(g_native_blob_path);
+#else
+  V8::InitializeExternalStartupData(argv[0]);
+#endif
+#endif
+
   default_platform = v8::platform::CreateDefaultPlatform(v8_thread_pool_size);
+
   V8::InitializePlatform(default_platform);
   V8::Initialize();
 
@@ -4314,5 +4469,294 @@
   return exit_code;
 }
 
+void ref_node_modules() {
+NODE_MODULE_REF2(cares_wrap)
+NODE_MODULE_REF2(fs_event_wrap)
+NODE_MODULE_REF2(buffer)
+NODE_MODULE_REF2(contextify)
+NODE_MODULE_REF2(crypto)
+NODE_MODULE_REF2(fs)
+NODE_MODULE_REF2(http_parser)
+NODE_MODULE_REF2(os)
+NODE_MODULE_REF2(v8)
+NODE_MODULE_REF2(zlib)
+NODE_MODULE_REF2(pipe_wrap)
+NODE_MODULE_REF2(process_wrap)
+NODE_MODULE_REF2(signal_wrap)
+NODE_MODULE_REF2(spawn_sync)
+NODE_MODULE_REF2(tcp_wrap)
+NODE_MODULE_REF2(timer_wrap)
+NODE_MODULE_REF2(tls_wrap)
+NODE_MODULE_REF2(tty_wrap)
+NODE_MODULE_REF2(udp_wrap)
+NODE_MODULE_REF2(uv)
+}
+
+NODE_EXTERN v8::Handle<v8::Value> CallNWTickCallback(Environment* env, const v8::Handle<v8::Value> ret) {
+  return (*g_nw_tick_callback)(env, ret);
+}
+
 
 }  // namespace node
+
+extern "C" {
+void wakeup_callback(uv_async_t* handle) {
+  // do nothing, just make libuv exit loop.
+}
+
+void idle_callback(uv_idle_t* handle) {
+  // do nothing, just make libuv exit loop.
+}
+
+void timer_callback(uv_timer_t* timer) {
+  // libuv would block unexpectedly with zero-timeout timer
+  // this is a workaround of libuv bug #574:
+  // https://github.com/joyent/libuv/issues/574
+  uv_idle_start(static_cast<uv_idle_t*>(timer->data), idle_callback);
+}
+
+
+NODE_EXTERN int g_uv_run(void* loop, int mode) {
+  return uv_run((uv_loop_t*)loop, (uv_run_mode)mode);
+}
+
+NODE_EXTERN void g_set_uv_run(UVRunFn uv_run_fn) {
+  node::g_nw_uv_run = uv_run_fn;
+}
+
+NODE_EXTERN int g_node_start(int argc, char** argv) {
+  return node::Start(argc, argv);
+}
+
+NODE_EXTERN void g_set_blob_path(const char* path) {
+  node::g_native_blob_path = path;
+}
+
+NODE_EXTERN void g_msg_pump_nest_enter(msg_pump_context_t* ctx) {
+  ctx->loop = uv_loop_new();
+
+  ctx->wakeup_events->push_back((uv_async_t*)ctx->wakeup_event);
+  ctx->wakeup_event = new uv_async_t;
+  uv_async_init((uv_loop_t*)ctx->loop, (uv_async_t*)ctx->wakeup_event, wakeup_callback);
+}
+
+NODE_EXTERN void g_msg_pump_pre_loop(msg_pump_context_t* ctx) {
+  ctx->idle_handle = new uv_idle_t;
+  uv_idle_init((uv_loop_t*)ctx->loop, (uv_idle_t*)ctx->idle_handle);
+
+  ctx->delay_timer = new uv_timer_t;
+  ((uv_timer_t*)ctx->delay_timer)->data = ctx->idle_handle;
+  uv_timer_init((uv_loop_t*)ctx->loop, (uv_timer_t*)ctx->delay_timer);
+}
+
+NODE_EXTERN void g_msg_pump_did_work(msg_pump_context_t* ctx) {
+  if (node::g_env) {
+    v8::Isolate* isolate = node::g_env->isolate();
+    v8::HandleScope handleScope(isolate);
+    v8::Context::Scope cscope(node::g_env->context());
+    (*node::g_nw_uv_run)((uv_loop_t*)ctx->loop, UV_RUN_NOWAIT);
+    node::CallNWTickCallback(node::g_env, v8::Undefined(isolate));
+  }
+}
+
+NODE_EXTERN void g_msg_pump_need_work(msg_pump_context_t* ctx) {
+  if (node::g_env) {
+    node::g_env->context()->Enter();
+  }
+  (*node::g_nw_uv_run)((uv_loop_t*)ctx->loop, UV_RUN_ONCE);
+  if (node::g_env) {
+    node::g_env->context()->Exit();
+  }
+}
+
+NODE_EXTERN void g_msg_pump_delay_work(msg_pump_context_t* ctx, int sec) {
+  if (node::g_env) {
+    node::g_env->context()->Enter();
+  }
+  uv_timer_start((uv_timer_t*)ctx->delay_timer, timer_callback, sec, 0);
+  (*node::g_nw_uv_run)((uv_loop_t*)ctx->loop, UV_RUN_ONCE);
+  uv_idle_stop((uv_idle_t*)ctx->idle_handle);
+  uv_timer_stop((uv_timer_t*)ctx->delay_timer);
+  if (node::g_env) {
+    node::g_env->context()->Exit();
+  }
+}
+
+NODE_EXTERN void g_msg_pump_nest_leave(msg_pump_context_t* ctx) {
+  uv_close((uv_handle_t*)(ctx->wakeup_event), NULL);
+  // Delete external loop.
+  uv_loop_close((uv_loop_t*)ctx->loop);
+  free((uv_loop_t*)ctx->loop);
+  ctx->loop = nullptr;
+    // // Restore previous async handle.
+  delete (uv_async_t*)ctx->wakeup_event;
+  ctx->wakeup_event = ctx->wakeup_events->back();
+  ctx->wakeup_events->pop_back();
+}
+
+NODE_EXTERN uv_loop_t* g_uv_default_loop() {
+  return uv_default_loop();
+}
+
+NODE_EXTERN void g_msg_pump_clean_ctx(msg_pump_context_t* ctx) {
+  delete (uv_idle_t*)ctx->idle_handle;
+  ctx->idle_handle = nullptr;
+
+  delete (uv_timer_t*)ctx->delay_timer;
+  ctx->delay_timer = nullptr;
+}
+
+NODE_EXTERN void g_msg_pump_sched_work(uv_async_t* wakeup_event) {
+#ifdef _WIN32
+  uv_async_send_nw(wakeup_event);
+#else
+  uv_async_send(wakeup_event);
+#endif
+}
+
+NODE_EXTERN void g_msg_pump_ctor(uv_async_t** wakeup_event) {
+  *wakeup_event = new uv_async_t;
+  uv_async_init(uv_default_loop(), *wakeup_event, wakeup_callback);
+  node::g_nw_uv_run = (UVRunFn)uv_run;
+}
+
+NODE_EXTERN void g_msg_pump_dtor(uv_async_t** wakeup_event) {
+  delete *wakeup_event;
+  *wakeup_event = nullptr;
+}
+
+NODE_EXTERN bool g_is_node_initialized() {
+  return node::node_is_initialized;
+}
+
+NODE_EXTERN void g_call_tick_callback(node::Environment* env) {
+  v8::HandleScope scope(env->isolate());
+  v8::Context::Scope context_scope(env->context());
+  node::Environment::AsyncCallbackScope callback_scope(env);
+
+  env->KickNextTick(&callback_scope);
+}
+
+// copied beginning of Start() until v8::Initialize()
+NODE_EXTERN void g_setup_nwnode(int argc, char** argv) {
+  node::node_is_initialized = true;
+  node::node_is_nwjs = true;
+  node::ref_node_modules();
+  node::node_isolate.exchange(v8::Isolate::GetCurrent());
+}
+
+NODE_EXTERN void g_start_nw_instance(int argc, char *argv[], v8::Handle<v8::Context> context) {
+  v8::Isolate* isolate = v8::Isolate::GetCurrent();
+  v8::HandleScope handle_scope(isolate);
+  v8::Context::Scope context_scope(context);
+
+  argv = uv_setup_args(argc, argv);
+
+  node::g_env = node::CreateEnvironment(isolate, uv_default_loop(),
+                            context, argc, argv, 0, NULL);
+  node::LoadEnvironment(node::g_env);
+}
+
+NODE_EXTERN void g_set_nw_tick_callback(NWTickCallback tick_callback) {
+  node::g_nw_tick_callback = tick_callback;
+}
+
+NODE_EXTERN void* g_get_node_env() {
+  return node::g_env;
+}
+
+NODE_EXTERN void g_get_node_context(v8::Local<v8::Context>* ret) {
+  *ret = v8::Local<v8::Context>::New(v8::Isolate::GetCurrent(), node::g_context);
+}
+
+NODE_EXTERN void g_set_node_context(v8::Isolate* isolate, v8::Local<v8::Context>* context) {
+  node::g_context.Reset(isolate, *context);
+}
+
+NODE_EXTERN void* g_get_current_env(v8::Handle<v8::Context> context) {
+  return node::Environment::GetCurrent(context);
+}
+
+NODE_EXTERN void g_emit_exit(node::Environment* env) {
+  node::EmitExit(env);
+}
+
+NODE_EXTERN void g_run_at_exit(node::Environment* env) {
+  node::RunAtExit(env);
+}
+
+NODE_EXTERN void g_promise_reject_callback(v8::PromiseRejectMessage* data) {
+  node::PromiseRejectCallback(*data);
+}
+
+#ifdef __APPLE__
+
+void UvNoOp(uv_async_t* handle) {
+}
+
+NODE_EXTERN void g_msg_pump_ctor_osx(msg_pump_context_t* ctx, void* EmbedThreadRunner, void* kevent_hook, void* data) {
+  // Add dummy handle for libuv, otherwise libuv would quit when there is
+  // nothing to do.
+  ctx->dummy_uv_handle = new uv_async_t;
+  uv_async_init(uv_default_loop(), (uv_async_t*)ctx->dummy_uv_handle, UvNoOp);
+
+  // Start worker that will interrupt main loop when having uv events.
+  ctx->embed_sem = new uv_sem_t;
+  uv_sem_init((uv_sem_t*)ctx->embed_sem, 0);
+  ctx->embed_thread = new uv_thread_t;
+  uv_thread_create((uv_thread_t*)ctx->embed_thread, (uv_thread_cb)EmbedThreadRunner, data);
+
+  uv_loop_t* uvloop = uv_default_loop();
+  uvloop->keventfunc = kevent_hook;
+
+  ctx->loop = uvloop;
+
+  // Execute loop for once.
+  uv_run(uv_default_loop(), UV_RUN_NOWAIT);
+  node::g_nw_uv_run = (UVRunFn)uv_run;
+}
+
+NODE_EXTERN void g_msg_pump_dtor_osx(msg_pump_context_t* ctx) {
+  uv_thread_join((uv_thread_t*)ctx->embed_thread);
+
+  delete (uv_async_t*)ctx->dummy_uv_handle;
+  ctx->dummy_uv_handle = nullptr;
+
+  delete (uv_sem_t*)ctx->embed_sem;
+  ctx->embed_sem = nullptr;
+
+  delete (uv_thread_t*)ctx->embed_thread;
+  ctx->embed_thread = nullptr;
+}
+
+NODE_EXTERN int g_nw_uvrun_nowait() {
+  return (*node::g_nw_uv_run)(uv_default_loop(), UV_RUN_NOWAIT);
+}
+
+NODE_EXTERN int g_uv_runloop_once() {
+  if (node::g_env) {
+    v8::Isolate* isolate = node::g_env->isolate();
+    v8::HandleScope handleScope(isolate);
+    v8::Context::Scope cscope(node::g_env->context());
+    return (*node::g_nw_uv_run)(uv_default_loop(), UV_RUN_ONCE);
+  }
+  return (*node::g_nw_uv_run)(uv_default_loop(), UV_RUN_ONCE);
+}
+
+NODE_EXTERN int g_uv_backend_timeout() {
+  return  uv_backend_timeout(uv_default_loop());
+}
+
+NODE_EXTERN void g_uv_sem_post(msg_pump_context_t* ctx) {
+  uv_sem_post((uv_sem_t*)ctx->embed_sem);
+}
+
+NODE_EXTERN int g_uv_backend_fd() {
+  return uv_backend_fd(uv_default_loop());
+}
+
+NODE_EXTERN void g_uv_sem_wait(msg_pump_context_t* ctx) {
+  uv_sem_wait((uv_sem_t*)ctx->embed_sem);
+}
+#endif
+}
diff -r -u --color up/node/src/node.h nw/node/src/node.h
--- up/node/src/node.h	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/src/node.h	2023-02-21 04:37:43.872361167 +0000
@@ -8,7 +8,7 @@
 #   define NODE_EXTERN __declspec(dllimport)
 # endif
 #else
-# define NODE_EXTERN /* nothing */
+# define NODE_EXTERN __attribute__((visibility("default")))
 #endif
 
 #ifdef BUILDING_NODE_EXTENSION
@@ -279,10 +279,6 @@
 NODE_EXTERN void FatalException(v8::Isolate* isolate,
                                 const v8::TryCatch& try_catch);
 
-NODE_DEPRECATED("Use FatalException(isolate, ...)",
-                inline void FatalException(const v8::TryCatch& try_catch) {
-  return FatalException(v8::Isolate::GetCurrent(), try_catch);
-})
 
 // Don't call with encoding=UCS2.
 NODE_EXTERN v8::Local<v8::Value> Encode(v8::Isolate* isolate,
@@ -314,12 +310,6 @@
 NODE_EXTERN ssize_t DecodeBytes(v8::Isolate* isolate,
                                 v8::Local<v8::Value>,
                                 enum encoding encoding = BINARY);
-NODE_DEPRECATED("Use DecodeBytes(isolate, ...)",
-                inline ssize_t DecodeBytes(
-    v8::Local<v8::Value> val,
-    enum encoding encoding = BINARY) {
-  return DecodeBytes(v8::Isolate::GetCurrent(), val, encoding);
-})
 
 // returns bytes written.
 NODE_EXTERN ssize_t DecodeWrite(v8::Isolate* isolate,
@@ -327,13 +317,6 @@
                                 size_t buflen,
                                 v8::Local<v8::Value>,
                                 enum encoding encoding = BINARY);
-NODE_DEPRECATED("Use DecodeWrite(isolate, ...)",
-                inline ssize_t DecodeWrite(char* buf,
-                                           size_t buflen,
-                                           v8::Local<v8::Value> val,
-                                           enum encoding encoding = BINARY) {
-  return DecodeWrite(v8::Isolate::GetCurrent(), buf, buflen, val, encoding);
-})
 
 #ifdef _WIN32
 NODE_EXTERN v8::Local<v8::Value> WinapiErrnoException(
@@ -427,6 +410,13 @@
     }                                                                 \
   }
 
+#define NODE_MODULE_REF(modname)                \
+  extern int _node_ref_ ## modname;
+
+#define NODE_MODULE_REF2(modname)                                      \
+  _node_ref_ ## modname = 1;
+
+
 #define NODE_MODULE_CONTEXT_AWARE_X(modname, regfunc, priv, flags)    \
   extern "C" {                                                        \
     static node::node_module _module =                                \
@@ -444,7 +434,8 @@
     NODE_C_CTOR(_register_ ## modname) {                              \
       node_module_register(&_module);                                 \
     }                                                                 \
-  }
+  }                                                                   \
+  int _node_ref_ ## modname;
 
 #define NODE_MODULE(modname, regfunc)                                 \
   NODE_MODULE_X(modname, regfunc, NULL, 0)
diff -r -u --color up/node/src/node_buffer.cc nw/node/src/node_buffer.cc
--- up/node/src/node_buffer.cc	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/src/node_buffer.cc	2023-02-21 04:37:43.872361167 +0000
@@ -234,7 +234,7 @@
   // nullptr for zero-sized allocation requests.  Normalize by always using
   // a nullptr.
   if (length > 0) {
-    data = static_cast<char*>(BUFFER_MALLOC(length));
+    data = static_cast<char*>(isolate->array_buffer_allocator()->Allocate(length));
 
     if (data == nullptr)
       return Local<Object>();
@@ -243,12 +243,18 @@
     CHECK(actual <= length);
 
     if (actual == 0) {
-      free(data);
+      isolate->array_buffer_allocator()->Free(data, length);
       data = nullptr;
-    } else if (actual < length) {
+    }
+#if 0 //FIXME #4357: costs some extra bytes here. It shouldn't be
+      //significant because of the length calculation in
+      //StringBytes::Size()
+      //v8 buffer allocator doesn't support reallocate
+    else if (actual < length) {
       data = static_cast<char*>(realloc(data, actual));
       CHECK_NE(data, nullptr);
     }
+#endif
   }
 
   Local<Object> buf;
@@ -256,7 +262,7 @@
     return scope.Escape(buf);
 
   // Object failed to be created. Clean up resources.
-  free(data);
+  isolate->array_buffer_allocator()->Free(data, length);
   return Local<Object>();
 }
 
@@ -280,7 +286,7 @@
 
   void* data;
   if (length > 0) {
-    data = BUFFER_MALLOC(length);
+    data = env->isolate()->array_buffer_allocator()->Allocate(length);
     if (data == nullptr)
       return Local<Object>();
   } else {
@@ -299,7 +305,7 @@
     return scope.Escape(ui);
 
   // Object failed to be created. Clean up resources.
-  free(data);
+  env->isolate()->array_buffer_allocator()->Free(data, length);
   return Local<Object>();
 }
 
@@ -325,7 +331,7 @@
   void* new_data;
   if (length > 0) {
     CHECK_NE(data, nullptr);
-    new_data = malloc(length);
+    new_data = env->isolate()->array_buffer_allocator()->Allocate(length);
     if (new_data == nullptr)
       return Local<Object>();
     memcpy(new_data, data, length);
@@ -345,7 +351,7 @@
     return scope.Escape(ui);
 
   // Object failed to be created. Clean up resources.
-  free(new_data);
+  env->isolate()->array_buffer_allocator()->Free(new_data, length);
   return Local<Object>();
 }
 
@@ -424,7 +430,6 @@
   return Local<Object>();
 }
 
-
 void CreateFromString(const FunctionCallbackInfo<Value>& args) {
   CHECK(args[0]->IsString());
   CHECK(args[1]->IsString());
diff -r -u --color up/node/src/node_buffer.h nw/node/src/node_buffer.h
--- up/node/src/node_buffer.h	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/src/node_buffer.h	2023-02-21 04:37:43.872361167 +0000
@@ -13,7 +13,10 @@
 static const unsigned int kMaxLength =
     sizeof(int32_t) == sizeof(intptr_t) ? 0x3fffffff : 0x7fffffff;
 
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wignored-attributes"
 NODE_EXTERN typedef void (*FreeCallback)(char* data, void* hint);
+#pragma clang diagnostic pop
 
 NODE_EXTERN bool HasInstance(v8::Local<v8::Value> val);
 NODE_EXTERN bool HasInstance(v8::Local<v8::Object> val);
diff -r -u --color up/node/src/node_crypto.cc nw/node/src/node_crypto.cc
--- up/node/src/node_crypto.cc	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/src/node_crypto.cc	2023-02-21 04:37:43.876361205 +0000
@@ -28,6 +28,7 @@
 #define strcasecmp _stricmp
 #endif
 
+
 #if OPENSSL_VERSION_NUMBER >= 0x10000000L
 #define OPENSSL_CONST const
 #else
@@ -3238,7 +3239,7 @@
   if (initialised_ || kind_ != kCipher || !auth_tag_)
     return false;
   *out_len = auth_tag_len_;
-  *out = static_cast<char*>(malloc(auth_tag_len_));
+  *out = static_cast<char*>(env()->isolate()->array_buffer_allocator()->Allocate(auth_tag_len_));
   CHECK_NE(*out, nullptr);
   memcpy(*out, auth_tag_, auth_tag_len_);
   return true;
@@ -4769,7 +4770,7 @@
   // NOTE: field_size is in bits
   int field_size = EC_GROUP_get_degree(ecdh->group_);
   size_t out_len = (field_size + 7) / 8;
-  char* out = static_cast<char*>(malloc(out_len));
+  char* out = static_cast<char*>(env->isolate()->array_buffer_allocator()->Allocate(out_len));
   CHECK_NE(out, nullptr);
 
   int r = ECDH_compute_key(out, out_len, pub, ecdh->key_, nullptr);
@@ -4804,7 +4805,7 @@
   if (size == 0)
     return env->ThrowError("Failed to get public key length");
 
-  unsigned char* out = static_cast<unsigned char*>(malloc(size));
+  unsigned char* out = static_cast<unsigned char*>(env->isolate()->array_buffer_allocator()->Allocate(size));
   CHECK_NE(out, nullptr);
 
   int r = EC_POINT_point2oct(ecdh->group_, pub, form, out, size, nullptr);
@@ -4829,7 +4830,7 @@
     return env->ThrowError("Failed to get ECDH private key");
 
   int size = BN_num_bytes(b);
-  unsigned char* out = static_cast<unsigned char*>(malloc(size));
+  unsigned char* out = static_cast<unsigned char*>(env->isolate()->array_buffer_allocator()->Allocate(size));
   CHECK_NE(out, nullptr);
 
   if (size != BN_bn2bin(b, out)) {
@@ -5225,7 +5226,7 @@
       : AsyncWrap(env, object, AsyncWrap::PROVIDER_CRYPTO),
         error_(0),
         size_(size),
-        data_(static_cast<char*>(malloc(size))) {
+        data_(static_cast<char*>(env->isolate()->array_buffer_allocator()->Allocate(size))) {
     if (data() == nullptr)
       FatalError("node::RandomBytesRequest()", "Out of Memory");
     Wrap(object, this);
@@ -5248,7 +5249,7 @@
   }
 
   inline void release() {
-    free(data_);
+    env()->isolate()->array_buffer_allocator()->Free(data_, size_);
     size_ = 0;
   }
 
diff -r -u --color up/node/src/node_internals.h nw/node/src/node_internals.h
--- up/node/src/node_internals.h	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/src/node_internals.h	2023-02-21 04:37:43.876361205 +0000
@@ -41,6 +41,7 @@
     v8::Isolate* isolate,
     const v8::Persistent<TypeName>& persistent);
 
+NODE_EXTERN v8::Handle<v8::Value> CallTickCallback(Environment* env, const v8::Handle<v8::Value> ret);
 // Call with valid HandleScope and while inside Context scope.
 v8::Local<v8::Value> MakeCallback(Environment* env,
                                    v8::Local<v8::Object> recv,
diff -r -u --color up/node/src/node_version.h nw/node/src/node_version.h
--- up/node/src/node_version.h	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/src/node_version.h	2023-02-21 04:37:43.876361205 +0000
@@ -2,8 +2,8 @@
 #define SRC_NODE_VERSION_H_
 
 #define NODE_MAJOR_VERSION 5
-#define NODE_MINOR_VERSION 11
-#define NODE_PATCH_VERSION 1
+#define NODE_MINOR_VERSION 12
+#define NODE_PATCH_VERSION 0
 
 #define NODE_VERSION_IS_RELEASE 1
 
Only in nw/node/src: node_webkit.h
diff -r -u --color up/node/src/stream_wrap.cc nw/node/src/stream_wrap.cc
--- up/node/src/stream_wrap.cc	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/src/stream_wrap.cc	2023-02-21 04:37:43.880361244 +0000
@@ -154,7 +154,9 @@
 
 
 void StreamWrap::OnAllocImpl(size_t size, uv_buf_t* buf, void* ctx) {
-  buf->base = static_cast<char*>(malloc(size));
+  StreamWrap* wrap = static_cast<StreamWrap*>(ctx);
+  Environment* env = wrap->env();
+  buf->base = static_cast<char*>(env->isolate()->array_buffer_allocator()->Allocate(size));
   buf->len = size;
 
   if (buf->base == nullptr && size > 0) {
@@ -198,18 +200,22 @@
 
   if (nread < 0)  {
     if (buf->base != nullptr)
-      free(buf->base);
+      env->isolate()->array_buffer_allocator()->Free(buf->base, buf->len);
     wrap->EmitData(nread, Local<Object>(), pending_obj);
     return;
   }
 
   if (nread == 0) {
     if (buf->base != nullptr)
-      free(buf->base);
+      env->isolate()->array_buffer_allocator()->Free(buf->base, buf->len);
     return;
   }
 
-  char* base = static_cast<char*>(realloc(buf->base, nread));
+  char* base = static_cast<char*>(buf->base); //NOTE: realloc is
+                                              //removed here because
+                                              //nread is always less
+                                              //than buf->len, see the
+                                              //check in the next line
   CHECK_LE(static_cast<size_t>(nread), buf->len);
 
   if (pending == UV_TCP) {
diff -r -u --color up/node/src/string_bytes.cc nw/node/src/string_bytes.cc
--- up/node/src/string_bytes.cc	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/src/string_bytes.cc	2023-02-21 04:37:43.880361244 +0000
@@ -420,7 +420,7 @@
     }
 
     case BASE64:
-      if (is_extern) {
+      if (is_extern && str->IsExternalOneByte()) {
         nbytes = base64_decode(buf, buflen, data, external_nbytes);
       } else {
         String::Value value(str);
@@ -432,7 +432,7 @@
       break;
 
     case HEX:
-      if (is_extern) {
+      if (is_extern && str->IsExternalOneByte()) {
         nbytes = hex_decode(buf, buflen, data, external_nbytes);
       } else {
         String::Value value(str);
diff -r -u --color up/node/src/string_bytes.h nw/node/src/string_bytes.h
--- up/node/src/string_bytes.h	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/src/string_bytes.h	2023-02-21 04:37:43.880361244 +0000
@@ -108,31 +108,31 @@
 
   // Deprecated legacy interface
 
-  NODE_DEPRECATED("Use IsValidString(isolate, ...)",
+  NODE_DEPRECATED("Use Is ValidString(isolate, ...)",
                   static inline bool IsValidString(
       v8::Local<v8::String> string,
       enum encoding enc) {
     return IsValidString(v8::Isolate::GetCurrent(), string, enc);
-  })
+                  })
 
   NODE_DEPRECATED("Use StorageSize(isolate, ...)",
                   static inline size_t StorageSize(v8::Local<v8::Value> val,
                                                   enum encoding enc) {
     return StorageSize(v8::Isolate::GetCurrent(), val, enc);
-  })
+                  })
 
   NODE_DEPRECATED("Use Size(isolate, ...)",
                   static inline size_t Size(v8::Local<v8::Value> val,
                                             enum encoding enc) {
     return Size(v8::Isolate::GetCurrent(), val, enc);
-  })
+                  })
 
   NODE_DEPRECATED("Use GetExternalParts(isolate, ...)",
                   static inline bool GetExternalParts(v8::Local<v8::Value> val,
                                                       const char** data,
                                                       size_t* len) {
     return GetExternalParts(v8::Isolate::GetCurrent(), val, data, len);
-  })
+                  })
 
   NODE_DEPRECATED("Use Write(isolate, ...)",
                   static inline size_t Write(char* buf,
@@ -142,7 +142,7 @@
                                              int* chars_written = nullptr) {
     v8::Isolate* isolate = v8::Isolate::GetCurrent();
     return Write(isolate, buf, buflen, val, enc, chars_written);
-  })
+                  })
 
   NODE_DEPRECATED("Use Encode(isolate, ...)",
                   static inline v8::Local<v8::Value> Encode(
@@ -150,7 +150,7 @@
       size_t buflen,
       enum encoding encoding) {
     return Encode(v8::Isolate::GetCurrent(), buf, buflen, encoding);
-  })
+                  })
 
  private:
   static size_t WriteUCS2(char* buf,
diff -r -u --color up/node/src/tls_wrap.cc nw/node/src/tls_wrap.cc
--- up/node/src/tls_wrap.cc	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/src/tls_wrap.cc	2023-02-21 04:37:43.880361244 +0000
@@ -657,7 +657,10 @@
 
 
 void TLSWrap::OnAllocSelf(size_t suggested_size, uv_buf_t* buf, void* ctx) {
-  buf->base = static_cast<char*>(malloc(suggested_size));
+  TLSWrap* wrap = static_cast<TLSWrap*>(ctx);
+  Environment* env = wrap->env();
+
+  buf->base = static_cast<char*>(env->isolate()->array_buffer_allocator()->Allocate(suggested_size));
   CHECK_NE(buf->base, nullptr);
   buf->len = suggested_size;
 }
diff -r -u --color up/node/src/udp_wrap.cc nw/node/src/udp_wrap.cc
--- up/node/src/udp_wrap.cc	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/src/udp_wrap.cc	2023-02-21 04:37:43.880361244 +0000
@@ -368,7 +368,10 @@
 void UDPWrap::OnAlloc(uv_handle_t* handle,
                       size_t suggested_size,
                       uv_buf_t* buf) {
-  buf->base = static_cast<char*>(malloc(suggested_size));
+  UDPWrap* wrap = static_cast<UDPWrap*>(((uv_udp_t*)handle)->data);
+  Environment* env = wrap->env();
+
+  buf->base = static_cast<char*>(env->isolate()->array_buffer_allocator()->Allocate(suggested_size));
   buf->len = suggested_size;
 
   if (buf->base == nullptr && suggested_size > 0) {
@@ -383,14 +386,14 @@
                      const uv_buf_t* buf,
                      const struct sockaddr* addr,
                      unsigned int flags) {
+  UDPWrap* wrap = static_cast<UDPWrap*>(handle->data);
+  Environment* env = wrap->env();
   if (nread == 0 && addr == nullptr) {
     if (buf->base != nullptr)
-      free(buf->base);
+      env->isolate()->array_buffer_allocator()->Free(buf->base, buf->len);
     return;
   }
 
-  UDPWrap* wrap = static_cast<UDPWrap*>(handle->data);
-  Environment* env = wrap->env();
 
   HandleScope handle_scope(env->isolate());
   Context::Scope context_scope(env->context());
@@ -405,12 +408,12 @@
 
   if (nread < 0) {
     if (buf->base != nullptr)
-      free(buf->base);
+      env->isolate()->array_buffer_allocator()->Free(buf->base, buf->len);
     wrap->MakeCallback(env->onmessage_string(), arraysize(argv), argv);
     return;
   }
 
-  char* base = static_cast<char*>(realloc(buf->base, nread));
+  char* base = static_cast<char*>(buf->base); //NOTE: we don't realloc here
   argv[2] = Buffer::New(env, base, nread).ToLocalChecked();
   argv[3] = AddressToJS(env, addr);
   wrap->MakeCallback(env->onmessage_string(), arraysize(argv), argv);
diff -r -u --color up/node/test/parallel/test-buffer-alloc.js nw/node/test/parallel/test-buffer-alloc.js
--- up/node/test/parallel/test-buffer-alloc.js	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/test/parallel/test-buffer-alloc.js	2023-02-21 04:37:43.896361398 +0000
@@ -1435,3 +1435,9 @@
 assert.throws(function() {
   Buffer.from(new ArrayBuffer(0), -1 >>> 0);
 }, /RangeError: 'offset' is out of bounds/);
+
+// Unpooled buffer (replaces SlowBuffer)
+const ubuf = Buffer.allocUnsafeSlow(10);
+assert(ubuf);
+assert(ubuf.buffer);
+assert.equal(ubuf.buffer.byteLength, 10);
diff -r -u --color up/node/test/parallel/test-buffer.js nw/node/test/parallel/test-buffer.js
--- up/node/test/parallel/test-buffer.js	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/test/parallel/test-buffer.js	2023-02-21 04:37:43.896361398 +0000
@@ -1438,3 +1438,37 @@
 assert.equal(Buffer.prototype.offset, undefined);
 assert.equal(SlowBuffer.prototype.parent, undefined);
 assert.equal(SlowBuffer.prototype.offset, undefined);
+
+{
+  // Test that large negative Buffer length inputs don't affect the pool offset.
+  assert.deepStrictEqual(Buffer(-Buffer.poolSize), Buffer.from(''));
+  assert.deepStrictEqual(Buffer(-100), Buffer.from(''));
+  assert.deepStrictEqual(Buffer.allocUnsafe(-Buffer.poolSize), Buffer.from(''));
+  assert.deepStrictEqual(Buffer.allocUnsafe(-100), Buffer.from(''));
+
+  // Check pool offset after that by trying to write string into the pool.
+  assert.doesNotThrow(() => Buffer.from('abc'));
+}
+
+
+// Test failed or zero-sized Buffer allocations not affecting typed arrays
+{
+  const zeroArray = new Uint32Array(10).fill(0);
+  const sizes = [1e10, 0, 0.1, -1, 'a', undefined, null, NaN];
+  const allocators = [
+    Buffer,
+    SlowBuffer,
+    Buffer.alloc,
+    Buffer.allocUnsafe,
+    Buffer.allocUnsafeSlow
+  ];
+  for (const allocator of allocators) {
+    for (const size of sizes) {
+      try {
+        allocator(size);
+      } catch (e) {
+        assert.deepStrictEqual(new Uint32Array(10), zeroArray);
+      }
+    }
+  }
+}
diff -r -u --color up/node/test/parallel/test-net-better-error-messages-port-hostname.js nw/node/test/parallel/test-net-better-error-messages-port-hostname.js
--- up/node/test/parallel/test-net-better-error-messages-port-hostname.js	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/test/parallel/test-net-better-error-messages-port-hostname.js	2023-02-21 04:37:43.916361590 +0000
@@ -3,12 +3,12 @@
 var net = require('net');
 var assert = require('assert');
 
-var c = net.createConnection(common.PORT, '...');
+var c = net.createConnection(common.PORT, '***');
 
 c.on('connect', common.fail);
 
 c.on('error', common.mustCall(function(e) {
   assert.equal(e.code, 'ENOTFOUND');
   assert.equal(e.port, common.PORT);
-  assert.equal(e.hostname, '...');
+  assert.equal(e.hostname, '***');
 }));
diff -r -u --color up/node/test/parallel/test-net-connect-immediate-finish.js nw/node/test/parallel/test-net-connect-immediate-finish.js
--- up/node/test/parallel/test-net-connect-immediate-finish.js	2016-05-05 19:27:05.000000000 +0000
+++ nw/node/test/parallel/test-net-connect-immediate-finish.js	2023-02-21 04:37:43.916361590 +0000
@@ -3,14 +3,14 @@
 const assert = require('assert');
 const net = require('net');
 
-const client = net.connect({host: '...', port: common.PORT});
+const client = net.connect({host: '***', port: common.PORT});
 
 client.once('error', common.mustCall(function(err) {
   assert(err);
   assert.strictEqual(err.code, err.errno);
   assert.strictEqual(err.code, 'ENOTFOUND');
   assert.strictEqual(err.host, err.hostname);
-  assert.strictEqual(err.host, '...');
+  assert.strictEqual(err.host, '***');
   assert.strictEqual(err.syscall, 'getaddrinfo');
 }));
 
