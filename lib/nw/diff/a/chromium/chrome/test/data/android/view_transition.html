<!DOCTYPE html>
<html>
  <head>
    <script>
      const params = new URLSearchParams(window.location.search);
      let metaTagContent = 'width=device-width,minimum-scale=1';
      if (params.has('resizes-content'))
        metaTagContent += ',interactive-widget=resizes-content';
      else if (params.has('resizes-visual'))
        metaTagContent += ',interactive-widget=resizes-visual';
      else if (params.has('overlays-content')) {
        metaTagContent += ',interactive-widget=overlays-content';
      }

      let meta = document.createElement('meta');
      meta.name = 'viewport';
      meta.content = metaTagContent;
      document.head.appendChild(meta);

      if (params.has('new'))
        document.documentElement.classList.add('new');
      else if (params.has('old'))
        document.documentElement.classList.add('old');
    </script>
    <style>
      input {
        /* Invisible so that blinking cursor doesn't affect pixel tests */
        position: absolute;
        top: 50px;
        opacity: 0;
      }

      #bottomfixed {
        position: fixed;
        left: 20px;
        bottom: 10px;
        width: 100px;
        height: 30px;
        background-color: coral;
        view-transition-name: bottom;
        contain: paint;
      }

      #topfixed {
        position: fixed;
        left: 20px;
        top: 10px;
        width: 100px;
        height: 30px;
        background-color: dodgerblue;
        view-transition-name: top;
        contain: paint;
      }

      #inflow {
        position: absolute;
        left: 100px;
        top: 200px;
        width: 100px;
        height: 300px;
        background-color: rebeccapurple;
      }

      /* For live testing - if no class is set on the root use the regular but
       * slow transition */
      ::view-transition-group(*),
      ::view-transition-new(*),
      ::view-transition-old(*) {
        animation-duration: 5s;
      }

      /* Step function and long duration means we'll simply keep the snapshots
       * in their initial state for 30 seconds so the pixel test can take a
       * screenshot reliably. */
      .old::view-transition-group(*),
      .old::view-transition-new(*),
      .old::view-transition-old(*) {
        animation-duration: 30s;
        animation-direction: normal;
        animation-timing-function: steps(1, end);
      }

      /* Reverse the direction if we're capturing the new state */
      .new::view-transition-group(*),
      .new::view-transition-new(*),
      .new::view-transition-old(*) {
        animation-duration: 30s;
        animation-direction: reverse;
        animation-timing-function: steps(1, start);
      }
    </style>
    <script>
      let transition = null;

      // Allow tests to control when the transition starts.
      let startTransitionAnimation = null;
      let startPromise = new Promise(resolve => {startTransitionAnimation = resolve;});

      // Allow tests to wait until the snapshot has been taken and is ready to
      // start transitioning.
      let readyToStartResolve = null;
      let readyToStartPromise = new Promise(resolve => {readyToStartResolve = resolve;});

      function updateDOM() {
        document.getElementById("inflow").style.transform = "translateX(100px)";
        document.getElementById("bottomfixed").style.transform = "translateX(100px)";
        document.getElementById("topfixed").style.transform = "translateX(100px)";
      }

      function undoUpdateDOM() {
        document.getElementById("inflow").style = "";
        document.getElementById("bottomfixed").style = "";
        document.getElementById("topfixed").style = "";
      }

      function createTransition() {
        transition = document.startViewTransition(() => {
          updateDOM();

          readyToStartResolve();

          return startPromise;
        });

      }
    </script>
  </head>
  <body>
    <input id="inputElement" type="text">
    <div id="inflow"></div>
    <div id="bottomfixed"></div>
    <div id="topfixed"></div>
  </body>
</html>
