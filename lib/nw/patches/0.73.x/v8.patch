Only in nw/v8: .git
diff -r -u --color up/v8/BUILD.gn nw/v8/BUILD.gn
--- up/v8/BUILD.gn	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/BUILD.gn	2023-02-19 00:13:05.791287408 +0000
@@ -59,7 +59,7 @@
   v8_deprecation_warnings = true
 
   # Enable compiler warnings when using V8_DEPRECATE_SOON apis.
-  v8_imminent_deprecation_warnings = true
+  v8_imminent_deprecation_warnings = false
 
   # Embeds the given script into the snapshot.
   v8_embed_script = ""
@@ -311,7 +311,7 @@
 
   # Enable the experimental V8 sandbox.
   # Sets -DV8_ENABLE_SANDBOX.
-  v8_enable_sandbox = ""
+  v8_enable_sandbox = false
 
   # Expose the memory corruption API to JavaScript. Useful for testing the sandbox.
   # WARNING This will expose builtins that (by design) cause memory corruption.
@@ -340,7 +340,7 @@
   v8_enable_map_packing = false
 
   # Allow for JS promise hooks (instead of just C++).
-  v8_enable_javascript_promise_hooks = false
+  v8_enable_javascript_promise_hooks = true
 
   # Enable allocation folding globally (sets -dV8_ALLOCATION_FOLDING).
   # When it's disabled, the --turbo-allocation-folding runtime flag will be ignored.
@@ -356,7 +356,7 @@
   # Enable legacy mode for ScriptOrModule's lifetime. By default it's a
   # temporary object, if enabled it will be kept alive by the parent Script.
   # This is only used by nodejs.
-  v8_scriptormodule_legacy_lifetime = false
+  v8_scriptormodule_legacy_lifetime = true
 
   # Change code emission and runtime features to be CET shadow-stack compliant
   # (incomplete and experimental).
@@ -652,7 +652,7 @@
 
 config("internal_config") {
   defines = []
-
+  cflags = []
   # Only targets in this file and its subdirs can depend on this.
   visibility = [ "./*" ]
 
@@ -663,13 +663,17 @@
     ":cppgc_header_features",
   ]
 
-  if (is_component_build) {
+  if (true) {
     defines += [ "BUILDING_V8_SHARED" ]
   }
 
   if (v8_current_cpu == "riscv64" || v8_current_cpu == "riscv32") {
     libs = [ "atomic" ]
   }
+
+  if (is_win) {
+    cflags += [ "/Zc:dllexportInlines-" ]
+  }
 }
 
 # Should be applied to all targets that write trace events.
@@ -686,14 +690,14 @@
 # This config should be applied to code using the libplatform.
 config("libplatform_config") {
   include_dirs = [ "include" ]
-  if (is_component_build) {
+  if (false) {
     defines = [ "USING_V8_PLATFORM_SHARED" ]
   }
 }
 
 # This config should be applied to code using the libbase.
 config("libbase_config") {
-  if (is_component_build) {
+  if (false) {
     defines = [ "USING_V8_BASE_SHARED" ]
   }
   libs = []
@@ -736,7 +740,9 @@
   configs = [ ":headers_config" ]
   defines = []
   if (is_component_build) {
-    defines += [ "USING_V8_SHARED" ]
+    defines += [ "USING_V8_SHARED", "V8_SHARED", "USING_V8_PLATFORM_SHARED" ]
+  } else {
+    defines += [ "V8_SHARED" ]
   }
 
   if (current_cpu == "riscv64" || current_cpu == "riscv32") {
@@ -2404,6 +2410,8 @@
   visibility = [
     ":*",
     "test/cctest:*",
+    "//tools/v8_context_snapshot:*",
+    "//chrome:*",
   ]
 
   allow_circular_includes_from = [ ":torque_generated_initializers" ]
@@ -5456,7 +5464,8 @@
   }
 }
 
-v8_component("v8_libbase") {
+v8_static_lib("v8_libbase") {
+
   sources = [
     "src/base/address-region.h",
     "src/base/atomic-utils.h",
@@ -5585,7 +5594,7 @@
 
   defines = []
 
-  if (is_component_build) {
+  if (false) {
     defines = [ "BUILDING_V8_BASE_SHARED" ]
   }
 
@@ -5743,7 +5752,7 @@
   }
 }
 
-v8_component("v8_libplatform") {
+v8_static_lib("v8_libplatform") {
   sources = [
     "//base/trace_event/common/trace_event_common.h",
     "include/libplatform/libplatform-export.h",
@@ -5774,7 +5783,7 @@
 
   configs = [ ":internal_config_base" ]
 
-  if (is_component_build) {
+  if (true) {
     defines = [ "BUILDING_V8_PLATFORM_SHARED" ]
   }
 
@@ -6206,6 +6215,25 @@
 ###############################################################################
 # Executables
 #
+v8_executable("nwjc") {
+
+    sources = [
+      "src/nwjc.cc",
+    ]
+
+    configs = [
+      ":internal_config",
+    ]
+
+    deps = [
+      ":v8_base",
+      ":v8_libplatform",
+      ":v8_libbase",
+      ":v8_snapshot",
+      ":v8_initializers",
+      "//build/win:default_exe_manifest",
+    ]
+}
 
 if (current_toolchain == v8_generator_toolchain) {
   v8_executable("bytecode_builtins_list_generator") {
diff -r -u --color up/v8/gni/v8.gni nw/v8/gni/v8.gni
--- up/v8/gni/v8.gni	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/gni/v8.gni	2023-02-19 00:13:05.791287408 +0000
@@ -245,6 +245,15 @@
   }
 }
 
+template("v8_static_lib") {
+  static_library(target_name) {
+    forward_variables_from(invoker, "*", [ "configs" ])
+    configs += invoker.configs
+    configs -= v8_remove_configs
+    configs += v8_add_configs
+  }
+}
+
 template("v8_executable") {
   executable(target_name) {
     forward_variables_from(invoker,
Only in nw/v8: gypfiles
diff -r -u --color up/v8/include/libplatform/libplatform.h nw/v8/include/libplatform/libplatform.h
--- up/v8/include/libplatform/libplatform.h	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/include/libplatform/libplatform.h	2023-02-19 00:13:05.795287409 +0000
@@ -36,7 +36,7 @@
  * If |tracing_controller| is nullptr, the default platform will create a
  * v8::platform::TracingController instance and use it.
  */
-V8_PLATFORM_EXPORT std::unique_ptr<v8::Platform> NewDefaultPlatform(
+V8_EXPORT std::unique_ptr<v8::Platform> NewDefaultPlatform(
     int thread_pool_size = 0,
     IdleTaskSupport idle_task_support = IdleTaskSupport::kDisabled,
     InProcessStackDumping in_process_stack_dumping =
@@ -74,7 +74,8 @@
  * the |behavior| parameter, this call does not block if no task is pending. The
  * |platform| has to be created using |NewDefaultPlatform|.
  */
-V8_PLATFORM_EXPORT bool PumpMessageLoop(
+
+V8_EXPORT bool PumpMessageLoop(
     v8::Platform* platform, v8::Isolate* isolate,
     MessageLoopBehavior behavior = MessageLoopBehavior::kDoNotWait);
 
@@ -85,7 +86,7 @@
  * This call does not block if no task is pending. The |platform| has to be
  * created using |NewDefaultPlatform|.
  */
-V8_PLATFORM_EXPORT void RunIdleTasks(v8::Platform* platform,
+V8_EXPORT void RunIdleTasks(v8::Platform* platform,
                                      v8::Isolate* isolate,
                                      double idle_time_in_seconds);
 
diff -r -u --color up/v8/include/v8-array-buffer.h nw/v8/include/v8-array-buffer.h
--- up/v8/include/v8-array-buffer.h	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/include/v8-array-buffer.h	2023-02-19 00:13:05.795287409 +0000
@@ -186,7 +186,8 @@
      * while kReservation is for larger allocations with the ability to set
      * access permissions.
      */
-    enum class AllocationMode { kNormal, kReservation };
+    enum class AllocationMode { kNormal, kReservation, kNodeJS };
+    virtual void Free(void* data, size_t length, AllocationMode mode);
 
     /**
      * Convenience allocator.
@@ -232,6 +233,8 @@
    */
   static Local<ArrayBuffer> New(Isolate* isolate,
                                 std::shared_ptr<BackingStore> backing_store);
+  static Local<ArrayBuffer> NewNode(Isolate* isolate,
+                                std::shared_ptr<BackingStore> backing_store);
 
   /**
    * Returns a new standalone BackingStore that is allocated using the array
@@ -292,6 +295,8 @@
       "ok).")
   void Detach();
 
+  void set_nodejs(bool);
+
   /**
    * Detaches this ArrayBuffer and all its views (typed arrays).
    * Detaching sets the byte length of the buffer and all typed arrays to zero,
diff -r -u --color up/v8/include/v8-debug.h nw/v8/include/v8-debug.h
--- up/v8/include/v8-debug.h	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/include/v8-debug.h	2023-02-19 00:13:05.799287410 +0000
@@ -130,6 +130,8 @@
     kDetailed = kOverview | kIsEval | kIsConstructor | kScriptNameOrSourceURL
   };
 
+  V8_DEPRECATED("Use Isolate version")
+                Local<StackFrame> GetFrame(uint32_t index) const;
   /**
    * Returns a StackFrame at a particular index.
    */
diff -r -u --color up/v8/include/v8-initialization.h nw/v8/include/v8-initialization.h
--- up/v8/include/v8-initialization.h	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/include/v8-initialization.h	2023-02-19 00:13:05.799287410 +0000
@@ -151,6 +151,7 @@
    */
   static bool InitializeICUDefaultLocation(const char* exec_path,
                                            const char* icu_data_file = nullptr);
+  static void* RawICUData();
 
   /**
    * Initialize the external startup data. The embedder only needs to
diff -r -u --color up/v8/include/v8-isolate.h nw/v8/include/v8-isolate.h
--- up/v8/include/v8-isolate.h	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/include/v8-isolate.h	2023-02-19 00:13:05.799287410 +0000
@@ -209,6 +209,7 @@
  */
 class V8_EXPORT Isolate {
  public:
+  ArrayBuffer::Allocator* array_buffer_allocator();
   /**
    * Initial configuration parameters for a new Isolate.
    */
@@ -296,6 +297,7 @@
     OOMErrorCallback oom_error_callback = nullptr;
   };
 
+  void SetArrayBufferAllocatorShared(std::shared_ptr<ArrayBuffer::Allocator> allocator);
   /**
    * Stack-allocated class which sets the isolate for all operations
    * executed within a local scope.
diff -r -u --color up/v8/include/v8-platform.h nw/v8/include/v8-platform.h
--- up/v8/include/v8-platform.h	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/include/v8-platform.h	2023-02-19 00:13:05.799287410 +0000
@@ -10,6 +10,37 @@
 #include <stdlib.h>  // For abort.
 #include <memory>
 #include <string>
+#include "v8config.h"
+
+#ifdef V8_OS_WIN
+
+// Setup for Windows DLL export/import. When building the V8 DLL the
+// BUILDING_V8_SHARED needs to be defined. When building a program which uses
+// the V8 DLL USING_V8_SHARED needs to be defined. When either building the V8
+// static library or building a program which uses the V8 static library neither
+// BUILDING_V8_SHARED nor USING_V8_SHARED should be defined.
+#ifdef BUILDING_V8_SHARED
+# define V8_EXPORT __declspec(dllexport)
+#elif USING_V8_SHARED
+# define V8_EXPORT __declspec(dllimport)
+#else
+# define V8_EXPORT
+#endif  // BUILDING_V8_SHARED
+
+#else  // V8_OS_WIN
+
+// Setup for Linux shared library export.
+#if V8_HAS_ATTRIBUTE_VISIBILITY
+# ifdef BUILDING_V8_SHARED
+#  define V8_EXPORT __attribute__ ((visibility("default")))
+# else
+#  define V8_EXPORT
+# endif
+#else
+# define V8_EXPORT
+#endif
+
+#endif  // V8_OS_WIN
 
 #include "v8config.h"  // NOLINT(build/include_directory)
 
@@ -1124,6 +1155,7 @@
    */
   V8_EXPORT static double SystemClockTimeMillis();
 };
+void V8_EXPORT SetTLSPlatform(Platform* platform);
 
 }  // namespace v8
 
diff -r -u --color up/v8/include/v8-primitive-object.h nw/v8/include/v8-primitive-object.h
--- up/v8/include/v8-primitive-object.h	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/include/v8-primitive-object.h	2023-02-19 00:13:05.799287410 +0000
@@ -78,6 +78,8 @@
  */
 class V8_EXPORT StringObject : public Object {
  public:
+  V8_DEPRECATED("Use Isolate* version") static
+                       Local<Value> New(Local<String> value);
   static Local<Value> New(Isolate* isolate, Local<String> value);
 
   Local<String> ValueOf() const;
diff -r -u --color up/v8/include/v8-primitive.h nw/v8/include/v8-primitive.h
--- up/v8/include/v8-primitive.h	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/include/v8-primitive.h	2023-02-19 00:13:05.799287410 +0000
@@ -69,6 +69,9 @@
     return reinterpret_cast<PrimitiveArray*>(data);
   }
 
+  V8_DEPRECATED("Use Isolate version")
+                void Set(int index, Local<Primitive> item);
+  V8_DEPRECATED("Use Isolate version") Local<Primitive> Get(int index);
  private:
   static void CheckCast(Data* obj);
 };
@@ -140,6 +143,7 @@
    * Returns the number of bytes in the UTF-8 encoded
    * representation of this string.
    */
+  V8_DEPRECATED("Use Isolate version instead") int Utf8Length() const;
   int Utf8Length(Isolate* isolate) const;
 
   /**
@@ -196,13 +200,24 @@
   // 16-bit character codes.
   int Write(Isolate* isolate, uint16_t* buffer, int start = 0, int length = -1,
             int options = NO_OPTIONS) const;
+  V8_DEPRECATED("Use Isolate* version")
+                int Write(uint16_t* buffer, int start = 0, int length = -1,
+                          int options = NO_OPTIONS) const;
   // One byte characters.
   int WriteOneByte(Isolate* isolate, uint8_t* buffer, int start = 0,
                    int length = -1, int options = NO_OPTIONS) const;
+  V8_DEPRECATED("Use Isolate* version")
+                int WriteOneByte(uint8_t* buffer, int start = 0,
+                                 int length = -1, int options = NO_OPTIONS)
+                    const;
   // UTF-8 encoded characters.
   int WriteUtf8(Isolate* isolate, char* buffer, int length = -1,
                 int* nchars_ref = nullptr, int options = NO_OPTIONS) const;
 
+  V8_DEPRECATED("Use Isolate* version")
+                int WriteUtf8(char* buffer, int length = -1,
+                              int* nchars_ref = NULL, int options = NO_OPTIONS)
+                    const;
   /**
    * A zero length string.
    */
@@ -446,6 +461,9 @@
   static Local<String> Concat(Isolate* isolate, Local<String> left,
                               Local<String> right);
 
+  V8_DEPRECATED("Use Isolate* version") static
+                       Local<String> Concat(Local<String> left,
+                                            Local<String> right);
   /**
    * Creates a new external string using the data defined in the given
    * resource. When the external string is no longer live on V8's heap the
@@ -509,6 +527,8 @@
    */
   class V8_EXPORT Utf8Value {
    public:
+   V8_DEPRECATED("Use Isolate version")
+                  explicit Utf8Value(Local<v8::Value> obj);
     Utf8Value(Isolate* isolate, Local<v8::Value> obj);
     ~Utf8Value();
     char* operator*() { return str_; }
@@ -532,6 +552,7 @@
    */
   class V8_EXPORT Value {
    public:
+   V8_DEPRECATED("Use Isolate version") explicit Value(Local<v8::Value> obj);
     Value(Isolate* isolate, Local<v8::Value> obj);
     ~Value();
     uint16_t* operator*() { return str_; }
diff -r -u --color up/v8/include/v8-script.h nw/v8/include/v8-script.h
--- up/v8/include/v8-script.h	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/include/v8-script.h	2023-02-19 00:13:05.799287410 +0000
@@ -621,6 +621,7 @@
       CompileOptions options = kNoCompileOptions,
       NoCacheReason no_cache_reason = kNoCacheNoReason);
 
+  static MaybeLocal<Module> CompileModuleWithCache(Isolate* isolate, Source* source);
   /**
    * Returns a task which streams script data into V8, or NULL if the script
    * cannot be streamed. The user is responsible for running the task on a
@@ -798,6 +799,9 @@
   return reinterpret_cast<Module*>(data);
 }
 
+void V8_EXPORT FixSourceNWBin(Isolate* v8_isolate, Local<UnboundScript> script);
+void V8_EXPORT FixSourceNWBin(Isolate* v8_isolate, Local<Module> module);
+
 }  // namespace v8
 
 #endif  // INCLUDE_V8_SCRIPT_H_
diff -r -u --color up/v8/include/v8-value.h nw/v8/include/v8-value.h
--- up/v8/include/v8-value.h	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/include/v8-value.h	2023-02-19 00:13:05.799287410 +0000
@@ -402,6 +402,10 @@
    */
   Local<Boolean> ToBoolean(Isolate* isolate) const;
 
+  V8_DEPRECATED("Use maybe version") Local<Boolean> ToBoolean() const;
+  V8_DEPRECATED("Use maybe version") Local<String> ToString() const;
+  V8_DEPRECATED("Use maybe version") Local<Object> ToObject() const;
+  V8_DEPRECATED("Use maybe version") Local<Integer> ToInteger() const;
   /**
    * Attempts to convert a string to an array index.
    * Returns an empty handle if the conversion fails.
@@ -423,7 +427,14 @@
   /** Returns the equivalent of `ToInt32()->Value()`. */
   V8_WARN_UNUSED_RESULT Maybe<int32_t> Int32Value(Local<Context> context) const;
 
+  V8_DEPRECATED("Use maybe version") bool BooleanValue() const;
+  V8_DEPRECATED("Use maybe version") double NumberValue() const;
+  V8_DEPRECATED("Use maybe version") int64_t IntegerValue() const;
+  V8_DEPRECATED("Use maybe version") uint32_t Uint32Value() const;
+  V8_DEPRECATED("Use maybe version") int32_t Int32Value() const;
+
   /** JS == */
+  V8_DEPRECATED("Use maybe version") bool Equals(Local<Value> that) const;
   V8_WARN_UNUSED_RESULT Maybe<bool> Equals(Local<Context> context,
                                            Local<Value> that) const;
   bool StrictEquals(Local<Value> that) const;
diff -r -u --color up/v8/include/v8-wasm.h nw/v8/include/v8-wasm.h
--- up/v8/include/v8-wasm.h	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/include/v8-wasm.h	2023-02-19 00:13:05.803287411 +0000
@@ -121,6 +121,9 @@
   static void CheckCast(Value* obj);
 };
 
+V8_DEPRECATED("Use WasmModuleObject")
+              typedef WasmModuleObject WasmCompiledModule;
+
 /**
  * The V8 interface for WebAssembly streaming compilation. When streaming
  * compilation is initiated, V8 passes a {WasmStreaming} object to the embedder
diff -r -u --color up/v8/src/api/api.cc nw/v8/src/api/api.cc
--- up/v8/src/api/api.cc	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/src/api/api.cc	2023-02-19 00:13:05.807287413 +0000
@@ -175,6 +175,31 @@
 namespace v8 {
 
 static OOMErrorCallback g_oom_error_callback = nullptr;
+namespace {
+
+// TODO(delphick): Remove this completely when the deprecated functions that use
+// it are removed.
+// DO NOT USE THIS IN NEW CODE!
+i::Isolate* UnsafeIsolateFromHeapObject(i::Handle<i::HeapObject> obj) {
+  // Use MemoryChunk directly instead of Isolate::FromWritableHeapObject to
+  // temporarily allow isolate access from read-only space objects.
+  i::MemoryChunk* chunk = i::MemoryChunk::FromHeapObject(*obj);
+  return chunk->heap()->isolate();
+}
+
+// TODO(delphick): Remove this completely when the deprecated functions that use
+// it are removed.
+// DO NOT USE THIS IN NEW CODE!
+Local<Context> UnsafeContextFromHeapObject(i::Handle<i::Object> obj) {
+  // Use MemoryChunk directly instead of Isolate::FromWritableHeapObject to
+  // temporarily allow isolate access from read-only space objects.
+  i::MemoryChunk* chunk =
+      i::MemoryChunk::FromHeapObject(i::HeapObject::cast(*obj));
+  return reinterpret_cast<Isolate*>(chunk->heap()->isolate())
+      ->GetCurrentContext();
+}
+
+}  // namespace
 
 static ScriptOrigin GetScriptOriginForScript(i::Isolate* i_isolate,
                                              i::Handle<i::Script> script) {
@@ -355,6 +380,11 @@
   i::V8::SetSnapshotBlob(snapshot_blob);
 }
 
+void v8::ArrayBuffer::Allocator::Free(void* data, size_t length,
+                                      AllocationMode mode) {
+  UNIMPLEMENTED();
+}
+
 namespace {
 
 #ifdef V8_ENABLE_SANDBOX
@@ -2345,6 +2375,12 @@
   array->set(index, *i_item);
 }
 
+void PrimitiveArray::Set(int index, Local<Primitive> item) {
+  i::Handle<i::FixedArray> array = Utils::OpenHandle(this);
+  i::Isolate* isolate = UnsafeIsolateFromHeapObject(array);
+  Set(reinterpret_cast<Isolate*>(isolate), index, item);
+}
+
 Local<Primitive> PrimitiveArray::Get(Isolate* v8_isolate, int index) {
   i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(v8_isolate);
   i::Handle<i::FixedArray> array = Utils::OpenHandle(this);
@@ -2395,6 +2431,12 @@
       i::handle(self->import_assertions(), i_isolate));
 }
 
+Local<Primitive> PrimitiveArray::Get(int index) {
+  i::Handle<i::FixedArray> array = Utils::OpenHandle(this);
+  i::Isolate* isolate = UnsafeIsolateFromHeapObject(array);
+  return Get(reinterpret_cast<Isolate*>(isolate), index);
+}
+
 Module::Status Module::GetStatus() const {
   i::Handle<i::Module> self = Utils::OpenHandle(this);
   switch (self->status()) {
@@ -2738,6 +2780,21 @@
   return ToApiHandle<Module>(i_isolate->factory()->NewSourceTextModule(shared));
 }
 
+MaybeLocal<Module> ScriptCompiler::CompileModuleWithCache(Isolate* isolate,
+                                                          Source* source) {
+  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);
+
+  Utils::ApiCheck(source->GetResourceOptions().IsModule(),
+                  "v8::ScriptCompiler::CompileModule",
+                  "Invalid ScriptOrigin: is_module must be true");
+  auto maybe = CompileUnboundInternal(isolate, source, kConsumeCodeCache, kNoCacheNoReason);
+  Local<UnboundScript> unbound;
+  if (!maybe.ToLocal(&unbound)) return MaybeLocal<Module>();
+
+  i::Handle<i::SharedFunctionInfo> shared = Utils::OpenHandle(*unbound);
+  return ToApiHandle<Module>(i_isolate->factory()->NewSourceTextModule(shared));
+}
+
 // static
 V8_WARN_UNUSED_RESULT MaybeLocal<Function> ScriptCompiler::CompileFunction(
     Local<Context> context, Source* source, size_t arguments_count,
@@ -3347,6 +3404,11 @@
   return Utils::StackFrameToLocal(info);
 }
 
+Local<StackFrame> StackTrace::GetFrame(uint32_t index) const {
+  i::Isolate* isolate = UnsafeIsolateFromHeapObject(Utils::OpenHandle(this));
+  return GetFrame(reinterpret_cast<Isolate*>(isolate), index);
+}
+
 int StackTrace::GetFrameCount() const {
   return Utils::OpenHandle(this)->length();
 }
@@ -3376,9 +3438,9 @@
   i::Isolate* i_isolate = self->GetIsolate();
   i::Handle<i::Script> script(self->script(), i_isolate);
   i::Script::PositionInfo info;
-  CHECK(i::Script::GetPositionInfo(script,
+  i::Script::GetPositionInfo(script,
                                    i::StackFrameInfo::GetSourcePosition(self),
-                                   &info, i::Script::WITH_OFFSET));
+                                   &info, i::Script::WITH_OFFSET);
   if (script->HasSourceURLComment()) {
     info.line -= script->line_offset();
     if (info.line == 0) {
@@ -3743,6 +3805,25 @@
 
 // --- D a t a ---
 
+Local<Boolean> Value::ToBoolean() const {
+  return ToBoolean(Isolate::GetCurrent());
+}
+
+Local<String> Value::ToString() const {
+  return ToString(Isolate::GetCurrent()->GetCurrentContext())
+      .FromMaybe(Local<String>());
+}
+
+Local<Object> Value::ToObject() const {
+  return ToObject(Isolate::GetCurrent()->GetCurrentContext())
+      .FromMaybe(Local<Object>());
+}
+
+Local<Integer> Value::ToInteger() const {
+  return ToInteger(Isolate::GetCurrent()->GetCurrentContext())
+      .FromMaybe(Local<Integer>());
+}
+
 bool Value::FullIsUndefined() const {
   i::Handle<i::Object> object = Utils::OpenHandle(this);
   bool result = object->IsUndefined();
@@ -4345,6 +4426,15 @@
                   "Value is not a RegExp");
 }
 
+bool Value::BooleanValue() const {
+  auto obj = Utils::OpenHandle(this);
+  if (obj->IsSmi()) return *obj != i::Smi::zero();
+  DCHECK(obj->IsHeapObject());
+  i::Isolate* isolate =
+      UnsafeIsolateFromHeapObject(i::Handle<i::HeapObject>::cast(obj));
+  return obj->BooleanValue(isolate);
+}
+
 Maybe<double> Value::NumberValue(Local<Context> context) const {
   auto obj = Utils::OpenHandle(this);
   if (obj->IsNumber()) return Just(obj->Number());
@@ -4357,6 +4447,13 @@
   return Just(num->Number());
 }
 
+double Value::NumberValue() const {
+  auto obj = Utils::OpenHandle(this);
+  if (obj->IsNumber()) return obj->Number();
+  return NumberValue(UnsafeContextFromHeapObject(obj))
+      .FromMaybe(std::numeric_limits<double>::quiet_NaN());
+}
+
 Maybe<int64_t> Value::IntegerValue(Local<Context> context) const {
   auto obj = Utils::OpenHandle(this);
   if (obj->IsNumber()) {
@@ -4371,6 +4468,18 @@
   return Just(NumberToInt64(*num));
 }
 
+int64_t Value::IntegerValue() const {
+  auto obj = Utils::OpenHandle(this);
+  if (obj->IsNumber()) {
+    if (obj->IsSmi()) {
+      return i::Smi::ToInt(*obj);
+    } else {
+      return static_cast<int64_t>(obj->Number());
+    }
+  }
+  return IntegerValue(UnsafeContextFromHeapObject(obj)).FromMaybe(0);
+}
+
 Maybe<int32_t> Value::Int32Value(Local<Context> context) const {
   auto obj = Utils::OpenHandle(this);
   if (obj->IsNumber()) return Just(NumberToInt32(*obj));
@@ -4384,6 +4493,12 @@
                            : static_cast<int32_t>(num->Number()));
 }
 
+int32_t Value::Int32Value() const {
+  auto obj = Utils::OpenHandle(this);
+  if (obj->IsNumber()) return NumberToInt32(*obj);
+  return Int32Value(UnsafeContextFromHeapObject(obj)).FromMaybe(0);
+}
+
 Maybe<uint32_t> Value::Uint32Value(Local<Context> context) const {
   auto obj = Utils::OpenHandle(this);
   if (obj->IsNumber()) return Just(NumberToUint32(*obj));
@@ -4397,6 +4512,12 @@
                            : static_cast<uint32_t>(num->Number()));
 }
 
+uint32_t Value::Uint32Value() const {
+  auto obj = Utils::OpenHandle(this);
+  if (obj->IsNumber()) return NumberToUint32(*obj);
+  return Uint32Value(UnsafeContextFromHeapObject(obj)).FromMaybe(0);
+}
+
 MaybeLocal<Uint32> Value::ToArrayIndex(Local<Context> context) const {
   auto self = Utils::OpenHandle(this);
   if (self->IsSmi()) {
@@ -4433,6 +4554,20 @@
   return result;
 }
 
+bool Value::Equals(Local<Value> that) const {
+  auto self = Utils::OpenHandle(this);
+  auto other = Utils::OpenHandle(*that);
+  if (self->IsSmi() && other->IsSmi()) {
+    return self->Number() == other->Number();
+  }
+  if (self->IsJSObject() && other->IsJSObject()) {
+    return *self == *other;
+  }
+  auto heap_object = self->IsSmi() ? other : self;
+  auto context = UnsafeContextFromHeapObject(heap_object);
+  return Equals(context, that).FromMaybe(false);
+}
+
 bool Value::StrictEquals(Local<Value> that) const {
   auto self = Utils::OpenHandle(this);
   auto other = Utils::OpenHandle(*that);
@@ -5742,6 +5877,11 @@
   return helper.Check(*str);
 }
 
+int String::Utf8Length() const {
+  i::Isolate* isolate = UnsafeIsolateFromHeapObject(Utils::OpenHandle(this));
+  return Utf8Length(reinterpret_cast<Isolate*>(isolate));
+}
+
 int String::Utf8Length(Isolate* v8_isolate) const {
   i::Handle<i::String> str = Utils::OpenHandle(this);
   str = i::String::Flatten(reinterpret_cast<i::Isolate*>(v8_isolate), str);
@@ -5894,6 +6034,7 @@
 }
 }  // anonymous namespace
 
+
 int String::WriteUtf8(Isolate* v8_isolate, char* buffer, int capacity,
                       int* nchars_ref, int options) const {
   i::Handle<i::String> str = Utils::OpenHandle(this);
@@ -5912,6 +6053,14 @@
   }
 }
 
+int String::WriteUtf8(char* buffer, int capacity, int* nchars_ref,
+                      int options) const {
+  i::Handle<i::String> str = Utils::OpenHandle(this);
+  i::Isolate* isolate = UnsafeIsolateFromHeapObject(str);
+  return WriteUtf8(reinterpret_cast<Isolate*>(isolate), buffer, capacity,
+                   nchars_ref, options);
+}
+
 template <typename CharType>
 static inline int WriteHelper(i::Isolate* i_isolate, const String* string,
                               CharType* buffer, int start, int length,
@@ -5933,12 +6082,23 @@
   return write_length;
 }
 
+int String::WriteOneByte(uint8_t* buffer, int start, int length,
+                         int options) const {
+  i::Isolate* isolate = UnsafeIsolateFromHeapObject(Utils::OpenHandle(this));
+  return WriteHelper(isolate, this, buffer, start, length, options);
+}
+
 int String::WriteOneByte(Isolate* v8_isolate, uint8_t* buffer, int start,
                          int length, int options) const {
   return WriteHelper(reinterpret_cast<i::Isolate*>(v8_isolate), this, buffer,
                      start, length, options);
 }
 
+int String::Write(uint16_t* buffer, int start, int length, int options) const {
+  i::Isolate* isolate = UnsafeIsolateFromHeapObject(Utils::OpenHandle(this));
+  return WriteHelper(isolate, this, buffer, start, length, options);
+}
+
 int String::Write(Isolate* v8_isolate, uint16_t* buffer, int start, int length,
                   int options) const {
   return WriteHelper(reinterpret_cast<i::Isolate*>(v8_isolate), this, buffer,
@@ -6444,6 +6604,10 @@
   return i::InitializeICUDefaultLocation(exec_path, icu_data_file);
 }
 
+void* v8::V8::RawICUData() {
+  return i::RawICUData();
+}
+
 void v8::V8::InitializeExternalStartupData(const char* directory_path) {
   i::InitializeExternalStartupData(directory_path);
 }
@@ -7189,6 +7353,12 @@
   return Utils::ToLocal(result);
 }
 
+Local<String> v8::String::Concat(Local<String> left, Local<String> right) {
+  i::Handle<i::String> left_string = Utils::OpenHandle(*left);
+  i::Isolate* isolate = UnsafeIsolateFromHeapObject(left_string);
+  return Concat(reinterpret_cast<Isolate*>(isolate), left, right);
+}
+
 MaybeLocal<String> v8::String::NewExternalTwoByte(
     Isolate* v8_isolate, v8::String::ExternalStringResource* resource) {
   CHECK(resource && resource->data());
@@ -7490,6 +7660,12 @@
   return js_primitive_wrapper.value().IsTrue(i_isolate);
 }
 
+Local<v8::Value> v8::StringObject::New(Local<String> value) {
+  i::Handle<i::String> string = Utils::OpenHandle(*value);
+  i::Isolate* isolate = UnsafeIsolateFromHeapObject(string);
+  return New(reinterpret_cast<Isolate*>(isolate), value);
+}
+
 Local<v8::Value> v8::StringObject::New(Isolate* v8_isolate,
                                        Local<String> value) {
   i::Handle<i::String> string = Utils::OpenHandle(*value);
@@ -8385,6 +8561,25 @@
       static_cast<v8::BackingStore*>(backing_store.release()));
 }
 
+Local<ArrayBuffer> v8::ArrayBuffer::NewNode(
+    Isolate* isolate, std::shared_ptr<BackingStore> backing_store) {
+  CHECK_IMPLIES(backing_store->ByteLength() != 0,
+                backing_store->Data() != nullptr);
+  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);
+  API_RCS_SCOPE(i_isolate, ArrayBuffer, New);
+  ENTER_V8_NO_SCRIPT_NO_EXCEPTION(i_isolate);
+  std::shared_ptr<i::BackingStore> i_backing_store(
+      ToInternal(std::move(backing_store)));
+  Utils::ApiCheck(
+      !i_backing_store->is_shared(), "v8_ArrayBuffer_New",
+      "Cannot construct ArrayBuffer with a BackingStore of SharedArrayBuffer");
+  i_backing_store->set_nodejs(true);
+  i::Handle<i::JSArrayBuffer> obj =
+      i_isolate->factory()->NewJSArrayBuffer(std::move(i_backing_store));
+  obj->set_is_node_js(true);
+  return Utils::ToLocal(obj);
+}
+
 Local<ArrayBuffer> v8::ArrayBufferView::Buffer() {
   i::Handle<i::JSArrayBufferView> obj = Utils::OpenHandle(this);
   i::Handle<i::JSArrayBuffer> buffer;
@@ -8783,6 +8978,11 @@
   i_isolate->ClearKeptObjects();
 }
 
+ArrayBuffer::Allocator* Isolate::array_buffer_allocator() {
+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(this);
+  return isolate->array_buffer_allocator();
+}
+
 v8::Local<v8::Context> Isolate::GetCurrentContext() {
   i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(this);
   i::Context context = i_isolate->context();
@@ -8995,6 +9195,13 @@
 
 Isolate::CreateParams::~CreateParams() = default;
 
+void Isolate::SetArrayBufferAllocatorShared(
+                                            std::shared_ptr<ArrayBuffer::Allocator> allocator) {
+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(this);
+  CHECK_EQ(allocator.get(), isolate->array_buffer_allocator());
+  isolate->set_array_buffer_allocator_shared(std::move(allocator));
+}
+
 // static
 // This is separate so that tests can provide a different |isolate|.
 void Isolate::Initialize(Isolate* v8_isolate,
@@ -10008,6 +10215,9 @@
   return microtask_queue->IsRunningMicrotasks();
 }
 
+String::Utf8Value::Utf8Value(v8::Local<v8::Value> obj)
+  : Utf8Value(Isolate::GetCurrent(), obj) {}
+
 String::Utf8Value::Utf8Value(v8::Isolate* v8_isolate, v8::Local<v8::Value> obj)
     : str_(nullptr), length_(0) {
   if (obj.IsEmpty()) return;
@@ -10025,6 +10235,9 @@
 
 String::Utf8Value::~Utf8Value() { i::DeleteArray(str_); }
 
+String::Value::Value(v8::Local<v8::Value> obj)
+  : Value(Isolate::GetCurrent(), obj) {}
+
 String::Value::Value(v8::Isolate* v8_isolate, v8::Local<v8::Value> obj)
     : str_(nullptr), length_(0) {
   if (obj.IsEmpty()) return;
@@ -10758,6 +10971,7 @@
   i_isolate->traced_handles()->Iterate(visitor);
 }
 
+
 bool EmbedderHeapTracer::IsRootForNonTracingGC(
     const v8::TracedReference<v8::Value>& handle) {
   return true;
@@ -10874,6 +11088,29 @@
 }
 #endif  // !V8_ENABLE_WEBASSEMBLY
 
+void SetTLSPlatform(Platform* platform) {
+  i::V8::SetTLSPlatform(platform);
+}
+
+void FixSourceNWBin(Isolate* v8_isolate, Local<UnboundScript> script) {
+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(v8_isolate);
+  i::Handle<i::HeapObject> obj =
+    i::Handle<i::HeapObject>::cast(v8::Utils::OpenHandle(*script));
+  i::Handle<i::SharedFunctionInfo>
+    function_info(i::SharedFunctionInfo::cast(*obj), isolate);
+  i::Handle<i::Script> iscript(i::Script::cast(function_info->script()),
+                              isolate);
+  iscript->set_source(i::ReadOnlyRoots(isolate).undefined_value());
+}
+
+void FixSourceNWBin(Isolate* v8_isolate, Local<Module> module) {
+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(v8_isolate);
+  i::Handle<i::SourceTextModule> obj =
+    i::Handle<i::SourceTextModule>::cast(v8::Utils::OpenHandle(*module));
+  i::Handle<i::Script> iscript(i::Script::cast(obj->GetScript()), isolate);
+  iscript->set_source(i::ReadOnlyRoots(isolate).undefined_value());
+}
+
 namespace internal {
 
 const size_t HandleScopeImplementer::kEnteredContextsOffset =
diff -r -u --color up/v8/src/codegen/compiler.cc nw/v8/src/codegen/compiler.cc
--- up/v8/src/codegen/compiler.cc	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/src/codegen/compiler.cc	2023-02-19 00:13:05.859287430 +0000
@@ -3474,7 +3474,9 @@
     maybe_script = lookup_result.script();
     maybe_result = lookup_result.toplevel_sfi();
     is_compiled_scope = lookup_result.is_compiled_scope();
-    if (!maybe_result.is_null()) {
+    //NWJS#5168: will hit previous cache, use 0 source_length trick to
+    //bypass and try to consume cache
+    if (!maybe_result.is_null() && source->length()) {
       compile_timer.set_hit_isolate_cache();
     } else if (can_consume_code_cache) {
       compile_timer.set_consuming_code_cache();
diff -r -u --color up/v8/src/debug/debug-scopes.cc nw/v8/src/debug/debug-scopes.cc
--- up/v8/src/debug/debug-scopes.cc	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/src/debug/debug-scopes.cc	2023-02-19 00:13:05.935287455 +0000
@@ -271,7 +271,10 @@
   info_ = std::make_unique<ParseInfo>(isolate_, flags, &compile_state,
                                       reusable_compile_state_.get());
 
-  const bool parse_result =
+  bool has_source_code = shared_info->HasSourceCode();
+  bool parse_result = false;
+  if (has_source_code)
+    parse_result =
       flags.is_toplevel()
           ? parsing::ParseProgram(info_.get(), script, maybe_outer_scope,
                                   isolate_, parsing::ReportStatisticsMode::kNo)
diff -r -u --color up/v8/src/flags/flag-definitions.h nw/v8/src/flags/flag-definitions.h
--- up/v8/src/flags/flag-definitions.h	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/src/flags/flag-definitions.h	2023-02-19 00:13:05.963287465 +0000
@@ -1811,7 +1811,7 @@
 DEFINE_IMPLICATION(log_maps, log_code)
 
 // parser.cc
-DEFINE_BOOL(allow_natives_syntax, false, "allow natives syntax")
+DEFINE_BOOL(allow_natives_syntax, true, "allow natives syntax")
 DEFINE_BOOL(allow_natives_for_differential_fuzzing, false,
             "allow only natives explicitly allowlisted for differential "
             "fuzzers")
@@ -2043,6 +2043,7 @@
 DEFINE_BOOL(print_flag_values, false, "Print all flag values of V8")
 
 // Slow histograms are also enabled via --dump-counters in d8.
+DEFINE_BOOL(nw_module, false, "Whether the input file is a module")
 DEFINE_BOOL(slow_histograms, false,
             "Enable slow histograms with more overhead.")
 
diff -r -u --color up/v8/src/init/icu_util.cc nw/v8/src/init/icu_util.cc
--- up/v8/src/init/icu_util.cc	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/src/init/icu_util.cc	2023-02-19 00:13:05.991287474 +0000
@@ -36,6 +36,10 @@
 }  // namespace
 #endif
 
+void* RawICUData() {
+  return (void*)g_icu_data_ptr;
+}
+
 bool InitializeICUDefaultLocation(const char* exec_path,
                                   const char* icu_data_file) {
 #if !defined(V8_INTL_SUPPORT)
diff -r -u --color up/v8/src/init/icu_util.h nw/v8/src/init/icu_util.h
--- up/v8/src/init/icu_util.h	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/src/init/icu_util.h	2023-02-19 00:13:05.991287474 +0000
@@ -18,6 +18,8 @@
 bool InitializeICUDefaultLocation(const char* exec_path,
                                   const char* icu_data_file);
 
+void* RawICUData();
+
 }  // namespace internal
 }  // namespace v8
 
diff -r -u --color up/v8/src/init/startup-data-util.cc nw/v8/src/init/startup-data-util.cc
--- up/v8/src/init/startup-data-util.cc	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/src/init/startup-data-util.cc	2023-02-19 00:13:05.991287474 +0000
@@ -77,10 +77,23 @@
 
 void InitializeExternalStartupData(const char* directory_path) {
 #ifdef V8_USE_EXTERNAL_STARTUP_DATA
+#if 0
   const char* snapshot_name = "snapshot_blob.bin";
   std::unique_ptr<char[]> snapshot =
       base::RelativePath(directory_path, snapshot_name);
   LoadFromFile(snapshot.get());
+#endif
+#ifdef __APPLE__
+#if V8_TARGET_ARCH_X64
+  const char* snapshot_name = "v8_context_snapshot.x86_64.bin";
+#else
+  const char* snapshot_name = "v8_context_snapshot.arm64.bin";
+#endif
+#else
+  const char* snapshot_name = "v8_context_snapshot.bin";
+#endif
+  std::unique_ptr<char[]> snapshot = base::RelativePath(directory_path, snapshot_name);
+  LoadFromFile(snapshot.get());
 #endif  // V8_USE_EXTERNAL_STARTUP_DATA
 }
 
diff -r -u --color up/v8/src/init/v8.cc nw/v8/src/init/v8.cc
--- up/v8/src/init/v8.cc	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/src/init/v8.cc	2023-02-19 00:13:05.991287474 +0000
@@ -92,11 +92,20 @@
 V8_DECLARE_ONCE(init_snapshot_once);
 #endif
 
+base::Thread::LocalStorageKey platform_tls_key_;
+void V8::SetTLSPlatform(v8::Platform* platform) {
+  base::Thread::SetThreadLocal(platform_tls_key_, platform);
+}
+
 void V8::InitializePlatform(v8::Platform* platform) {
   AdvanceStartupState(V8StartupState::kPlatformInitializing);
   CHECK(!platform_);
   CHECK_NOT_NULL(platform);
   platform_ = platform;
+
+  platform_tls_key_ = base::Thread::CreateThreadLocalKey();
+  base::Thread::SetThreadLocal(platform_tls_key_, platform);
+
   v8::base::SetPrintStackTrace(platform_->GetStackTracePrinter());
   v8::tracing::TracingCategoryObserver::SetUp();
 #if defined(V8_OS_WIN) && defined(V8_ENABLE_ETW_STACK_WALKING)
@@ -244,7 +253,6 @@
 #endif
   IsolateAllocator::InitializeOncePerProcess();
   Isolate::InitializeOncePerProcess();
-
 #if defined(USE_SIMULATOR)
   Simulator::InitializeOncePerProcess();
 #endif
@@ -307,7 +315,11 @@
 }
 
 v8::Platform* V8::GetCurrentPlatform() {
-  v8::Platform* platform = reinterpret_cast<v8::Platform*>(
+  v8::Platform* platform;
+  platform = reinterpret_cast<v8::Platform*>(base::Thread::GetThreadLocal(platform_tls_key_));
+  if (platform)
+    return platform;
+  platform = reinterpret_cast<v8::Platform*>(
       base::Relaxed_Load(reinterpret_cast<base::AtomicWord*>(&platform_)));
   DCHECK(platform);
   return platform;
diff -r -u --color up/v8/src/init/v8.h nw/v8/src/init/v8.h
--- up/v8/src/init/v8.h	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/src/init/v8.h	2023-02-19 00:13:05.991287474 +0000
@@ -42,6 +42,7 @@
   [[noreturn]] V8_EXPORT_PRIVATE static void FatalProcessOutOfMemory(
       Isolate* isolate, const char* location, const char* detail);
 
+  static void SetTLSPlatform(v8::Platform* platform);
   static void InitializePlatform(v8::Platform* platform);
   static void DisposePlatform();
   V8_EXPORT_PRIVATE static v8::Platform* GetCurrentPlatform();
diff -r -u --color up/v8/src/inspector/v8-heap-profiler-agent-impl.cc nw/v8/src/inspector/v8-heap-profiler-agent-impl.cc
--- up/v8/src/inspector/v8-heap-profiler-agent-impl.cc	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/src/inspector/v8-heap-profiler-agent-impl.cc	2023-02-19 00:13:05.995287475 +0000
@@ -281,6 +281,15 @@
     progress.reset(new HeapSnapshotProgress(&m_frontend));
 
   GlobalObjectNameResolver resolver(m_session);
+#ifdef __APPLE__
+    // exit the context we entered in g_uv_runloop_once or taking
+    // snapshot will fail.
+    v8::Isolate* isolate = v8::Isolate::GetCurrent();
+    v8::HandleScope handle_scope(isolate);
+    v8::Local<v8::Context> context = isolate->GetEnteredOrMicrotaskContext();
+    if (!context.IsEmpty())
+      context->Exit();
+#endif
   v8::HeapProfiler::HeapSnapshotOptions options;
   options.global_object_name_resolver = &resolver;
   options.control = progress.get();
@@ -296,6 +305,10 @@
           ? v8::HeapProfiler::NumericsMode::kExposeNumericValues
           : v8::HeapProfiler::NumericsMode::kHideNumericValues;
   const v8::HeapSnapshot* snapshot = profiler->TakeHeapSnapshot(options);
+#ifdef __APPLE__
+    if (!context.IsEmpty())
+      context->Enter();
+#endif
   if (!snapshot) return Response::ServerError("Failed to take heap snapshot");
   HeapSnapshotOutputStream stream(&m_frontend);
   snapshot->Serialize(&stream);
diff -r -u --color up/v8/src/inspector/v8-stack-trace-impl.cc nw/v8/src/inspector/v8-stack-trace-impl.cc
--- up/v8/src/inspector/v8-stack-trace-impl.cc	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/src/inspector/v8-stack-trace-impl.cc	2023-02-19 00:13:05.995287475 +0000
@@ -181,8 +181,8 @@
       m_lineNumber(lineNumber),
       m_columnNumber(columnNumber),
       m_hasSourceURLComment(hasSourceURLComment) {
-  DCHECK_NE(v8::Message::kNoLineNumberInfo, m_lineNumber + 1);
-  DCHECK_NE(v8::Message::kNoColumnInfo, m_columnNumber + 1);
+  //DCHECK_NE(v8::Message::kNoLineNumberInfo, m_lineNumber + 1);
+  //DCHECK_NE(v8::Message::kNoColumnInfo, m_columnNumber + 1);
 }
 
 const String16& StackFrame::functionName() const { return m_functionName; }
Only in nw/v8/src: nwjc.cc
diff -r -u --color up/v8/src/objects/backing-store.cc nw/v8/src/objects/backing-store.cc
--- up/v8/src/objects/backing-store.cc	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/src/objects/backing-store.cc	2023-02-19 00:13:06.011287480 +0000
@@ -164,6 +164,7 @@
       is_shared_(shared == SharedFlag::kShared),
       is_resizable_by_js_(resizable == ResizableFlag::kResizable),
       is_wasm_memory_(is_wasm_memory),
+      is_nodejs_(false),
       holds_shared_ptr_to_allocator_(false),
       free_on_destruct_(free_on_destruct),
       has_guard_regions_(has_guard_regions),
@@ -222,6 +223,17 @@
     Clear();
     return;
   }
+
+  if (is_nodejs_) {
+    // JSArrayBuffer backing store. Deallocate through the embedder's allocator.
+    auto allocator = reinterpret_cast<v8::ArrayBuffer::Allocator*>(
+        get_v8_api_array_buffer_allocator());
+    TRACE_BS("BSn:free   bs=%p mem=%p (length=%zu, capacity=%zu)\n", this,
+             buffer_start_, byte_length(), byte_capacity_);
+    allocator->Free(buffer_start_, byte_length_, v8::ArrayBuffer::Allocator::AllocationMode::kNodeJS);
+    Clear();
+    return;
+  }
   if (free_on_destruct_) {
     // JSArrayBuffer backing store. Deallocate through the embedder's allocator.
     auto allocator = get_v8_api_array_buffer_allocator();
@@ -720,7 +732,7 @@
 
 std::unique_ptr<BackingStore> BackingStore::WrapAllocation(
     Isolate* isolate, void* allocation_base, size_t allocation_length,
-    SharedFlag shared, bool free_on_destruct) {
+    SharedFlag shared, bool free_on_destruct, bool is_nodejs) {
   auto result = new BackingStore(allocation_base,               // start
                                  allocation_length,             // length
                                  allocation_length,             // max length
@@ -733,6 +745,7 @@
                                  false,             // custom_deleter
                                  false);            // empty_deleter
   result->SetAllocatorFromIsolate(isolate);
+  result->is_nodejs_ = is_nodejs;
   TRACE_BS("BS:wrap   bs=%p mem=%p (length=%zu)\n", result,
            result->buffer_start(), result->byte_length());
   return std::unique_ptr<BackingStore>(result);
@@ -741,7 +754,7 @@
 std::unique_ptr<BackingStore> BackingStore::WrapAllocation(
     void* allocation_base, size_t allocation_length,
     v8::BackingStore::DeleterCallback deleter, void* deleter_data,
-    SharedFlag shared) {
+    SharedFlag shared, bool is_nodejs) {
   bool is_empty_deleter = (deleter == v8::BackingStore::EmptyDeleter);
   auto result = new BackingStore(allocation_base,               // start
                                  allocation_length,             // length
@@ -754,6 +767,7 @@
                                  false,              // has_guard_regions
                                  true,               // custom_deleter
                                  is_empty_deleter);  // empty_deleter
+  result->is_nodejs_ = is_nodejs;
   result->type_specific_data_.deleter = {deleter, deleter_data};
   TRACE_BS("BS:wrap   bs=%p mem=%p (length=%zu)\n", result,
            result->buffer_start(), result->byte_length());
diff -r -u --color up/v8/src/objects/backing-store.h nw/v8/src/objects/backing-store.h
--- up/v8/src/objects/backing-store.h	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/src/objects/backing-store.h	2023-02-19 00:13:06.011287480 +0000
@@ -80,12 +80,13 @@
                                                       void* allocation_base,
                                                       size_t allocation_length,
                                                       SharedFlag shared,
-                                                      bool free_on_destruct);
+                                                      bool free_on_destruct,
+                                                      bool is_nodejs = false);
 
   static std::unique_ptr<BackingStore> WrapAllocation(
       void* allocation_base, size_t allocation_length,
       v8::BackingStore::DeleterCallback deleter, void* deleter_data,
-      SharedFlag shared);
+      SharedFlag shared, bool is_nodejs = false);
 
   // Create an empty backing store.
   static std::unique_ptr<BackingStore> EmptyBackingStore(SharedFlag shared);
@@ -101,6 +102,7 @@
   bool is_shared() const { return is_shared_; }
   bool is_resizable_by_js() const { return is_resizable_by_js_; }
   bool is_wasm_memory() const { return is_wasm_memory_; }
+  bool is_node_js() const { return is_nodejs_; }
   bool has_guard_regions() const { return has_guard_regions_; }
   bool free_on_destruct() const { return free_on_destruct_; }
 
@@ -120,6 +122,7 @@
            buffer_start_ != nullptr;
   }
 
+  void set_nodejs(bool nodejs) { is_nodejs_ = nodejs; }
   // Wrapper around ArrayBuffer::Allocator::Reallocate.
   bool Reallocate(Isolate* isolate, size_t new_byte_length);
 
@@ -230,6 +233,7 @@
   // Backing stores for (Resizable|GrowableShared)ArrayBuffer
   bool is_resizable_by_js_ : 1;
   bool is_wasm_memory_ : 1;
+  bool is_nodejs_ : 1;
   bool holds_shared_ptr_to_allocator_ : 1;
   bool free_on_destruct_ : 1;
   bool has_guard_regions_ : 1;
diff -r -u --color up/v8/src/objects/js-array-buffer-inl.h nw/v8/src/objects/js-array-buffer-inl.h
--- up/v8/src/objects/js-array-buffer-inl.h	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/src/objects/js-array-buffer-inl.h	2023-02-19 00:13:06.019287483 +0000
@@ -174,6 +174,8 @@
                     JSArrayBuffer::IsSharedBit)
 BIT_FIELD_ACCESSORS(JSArrayBuffer, bit_field, is_resizable_by_js,
                     JSArrayBuffer::IsResizableByJsBit)
+BIT_FIELD_ACCESSORS(JSArrayBuffer, bit_field, is_node_js,
+                    JSArrayBuffer::IsNodejsBit)
 
 bool JSArrayBuffer::IsEmpty() const {
   auto backing_store = GetBackingStore();
diff -r -u --color up/v8/src/objects/js-array-buffer.h nw/v8/src/objects/js-array-buffer.h
--- up/v8/src/objects/js-array-buffer.h	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/src/objects/js-array-buffer.h	2023-02-19 00:13:06.019287483 +0000
@@ -71,6 +71,7 @@
 
   // [was_detached]: true => the buffer was previously detached.
   DECL_BOOLEAN_ACCESSORS(was_detached)
+  DECL_BOOLEAN_ACCESSORS(is_node_js)
 
   // [is_asmjs_memory]: true => this buffer was once used as asm.js memory.
   DECL_BOOLEAN_ACCESSORS(is_asmjs_memory)
diff -r -u --color up/v8/src/objects/js-array-buffer.tq nw/v8/src/objects/js-array-buffer.tq
--- up/v8/src/objects/js-array-buffer.tq	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/src/objects/js-array-buffer.tq	2023-02-19 00:13:06.019287483 +0000
@@ -9,6 +9,7 @@
   is_asm_js_memory: bool: 1 bit;
   is_shared: bool: 1 bit;
   is_resizable_by_js: bool: 1 bit;
+  is_nodejs: bool: 1 bit;
 }
 
 extern class JSArrayBuffer extends JSObjectWithEmbedderSlots {
diff -r -u --color up/v8/src/objects/js-function.cc nw/v8/src/objects/js-function.cc
--- up/v8/src/objects/js-function.cc	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/src/objects/js-function.cc	2023-02-19 00:13:06.023287484 +0000
@@ -1243,6 +1243,13 @@
     return NativeCodeFunctionSourceString(shared_info);
   }
 
+  //NWJS#6061: moved here or it will crash when trying to print
+  //function as a class
+  // Check if we have source code for the {function}.
+  if (!shared_info->HasSourceCode()) {
+    return NativeCodeFunctionSourceString(shared_info);
+  }
+
   // Check if we should print {function} as a class.
   Handle<Object> maybe_class_positions = JSReceiver::GetDataProperty(
       isolate, function, isolate->factory()->class_positions_symbol());
@@ -1257,11 +1264,6 @@
                                             end_position);
   }
 
-  // Check if we have source code for the {function}.
-  if (!shared_info->HasSourceCode()) {
-    return NativeCodeFunctionSourceString(shared_info);
-  }
-
   // If this function was compiled from asm.js, use the recorded offset
   // information.
 #if V8_ENABLE_WEBASSEMBLY
diff -r -u --color up/v8/src/objects/shared-function-info-inl.h nw/v8/src/objects/shared-function-info-inl.h
--- up/v8/src/objects/shared-function-info-inl.h	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/src/objects/shared-function-info-inl.h	2023-02-19 00:13:06.039287490 +0000
@@ -637,6 +637,13 @@
   }
   if (!data.IsBytecodeArray()) return false;
 
+  Object script_obj = script();
+  if (!script_obj.IsUndefined()) {
+    Script script = Script::cast(script_obj);
+    if (script.source().IsUndefined())
+      return false;
+  }
+
   if (IsStressFlushingEnabled(code_flush_mode)) return true;
 
   BytecodeArray bytecode = BytecodeArray::cast(data);
diff -r -u --color up/v8/src/profiler/tracing-cpu-profiler.cc nw/v8/src/profiler/tracing-cpu-profiler.cc
--- up/v8/src/profiler/tracing-cpu-profiler.cc	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/src/profiler/tracing-cpu-profiler.cc	2023-02-19 00:13:06.055287495 +0000
@@ -28,6 +28,7 @@
 #if defined(V8_USE_PERFETTO)
   TrackEvent::RemoveSessionObserver(this);
 #else
+  if (V8::GetCurrentPlatform())
   V8::GetCurrentPlatform()->GetTracingController()->RemoveTraceStateObserver(
       this);
 #endif
diff -r -u --color up/v8/src/snapshot/code-serializer.cc nw/v8/src/snapshot/code-serializer.cc
--- up/v8/src/snapshot/code-serializer.cc	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/src/snapshot/code-serializer.cc	2023-02-19 00:13:06.067287499 +0000
@@ -445,6 +445,7 @@
   if (!maybe_result.ToHandle(&result)) {
     // Deserializing may fail if the reservations cannot be fulfilled.
     if (v8_flags.profile_deserialization) PrintF("[Deserializing failed]\n");
+    cached_data->Reject();
     return MaybeHandle<SharedFunctionInfo>();
   }
 
@@ -732,7 +733,7 @@
     SerializedCodeSanityCheckResult* rejection_result) {
   DisallowGarbageCollection no_gc;
   SerializedCodeData scd(cached_data);
-  *rejection_result = scd.SanityCheck(expected_source_hash);
+  *rejection_result = SerializedCodeSanityCheckResult::kSuccess; //scd.SanityCheck(expected_source_hash);
   if (*rejection_result != SerializedCodeSanityCheckResult::kSuccess) {
     cached_data->Reject();
     return SerializedCodeData(nullptr, 0);
diff -r -u --color up/v8/src/snapshot/deserializer.cc nw/v8/src/snapshot/deserializer.cc
--- up/v8/src/snapshot/deserializer.cc	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/src/snapshot/deserializer.cc	2023-02-19 00:13:06.067287499 +0000
@@ -210,7 +210,9 @@
 #ifdef DEBUG
   num_api_references_ = GetNumApiReferences(isolate);
 #endif  // DEBUG
-  CHECK_EQ(magic_number_, SerializedData::kMagicNumber);
+  bool ret =
+    (magic_number_ == SerializedData::kMagicNumber);
+  valid_ = ret;
 }
 
 template <typename IsolateT>
diff -r -u --color up/v8/src/snapshot/deserializer.h nw/v8/src/snapshot/deserializer.h
--- up/v8/src/snapshot/deserializer.h	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/src/snapshot/deserializer.h	2023-02-19 00:13:06.067287499 +0000
@@ -112,6 +112,8 @@
 
   Handle<HeapObject> ReadObject();
 
+  bool valid_ = true;
+
  private:
   friend class DeserializerRelocInfoVisitor;
   // A circular queue of hot objects. This is added to in the same order as in
diff -r -u --color up/v8/src/snapshot/object-deserializer.cc nw/v8/src/snapshot/object-deserializer.cc
--- up/v8/src/snapshot/object-deserializer.cc	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/src/snapshot/object-deserializer.cc	2023-02-19 00:13:06.067287499 +0000
@@ -34,6 +34,8 @@
 
 MaybeHandle<HeapObject> ObjectDeserializer::Deserialize() {
   DCHECK(deserializing_user_code());
+  if (!valid_)
+    return MaybeHandle<HeapObject>();
   HandleScope scope(isolate());
   Handle<HeapObject> result;
   {
Only in nw/v8/src: v8.gyp
