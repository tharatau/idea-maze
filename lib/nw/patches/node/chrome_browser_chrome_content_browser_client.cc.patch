diff -r -u --color up/chromium/chrome/browser/chrome_content_browser_client.cc nw/chromium/chrome/browser/chrome_content_browser_client.cc
--- up/chromium/chrome/browser/chrome_content_browser_client.cc	2023-02-21 19:03:23.000000000 +0000
+++ nw/chromium/chrome/browser/chrome_content_browser_client.cc	2023-02-24 20:12:03.100809566 +0000
@@ -1,8 +1,11 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wunreachable-code"
 
 #include "chrome/browser/chrome_content_browser_client.h"
+#include "content/browser/renderer_host/render_process_host_impl.h"
+#include "components/crash/core/app/crash_reporter_client.h"
 
 #include <algorithm>
 #include <iterator>
@@ -12,6 +15,12 @@
 #include <utility>
 #include <vector>
 
+#include "content/nw/src/common/nw_content_common_hooks.h"
+#include "content/nw/src/common/shell_switches.h"
+#include "content/nw/src/nw_content.h"
+#include "content/nw/src/nw_base.h"
+#include "chrome/browser/profiles/profile_manager.h"
+
 #include "base/base_switches.h"
 #include "base/bind.h"
 #include "base/callback.h"
@@ -575,6 +584,7 @@
 #include "extensions/browser/extension_navigation_throttle.h"
 #include "extensions/browser/extension_protocols.h"
 #include "extensions/browser/extension_registry.h"
+#include "chrome/browser/extensions/extension_service.h"
 #include "extensions/browser/extension_util.h"
 #include "extensions/browser/guest_view/web_view/web_view_guest.h"
 #include "extensions/browser/guest_view/web_view/web_view_permission_helper.h"
@@ -669,7 +679,7 @@
 #endif
 
 // This should be after all other #includes.
-#if defined(_WINDOWS_)  // Detect whether windows.h was included.
+#if 0 //defined(_WINDOWS_)  // Detect whether windows.h was included.
 #include "base/win/windows_h_disallowed.h"
 #endif  // defined(_WINDOWS_)
 
@@ -967,7 +977,7 @@
   base::PathService::Get(chrome::DIR_CRASH_DUMPS, &dumps_path);
   {
     ANNOTATE_SCOPED_MEMORY_LEAK;
-    bool upload = !getenv(env_vars::kHeadless);
+    bool upload = !crash_reporter::GetCrashReporterClient()->IsRunningUnattended();
     breakpad::CrashHandlerHostLinux* crash_handler =
         new breakpad::CrashHandlerHostLinux(process_type, dumps_path, upload);
     crash_handler->StartUploaderThread();
@@ -1043,8 +1053,7 @@
  public:
   explicit CertificateReportingServiceCertReporter(
       content::WebContents* web_contents)
-      : service_(CertificateReportingServiceFactory::GetForBrowserContext(
-            web_contents->GetBrowserContext())) {}
+     {}
 
   CertificateReportingServiceCertReporter(
       const CertificateReportingServiceCertReporter&) = delete;
@@ -1056,15 +1065,16 @@
   // SSLCertReporter implementation
   void ReportInvalidCertificateChain(
       const std::string& serialized_report) override {
-    service_->Send(serialized_report);
+    //service_->Send(serialized_report);
   }
 
  private:
-  raw_ptr<CertificateReportingService> service_;
+  //raw_ptr<CertificateReportingService> service_;
 };
 
 #if BUILDFLAG(ENABLE_EXTENSIONS)
 
+#if 0
 AppLoadedInTabSource ClassifyAppLoadedInTabSource(
     const GURL& opener_url,
     const extensions::Extension* target_platform_app) {
@@ -1089,6 +1099,7 @@
   // Source was a different page inside the app.
   return APP_LOADED_IN_TAB_SOURCE_APP;
 }
+#endif
 
 // Returns true if there is is an extension matching `url` in
 // `render_process_id` with `permission`.
@@ -2036,6 +2047,24 @@
   return true;
 }
 
+bool ChromeContentBrowserClient::IsNWOrigin(const url::Origin& origin, content::BrowserContext* context) {
+  return IsNWURL(origin.GetURL(), context);
+}
+
+bool ChromeContentBrowserClient::IsNWURL(const GURL& url, content::BrowserContext* context) {
+  const extensions::ExtensionRegistry* registry =
+    extensions::ExtensionRegistry::Get(context);
+  const extensions::Extension* extension =
+    registry->enabled_extensions().GetByID(nw::GetMainExtensionId());
+  if (!extension)
+    return false;
+  if (url.SchemeIs(extensions::kExtensionScheme) && url.host() == nw::GetMainExtensionId())
+    return true;
+  if (extension->web_extent().MatchesURL(url))
+    return true;
+  return false;
+}
+
 bool ChromeContentBrowserClient::ShouldTreatURLSchemeAsFirstPartyWhenTopLevel(
     base::StringPiece scheme,
     bool is_embedded_origin_secure) {
@@ -2294,12 +2323,31 @@
 bool ChromeContentBrowserClient::ShouldTryToUseExistingProcessHost(
     content::BrowserContext* browser_context,
     const GURL& url) {
+  // PDF extension should use new process, or there is a loop of IPC
+  // message BrowserPluginHostMsg_SetFocus and InputMsg_SetFocus
+  // #4335
+
+  if (url.SchemeIs(extensions::kExtensionScheme)) {
+    if (url.host() == nw::GetMainExtensionId() && !content::RenderProcessHostImpl::main_host())
+      return false; //other extensions could load before the main
+                    //extension NWJS#5483
+    if (url.host() == extension_misc::kPdfExtensionId)
+      return false;
+  } else if (url.SchemeIs(content::kGuestScheme))
+    return false;
+
+  if (nw::PinningRenderer())
+    return true;
+  else
+    return false;
+#if 0
   // Top Chrome WebUI should try to share a RenderProcessHost with other
   // existing Top Chrome WebUI.
   if (IsTopChromeWebUIURL(url))
     return true;
 
   return false;
+#endif
 }
 
 bool ChromeContentBrowserClient::ShouldEmbeddedFramesTryToReuseExistingProcess(
@@ -2373,9 +2421,11 @@
 ChromeContentBrowserClient::GetOriginsRequiringDedicatedProcess() {
   std::vector<url::Origin> isolated_origin_list;
 
+#if 0
   if (DoesGaiaOriginRequireDedicatedProcess()) {
     isolated_origin_list.push_back(GaiaUrls::GetInstance()->gaia_origin());
   }
+#endif
 
 #if BUILDFLAG(ENABLE_EXTENSIONS)
   auto origins_from_extensions = ChromeContentBrowserClientExtensionsPart::
@@ -2636,7 +2686,10 @@
                                   homedir.value().c_str());
 #endif
 
+  command_line->AppendSwitchPath(switches::kNWAppPath, nw::package()->path());
   if (process_type == switches::kRendererProcess) {
+    command_line->AppendSwitch(switches::kNWJS);
+
     content::RenderProcessHost* process =
         content::RenderProcessHost::FromID(child_process_id);
     Profile* profile =
@@ -2826,6 +2879,7 @@
 
     // Please keep this in alphabetical order.
     static const char* const kSwitchNames[] = {
+      switches::kEnableSpellChecking,
       autofill::switches::kIgnoreAutocompleteOffForAutofill,
       autofill::switches::kShowAutofillSignatures,
 #if BUILDFLAG(IS_CHROMEOS_ASH)
@@ -2982,6 +3036,9 @@
 }
 
 gfx::ImageSkia ChromeContentBrowserClient::GetDefaultFavicon() {
+  gfx::ImageSkia* icon = nw::GetAppIcon();
+  if (icon)
+    return *icon;
   return favicon::GetDefaultFavicon().AsImageSkia();
 }
 
@@ -3109,6 +3166,20 @@
 #endif
 }
 
+base::FilePath ChromeContentBrowserClient::GetRootPath() {
+  std::string id = nw::GetMainExtensionId();
+  base::FilePath path;
+  extensions::ExtensionRegistry* extension_registry =
+    extensions::ExtensionRegistry::Get(ProfileManager::GetLastUsedProfileIfLoaded());
+  if (extension_registry) {
+    const extensions::Extension* extension =
+      extension_registry->GetExtensionById(id, extensions::ExtensionRegistry::EVERYTHING);
+    if (extension)
+      path = extension->path();
+  }
+  return path;
+}
+
 void ChromeContentBrowserClient::AllowWorkerFileSystem(
     const GURL& url,
     content::BrowserContext* browser_context,
@@ -3724,12 +3795,18 @@
   DCHECK(profile);
   *no_javascript_access = false;
 
+  auto* registry = extensions::ExtensionRegistry::Get(profile);
+  if (registry) {
+    const Extension* extension =
+        registry->enabled_extensions().GetExtensionOrAppByURL(opener_url);
+    if (extension && extension->is_nwjs_app())
+      return true;
+  }
   // If the opener is trying to create a background window but doesn't have
   // the appropriate permission, fail the attempt.
   if (container_type == content::mojom::WindowContainerType::BACKGROUND) {
 #if BUILDFLAG(ENABLE_EXTENSIONS)
     auto* process_map = extensions::ProcessMap::Get(profile);
-    auto* registry = extensions::ExtensionRegistry::Get(profile);
     if (!URLHasExtensionPermission(process_map, registry, opener_url,
                                    opener->GetProcess()->GetID(),
                                    APIPermissionID::kBackground)) {
@@ -3760,10 +3837,12 @@
   if (target_url.SchemeIs(extensions::kExtensionScheme)) {
     // Intentionally duplicating |registry| code from above because we want to
     // reduce calls to retrieve them as this function is a SYNC IPC handler.
-    auto* registry = extensions::ExtensionRegistry::Get(profile);
     const Extension* extension =
         registry->enabled_extensions().GetExtensionOrAppByURL(target_url);
     if (extension && extension->is_platform_app()) {
+#if 1
+      return true;
+#else
       UMA_HISTOGRAM_ENUMERATION(
           "Extensions.AppLoadedInTab",
           ClassifyAppLoadedInTabSource(opener_url, extension),
@@ -3771,6 +3850,7 @@
 
       // window.open() may not be used to load v2 apps in a regular tab.
       return false;
+#endif
     }
   }
 #endif
@@ -4142,7 +4222,7 @@
       web_contents->GetPrimaryMainFrame()->GetSiteInstance()->GetSiteURL(),
       web_contents, GetWebTheme());
 
-  web_prefs->translate_service_available = TranslateService::IsAvailable(prefs);
+  web_prefs->translate_service_available = false; //TranslateService::IsAvailable(prefs);
 
   absl::optional<ui::CaptionStyle> style =
       captions::GetCaptionStyleFromUserSettings(prefs,
@@ -4175,6 +4255,8 @@
 
   for (ChromeContentBrowserClientParts* parts : extra_parts_)
     parts->OverrideWebkitPrefs(web_contents, web_prefs);
+
+  nw::OverrideWebkitPrefsHook(web_contents, web_prefs);
 }
 
 bool ChromeContentBrowserClientParts::OverrideWebPreferencesAfterNavigation(
@@ -4962,6 +5044,7 @@
       &throttles);
 #endif
 
+#if 0
   // g_browser_process->safe_browsing_service() may be null in unittests.
   safe_browsing::SafeBrowsingUIManager* ui_manager =
       g_browser_process->safe_browsing_service()
@@ -4977,6 +5060,7 @@
         std::make_unique<safe_browsing::DelayedWarningNavigationThrottle>(
             handle));
   }
+#endif
 
 #if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_MAC) || BUILDFLAG(IS_LINUX)
   MaybeAddThrottle(browser_switcher::BrowserSwitcherNavigationThrottle::
@@ -5636,9 +5720,9 @@
   // gets approval from ChildProcessSecurityPolicy. Keep this logic in sync with
   // ExtensionWebContentsObserver::RenderFrameCreated.
   Manifest::Type type = extension->GetType();
-  if ((type == Manifest::TYPE_EXTENSION ||
+  if (type == Manifest::TYPE_NWJS_APP || ((type == Manifest::TYPE_EXTENSION ||
        type == Manifest::TYPE_LEGACY_PACKAGED_APP) &&
-      extensions::util::AllowFileAccess(extension->id(), browser_context)) {
+      extensions::util::AllowFileAccess(extension->id(), browser_context))) {
     factories->emplace(
         url::kFileScheme,
         SpecialAccessFileURLLoaderFactory::Create(render_process_id));
@@ -6464,6 +6548,9 @@
     bool safe_browsing_enabled_for_profile,
     bool should_check_on_sb_disabled,
     const std::vector<std::string>& allowlist_domains) {
+#if 1
+  return nullptr;
+#else
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
 
   // Should not bypass safe browsing check if the check is for enterprise
@@ -6486,6 +6573,7 @@
   }
 
   return safe_browsing_url_checker_delegate_;
+#endif
 }
 
 safe_browsing::RealTimeUrlLookupServiceBase*
@@ -6493,6 +6581,7 @@
     content::BrowserContext* browser_context,
     bool is_enterprise_lookup_enabled,
     bool is_consumer_lookup_enabled) {
+#if 0
   // |safe_browsing_service_| may be unavailable in tests.
   if (!safe_browsing_service_) {
     return nullptr;
@@ -6511,6 +6600,7 @@
     return safe_browsing::RealTimeUrlLookupServiceFactory::GetForProfile(
         profile);
   }
+#endif
   return nullptr;
 }
 
