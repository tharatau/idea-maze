diff -r -u --color up/chromium/extensions/browser/guest_view/web_view/web_view_guest.cc nw/chromium/extensions/browser/guest_view/web_view/web_view_guest.cc
--- up/chromium/extensions/browser/guest_view/web_view/web_view_guest.cc	2023-02-21 19:03:23.000000000 +0000
+++ nw/chromium/extensions/browser/guest_view/web_view/web_view_guest.cc	2023-02-24 20:54:13.716489595 +0000
@@ -4,7 +4,14 @@
 
 #include "extensions/browser/guest_view/web_view/web_view_guest.h"
 
+#include "content/nw/src/nw_content.h"
+#include "content/public/common/content_client.h"
+#include "content/public/browser/content_browser_client.h"
+
 #include <stddef.h>
+#include "content/nw/src/nw_content.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/common/manifest_handlers/webview_info.h"
 
 #include <map>
 #include <memory>
@@ -314,6 +321,7 @@
   std::string storage_partition_id;
   bool persist_storage = false;
   ParsePartitionParam(create_params, &storage_partition_id, &persist_storage);
+
   // Validate that the partition id coming from the renderer is valid UTF-8,
   // since we depend on this in other parts of the code, such as FilePath
   // creation. If the validation fails, treat it as a bad message and kill the
@@ -758,6 +766,7 @@
     : GuestView<WebViewGuest>(owner_web_contents),
       rules_registry_id_(RulesRegistryService::kInvalidRulesRegistryID),
       find_helper_(this),
+      allow_nw_(false),
       javascript_dialog_helper_(this),
       web_view_guest_delegate_(base::WrapUnique(
           ExtensionsAPIClient::Get()->CreateWebViewGuestDelegate(this))),
@@ -1166,6 +1175,11 @@
   if (allow_scaling)
     SetAllowScaling(*allow_scaling);
 
+  absl::optional<bool> allow_nw = params.FindBool(webview::kAttributeAllowNW);
+  if (allow_nw) {
+    allow_nw_ = *allow_nw;
+  }
+
   // Check for a pending zoom from before the first navigation.
   pending_zoom_factor_ = params.FindDouble(webview::kInitialZoomFactor)
                              .value_or(pending_zoom_factor_);
@@ -1289,11 +1303,14 @@
   }
   const url::Origin& owner_origin =
       owner_web_contents()->GetPrimaryMainFrame()->GetLastCommittedOrigin();
+  bool owner_is_nwjs =
+    content::GetContentClient()->browser()->IsNWOrigin(owner_origin, browser_context());
   const bool base_in_owner_origin = owner_origin.IsSameOriginWith(base_url);
   // |base_url| must be a valid URL. It is also limited to URLs that the owner
   // is trusted to have control over.
   if (!base_url.is_valid() ||
-      (!base_url.SchemeIsHTTPOrHTTPS() && !base_in_owner_origin)) {
+      (!base_url.SchemeIsHTTPOrHTTPS() && !base_in_owner_origin &&
+       !owner_is_nwjs)) {
     base::SStringPrintf(error, webview::kAPILoadDataInvalidBaseURL,
                         base_url.possibly_invalid_spec().c_str());
     return false;
@@ -1417,7 +1434,8 @@
                                       int opener_render_frame_id,
                                       const std::string& frame_name,
                                       const GURL& target_url,
-                                      WebContents* new_contents) {
+                                      WebContents* new_contents,
+                                      const std::u16string& nw_window_manifest) {
   // The `new_contents` is the one we just created in CreateNewGuestWindow.
   auto* guest = WebViewGuest::FromWebContents(new_contents);
   CHECK(guest);
@@ -1469,6 +1487,17 @@
           base::Unretained(web_contents)));
 }
 
+bool WebViewGuest::CanLoadFileSubresource(const GURL& url) {
+  GURL test_file_url("file:///");
+  const Extension* extension =
+      ExtensionRegistry::Get(browser_context())->enabled_extensions().GetByID(owner_host());
+  if (extension && WebviewInfo::IsURLWebviewAccessible(extension,
+                                                       GetPartitionID(web_contents()->GetRenderViewHost()->GetProcess()),
+                                                       test_file_url))
+    return true;
+  return false;
+}
+
 void WebViewGuest::LoadURLWithParams(const GURL& url,
                                      const content::Referrer& referrer,
                                      ui::PageTransition transition_type,
@@ -1485,6 +1514,16 @@
        !url.SchemeIs(url::kAboutScheme)) ||
       url.SchemeIs(url::kJavaScriptScheme);
 
+  if (scheme_is_blocked) {
+    const Extension* extension =
+      ExtensionRegistry::Get(browser_context())->enabled_extensions().GetByID(owner_host());
+    if (extension && WebviewInfo::IsURLWebviewAccessible(extension,
+                                                         GetPartitionID(web_contents()->GetRenderViewHost()->GetProcess()),
+                                                         url)) {
+      scheme_is_blocked = false;
+    }
+  }
+    
   // Do not allow navigating a guest to schemes other than known safe schemes.
   // This will block the embedder trying to load unwanted schemes, e.g.
   // chrome://.
@@ -1517,7 +1556,9 @@
     load_url_params.override_user_agent =
         content::NavigationController::UA_OVERRIDE_TRUE;
   }
+  nw::SetInWebViewApplyAttr(true, allow_nw_);
   GetController().LoadURLWithParams(load_url_params);
+  nw::SetInWebViewApplyAttr(false, allow_nw_);
 }
 
 void WebViewGuest::RequestNewWindowPermission(
@@ -1597,6 +1638,21 @@
   SetFullscreenState(allowed);
 }
 
+void WebViewGuest::ShowDevTools(bool show, int proc_id, int guest_id) {
+  if (proc_id > 0 && guest_id >= 0) {
+    auto* that =
+      WebViewGuest::FromInstanceID(owner_web_contents()->GetRenderViewHost()->GetProcess()->GetID(),
+                         guest_id);
+    nw::ShowDevtools(show, web_contents(), that->web_contents());
+    return;
+  }
+  nw::ShowDevtools(show, web_contents());
+}
+
+void WebViewGuest::InspectElement(int x, int y) {
+  nw::InspectElement(web_contents(), x, y);
+}
+
 bool WebViewGuest::GuestMadeEmbedderFullscreen() const {
   return last_fullscreen_permission_was_allowed_by_embedder_ &&
          is_embedder_fullscreen_;
