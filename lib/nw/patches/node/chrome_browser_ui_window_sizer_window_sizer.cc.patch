diff -r -u --color up/chromium/chrome/browser/ui/window_sizer/window_sizer.cc nw/chromium/chrome/browser/ui/window_sizer/window_sizer.cc
--- up/chromium/chrome/browser/ui/window_sizer/window_sizer.cc	2023-02-15 18:46:36.000000000 +0000
+++ nw/chromium/chrome/browser/ui/window_sizer/window_sizer.cc	2023-02-24 06:16:22.712169002 +0000
@@ -1,10 +1,11 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
-
+#pragma clang diagnostic ignored "-Wunreachable-code"
 #include "chrome/browser/ui/window_sizer/window_sizer.h"
 
 #include <algorithm>
+#include "content/nw/src/nw_base.h"
 #include <utility>
 
 #include "base/command_line.h"
@@ -69,6 +70,8 @@
     if (!browser_ || !browser_->profile()->GetPrefs())
       return false;
 
+    if (browser_->is_type_popup() && browser_->windows_key().empty())
+      return false;
     const base::Value::Dict* pref =
         chrome::GetWindowPlacementDictionaryReadOnly(
             chrome::GetWindowName(browser_), browser_->profile()->GetPrefs());
@@ -78,6 +81,8 @@
         RectFromPrefixedPref(pref, "work_area_");
     absl::optional<bool> maximized =
         pref ? pref->FindBool("maximized") : absl::nullopt;
+    absl::optional<bool> fullscreen =
+        pref ? pref->FindBool("fullscreen") : absl::nullopt;
 
     if (!pref_bounds || !maximized)
       return false;
@@ -87,6 +92,8 @@
       *work_area = pref_area.value();
     if (*show_state == ui::SHOW_STATE_DEFAULT && maximized.value())
       *show_state = ui::SHOW_STATE_MAXIMIZED;
+    if (*show_state == ui::SHOW_STATE_DEFAULT && fullscreen && fullscreen.value())
+      *show_state = ui::SHOW_STATE_FULLSCREEN;
 
     return true;
   }
@@ -195,7 +202,7 @@
 WindowSizer::~WindowSizer() = default;
 
 // static
-void WindowSizer::GetBrowserWindowBoundsAndShowState(
+bool WindowSizer::GetBrowserWindowBoundsAndShowState(
     const gfx::Rect& specified_bounds,
     const Browser* browser,
     gfx::Rect* window_bounds,
@@ -208,7 +215,7 @@
 #if !BUILDFLAG(IS_LINUX)
 // Linux has its own implementation, see WindowSizerLinux.
 // static
-void WindowSizer::GetBrowserWindowBoundsAndShowState(
+bool WindowSizer::GetBrowserWindowBoundsAndShowState(
     std::unique_ptr<StateProvider> state_provider,
     const gfx::Rect& specified_bounds,
     const Browser* browser,
@@ -224,26 +231,34 @@
   // Pre-populate the window state with our default.
   *show_state = GetWindowDefaultShowState(browser);
   *bounds = specified_bounds;
-  sizer.DetermineWindowBoundsAndShowState(specified_bounds, bounds, show_state);
+  return sizer.DetermineWindowBoundsAndShowState(specified_bounds, bounds, show_state);
 }
 #endif  // !BUILDFLAG(IS_LINUX)
 
-void WindowSizer::DetermineWindowBoundsAndShowState(
+bool WindowSizer::DetermineWindowBoundsAndShowState(
     const gfx::Rect& specified_bounds,
     gfx::Rect* bounds,
     ui::WindowShowState* show_state) {
-  if (bounds->IsEmpty()) {
+  // In upstream, non empty case is only used in chrome tests, so we ignore it.
+  // In NW, the non empty value is the API parameter passed by browser->override_bounds()
+  // Use this strategy as the central place to determine window size
+  // priority: saved > API parameter > default in manifest > default value
+  if (true || bounds->IsEmpty()) {
     // See if there's last active window's placement information.
     if (GetLastActiveWindowBounds(bounds, show_state))
-      return;
+      return false;
+    gfx::Rect saved;
     // See if there's saved placement information.
-    if (GetSavedWindowBounds(bounds, show_state))
-      return;
-
+    if (GetSavedWindowBounds(&saved, show_state)) {
+      *bounds = saved;
+      return true;
+    }
+    if (!bounds->IsEmpty())
+      return false;
     // No saved placement, figure out some sensible default size based on
     // the user's screen size.
     *bounds = GetDefaultWindowBounds(GetDisplayForNewWindow());
-    return;
+    return false;
   }
 
   // In case that there was a bound given we need to make sure that it is
@@ -259,6 +274,7 @@
 
   // Resize so that it fits.
   bounds->AdjustToFit(work_area);
+  return false;
 }
 
 void WindowSizer::AdjustWorkAreaForPlatform(gfx::Rect& work_area) {}
@@ -297,6 +313,15 @@
     const display::Display& display) const {
   gfx::Rect work_area = display.work_area();
 
+  int default_width = 800;
+  int default_height = 600;
+  nw::Package* package = nw::package();
+  if (package && package->window()) {
+    default_width = package->window()->FindInt("width").value_or(800);
+    default_height = package->window()->FindInt("height").value_or(600);
+  }
+
+#if 0
   // The default size is either some reasonably wide width, or if the work
   // area is narrower, then the work area width less some aesthetic padding.
   int default_width = std::min(work_area.width() - 2 * kWindowTilePixels,
@@ -324,9 +349,10 @@
         1.5 * kWindowTilePixels);
   }
 #endif  // !BUILDFLAG(IS_MAC)
+#endif
   return gfx::Rect(kWindowTilePixels + work_area.x(),
-                   kWindowTilePixels + work_area.y(), default_width,
-                   default_height);
+                   kWindowTilePixels + work_area.y(),
+                   default_width, default_height);
 }
 
 void WindowSizer::AdjustBoundsToBeVisibleOnDisplay(
