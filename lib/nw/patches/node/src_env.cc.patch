diff -r -u --color up/node/src/env.cc nw/node/src/env.cc
--- up/node/src/env.cc	2023-02-20 19:32:04.000000000 +0000
+++ nw/node/src/env.cc	2023-02-25 19:08:13.822006732 +0000
@@ -60,6 +60,8 @@
 using v8::Value;
 using worker::Worker;
 
+extern bool node_is_nwjs;
+
 int const ContextEmbedderTag::kNodeContextTag = 0x6e6f64;
 void* const ContextEmbedderTag::kNodeContextTagPtr = const_cast<void*>(
     static_cast<const void*>(&ContextEmbedderTag::kNodeContextTag));
@@ -689,8 +691,8 @@
         isolate_data->worker_context()->env()->builtin_loader());
   } else if (isolate_data->snapshot_data() != nullptr) {
     // ... otherwise, if a snapshot was provided, use its code cache.
-    builtin_loader()->RefreshCodeCache(
-        isolate_data->snapshot_data()->code_cache);
+    //builtin_loader()->RefreshCodeCache(
+    //    isolate_data->snapshot_data()->code_cache);
   }
 
   // We'll be creating new objects so make sure we've entered the context.
@@ -728,16 +730,19 @@
   inspector_agent_ = std::make_unique<inspector::Agent>(this);
 #endif
 
+#if 0
   if (tracing::AgentWriterHandle* writer = GetTracingAgentWriter()) {
     trace_state_observer_ = std::make_unique<TrackingTraceStateObserver>(this);
     if (TracingController* tracing_controller = writer->GetTracingController())
       tracing_controller->AddTraceStateObserver(trace_state_observer_.get());
   }
+#endif
 
   destroy_async_id_list_.reserve(512);
 
   performance_state_ = std::make_unique<performance::PerformanceState>(
       isolate, MAYBE_FIELD_PTR(env_info, performance_state));
+#if 0
 
   if (*TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(
           TRACING_CATEGORY_NODE1(environment)) != 0) {
@@ -754,12 +759,13 @@
                                       "args",
                                       std::move(traced_value));
   }
+#endif
 }
 
 void Environment::InitializeMainContext(Local<Context> context,
                                         const EnvSerializeInfo* env_info) {
   principal_realm_ = std::make_unique<Realm>(
-      this, context, MAYBE_FIELD_PTR(env_info, principal_realm));
+     this, context, MAYBE_FIELD_PTR(env_info, principal_realm), node_is_nwjs);
   AssignToContext(context, principal_realm_.get(), ContextInfo(""));
   if (env_info != nullptr) {
     DeserializeProperties(env_info);
@@ -860,6 +866,7 @@
 void Environment::InitializeLibuv() {
   HandleScope handle_scope(isolate());
   Context::Scope context_scope(context());
+  uv_initialized_ = true;
 
   CHECK_EQ(0, uv_timer_init(event_loop(), timer_handle()));
   uv_unref(reinterpret_cast<uv_handle_t*>(timer_handle()));
@@ -1263,7 +1270,7 @@
 }
 
 void Environment::ToggleImmediateRef(bool ref) {
-  if (started_cleanup_) return;
+  if (started_cleanup_|| !uv_initialized_) return;
 
   if (ref) {
     // Idle handle is needed only to stop the event loop from blocking in poll.
