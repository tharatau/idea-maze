diff -r -u --color up/chromium/extensions/browser/api/app_window/app_window_api.cc nw/chromium/extensions/browser/api/app_window/app_window_api.cc
--- up/chromium/extensions/browser/api/app_window/app_window_api.cc	2023-02-15 18:46:36.000000000 +0000
+++ nw/chromium/extensions/browser/api/app_window/app_window_api.cc	2023-02-24 06:16:28.984540146 +0000
@@ -4,6 +4,8 @@
 
 #include "extensions/browser/api/app_window/app_window_api.h"
 
+#include "ui/display/display_export.h"
+
 #include <memory>
 #include <utility>
 
@@ -41,9 +43,15 @@
 #include "ui/gfx/geometry/rect.h"
 #include "url/gurl.h"
 
+#include "content/nw/src/nw_base.h"
+#include "content/nw/src/browser/nw_content_browser_hooks.h"
+
 namespace app_window = extensions::api::app_window;
 namespace Create = app_window::Create;
 
+namespace content {
+  DISPLAY_EXPORT extern bool g_support_transparency;
+}
 namespace extensions {
 
 namespace app_window_constants {
@@ -59,8 +67,8 @@
     "The $1 property cannot be specified for both inner and outer bounds.";
 constexpr char kAlwaysOnTopPermission[] =
     "The \"app.window.alwaysOnTop\" permission is required.";
-constexpr char kInvalidUrlParameter[] =
-    "The URL used for window creation must be local for security reasons.";
+//constexpr char kInvalidUrlParameter[] =
+//    "The URL used for window creation must be local for security reasons.";
 constexpr char kAlphaEnabledWrongChannel[] =
     "The alphaEnabled option requires dev channel or newer.";
 constexpr char kAlphaEnabledMissingPermission[] =
@@ -153,6 +161,10 @@
   // to allow component apps to open chrome URLs (e.g. for the settings page
   // on ChromeOS).
   GURL absolute = GURL(params->url);
+
+  if (absolute.has_scheme())
+    url = absolute;
+#if 0
   if (absolute.has_scheme()) {
     if (extension()->location() == mojom::ManifestLocation::kComponent &&
         absolute.SchemeIs(content::kChromeUIScheme)) {
@@ -162,13 +174,27 @@
       return RespondNow(Error(app_window_constants::kInvalidUrlParameter));
     }
   }
-
+#endif
   // TODO(jeremya): figure out a way to pass the opening WebContents through to
   // AppWindow::Create so we can set the opener at create time rather than
   // with a hack in AppWindowCustomBindings::GetView().
   AppWindow::CreateParams create_params;
   absl::optional<app_window::CreateWindowOptions>& options = params->options;
   if (options) {
+    if (options->title)
+      create_params.title = *options->title;
+
+    if (options->icon) {
+      base::ScopedAllowBlocking allow_io;
+      gfx::Image app_icon;
+      nw::Package* package = nw::package();
+      if (nw::GetPackageImage(package,
+                              base::FilePath::FromUTF8Unsafe(*options->icon),
+                              &app_icon)) {
+        create_params.icon = app_icon;
+      }
+    }
+
     if (options->id) {
       // TODO(mek): use URL if no id specified?
       // Limit length of id to 256 characters.
@@ -304,6 +330,8 @@
 #else
       // Transparency is only supported on Aura.
       // Fallback to creating an opaque window (by ignoring alphaEnabled).
+      if (content::g_support_transparency)
+        create_params.alpha_enabled = *options->alpha_enabled;
 #endif
     }
 
@@ -351,6 +379,23 @@
       }
     }
 
+    if (options->show_in_taskbar) {
+      create_params.show_in_taskbar = *options->show_in_taskbar;
+    }
+
+    if (options->new_instance) {
+      create_params.new_instance = *options->new_instance;
+    }
+
+    if (options->inject_js_start) {
+      create_params.inject_js_start =
+          *options->inject_js_start;
+    }
+    if (options->inject_js_end) {
+      create_params.inject_js_end =
+          *options->inject_js_end;
+    }
+
     switch (options->state) {
       case app_window::STATE_NONE:
       case app_window::STATE_NORMAL:
@@ -384,9 +429,23 @@
     action_type = options->lock_screen_action;
     create_params.show_on_lock_screen = true;
   }
+  switch (options->position) {
+  case app_window::POSITION_NONE:
+    create_params.position = extensions::AppWindow::POS_NONE;
+    break;
+  case app_window::POSITION_CENTER:
+    create_params.position = extensions::AppWindow::POS_CENTER;
+    break;
+  case app_window::POSITION_MOUSE:
+    create_params.position = extensions::AppWindow::POS_MOUSE;
+    break;
+  }
 
   create_params.creator_process_id = source_process_id();
 
+  if (create_params.new_instance)
+    nw::SetPinningRenderer(false);
+
   AppWindow* app_window = nullptr;
   if (action_type == api::app_runtime::ACTION_TYPE_NONE) {
     app_window =
@@ -405,11 +464,17 @@
   app_window->Init(url, std::make_unique<AppWindowContentsImpl>(app_window),
                    render_frame_host(), create_params);
 
+  if (create_params.new_instance)
+    nw::SetPinningRenderer(true);
+
   if (ExtensionsBrowserClient::Get()->IsRunningInForcedAppMode() &&
       !app_window->is_ime_window()) {
     app_window->ForcedFullscreen();
   }
 
+  if (options && options->kiosk)
+    app_window->ForcedFullscreen();
+
   content::RenderFrameHost* created_frame =
       app_window->web_contents()->GetPrimaryMainFrame();
   int frame_id = MSG_ROUTING_NONE;
@@ -424,12 +489,15 @@
 
   if (AppWindowRegistry::Get(browser_context())
           ->HadDevToolsAttached(app_window->web_contents())) {
-    AppWindowClient::Get()->OpenDevToolsWindow(
+    base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
+    if (!command_line->HasSwitch("skip-reopen-app-devtools")) {
+      AppWindowClient::Get()->OpenDevToolsWindow(
         app_window->web_contents(),
         base::BindOnce(&AppWindowCreateFunction::Respond, this,
                        std::move(result_arg)));
     // OpenDevToolsWindow might have already responded.
     return did_respond() ? AlreadyResponded() : RespondLater();
+    }
   }
 
   // Delay sending the response until the newly created window has finished its
