diff -r -u --color up/chromium/chrome/app/chrome_exe_main_win.cc nw/chromium/chrome/app/chrome_exe_main_win.cc
--- up/chromium/chrome/app/chrome_exe_main_win.cc	2023-02-15 18:46:36.000000000 +0000
+++ nw/chromium/chrome/app/chrome_exe_main_win.cc	2023-02-24 06:16:19.267965043 +0000
@@ -70,6 +70,7 @@
 // process) created before MainDllLoader changes the current working directory
 // to the browser's version directory.
 void SetCwdForBrowserProcess() {
+#if 0
   if (!::IsBrowserProcess())
     return;
 
@@ -82,7 +83,9 @@
   base::SetCurrentDirectory(
       base::FilePath(base::FilePath::StringPieceType(&buffer[0], length))
           .DirName());
+#endif
 }
+#if 0
 
 bool IsFastStartSwitch(const std::string& command_line_switch) {
   return command_line_switch == switches::kProfileDirectory;
@@ -114,6 +117,7 @@
     return false;
   return chrome::AttemptToNotifyRunningChrome(chrome) == chrome::NOTIFY_SUCCESS;
 }
+#endif
 
 // Returns true if |command_line| contains a /prefetch:# argument where # is in
 // [1, 8].
@@ -229,8 +233,8 @@
     const uint8_t** chrome_100_pak,
     const uint8_t** chrome_200_pak) {
   *resources_pak = kSha256_resources_pak.data();
-  *chrome_100_pak = kSha256_chrome_100_percent_pak.data();
-  *chrome_200_pak = kSha256_chrome_200_percent_pak.data();
+  *chrome_100_pak = kSha256_nw_100_percent_pak.data();
+  *chrome_200_pak = kSha256_nw_200_percent_pak.data();
 }
 
 #if !defined(WIN_CONSOLE_APP)
@@ -282,7 +286,6 @@
 
   SetCwdForBrowserProcess();
   install_static::InitializeFromPrimaryModule();
-  SignalInitializeCrashReporting();
   if (IsBrowserProcess())
     chrome::DisableDelayLoadFailureHooksForMainExecutable();
 #if defined(ARCH_CPU_32_BITS)
@@ -325,9 +328,15 @@
          HasValidWindowsPrefetchArgument(*command_line));
 
   if (process_type == crash_reporter::switches::kCrashpadHandler) {
+    // HACK: Let Windows know that we have started.  This is needed to suppress
+    // the IDC_APPSTARTING cursor from being displayed for a prolonged period
+    // while a subprocess is starting. NWJS#4685
+    PostThreadMessage(GetCurrentThreadId(), WM_NULL, 0, 0);
+    MSG msg;
+    PeekMessage(&msg, NULL, 0, 0, PM_REMOVE);
+
     // Check if we should monitor the exit code of this process
     std::unique_ptr<browser_watcher::ExitCodeWatcher> exit_code_watcher;
-
     crash_reporter::SetupFallbackCrashHandling(*command_line);
     // no-periodic-tasks is specified for self monitoring crashpad instances.
     // This is to ensure we are a crashpad process monitoring the browser
@@ -380,8 +389,10 @@
   // The exit manager is in charge of calling the dtors of singletons.
   base::AtExitManager exit_manager;
 
+#if 0 //FIXME(nwjs)
   if (AttemptFastNotify(*command_line))
     return 0;
+#endif
 
   RemoveAppCompatFlagsEntry();
 
