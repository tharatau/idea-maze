diff -r -u --color up/chromium/chrome/common/chrome_paths_mac.mm nw/chromium/chrome/common/chrome_paths_mac.mm
--- up/chromium/chrome/common/chrome_paths_mac.mm	2023-02-15 18:46:36.000000000 +0000
+++ nw/chromium/chrome/common/chrome_paths_mac.mm	2023-02-24 06:16:22.872178477 +0000
@@ -19,6 +19,8 @@
 #include "chrome/common/chrome_constants.h"
 #include "chrome/common/chrome_paths_internal.h"
 
+#include "content/nw/src/nw_base.h"
+
 namespace {
 
 // Return a retained (NOT autoreleased) NSBundle* as the internal
@@ -59,7 +61,7 @@
 #if BUILDFLAG(GOOGLE_CHROME_BRANDING)
       product_dir_name = "Google/Chrome";
 #else
-      product_dir_name = "Chromium";
+    product_dir_name = "nwjs";
 #endif
     }
 
@@ -69,6 +71,7 @@
   }
 }
 
+#if 0
 // ProductDirName returns the name of the directory inside
 // ~/Library/Application Support that should hold the product application
 // data. This can be overridden by setting the CrProductDirName key in the
@@ -90,6 +93,7 @@
       ProductDirNameForBundle(chrome::OuterAppBundle());
   return std::string(product_dir_name);
 }
+#endif
 
 bool GetDefaultUserDataDirectoryForProduct(const std::string& product_dir,
                                            base::FilePath* result) {
@@ -106,7 +110,7 @@
 namespace chrome {
 
 bool GetDefaultUserDataDirectory(base::FilePath* result) {
-  return GetDefaultUserDataDirectoryForProduct(ProductDirName(), result);
+  return GetDefaultUserDataDirectoryForProduct(nw::package()->GetName(), result);
 }
 
 bool GetUserDocumentsDirectory(base::FilePath* result) {
