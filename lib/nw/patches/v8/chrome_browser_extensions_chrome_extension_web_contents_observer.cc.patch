diff -r -u --color up/chromium/chrome/browser/extensions/chrome_extension_web_contents_observer.cc nw/chromium/chrome/browser/extensions/chrome_extension_web_contents_observer.cc
--- up/chromium/chrome/browser/extensions/chrome_extension_web_contents_observer.cc	2023-02-15 18:46:36.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/chrome_extension_web_contents_observer.cc	2023-02-24 06:16:20.996067378 +0000
@@ -29,13 +29,47 @@
 #include "extensions/common/switches.h"
 #include "third_party/blink/public/common/chrome_debug_urls.h"
 
+#include "components/zoom/zoom_controller.h"
+#include "content/public/browser/web_contents.h"
+
+using content::BrowserContext;
+
 namespace extensions {
 
 ChromeExtensionWebContentsObserver::ChromeExtensionWebContentsObserver(
     content::WebContents* web_contents)
     : ExtensionWebContentsObserver(web_contents),
       content::WebContentsUserData<ChromeExtensionWebContentsObserver>(
-          *web_contents) {}
+          *web_contents) {
+  // Since ZoomController is also a WebContentsObserver, we need to be careful
+  // about disconnecting from it since the relative order of destruction of
+  // WebContentsObservers is not guaranteed. ZoomController silently clears
+  // its ZoomObserver list during WebContentsDestroyed() so there's no need
+  // to explicitly remove ourselves on destruction.
+  zoom::ZoomController* zoom_controller =
+      zoom::ZoomController::FromWebContents(web_contents);
+  // There may not always be a ZoomController, e.g. in tests.
+  if (zoom_controller)
+    zoom_controller->AddObserver(this);
+}
+
+void ChromeExtensionWebContentsObserver::OnZoomChanged(
+    const zoom::ZoomController::ZoomChangedEventData& data) {
+  ProcessManager* const process_manager = ProcessManager::Get(browser_context());
+  const Extension* const extension =
+      process_manager->GetExtensionForWebContents(web_contents());
+  if (extension) {
+    base::Value::List args;
+    args.Append(data.old_zoom_level);
+    args.Append(data.new_zoom_level);
+
+    content::RenderFrameHost* rfh = web_contents()->GetPrimaryMainFrame();
+    ExtensionWebContentsObserver::GetForWebContents(web_contents())
+      ->GetLocalFrame(rfh)
+      ->MessageInvoke(extension->id(), "nw.Window",
+                      "updateAppWindowZoom", std::move(args));
+  }
+}
 
 ChromeExtensionWebContentsObserver::~ChromeExtensionWebContentsObserver() {}
 
@@ -73,7 +107,8 @@
   // Components of chrome that are implemented as extensions or platform apps
   // are allowed to use chrome://resources/ and chrome://theme/ URLs.
   if ((extension->is_extension() || extension->is_platform_app()) &&
-      Manifest::IsComponentLocation(extension->location())) {
+      (Manifest::IsComponentLocation(extension->location()) ||
+       extension->is_nwjs_app())) {
     policy->GrantRequestOrigin(
         process_id, url::Origin::Create(GURL(blink::kChromeUIResourcesURL)));
     policy->GrantRequestOrigin(
@@ -86,6 +121,7 @@
   // never given access to Chrome APIs).
   if (extension->is_extension() ||
       extension->is_legacy_packaged_app() ||
+      extension->is_nwjs_app() ||
       (extension->is_platform_app() &&
        Manifest::IsComponentLocation(extension->location()))) {
     policy->GrantRequestOrigin(
