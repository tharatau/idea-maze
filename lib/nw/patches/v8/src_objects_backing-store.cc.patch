diff -r -u --color up/v8/src/objects/backing-store.cc nw/v8/src/objects/backing-store.cc
--- up/v8/src/objects/backing-store.cc	2023-02-10 19:02:29.000000000 +0000
+++ nw/v8/src/objects/backing-store.cc	2023-02-25 19:08:24.062056030 +0000
@@ -164,6 +164,7 @@
       is_shared_(shared == SharedFlag::kShared),
       is_resizable_by_js_(resizable == ResizableFlag::kResizable),
       is_wasm_memory_(is_wasm_memory),
+      is_nodejs_(false),
       holds_shared_ptr_to_allocator_(false),
       free_on_destruct_(free_on_destruct),
       has_guard_regions_(has_guard_regions),
@@ -222,6 +223,17 @@
     Clear();
     return;
   }
+
+  if (is_nodejs_) {
+    // JSArrayBuffer backing store. Deallocate through the embedder's allocator.
+    auto allocator = reinterpret_cast<v8::ArrayBuffer::Allocator*>(
+        get_v8_api_array_buffer_allocator());
+    TRACE_BS("BSn:free   bs=%p mem=%p (length=%zu, capacity=%zu)\n", this,
+             buffer_start_, byte_length(), byte_capacity_);
+    allocator->Free(buffer_start_, byte_length_, v8::ArrayBuffer::Allocator::AllocationMode::kNodeJS);
+    Clear();
+    return;
+  }
   if (free_on_destruct_) {
     // JSArrayBuffer backing store. Deallocate through the embedder's allocator.
     auto allocator = get_v8_api_array_buffer_allocator();
@@ -720,7 +732,7 @@
 
 std::unique_ptr<BackingStore> BackingStore::WrapAllocation(
     Isolate* isolate, void* allocation_base, size_t allocation_length,
-    SharedFlag shared, bool free_on_destruct) {
+    SharedFlag shared, bool free_on_destruct, bool is_nodejs) {
   auto result = new BackingStore(allocation_base,               // start
                                  allocation_length,             // length
                                  allocation_length,             // max length
@@ -733,6 +745,7 @@
                                  false,             // custom_deleter
                                  false);            // empty_deleter
   result->SetAllocatorFromIsolate(isolate);
+  result->is_nodejs_ = is_nodejs;
   TRACE_BS("BS:wrap   bs=%p mem=%p (length=%zu)\n", result,
            result->buffer_start(), result->byte_length());
   return std::unique_ptr<BackingStore>(result);
@@ -741,7 +754,7 @@
 std::unique_ptr<BackingStore> BackingStore::WrapAllocation(
     void* allocation_base, size_t allocation_length,
     v8::BackingStore::DeleterCallback deleter, void* deleter_data,
-    SharedFlag shared) {
+    SharedFlag shared, bool is_nodejs) {
   bool is_empty_deleter = (deleter == v8::BackingStore::EmptyDeleter);
   auto result = new BackingStore(allocation_base,               // start
                                  allocation_length,             // length
@@ -754,6 +767,7 @@
                                  false,              // has_guard_regions
                                  true,               // custom_deleter
                                  is_empty_deleter);  // empty_deleter
+  result->is_nodejs_ = is_nodejs;
   result->type_specific_data_.deleter = {deleter, deleter_data};
   TRACE_BS("BS:wrap   bs=%p mem=%p (length=%zu)\n", result,
            result->buffer_start(), result->byte_length());
