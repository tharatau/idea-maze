diff -r -u --color up/chromium/chrome/app/chrome_main_delegate.cc nw/chromium/chrome/app/chrome_main_delegate.cc
--- up/chromium/chrome/app/chrome_main_delegate.cc	2023-02-21 19:03:23.000000000 +0000
+++ nw/chromium/chrome/app/chrome_main_delegate.cc	2023-02-24 20:12:01.884797184 +0000
@@ -2,8 +2,13 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "chrome/common/chrome_constants.h"
 #include "chrome/app/chrome_main_delegate.h"
 
+#include "chrome/chrome_elf/chrome_elf_main.h"
+#include "base/files/file_util.h"
+#include "tools/v8_context_snapshot/buildflags.h"
+
 #include <stddef.h>
 
 #include <string>
@@ -98,6 +103,7 @@
 #include "ui/base/resource/scoped_startup_resource_bundle.h"
 #include "ui/base/ui_base_switches.h"
 
+#include "content/nw/src/nw_base.h"
 #if BUILDFLAG(IS_WIN)
 #include <malloc.h>
 
@@ -235,6 +241,16 @@
 #include "ui/base/resource/data_pack_with_resource_sharing_lacros.h"
 #endif
 
+#include "third_party/node-nw/src/node_webkit.h"
+#include "third_party/zlib/google/zip_reader.h"
+#include "base/native_library.h"
+#include "base/strings/utf_string_conversions.h"
+#if defined(OS_MAC)
+#include "base/mac/bundle_locations.h"
+#include "base/strings/sys_string_conversions.h"
+#endif
+
+
 base::LazyInstance<ChromeContentGpuClient>::DestructorAtExit
     g_chrome_content_gpu_client = LAZY_INSTANCE_INITIALIZER;
 base::LazyInstance<ChromeContentRendererClient>::DestructorAtExit
@@ -251,6 +267,13 @@
 const size_t ChromeMainDelegate::kNonWildcardDomainNonPortSchemesSize =
     std::size(kNonWildcardDomainNonPortSchemes);
 
+#if defined(COMPONENT_BUILD)
+CONTENT_EXPORT NodeStartFn g_node_start_fn;
+#else
+extern NodeStartFn g_node_start_fn;
+#endif
+SetBlobPathFn g_set_blob_path_fn = nullptr;
+
 namespace {
 
 #if BUILDFLAG(IS_CHROMEOS_LACROS)
@@ -526,7 +549,7 @@
 
 // Initializes the user data dir. Must be called before InitializeLocalState().
 void InitializeUserDataDir(base::CommandLine* command_line) {
-#if BUILDFLAG(IS_WIN)
+#if 0
   // Reach out to chrome_elf for the truth on the user data directory.
   // Note that in tests, this links to chrome_elf_test_stubs.
   wchar_t user_data_dir_buf[MAX_PATH], invalid_user_data_dir_buf[MAX_PATH];
@@ -563,10 +586,15 @@
     }
   }
 #endif  // BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
-#if BUILDFLAG(IS_MAC)
+#if BUILDFLAG(IS_MAC) || BUILDFLAG(IS_WIN)
   policy::path_parser::CheckUserDataDirPolicy(&user_data_dir);
 #endif  // BUILDFLAG(IS_MAC)
 
+  // On Windows, trailing separators leave Chrome in a bad state.
+  // See crbug.com/464616.
+  if (user_data_dir.EndsWithSeparator())
+    user_data_dir = user_data_dir.StripTrailingSeparators();
+
   const bool specified_directory_was_invalid =
       !user_data_dir.empty() &&
       !base::PathService::OverrideAndCreateIfNeeded(chrome::DIR_USER_DATA,
@@ -597,7 +625,7 @@
 
   // Append the fallback user data directory to the commandline. Otherwise,
   // child or service processes will attempt to use the invalid directory.
-  if (specified_directory_was_invalid)
+  //if (specified_directory_was_invalid)
     command_line->AppendSwitchPath(switches::kUserDataDir, user_data_dir);
 #endif  // BUILDFLAG(IS_WIN)
 }
@@ -1054,7 +1082,7 @@
   ash::BootTimesRecorder::Get()->SaveChromeMainStats();
 #endif
 
-  const base::CommandLine& command_line =
+  base::CommandLine& command_line =
       *base::CommandLine::ForCurrentProcess();
 
   // Only allow disabling web security via the command-line flag if the user has
@@ -1096,6 +1124,36 @@
 
   content::Profiling::ProcessStarted();
 
+  const base::CommandLine::StringVector& args = command_line.GetArgs();
+  if (args.size() > 0) {
+    zip::ZipReader reader;
+    base::FilePath fp(args[0]);
+    //LOG(WARNING) << "final extension: " << fp.FinalExtension();
+    if (!command_line.HasSwitch(switches::kProcessType) && fp.FinalExtension() == FILE_PATH_LITERAL(".js") &&
+        base::PathExists(fp) && !base::DirectoryExists(fp) && !reader.Open(fp)) {
+      base::NativeLibraryLoadError error;
+#if defined(OS_MAC)
+      base::FilePath node_dll_path = base::mac::FrameworkBundlePath().Append(base::FilePath::FromUTF8Unsafe(base::GetNativeLibraryName("node")));
+      std::string blob_path = base::mac::PathForFrameworkBundleResource(BUILDFLAG(V8_CONTEXT_SNAPSHOT_FILENAME)).AsUTF8Unsafe();
+#else
+      base::FilePath node_dll_path = base::FilePath::FromUTF8Unsafe(base::GetNativeLibraryName("node"));
+#endif
+      base::NativeLibrary node_dll = base::LoadNativeLibrary(node_dll_path, &error);
+      if(!node_dll)
+        LOG(FATAL) << "Failed to load node library (error: " << error.ToString() << ")";
+      else {
+#if defined(OS_MAC)
+        g_set_blob_path_fn = (SetBlobPathFn)base::GetFunctionPointerFromNativeLibrary(node_dll, "g_set_blob_path");
+        g_set_blob_path_fn(blob_path.c_str());
+#endif
+        g_node_start_fn = (NodeStartFn)base::GetFunctionPointerFromNativeLibrary(node_dll, "g_node_start");
+        return g_node_start_fn(command_line.argc0(), command_line.argv0());
+      }
+      return 0;
+    }
+  }
+
+
   // Setup tracing sampler profiler as early as possible at startup if needed.
   SetupTracing();
 
@@ -1259,6 +1317,26 @@
   // partially-initialized, which the TLS object is supposed to protect again.
   heap_profiling::InitTLSSlot();
 
+  std::wstring product_name, product_version;
+  std::string report_url;
+
+  nw::InitNWPackage();
+  std::string name = nw::package()->GetName();
+  std::string version;
+  product_name = std::wstring(name.begin(), name.end());
+  std::string* str = nw::package()->root()->FindString("version");
+  if (str)
+    version = *str;
+  product_version = std::wstring(version.begin(), version.end());
+#if defined(OS_WIN)
+  SignalInitializeCrashReporting(&product_name, &product_version);
+  str = nw::package()->root()->FindString("crash_report_url");
+  if (str) {
+    report_url = *str;
+    crash_reporter::CrashReporterClient* client = (crash_reporter::CrashReporterClient*)ElfGetReporterClient();
+    client->SetUploadDump(true);
+  }
+#endif
   return absl::nullopt;
 }
 
@@ -1333,7 +1411,39 @@
   ChromeCrashReporterClient::Create();
 #endif
 
+  std::string report_url;
+  std::string* str = nw::package()->root()->FindString("crash_report_url");
+  if (str) {
+    report_url = *str;
+#if !defined(OS_WIN)
+    crash_reporter::CrashReporterClient* client = crash_reporter::GetCrashReporterClient();
+    client->SetUploadDump(true);
+    client->product_name_ = nw::package()->GetName();
+    str = nw::package()->root()->FindString("version");
+    if (str)
+      client->product_version_ = *str;
+#endif
+  }
+
 #if BUILDFLAG(IS_MAC)
+  // On the Mac, the child executable lives at a predefined location within
+  // the app bundle's versioned directory.
+  std::string product_string;
+  str = nw::package()->root()->FindString("product_string");
+  if (str) {
+    product_string = *str;
+    std::string helperProcessExecutablePath = (product_string + " Helper.app/Contents/MacOS/" + product_string + " Helper");
+    base::PathService::Override(content::CHILD_PROCESS_EXE,
+                                chrome::GetFrameworkBundlePath()
+                                .Append("Helpers")
+                                .Append(helperProcessExecutablePath));
+  }else{
+    base::PathService::Override(content::CHILD_PROCESS_EXE,
+                                chrome::GetFrameworkBundlePath()
+                                .Append("Helpers")
+                                .Append(chrome::kHelperProcessExecutablePath));
+  }
+
   InitMacCrashReporter(command_line, process_type);
   SetUpInstallerPreferences(command_line);
 #endif
@@ -1400,7 +1510,7 @@
   }
 #endif  // BUILDFLAG(IS_CHROMEOS_LACROS)
 
-  // Register component_updater PathProvider after DIR_USER_DATA overridden by
+#if 1
   // command line flags. Maybe move the chrome PathProvider down here also?
   int alt_preinstalled_components_dir =
 #if BUILDFLAG(IS_CHROMEOS_ASH)
@@ -1411,6 +1521,7 @@
   component_updater::RegisterPathProvider(chrome::DIR_COMPONENTS,
                                           alt_preinstalled_components_dir,
                                           chrome::DIR_USER_DATA);
+#endif
 
 #if !BUILDFLAG(IS_ANDROID) && !BUILDFLAG(IS_WIN)
   // Android does InitLogging when library is loaded. Skip here.
@@ -1575,6 +1686,13 @@
   // line for crash reporting.
   crash_keys::SetCrashKeysFromCommandLine(command_line);
 
+#if 1 //!defined(OS_WIN)
+  if (!report_url.empty()) {
+    GURL url(report_url);
+    chrome_content_client_.SetNWReportURL(url);
+  }
+#endif
+
 #if BUILDFLAG(ENABLE_PDF)
   MaybePatchGdiGetFontData();
 #endif
