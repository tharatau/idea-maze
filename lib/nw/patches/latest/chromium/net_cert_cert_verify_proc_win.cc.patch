diff -r -u --color up/chromium/net/cert/cert_verify_proc_win.cc nw/chromium/net/cert/cert_verify_proc_win.cc
--- up/chromium/net/cert/cert_verify_proc_win.cc	2023-02-15 18:46:36.000000000 +0000
+++ nw/chromium/net/cert/cert_verify_proc_win.cc	2023-02-19 17:36:40.087475700 +0000
@@ -35,6 +35,7 @@
 #include "net/cert/test_root_certs.h"
 #include "net/cert/x509_certificate.h"
 #include "net/cert/x509_util_win.h"
+#include "net/cert/x509_util.h"
 
 #if !defined(CERT_TRUST_HAS_WEAK_SIGNATURE)
 // This was introduced in Windows 8 / Windows Server 2012, but retroactively
@@ -1061,7 +1062,7 @@
 CertVerifyProcWin::~CertVerifyProcWin() = default;
 
 bool CertVerifyProcWin::SupportsAdditionalTrustAnchors() const {
-  return false;
+  return true;
 }
 
 int CertVerifyProcWin::VerifyInternal(
@@ -1300,8 +1301,36 @@
 
   crypto::ScopedPCCERT_CHAIN_CONTEXT scoped_chain_context(chain_context);
 
+  DWORD errorStatus = chain_context->TrustStatus.dwErrorStatus;
+  bool skipPolicyCheck = false;
+  if (((errorStatus & CERT_TRUST_IS_UNTRUSTED_ROOT) || (errorStatus & (CERT_TRUST_IS_OFFLINE_REVOCATION | CERT_TRUST_REVOCATION_STATUS_UNKNOWN)))&&
+      !additional_trust_anchors.empty()) {
+    // check if the (untrusted) validated root is in the list of
+    // additional trust anchors
+    PCERT_SIMPLE_CHAIN first_chain = chain_context->rgpChain[0];
+    DWORD num_elements = first_chain->cElement;
+    if (num_elements >= 1) {
+      PCERT_CHAIN_ELEMENT* element = first_chain->rgpElement;
+      PCCERT_CONTEXT cert2 = element[num_elements - 1]->pCertContext;
+      for (size_t i=0; i<additional_trust_anchors.size(); i++) {
+	bssl::UniquePtr<CRYPTO_BUFFER> cert_handle(X509Certificate::CreateCertBufferFromBytes(base::as_bytes(base::make_span((const char*)(cert2->pbCertEncoded), cert2->cbCertEncoded))));
+        if (x509_util::CryptoBufferEqual(cert_handle.get(),
+            additional_trust_anchors[i]->cert_buffer())) {
+          LOG(INFO) << "Untrusted root \"" <<
+              additional_trust_anchors[i]->subject().GetDisplayName() <<
+              "\" found in additional anchors, assuming trusted.";
+          verify_result->is_issued_by_additional_trust_anchor = true;
+          errorStatus &= ~(CERT_TRUST_IS_UNTRUSTED_ROOT | CERT_TRUST_IS_OFFLINE_REVOCATION 
+            | CERT_TRUST_REVOCATION_STATUS_UNKNOWN | CERT_TRUST_IS_PARTIAL_CHAIN);
+          skipPolicyCheck = true;
+          break;
+        }
+      }
+    }
+  }
+
   verify_result->cert_status |= MapCertChainErrorStatusToCertStatus(
-      chain_context->TrustStatus.dwErrorStatus);
+      errorStatus);
 
   // Flag certificates that have a Subject common name with a NULL character.
   if (CertSubjectCommonNameHasNull(cert_list.get()))
@@ -1309,6 +1338,7 @@
 
   std::u16string hostname16 = base::ASCIIToUTF16(hostname);
 
+  if (!skipPolicyCheck) {
   SSL_EXTRA_CERT_CHAIN_POLICY_PARA extra_policy_para;
   memset(&extra_policy_para, 0, sizeof(extra_policy_para));
   extra_policy_para.cbSize = sizeof(extra_policy_para);
@@ -1341,6 +1371,7 @@
     verify_result->cert_status |= MapNetErrorToCertStatus(
         MapSecurityError(policy_status.dwError));
   }
+  }
 
   // Mask off revocation checking failures unless hard-fail revocation checking
   // for local anchors is enabled and the chain is issued by a local root.
