diff -r -u --color up/chromium/extensions/browser/app_window/app_window.cc nw/chromium/extensions/browser/app_window/app_window.cc
--- up/chromium/extensions/browser/app_window/app_window.cc	2023-02-15 18:46:36.000000000 +0000
+++ nw/chromium/extensions/browser/app_window/app_window.cc	2023-02-19 17:36:36.815467450 +0000
@@ -4,6 +4,10 @@
 
 #include "extensions/browser/app_window/app_window.h"
 
+#include "components/web_cache/browser/web_cache_manager.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/browser/renderer_host/render_frame_host_impl.h"
+#include "base/command_line.h"
 #include <stddef.h>
 
 #include <algorithm>
@@ -30,7 +34,9 @@
 #include "content/public/browser/navigation_entry.h"
 #include "content/public/browser/render_view_host.h"
 #include "content/public/browser/render_widget_host.h"
+#include "content/public/browser/render_widget_host_view.h"
 #include "content/public/browser/web_contents.h"
+#include "content/public/common/content_switches.h"
 #include "extensions/browser/app_window/app_delegate.h"
 #include "extensions/browser/app_window/app_web_contents_helper.h"
 #include "extensions/browser/app_window/app_window_client.h"
@@ -65,7 +71,29 @@
 #include "extensions/browser/pref_names.h"
 #endif
 
+
 using blink::mojom::ConsoleMessageLevel;
+
+#if defined(OS_MAC)
+#include "content/public/browser/browser_plugin_guest_manager.h"
+#include "extensions/browser/process_manager.h"
+#endif
+
+#include "extensions/browser/extension_host.h"
+//#include "extensions/common/extension_messages.h"
+
+#include "content/public/browser/render_frame_host.h"
+#include "third_party/blink/public/mojom/renderer_preferences.mojom.h"
+
+#include "extensions/browser/process_manager.h"
+#include "extensions/browser/app_window/app_window_contents.h"
+#include "extensions/browser/event_router.h"
+
+#include "content/nw/src/nw_base.h"
+#include "content/nw/src/nw_content.h"
+#include "content/nw/src/common/shell_switches.h"
+
+
 using content::BrowserContext;
 using content::WebContents;
 using web_modal::WebContentsModalDialogHost;
@@ -176,7 +204,13 @@
       always_on_top(false),
       visible_on_all_workspaces(false),
       show_on_lock_screen(false),
-      show_in_shelf(false) {}
+      show_in_shelf(false),
+      skip_load(false),
+      show_in_taskbar(true),
+      new_instance(false),
+      skip_block_parser(false)
+{
+}
 
 AppWindow::CreateParams::CreateParams(const CreateParams& other) = default;
 
@@ -239,7 +273,7 @@
 AppWindow::AppWindow(BrowserContext* context,
                      std::unique_ptr<AppDelegate> app_delegate,
                      const Extension* extension)
-    : browser_context_(context),
+    : menu_(nullptr), browser_context_(context),
       extension_id_(extension->id()),
       session_id_(SessionID::NewUnique()),
       app_delegate_(std::move(app_delegate)) {
@@ -248,13 +282,53 @@
       << "Only off the record window may be opened in the guest mode.";
 }
 
+void AppWindow::LoadingStateChanged(content::WebContents* source, bool to_different_document) {
+  base::Value::List args;
+  if (source->IsLoading()) {
+    args.Append("loading");
+    last_to_different_document_ = to_different_document;
+    if (!to_different_document) //NWJS#5001
+      return;
+  } else {
+    if (!last_to_different_document_)
+      return;
+    args.Append("loaded");
+  }
+  content::RenderFrameHost* rfh = web_contents()->GetPrimaryMainFrame();
+    ExtensionWebContentsObserver::GetForWebContents(web_contents())
+      ->GetLocalFrame(rfh)
+      ->MessageInvoke(
+                      extension_id(),
+                      "nw.Window",
+                      "LoadingStateChanged",
+                      std::move(args));
+}
+
 void AppWindow::Init(const GURL& url,
                      std::unique_ptr<AppWindowContents> app_window_contents,
                      content::RenderFrameHost* creator_frame,
                      const CreateParams& params) {
   // Initialize the render interface and web contents
   app_window_contents_ = std::move(app_window_contents);
-  app_window_contents_->Initialize(browser_context(), creator_frame, url);
+  app_window_contents_->Initialize(browser_context(), creator_frame, url,
+                                   GetExtension(), params.new_instance || params.skip_block_parser);
+
+  nw::Package* package = nw::package();
+  std::string js_doc_start(params.inject_js_start), js_doc_end(params.inject_js_end);
+  if (js_doc_start.empty()) {
+    std::string* str = package->root()->FindString(::switches::kmInjectJSDocStart);
+    if (str)
+      js_doc_start = *str;
+  }
+  web_contents()->GetMutableRendererPrefs()->nw_inject_js_doc_start = js_doc_start;
+  if (js_doc_end.empty()) {
+    std::string* str = package->root()->FindString(::switches::kmInjectJSDocEnd);
+    if (str)
+      js_doc_end = *str;
+  }
+  web_contents()->GetMutableRendererPrefs()->nw_inject_js_doc_end = js_doc_end;
+  if (!js_doc_start.empty() || !js_doc_end.empty())
+    web_contents()->SyncRendererPrefs();
 
   initial_url_ = url;
 
@@ -279,11 +353,22 @@
 
   // Windows cannot be always-on-top in fullscreen mode for security reasons.
   cached_always_on_top_ = new_params.always_on_top;
+#if 0
   if (new_params.state == ui::SHOW_STATE_FULLSCREEN &&
       !ExtensionsBrowserClient::Get()->IsScreensaverInDemoMode(
           extension_id())) {
     new_params.always_on_top = false;
   }
+#endif
+
+  title_override_ = new_params.title;
+  custom_app_icon_ = new_params.icon;
+  icon_override_ = new_params.icon;
+
+  content::g_support_transparency = !base::CommandLine::ForCurrentProcess()->HasSwitch(::switches::kDisableTransparency);
+  if (content::g_support_transparency) {
+    content::g_force_cpu_draw = base::CommandLine::ForCurrentProcess()->HasSwitch(::switches::kForceCpuDraw);
+  }
 
   requested_alpha_enabled_ = new_params.alpha_enabled;
   is_ime_window_ = params.is_ime_window;
@@ -321,6 +406,9 @@
     Show(new_params.focused ? SHOW_ACTIVE : SHOW_INACTIVE);
   }
 
+  if (!new_params.show_in_taskbar)
+    SetShowInTaskbar(false);
+
   OnNativeWindowChanged();
 
   ExtensionRegistry::Get(browser_context_)->AddObserver(this);
@@ -329,7 +417,8 @@
   app_delegate_->SetTerminatingCallback(base::BindOnce(
       &NativeAppWindow::Close, base::Unretained(native_app_window_.get())));
 
-  app_window_contents_->LoadContents(new_params.creator_process_id);
+  if (!params.skip_load)
+    app_window_contents_->LoadContents(new_params.creator_process_id);
 }
 
 AppWindow::~AppWindow() {
@@ -370,9 +459,29 @@
     bool user_gesture,
     bool* was_blocked) {
   DCHECK(new_contents->GetBrowserContext() == browser_context_);
-  app_delegate_->AddNewContents(browser_context_, std::move(new_contents),
-                                target_url, disposition, window_features,
-                                user_gesture);
+  const extensions::Extension* extension = GetExtension();
+  extensions::AppWindow* app_window =
+      extensions::AppWindowClient::Get()->CreateAppWindow(browser_context_, extension);
+
+  extensions::AppWindow::CreateParams params;
+  std::string js_doc_start, js_doc_end;
+  nw::CalcNewWinParams(new_contents.get(), &params, &js_doc_start, &js_doc_end, std::string());
+  nw::SetCurrentNewWinManifest(std::u16string());
+  new_contents->GetMutableRendererPrefs()->
+    nw_inject_js_doc_start = js_doc_start;
+  new_contents->GetMutableRendererPrefs()->
+    nw_inject_js_doc_end = js_doc_end;
+  new_contents->SyncRendererPrefs();
+
+  if(window_features.bounds.width() != 0) {
+    params.content_spec.bounds = window_features.bounds; //NWJS#5517
+  }
+  params.skip_load = true;
+  GURL new_url = new_contents->GetURL();
+  app_window->Init(new_url,
+                   std::make_unique<AppWindowContentsImpl>(app_window, std::move(new_contents)),
+                   web_contents()->GetPrimaryMainFrame(),
+                   params);
 }
 
 content::KeyboardEventProcessingResult AppWindow::PreHandleKeyboardEvent(
@@ -404,6 +513,7 @@
 bool AppWindow::HandleKeyboardEvent(
     WebContents* source,
     const content::NativeWebKeyboardEvent& event) {
+#if 0
   // If the window is currently fullscreen and not forced, ESC should leave
   // fullscreen.  If this code is being called for ESC, that means that the
   // KeyEvent's default behavior was not prevented by the content.
@@ -413,6 +523,8 @@
     return true;
   }
 
+#endif
+
   return native_app_window_->HandleKeyboardEvent(event);
 }
 
@@ -425,7 +537,28 @@
 
 bool AppWindow::PreHandleGestureEvent(WebContents* source,
                                       const blink::WebGestureEvent& event) {
-  return AppWebContentsHelper::ShouldSuppressGestureEvent(event);
+#if defined(OS_MAC)
+  // Disable "smart zoom" (double-tap with two fingers on Mac trackpad)
+  // for the PDF viewer, otherwise the viewer's controls will be scaled off
+  // screen.
+  // TODO(mcnee): Investigate having the PDF viewer handle the gesture
+  // once it is a service. crbug.com/757541
+  if (event.GetType() == blink::WebInputEvent::Type::kGestureDoubleTap) {
+    content::BrowserPluginGuestManager* guest_manager =
+        source->GetBrowserContext()->GetGuestManager();
+    if (guest_manager) {
+      content::WebContents* guest_contents = guest_manager->GetFullPageGuest(source);
+      if (guest_contents) {
+        const extensions::Extension* extension =
+            extensions::ProcessManager::Get(guest_contents->GetBrowserContext())
+                ->GetExtensionForWebContents(guest_contents);
+        if (extension && extension->id() == extension_misc::kPdfExtensionId)
+          return true;
+      }
+    }
+  }
+#endif  // defined(OS_MAC)
+  return false;
 }
 
 bool AppWindow::TakeFocus(WebContents* source, bool reverse) {
@@ -476,6 +609,31 @@
     std::move(callback).Run(true /* did_finish */);
 }
 
+bool AppWindow::NWCanClose(bool user_force) const {
+  const Extension* extension = GetExtension();
+  if (!extension)
+    return true;
+  content::RenderFrameHost* rfh = web_contents()->GetPrimaryMainFrame();
+  EventRouter* event_router = EventRouter::Get(browser_context());
+  std::string listener_extension_id;
+  bool listening_to_close = event_router->
+    ExtensionHasEventListener(extension->id(), "nw.Window.onClose",
+                              rfh->GetRenderViewHost()->GetRoutingID(),
+                              &listener_extension_id);
+  if (listening_to_close) {
+    base::Value::List args;
+    if (user_force)
+      args.Append("quit");
+    ExtensionWebContentsObserver::GetForWebContents(web_contents())
+      ->GetLocalFrame(rfh)
+      ->MessageInvoke(
+                      listener_extension_id, "nw.Window",
+                      "onClose", std::move(args));
+    return false;
+  }
+  return true;
+}
+
 void AppWindow::OnNativeClose() {
   AppWindowRegistry::Get(browser_context_)->RemoveAppWindow(this);
 
@@ -520,9 +678,19 @@
   SaveWindowPosition();
 
 #if BUILDFLAG(IS_WIN)
+  if (content::g_support_transparency && requested_alpha_enabled_) {
+    content::RenderFrameHost* rfh = web_contents()->GetPrimaryMainFrame();
+    content::RenderWidgetHostView* view = rfh->GetRenderViewHost()->GetWidget()->GetView();
+    if(view)
+      view->SetBackgroundColor(native_app_window_->CanHaveAlphaEnabled() ? SK_ColorTRANSPARENT : native_app_window_->ActiveFrameColor());
+  }
+#if 0
   if (cached_always_on_top_ && !IsFullscreen() &&
       !native_app_window_->IsMaximized() &&
       !native_app_window_->IsMinimized()) {
+#else
+  if (cached_always_on_top_) {
+#endif
     UpdateNativeAlwaysOnTop();
   }
 #endif
@@ -562,9 +730,10 @@
 }
 
 std::u16string AppWindow::GetTitle() const {
+  std::u16string override = base::UTF8ToUTF16(title_override_);
   const Extension* extension = GetExtension();
   if (!extension)
-    return std::u16string();
+    return override;
 
   // WebContents::GetTitle() will return the page's URL if there's no <title>
   // specified. However, we'd prefer to show the name of the extension in that
@@ -574,12 +743,14 @@
       web_contents() ? web_contents()->GetController().GetLastCommittedEntry()
                      : nullptr;
   if (!entry || entry->GetTitle().empty()) {
-    title = base::UTF8ToUTF16(extension->name());
+    title = override.empty() ? base::UTF8ToUTF16(extension->name()) : override;
   } else {
     title = web_contents()->GetTitle();
   }
   base::RemoveChars(title, u"\n", &title);
-  return title;
+  if (!title.empty())
+    return title;
+  return override;
 }
 
 void AppWindow::SetAppIconUrl(const GURL& url) {
@@ -669,6 +840,10 @@
   }
 }
 
+void AppWindow::SetShowInTaskbar(bool show) {
+  GetBaseWindow()->SetShowInTaskbar(show);
+}
+
 void AppWindow::OSFullscreen() {
   SetFullscreen(FULLSCREEN_TYPE_OS, true);
 }
@@ -726,14 +901,15 @@
   // As a security measure, do not allow fullscreen windows or windows that
   // overlap the taskbar to be on top. The property will be applied when the
   // window exits fullscreen and moves away from the taskbar.
+#if 0
   if ((!IsFullscreen() ||
        ExtensionsBrowserClient::Get()->IsScreensaverInDemoMode(
            extension_id())) &&
       !IntersectsWithTaskbar()) {
+#endif
     native_app_window_->SetZOrderLevel(always_on_top
                                            ? ui::ZOrderLevel::kFloatingWindow
                                            : ui::ZOrderLevel::kNormal);
-  }
 
   OnNativeWindowChanged();
 }
@@ -751,6 +927,8 @@
   DCHECK(properties);
   DCHECK(properties->is_dict());
 
+  properties->SetBoolKey("resizable",
+                         native_app_window_->IsResizable());
   properties->SetBoolKey("fullscreen",
                          native_app_window_->IsFullscreenOrPending());
   properties->SetBoolKey("minimized", native_app_window_->IsMinimized());
@@ -857,6 +1035,9 @@
 
 void AppWindow::UpdateNativeAlwaysOnTop() {
   DCHECK(cached_always_on_top_);
+#if 1
+  native_app_window_->SetZOrderLevel(ui::ZOrderLevel::kFloatingWindow);
+#else
   bool is_on_top =
       native_app_window_->GetZOrderLevel() == ui::ZOrderLevel::kFloatingWindow;
   bool fullscreen = IsFullscreen();
@@ -871,6 +1052,7 @@
     // always-on-top.
     native_app_window_->SetZOrderLevel(ui::ZOrderLevel::kFloatingWindow);
   }
+#endif
 }
 
 void AppWindow::ActivateContents(WebContents* contents) {
@@ -882,7 +1064,7 @@
 }
 
 bool AppWindow::ShouldSuppressDialogs(WebContents* source) {
-  return true;
+  return false;
 }
 
 void AppWindow::RunFileChooser(
@@ -1081,4 +1263,11 @@
   return sk_region;
 }
 
+content::JavaScriptDialogManager* AppWindow::GetJavaScriptDialogManager(
+    WebContents* source) {
+  ExtensionHost* host = ProcessManager::Get(browser_context())
+                            ->GetBackgroundHostForExtension(extension_id());
+  return host->GetJavaScriptDialogManager(source);
+}
+
 }  // namespace extensions
