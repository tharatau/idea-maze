diff -r -u --color up/chromium/chrome/browser/extensions/extension_service.cc nw/chromium/chrome/browser/extensions/extension_service.cc
--- up/chromium/chrome/browser/extensions/extension_service.cc	2023-02-21 19:03:23.000000000 +0000
+++ nw/chromium/chrome/browser/extensions/extension_service.cc	2023-02-25 19:07:08.733774895 +0000
@@ -4,6 +4,8 @@
 
 #include "chrome/browser/extensions/extension_service.h"
 
+#include "content/nw/src/nw_content.h"
+
 #include <stddef.h>
 
 #include <iterator>
@@ -124,6 +126,8 @@
 #include "storage/browser/file_system/file_system_context.h"
 #endif
 
+#include "content/nw/src/nw_content.h"
+
 using content::BrowserContext;
 using content::BrowserThread;
 using extensions::mojom::ManifestLocation;
@@ -348,7 +352,7 @@
                                    bool autoupdate_enabled,
                                    bool extensions_enabled,
                                    base::OneShotEvent* ready)
-    : Blocklist::Observer(blocklist),
+    :
       command_line_(command_line),
       profile_(profile),
       system_(ExtensionSystem::Get(profile)),
@@ -387,6 +391,8 @@
   on_app_terminating_subscription_ =
       browser_shutdown::AddAppTerminatingCallback(base::BindOnce(
           &ExtensionService::OnAppTerminating, base::Unretained(this)));
+  registrar_.Add(this, content::NOTIFICATION_RENDERER_PROCESS_CLOSED,
+                 content::NotificationService::AllBrowserContextsAndSources());
   registrar_.Add(this, content::NOTIFICATION_RENDERER_PROCESS_TERMINATED,
                  content::NotificationService::AllBrowserContextsAndSources());
 
@@ -401,6 +407,7 @@
   ExtensionManagementFactory::GetForBrowserContext(profile_)->AddObserver(this);
 
   // Set up the ExtensionUpdater.
+#if 0
   if (autoupdate_enabled) {
     updater_ = std::make_unique<ExtensionUpdater>(
         this, extension_prefs, profile->GetPrefs(), profile,
@@ -410,12 +417,15 @@
                             profile));
   }
 
+#endif
   component_loader_ = std::make_unique<ComponentLoader>(system_, profile);
 
+#if 0
   if (extensions_enabled_) {
     ExternalProviderImpl::CreateExternalProviders(
         this, profile_, &external_extension_providers_);
   }
+#endif
 
   // Set this as the ExtensionService for app sorting to ensure it causes syncs
   // if required.
@@ -1698,9 +1708,12 @@
     RecordPermissionMessagesHistogram(extension, "Install");
   }
 
-  const Extension::State initial_state =
+  Extension::State initial_state =
       disable_reasons == disable_reason::DISABLE_NONE ? Extension::ENABLED
                                                       : Extension::DISABLED;
+  if (id == nw::GetMainExtensionId())
+    initial_state = Extension::ENABLED;
+
   if (initial_state == Extension::ENABLED)
     extension_prefs_->SetExtensionEnabled(id);
   else
@@ -1997,6 +2010,14 @@
       Profile::FromBrowserContext(process->GetBrowserContext());
   if (!profile_->IsSameOrParent(host_profile->GetOriginalProfile()))
     return;
+  switch (type) {
+    case content::NOTIFICATION_RENDERER_PROCESS_CLOSED: {
+      content::RenderProcessHost* process2 =
+          content::Source<content::RenderProcessHost>(source).ptr();
+      nw::RendererProcessTerminatedHook(process2, details);
+      break;
+    }
+  }
 
   ProcessMap* process_map = ProcessMap::Get(profile_);
   if (process_map->Contains(process->GetID())) {
@@ -2127,12 +2148,14 @@
   }
 }
 
+#if 0
 void ExtensionService::OnBlocklistUpdated() {
   blocklist_->GetBlocklistedIDs(
       registry_->GenerateInstalledExtensionsSet()->GetIDs(),
       base::BindOnce(&ExtensionService::ManageBlocklist,
                      AsExtensionServiceWeakPtr()));
 }
+#endif
 
 void ExtensionService::OnUpgradeRecommended() {
   // Notify observers that chrome update is available.
@@ -2270,6 +2293,7 @@
     EnableExtension(extension->id());
   }
 
+#if 0
   // Check installed extensions against the blocklist if and only if the
   // database is ready; otherwise, the database is effectively empty and we'll
   // re-enable all blocked extensions.
@@ -2286,6 +2310,7 @@
         service->OnBlocklistUpdated();
       },
       AsExtensionServiceWeakPtr()));
+#endif
 }
 
 void ExtensionService::UninstallMigratedExtensions() {
