diff -r -u --color up/chromium/chrome/browser/ui/apps/chrome_app_delegate.cc nw/chromium/chrome/browser/ui/apps/chrome_app_delegate.cc
--- up/chromium/chrome/browser/ui/apps/chrome_app_delegate.cc	2023-02-15 18:46:36.000000000 +0000
+++ nw/chromium/chrome/browser/ui/apps/chrome_app_delegate.cc	2023-02-19 17:36:29.331448533 +0000
@@ -10,6 +10,15 @@
 
 #include "base/bind.h"
 #include "build/build_config.h"
+
+#include "components/sessions/content/session_tab_helper.h"
+#include "chrome/browser/extensions/tab_helper.h"
+#include "chrome/browser/password_manager/chrome_password_manager_client.h"
+#include "chrome/browser/ui/passwords/manage_passwords_ui_controller.h"
+#include "chrome/browser/external_protocol/external_protocol_observer.h"
+#include "components/content_settings/browser/page_specific_content_settings.h"
+#include "chrome/browser/content_settings/page_specific_content_settings_delegate.h"
+
 #include "build/chromeos_buildflags.h"
 #include "chrome/browser/app_mode/app_mode_utils.h"
 #include "chrome/browser/apps/platform_apps/audio_focus_web_contents_observer.h"
@@ -62,10 +71,16 @@
 #include "chrome/browser/printing/printing_init.h"
 #endif
 
+#include "chrome/browser/browser_process.h"
+#include "chrome/browser/ui/autofill/chrome_autofill_client.h"
+#include "components/autofill/content/browser/content_autofill_driver_factory.h"
+#include "components/autofill/core/browser/browser_autofill_manager.h"
+#include "chrome/browser/ui/prefs/prefs_tab_helper.h"
+
 namespace {
 
 // Time to wait for an app window to show before allowing Chrome to quit.
-int kAppWindowFirstShowTimeoutSeconds = 10;
+//int kAppWindowFirstShowTimeoutSeconds = 10;
 
 bool disable_external_open_for_testing_ = false;
 
@@ -82,7 +97,7 @@
   if (params.disposition == WindowOpenDisposition::NEW_BACKGROUND_TAB) {
     new_tab_params.disposition = WindowOpenDisposition::NEW_BACKGROUND_TAB;
   } else {
-    new_tab_params.disposition = WindowOpenDisposition::NEW_FOREGROUND_TAB;
+    new_tab_params.disposition = WindowOpenDisposition::NEW_POPUP;
     new_tab_params.window_action = NavigateParams::SHOW_WINDOW;
   }
 
@@ -201,7 +216,8 @@
       is_hidden_(true),
       for_lock_screen_app_(false),
       profile_(profile),
-      new_window_contents_delegate_(new NewWindowContentsDelegate()) {
+      new_window_contents_delegate_(new NewWindowContentsDelegate()),
+      web_contents_(nullptr) {
   if (keep_alive) {
     keep_alive_ = std::make_unique<ScopedKeepAlive>(
         KeepAliveOrigin::CHROME_APP_DELEGATE, KeepAliveRestartOption::DISABLED);
@@ -224,19 +240,44 @@
 }
 
 void ChromeAppDelegate::InitWebContents(content::WebContents* web_contents) {
+  web_contents_ = web_contents;
+
   favicon::CreateContentFaviconDriverForWebContents(web_contents);
 
 #if BUILDFLAG(ENABLE_PRINTING)
   printing::InitializePrintingForWebContents(web_contents);
 #endif
+  // ZoomController comes before common tab helpers since ChromeExtensionWebContentsObserver
+  // may want to register as a ZoomObserver with it.
+  zoom::ZoomController::CreateForWebContents(web_contents);
 
+#if 1
+  extensions::TabHelper::CreateForWebContents(web_contents);
+#else
+  SessionTabHelper::CreateForWebContents(web_contents);
+#endif
   apps::AudioFocusWebContentsObserver::CreateForWebContents(web_contents);
 
 #if BUILDFLAG(IS_CHROMEOS)
   policy::DlpContentTabHelper::MaybeCreateForWebContents(web_contents);
 #endif
 
-  zoom::ZoomController::CreateForWebContents(web_contents);
+  autofill::ChromeAutofillClient::CreateForWebContents(web_contents);
+  autofill::ContentAutofillDriverFactory::CreateForWebContentsAndDelegate(
+      web_contents,
+      autofill::ChromeAutofillClient::FromWebContents(web_contents),
+      base::BindRepeating(
+          &autofill::BrowserDriverInitHook,
+          autofill::ChromeAutofillClient::FromWebContents(web_contents),
+          g_browser_process->GetApplicationLocale()));
+  ChromePasswordManagerClient::CreateForWebContentsWithAutofillClient(
+      web_contents,
+      autofill::ChromeAutofillClient::FromWebContents(web_contents));
+  ManagePasswordsUIController::CreateForWebContents(web_contents);
+  PrefsTabHelper::CreateForWebContents(web_contents);
+  ExternalProtocolObserver::CreateForWebContents(web_contents);
+  content_settings::PageSpecificContentSettings::CreateForWebContents(web_contents,
+                                                                     std::make_unique<chrome::PageSpecificContentSettingsDelegate>(web_contents));
 }
 
 void ChromeAppDelegate::RenderFrameCreated(
@@ -279,12 +320,14 @@
     const blink::mojom::WindowFeatures& window_features,
     bool user_gesture) {
   if (!disable_external_open_for_testing_) {
+#if 0
     // We don't really want to open a window for |new_contents|, but we need to
     // capture its intended navigation. Here we give ownership to the
     // NewWindowContentsDelegate, which will dispose of the contents once
     // a navigation is captured.
     new_window_contents_delegate_->BecomeOwningDeletageOf(
         std::move(new_contents));
+#endif
     return;
   }
 
@@ -361,6 +404,7 @@
 
 void ChromeAppDelegate::OnHide() {
   is_hidden_ = true;
+#if 0
   if (has_been_shown_) {
     profile_keep_alive_.reset();
     keep_alive_.reset();
@@ -374,17 +418,20 @@
       base::BindOnce(&ChromeAppDelegate::RelinquishKeepAliveAfterTimeout,
                      weak_factory_.GetWeakPtr()),
       base::Seconds(kAppWindowFirstShowTimeoutSeconds));
+#endif
 }
 
 void ChromeAppDelegate::OnShow() {
   has_been_shown_ = true;
   is_hidden_ = false;
+#if 0
   keep_alive_ = std::make_unique<ScopedKeepAlive>(
       KeepAliveOrigin::CHROME_APP_DELEGATE, KeepAliveRestartOption::DISABLED);
   if (!profile_->IsOffTheRecord()) {
     profile_keep_alive_ = std::make_unique<ScopedProfileKeepAlive>(
         profile_, ProfileKeepAliveOrigin::kAppWindow);
   }
+#endif
 }
 
 bool ChromeAppDelegate::TakeFocus(content::WebContents* web_contents,
