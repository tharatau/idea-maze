diff -r -u --color up/chromium/chrome/browser/ui/views/frame/browser_view.cc nw/chromium/chrome/browser/ui/views/frame/browser_view.cc
--- up/chromium/chrome/browser/ui/views/frame/browser_view.cc	2023-02-15 18:46:36.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/browser_view.cc	2023-02-19 17:36:29.555449100 +0000
@@ -1,9 +1,34 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wunreachable-code"
 
 #include "chrome/browser/ui/views/frame/browser_view.h"
 
+#include "chrome/browser/extensions/api/tabs/tabs_windows_api.h"
+#include "chrome/browser/extensions/api/tabs/windows_event_router.h"
+#include "chrome/browser/extensions/browser_extension_window_controller.h"
+#include "components/favicon/content/content_favicon_driver.h"
+#include "content/public/browser/render_widget_host.h"
+
+#if defined(OS_MAC)
+#include "content/nw/src/nw_content_mac.h"
+#endif
+
+#if defined(OS_WIN)
+#include <shobjidl.h>
+#include <dwmapi.h>
+
+#include "base/win/windows_version.h"
+#include "ui/base/win/hidden_window.h"
+#include "ui/gfx/canvas.h"
+#include "ui/gfx/icon_util.h"
+#include "ui/gfx/font_list.h"
+#include "ui/gfx/platform_font.h"
+#include "ui/display/win/dpi.h"
+#include "ui/views/win/hwnd_util.h"
+#endif
+
 #include <stdint.h>
 
 #include <memory>
@@ -277,6 +302,9 @@
 #include "components/remote_cocoa/browser/application_host.h"
 #endif
 
+#include "extensions/browser/app_window/app_window.h"
+#include "extensions/browser/app_window/app_window_registry.h"
+
 #if defined(USE_AURA)
 #include "chrome/browser/ui/views/theme_profile_key.h"
 #include "ui/aura/client/window_parenting_client.h"
@@ -306,6 +334,8 @@
 #include "chrome/browser/ui/views/lens/lens_side_panel_controller.h"
 #endif
 
+using extensions::DraggableRegion;
+
 using base::UserMetricsAction;
 using content::NativeWebKeyboardEvent;
 using content::WebContents;
@@ -371,6 +401,20 @@
 
 #endif  // DCHECK_IS_ON()
 
+SkRegion* RawDraggableRegionsToSkRegion(
+    const std::vector<DraggableRegion>& regions) {
+  SkRegion* sk_region = new SkRegion;
+  for (std::vector<DraggableRegion>::const_iterator iter = regions.begin();
+       iter != regions.end(); ++iter) {
+    const DraggableRegion& region = *iter;
+    sk_region->op(
+                  SkIRect::MakeLTRB(region.bounds.x(), region.bounds.y(), region.bounds.right(),
+                                    region.bounds.bottom()),
+        region.draggable ? SkRegion::kUnion_Op : SkRegion::kDifference_Op);
+  }
+  return sk_region;
+}
+
 bool GetGestureCommand(ui::GestureEvent* event, int* command) {
   DCHECK(command);
   *command = 0;
@@ -841,6 +885,7 @@
       browser_(std::move(browser)),
       accessibility_mode_observer_(
           std::make_unique<AccessibilityModeObserver>(this)) {
+  CHECK(browser_->is_type_popup() || browser_->is_type_devtools()) << "opening browser window.";
   SetShowIcon(
       ::ShouldShowWindowIcon(browser_.get(), AppUsesWindowControlsOverlay()));
 
@@ -884,6 +929,14 @@
   }
 
   browser_->tab_strip_model()->AddObserver(this);
+  resizable_ = browser_->initial_resizable();
+#if defined(OS_LINUX) || defined(OS_WIN)
+  if (!resizable_) {
+    gfx::Size size = browser_->override_bounds().size();
+    size_constraints_.set_minimum_size(size);
+    size_constraints_.set_maximum_size(size);
+  }
+#endif
   immersive_mode_controller_ = chrome::CreateImmersiveModeController(this);
 
   // Top container holds tab strip region and toolbar and lives at the front of
@@ -918,10 +971,12 @@
   devtools_web_view->SetVisible(false);
 
   auto contents_web_view =
-      std::make_unique<ContentsWebView>(browser_->profile());
+    std::make_unique<ContentsWebView>(browser_->profile(), browser_->is_transparent());
   contents_web_view->SetID(VIEW_ID_TAB_CONTAINER);
 
   auto contents_container = std::make_unique<views::View>();
+  if (browser_->is_transparent())
+    contents_container->SetBackground(views::CreateSolidBackground(SK_ColorTRANSPARENT));
   devtools_web_view_ =
       contents_container->AddChildView(std::move(devtools_web_view));
   contents_web_view_ =
@@ -986,7 +1041,7 @@
   infobar_container_ =
       AddChildView(std::make_unique<InfoBarContainerView>(this));
 
-  InitStatusBubble();
+  //InitStatusBubble();
 
   // Create do-nothing view for the sake of controlling the z-order of the find
   // bar widget.
@@ -1014,6 +1069,90 @@
   }
 }
 
+void BrowserView::ForceClose() {
+  GetWidget()->Close(true);
+}
+bool BrowserView::NWCanClose(bool user_force) const {
+  return browser_->NWCanClose(user_force);
+}
+
+void BrowserView::UpdateDraggableRegions(
+    const std::vector<extensions::DraggableRegion>& regions) {
+  // Draggable region is not supported for non-frameless window.
+  if (!browser_->is_frameless())
+    return;
+
+  draggable_region_.reset(RawDraggableRegionsToSkRegion(regions));
+  //OnViewWasResized();
+}
+
+
+void BrowserView::SetShowInTaskbar(bool show) {
+#if defined(OS_WIN)
+  views::Widget* widget = GetWidget()->GetTopLevelWidget();
+
+  if (show == false && base::win::GetVersion() < base::win::Version::VISTA) {
+    // Change the owner of native window. Only needed on Windows XP.
+    ::SetParent(views::HWNDForWidget(widget),
+                ui::GetHiddenWindow());
+  }
+
+  Microsoft::WRL::ComPtr<ITaskbarList3> taskbar;
+  HRESULT result = ::CoCreateInstance(CLSID_TaskbarList, nullptr,
+                                      CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&taskbar));
+  if (FAILED(result)) {
+    VLOG(1) << "Failed creating a TaskbarList object: " << result;
+    return;
+  }
+
+  result = taskbar->HrInit();
+  if (FAILED(result)) {
+    LOG(ERROR) << "Failed initializing an ITaskbarList interface.";
+    return;
+  }
+
+  if (show)
+    result = taskbar->AddTab(views::HWNDForWidget(widget));
+  else
+    result = taskbar->DeleteTab(views::HWNDForWidget(widget));
+
+  if (FAILED(result)) {
+    LOG(ERROR) << "Failed to change the show in taskbar attribute";
+    return;
+  }
+#elif defined(OS_MAC)
+  NWSetNSWindowShowInTaskbar(browser()->window()->GetNativeWindow(), show);
+#endif
+}
+
+SkRegion* BrowserView::GetDraggableRegion() {
+  return draggable_region_.get();
+}
+
+void BrowserView::SetAllVisible(bool visible) {
+  frame_->SetVisibleOnAllWorkspaces(visible);
+}
+
+void BrowserView::SetResizable(bool resizable) {
+  resizable_ = resizable;
+  SetCanResize(resizable_);
+#if defined(OS_LINUX) || defined(OS_WIN)
+  if (!resizable) {
+    size_constraints_.set_minimum_size(GetContentsSize());
+    size_constraints_.set_maximum_size(GetContentsSize());
+  } else {
+    size_constraints_ = saved_size_constraints_;
+#if defined(OS_LINUX) //NWJS#6609
+    if (size_constraints_.HasFixedSize())
+      size_constraints_ = extensions::SizeConstraints();
+#endif
+  }
+#endif
+  GetWidget()->OnSizeConstraintsChanged();
+  frame_->non_client_view()->ResetWindowControls();
+  frame_->non_client_view()->Layout();
+}
+
 BrowserView::~BrowserView() {
   // Destroy the top controls slide controller first as it depends on the
   // tabstrip model and the browser frame.
@@ -1331,7 +1470,7 @@
 }
 
 void BrowserView::Hide() {
-  // Not implemented.
+  frame_->Hide();
 }
 
 bool BrowserView::IsVisible() const {
@@ -1346,6 +1485,13 @@
   frame_->SetBounds(bounds);
 }
 
+#if defined(OS_WIN)
+void BrowserView::SetPosition(const gfx::Point& pos) {
+  ExitFullscreen();
+  GetWidget()->SetPosition(pos);
+}
+#endif
+
 void BrowserView::Close() {
   frame_->Close();
 }
@@ -1371,8 +1517,7 @@
 }
 
 void BrowserView::SetZOrderLevel(ui::ZOrderLevel level) {
-  // Not implemented for browser windows.
-  NOTIMPLEMENTED();
+  frame_->SetZOrderLevel(level);
 }
 
 gfx::NativeWindow BrowserView::GetNativeWindow() const {
@@ -1682,6 +1827,7 @@
   // Update all the UI bits.
   UpdateTitleBar();
 
+#if 0
   if (old_contents) {
     TranslateBubbleController* translate_bubble_controller =
         TranslateBubbleController::FromWebContents(old_contents);
@@ -1689,6 +1835,7 @@
     if (translate_bubble_controller)
       translate_bubble_controller->CloseBubble();
   }
+#endif
 
   // This is only done once when the app is first opened so that there is only
   // one subscriber per web contents.
@@ -1882,7 +2029,7 @@
   // top that gives the user a hover target. In a public session we show the
   // bubble.
   // TODO(jamescook): Figure out what to do with mouse-lock.
-  if (is_trusted_pinned ||
+  if (true || is_trusted_pinned ||
       (!notify_download && bubble_type == EXCLUSIVE_ACCESS_BUBBLE_TYPE_NONE) ||
       (ShouldUseImmersiveFullscreenForUrl(url) &&
        !profiles::IsPublicSession())) {
@@ -1952,9 +2099,9 @@
   bool fullscreen = IsFullscreen();
   ProcessFullscreen(
       fullscreen, GURL(),
-      fullscreen
+      /*fullscreen
           ? GetExclusiveAccessManager()->GetExclusiveAccessExitBubbleType()
-          : EXCLUSIVE_ACCESS_BUBBLE_TYPE_NONE,
+          : */EXCLUSIVE_ACCESS_BUBBLE_TYPE_NONE,
       display::kInvalidDisplayId);
 }
 
@@ -2715,6 +2862,7 @@
     return ShowTranslateBubbleResult::EDITABLE_FIELD_IS_ACTIVE;
   }
 
+#if 0
   ChromeTranslateClient::FromWebContents(web_contents)
       ->GetTranslateManager()
       ->GetLanguageState()
@@ -2734,12 +2882,14 @@
                             is_user_gesture ? TranslateBubbleView::USER_GESTURE
                                             : TranslateBubbleView::AUTOMATIC);
 
+#endif
   return ShowTranslateBubbleResult::SUCCESS;
 }
 
 void BrowserView::StartPartialTranslate(const std::string& source_language,
                                         const std::string& target_language,
                                         const std::u16string& text_selection) {
+#if 0
   // Show the Translate icon and enabled the associated command to show the
   // Translate UI.
   ChromeTranslateClient::FromWebContents(GetActiveWebContents())
@@ -2753,6 +2903,7 @@
                               toolbar_button_provider()->GetPageActionIconView(
                                   PageActionIconType::kTranslate),
                               source_language, target_language, text_selection);
+#endif
 }
 
 void BrowserView::ShowOneClickSigninConfirmation(
@@ -3076,6 +3227,18 @@
 ///////////////////////////////////////////////////////////////////////////////
 // BrowserView, views::WidgetDelegate implementation:
 
+bool BrowserView::CanResize() const {
+#if defined(OS_MAC)
+  return resizable_;
+#else
+  return true;
+#endif
+}
+
+bool BrowserView::CanMaximize() const {
+  return resizable_ && size_constraints_.GetMaximumSize().IsEmpty() && !WidgetHasHitTestMask();
+}
+
 bool BrowserView::CanActivate() const {
   javascript_dialogs::AppModalDialogQueue* queue =
       javascript_dialogs::AppModalDialogQueue::GetInstance();
@@ -3361,17 +3524,82 @@
 }
 
 ui::ImageModel BrowserView::GetWindowAppIcon() {
+#if 1
+  if (browser_->is_type_devtools()) {
+    WebContents* contents = browser_->tab_strip_model()->GetActiveWebContents();
+    DevToolsWindow* devtools_window =
+        DevToolsWindow::AsDevToolsWindow(contents);
+    if (devtools_window) {
+      WebContents* inspected_contents =
+          devtools_window->GetInspectedWebContents();
+      if (!inspected_contents)
+        return ui::ImageModel();
+      Browser* browser = chrome::FindBrowserWithWebContents(inspected_contents);
+      if (browser && !browser->icon_override().IsEmpty())
+        return ui::ImageModel::FromImage(browser->icon_override());
+      favicon::FaviconDriver* favicon_driver =
+          favicon::ContentFaviconDriver::FromWebContents(inspected_contents);
+      gfx::Image app_icon;
+      if (favicon_driver)
+        app_icon = favicon_driver->GetFavicon();
+      if (!app_icon.IsEmpty())
+        return ui::ImageModel::FromImage(app_icon);
+      Profile* profile =
+          Profile::FromBrowserContext(contents->GetBrowserContext());
+      extensions::AppWindowRegistry* registry =
+          extensions::AppWindowRegistry::Get(profile);
+      if (registry) {
+        extensions::AppWindow* app_window =
+            registry->GetAppWindowForWebContents(inspected_contents);
+        if (app_window)
+          return ui::ImageModel::FromImageSkia(app_window->custom_app_icon().AsImageSkia());
+      }
+    }
+  }
+#endif
   web_app::AppBrowserController* app_controller = browser()->app_controller();
   return app_controller ? app_controller->GetWindowAppIcon() : GetWindowIcon();
 }
 
 ui::ImageModel BrowserView::GetWindowIcon() {
+  gfx::Image icon_override = browser()->icon_override();
+  if (!icon_override.IsEmpty())
+    return ui::ImageModel::FromImageSkia(*icon_override.ToImageSkia());
   // Use the default icon for devtools.
-  if (browser_->is_type_devtools())
+  if (browser_->is_type_devtools()) {
+    WebContents* active_content = browser_->tab_strip_model()->GetActiveWebContents();
+    DevToolsWindow* devtools_window =
+        DevToolsWindow::AsDevToolsWindow(active_content);
+    if (devtools_window) {
+      WebContents* inspected_contents =
+          devtools_window->GetInspectedWebContents();
+      Browser* browser = chrome::FindBrowserWithWebContents(inspected_contents);
+      if (browser && !browser->icon_override().IsEmpty())
+        return ui::ImageModel::FromImageSkia(*browser->icon_override().ToImageSkia());
+      favicon::FaviconDriver* favicon_driver = nullptr;
+      if (inspected_contents)
+          favicon_driver = favicon::ContentFaviconDriver::FromWebContents(inspected_contents);
+      gfx::Image app_icon;
+      if (favicon_driver)
+        app_icon = favicon_driver->GetFavicon();
+      if (!app_icon.IsEmpty())
+        return ui::ImageModel::FromImageSkia(*app_icon.ToImageSkia());
+      Profile* profile =
+          Profile::FromBrowserContext(active_content->GetBrowserContext());
+      extensions::AppWindowRegistry* registry =
+          extensions::AppWindowRegistry::Get(profile);
+      if (registry) {
+        extensions::AppWindow* app_window =
+            registry->GetAppWindowForWebContents(inspected_contents);
+        if (app_window)
+          return ui::ImageModel::FromImageSkia(app_window->custom_app_icon().AsImageSkia());
+      }
+    }
     return ui::ImageModel();
+  }
 
   // Hosted apps always show their app icon.
-  web_app::AppBrowserController* app_controller = browser()->app_controller();
+  web_app::AppBrowserController* app_controller = browser_->app_controller();
   if (app_controller)
     return app_controller->GetWindowIcon();
 
@@ -3416,7 +3644,7 @@
   // If IsFullscreen() is true, we've just changed into fullscreen mode, and
   // we're catching the going-into-fullscreen sizing and positioning calls,
   // which we want to ignore.
-  return !IsFullscreen() && frame_->ShouldSaveWindowPlacement() &&
+  return /* !IsFullscreen() && */ frame_->ShouldSaveWindowPlacement() &&
          chrome::ShouldSaveWindowPlacement(browser_.get());
 }
 
@@ -3424,17 +3652,26 @@
                                       ui::WindowShowState show_state) {
   DCHECK(ShouldSaveWindowPlacement());
 
-  WidgetDelegate::SaveWindowPlacement(bounds, show_state);
   gfx::Rect saved_bounds = bounds;
   if (chrome::SavedBoundsAreContentBounds(browser_.get())) {
+#if 0
     // Invert the transformation done in GetSavedWindowPlacement().
     gfx::Size client_size =
         frame_->GetFrameView()->GetBoundsForClientView().size();
     if (IsToolbarVisible())
       client_size.Enlarge(0, -toolbar_->GetPreferredSize().height());
     saved_bounds.set_size(client_size);
+#endif
+    gfx::Rect client_bounds = gfx::Rect(1000, 1000);
+    gfx::Rect window_bounds =
+          frame_->non_client_view()->GetWindowBoundsForClientBounds(client_bounds);
+    gfx::Insets insets = window_bounds.InsetsFrom(client_bounds);
+    saved_bounds.Inset(insets);
+    saved_bounds.set_origin(bounds.origin());
   }
+  WidgetDelegate::SaveWindowPlacement(bounds, show_state);
   chrome::SaveWindowPlacement(browser_.get(), saved_bounds, show_state);
+  NativeWindowChanged();
 }
 
 bool BrowserView::GetSavedWindowPlacement(
@@ -3476,7 +3713,7 @@
     rect.AdjustToFit(display.work_area());
 
     *bounds = rect;
-    *show_state = ui::SHOW_STATE_NORMAL;
+    //*show_state = ui::SHOW_STATE_NORMAL;
   }
 
   // We return true because we can _always_ locate reasonable bounds using the
@@ -3540,6 +3777,13 @@
 }
 #endif  // IS_MAC
 
+void BrowserView::NativeWindowChanged() {
+  extensions::TabsWindowsAPI* tabs_window_api =
+    extensions::TabsWindowsAPI::Get(browser_->profile());
+  tabs_window_api->windows_event_router()->
+    OnWindowChanged(browser_ ? browser_->extension_window_controller() : nullptr);
+}
+
 void BrowserView::OnWidgetDestroying(views::Widget* widget) {
   DCHECK(widget_observation_.IsObservingSource(widget));
   widget_observation_.Reset();
@@ -3636,6 +3880,10 @@
   LocationBarView* location_bar_view = GetLocationBarView();
   if (location_bar_view)
     location_bar_view->GetOmniboxView()->CloseOmniboxPopup();
+  extensions::TabsWindowsAPI* tabs_window_api =
+    extensions::TabsWindowsAPI::Get(browser_->profile());
+  tabs_window_api->windows_event_router()->
+    OnWindowMove(browser_ ? browser_->extension_window_controller() : nullptr);
 }
 
 views::Widget* BrowserView::GetWidget() {
@@ -3788,6 +4036,18 @@
         point_in_contents_web_view_coords.y());
   }
 
+#if defined(USE_AURA)
+  WebContents* web_contents = GetActiveWebContents();
+  if (!web_contents)
+    return true;
+  if (child->Contains(web_contents->GetNativeView())) {
+    // App window should claim mouse events that fall within the draggable
+    // region.
+    return !draggable_region_.get() ||
+           !draggable_region_->contains(location.x(), location.y());
+  }
+#endif
+
   return true;
 }
 
@@ -3838,10 +4098,27 @@
   return GetBrowserViewLayout()->NonClientHitTest(point);
 }
 
+void BrowserView::SetMinimumSize(gfx::Size size) {
+  size_constraints_.set_minimum_size(size);
+  saved_size_constraints_ = size_constraints_;
+  GetWidget()->OnSizeConstraintsChanged();
+}
+
+void BrowserView::SetMaximumSize(gfx::Size size) {
+  size_constraints_.set_maximum_size(size);
+  saved_size_constraints_ = size_constraints_;
+  GetWidget()->OnSizeConstraintsChanged();
+}
+
 gfx::Size BrowserView::GetMinimumSize() const {
+  if (size_constraints_.HasMinimumSize())
+    return size_constraints_.GetMinimumSize();
   return GetBrowserViewLayout()->GetMinimumSize(this);
 }
 
+gfx::Size BrowserView::GetMaximumSize() const {
+  return size_constraints_.GetMaximumSize();
+}
 ///////////////////////////////////////////////////////////////////////////////
 // BrowserView, views::View overrides:
 
