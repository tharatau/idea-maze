diff -r -u --color up/chromium/chrome/browser/download/download_target_determiner.cc nw/chromium/chrome/browser/download/download_target_determiner.cc
--- up/chromium/chrome/browser/download/download_target_determiner.cc	2023-02-15 18:46:36.000000000 +0000
+++ nw/chromium/chrome/browser/download/download_target_determiner.cc	2023-02-19 17:36:27.619444200 +0000
@@ -324,10 +324,12 @@
 
   // We don't replace the file extension if sfafe browsing consider the file
   // extension to be unsafe. Just let safe browsing scan the generated file.
+#if 0
   if (safe_browsing::FileTypePolicies::GetInstance()->IsCheckedBinaryFile(
           generated_filename)) {
     return generated_filename;
   }
+#endif
 
   // If no mime type or explicitly specified a name, don't replace file
   // extension.
@@ -996,12 +998,14 @@
     bool visited_referrer_before) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
   DCHECK_EQ(STATE_DETERMINE_INTERMEDIATE_PATH, next_state_);
+#if 0
   safe_browsing::RecordDownloadFileTypeAttributes(
       safe_browsing::FileTypePolicies::GetInstance()->GetFileDangerLevel(
           virtual_path_.BaseName(), download_->GetURL(),
           GetProfile()->GetPrefs()),
       download_->HasUserGesture(), visited_referrer_before,
       GetLastDownloadBypassTimestamp());
+#endif
   danger_level_ = GetDangerLevel(
       visited_referrer_before ? VISITED_REFERRER : NO_VISITS_TO_REFERRER);
   if (danger_level_ != DownloadFileType::NOT_DANGEROUS &&
@@ -1267,7 +1271,7 @@
   if (download_prefs_->IsAutoOpenEnabled(download_->GetURL(), virtual_path_) &&
       download_->HasUserGesture())
     return DownloadFileType::NOT_DANGEROUS;
-
+#if 0
   DownloadFileType::DangerLevel danger_level =
       safe_browsing::FileTypePolicies::GetInstance()->GetFileDangerLevel(
           virtual_path_.BaseName(), download_->GetURL(),
@@ -1291,9 +1295,11 @@
         ui::PAGE_TRANSITION_FROM_ADDRESS_BAR) != 0 ||
        (download_->HasUserGesture() && visits == VISITED_REFERRER)))
     return DownloadFileType::NOT_DANGEROUS;
-  return danger_level;
+#endif
+  return DownloadFileType::NOT_DANGEROUS;
 }
 
+#if 0
 absl::optional<base::Time>
 DownloadTargetDeterminer::GetLastDownloadBypassTimestamp() const {
   safe_browsing::SafeBrowsingMetricsCollector* metrics_collector =
@@ -1305,6 +1311,7 @@
                                      EventType::DANGEROUS_DOWNLOAD_BYPASS)
                            : absl::nullopt;
 }
+#endif
 
 void DownloadTargetDeterminer::OnDownloadDestroyed(
     DownloadItem* download) {
