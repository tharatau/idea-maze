diff -r -u --color up/chromium/content/browser/renderer_host/render_process_host_impl.cc nw/chromium/content/browser/renderer_host/render_process_host_impl.cc
--- up/chromium/content/browser/renderer_host/render_process_host_impl.cc	2023-02-21 19:03:23.000000000 +0000
+++ nw/chromium/content/browser/renderer_host/render_process_host_impl.cc	2023-02-25 19:07:16.333819726 +0000
@@ -118,6 +118,7 @@
 #include "content/browser/renderer_host/render_message_filter.h"
 #include "content/browser/renderer_host/render_widget_helper.h"
 #include "content/browser/renderer_host/renderer_sandboxed_process_launcher_delegate.h"
+#include "content/browser/resolve_proxy_helper.h"
 #include "content/browser/service_worker/service_worker_context_wrapper.h"
 #include "content/browser/site_info.h"
 #include "content/browser/site_instance_impl.h"
@@ -283,6 +284,15 @@
 #define MAYBEVLOG DVLOG
 #endif
 
+#include "content/nw/src/common/shell_switches.h"
+#include "content/nw/src/browser/nw_content_browser_hooks.h"
+
+namespace nw {
+typedef bool (*RphGuestFilterURLHookFn)(content::RenderProcessHost* rph, const GURL* url);
+CONTENT_EXPORT RphGuestFilterURLHookFn gRphGuestFilterURLHook = nullptr;
+void LoadNodeSymbols();
+}
+
 namespace content {
 
 namespace {
@@ -300,6 +310,8 @@
 base::Thread* g_in_process_thread = nullptr;
 
 RenderProcessHostFactory* g_render_process_host_factory_ = nullptr;
+RenderProcessHostImpl* g_main_host = nullptr;
+
 const char kSiteProcessMapKeyName[] = "content_site_process_map";
 
 RenderProcessHost::AnalyzeHungRendererFunction g_analyze_hung_renderer =
@@ -1533,6 +1545,7 @@
                     ChromeTrackEvent::kRenderProcessHost, *this);
 
   widget_helper_ = new RenderWidgetHelper();
+  resolve_proxy_helper_ = new ResolveProxyHelper(GetID());
 
   ChildProcessSecurityPolicyImpl::GetInstance()->Add(GetID(), browser_context);
 
@@ -1745,6 +1758,8 @@
       AttributionManager::GetOsSupport());
 
   if (run_renderer_in_process()) {
+    base::ScopedAllowBlocking allow_io;
+    nw::LoadNodeSymbols();
     DCHECK(g_renderer_main_thread_factory);
     // Crank up a thread and run the initialization there.  With the way that
     // messages flow between the browser and renderer, this thread is required
@@ -1766,6 +1781,8 @@
     // in-process plugins.
     options.message_pump_type = base::MessagePumpType::DEFAULT;
 #endif
+    options.message_pump_type = base::MessagePumpType::NODE;
+
     // As for execution sequence, this callback should have no any dependency
     // on starting in-process-render-thread.
     // So put it here to trigger ChannelMojo initialization earlier to enable
@@ -3260,6 +3277,18 @@
   }
 #endif
 
+  bool allow_nw = false;
+  if (IsForGuestsOnly()) {
+    if (nw::GetInWebViewApplyAttr(&allow_nw) && allow_nw)
+      command_line->AppendSwitch("nwjs-guest-nw");
+    else
+      command_line->AppendSwitch("nwjs-guest");
+  }
+
+  if (nw::MixedContext()) {
+    command_line->AppendSwitch("mixed-context");
+  }
+
 #if BUILDFLAG(IS_WIN)
   command_line->AppendSwitchASCII(
       switches::kDeviceScaleFactor,
@@ -3286,6 +3315,7 @@
   // Propagate the following switches to the renderer command line (along
   // with any associated values) if present in the browser command line.
   static const char* const kSwitchNames[] = {
+    "nwjs-test-mode",
     switches::kDisableInProcessStackTraces,
     sandbox::policy::switches::kDisableSeccompFilterSandbox,
     sandbox::policy::switches::kNoSandbox,
@@ -3297,6 +3327,9 @@
     // Allow this to be set when invoking the browser and relayed along.
     sandbox::policy::switches::kEnableSandboxLogging,
 #endif
+    switches::kDisableRAFThrottling,
+    switches::kEnableNodeWorker,
+    switches::kEnableSpellChecking,
     switches::kAllowLoopbackInPeerConnection,
     switches::kAndroidFontsPath,
     switches::kAudioBufferSize,
@@ -4140,6 +4173,16 @@
   GetAllHosts().AddWithID(host, host_id);
 }
 
+void RenderProcessHostImpl::set_main_host() {
+  g_main_host = this;
+}
+
+RenderProcessHostImpl* RenderProcessHostImpl::main_host() {
+  return g_main_host;
+}
+
+extern bool g_browser_main_loop_shutting_down;
+
 // static
 void RenderProcessHostImpl::UnregisterHost(int host_id) {
   RenderProcessHost* host = GetAllHosts().Lookup(host_id);
@@ -4161,6 +4204,12 @@
                           host->GetBrowserContext()->GetUserData(
                               kCommittedSiteProcessCountTrackerKey)));
 
+  if (g_main_host == host)
+    g_main_host = nullptr;
+
+  if (run_renderer_in_process() && g_browser_main_loop_shutting_down)
+    return; //or the following line will crash because browser context
+            //has been destroyed
   // Look up the map of site to process for the given browser_context,
   // in case we need to remove this process from it.  It will be registered
   // under any sites it rendered that use process-per-site mode.
@@ -4212,6 +4261,8 @@
     TRACE_EVENT2("navigation",
                  "RenderProcessHost::FilterURL - failed CanRequestURL",
                  "process_id", rph->GetID(), "url", url->spec());
+    if (nw::gRphGuestFilterURLHook && nw::gRphGuestFilterURLHook(rph, url))
+      return;
     VLOG(1) << "Blocked URL " << url->spec();
     *url = GURL(kBlockedURL);
   }
@@ -4461,8 +4512,11 @@
                                       .spare_render_process_host()) {
       continue;
     }
-    if (MayReuseAndIsSuitable(iter.GetCurrentValue(), site_instance))
+    if (MayReuseAndIsSuitable(iter.GetCurrentValue(), site_instance)) {
+      if (iter.GetCurrentValue() == g_main_host)
+        return g_main_host;
       suitable_renderers.push_back(iter.GetCurrentValue());
+    }
   }
 
   MAYBEVLOG(4) << __func__ << ": Found " << suitable_renderers.size()
@@ -4471,9 +4525,12 @@
 
   // Now pick a random suitable renderer, if we have any.
   if (!suitable_renderers.empty()) {
-    int suitable_count = static_cast<int>(suitable_renderers.size());
-    int random_index = base::RandInt(0, suitable_count - 1);
-    return suitable_renderers[random_index];
+    //int suitable_count = static_cast<int>(suitable_renderers.size());
+    //int random_index = base::RandInt(0, suitable_count - 1);
+    //return suitable_renderers[random_index];
+    //NWJS: reuse first renderer, the main process for valid nw.Window.open
+    //callback value. see also app_window_api.cc:416
+    return suitable_renderers[0];
   }
 
   return nullptr;
@@ -4518,6 +4575,11 @@
   // use process-per-site mode.  We cannot check whether the process has
   // appropriate bindings here, because the bindings have not yet been
   // granted.
+  // don't register process when we're opening new_instance window, or
+  // the map slot will be took over and following same-instance window
+  // opening will return null; NWJS#4691
+  if (!nw::PinningRenderer())
+    return;
   if (!site_instance->GetSiteInfo().is_empty())
     map->RegisterProcess(site_instance->GetSiteInfo(), process);
 }
@@ -4869,6 +4931,12 @@
   base::RecordComputedAction(action);
 }
 
+void RenderProcessHostImpl::ResolveProxy(
+    const GURL& url,
+    mojom::RendererHost::ResolveProxyCallback callback) {
+  resolve_proxy_helper_->ResolveProxy(url, std::move(callback));
+}
+
 void RenderProcessHostImpl::UpdateProcessPriorityInputs() {
   int32_t new_visible_widgets_count = 0;
   unsigned int new_frame_depth = kMaxFrameDepthForPriority;
