diff -r -u --color up/chromium/third_party/blink/renderer/core/page/frame_tree.cc nw/chromium/third_party/blink/renderer/core/page/frame_tree.cc
--- up/chromium/third_party/blink/renderer/core/page/frame_tree.cc	2023-02-21 19:03:23.000000000 +0000
+++ nw/chromium/third_party/blink/renderer/core/page/frame_tree.cc	2023-02-25 19:07:23.281857662 +0000
@@ -187,12 +187,12 @@
   return count;
 }
 
-Frame* FrameTree::FindFrameByName(const AtomicString& name) const {
+Frame* FrameTree::FindFrameByName(const AtomicString& name, bool nw) const {
   // Named frame lookup should always be relative to a local frame.
   DCHECK(IsA<LocalFrame>(this_frame_.Get()));
 
   Frame* frame = FindFrameForNavigationInternal(name, KURL());
-  if (frame && !To<LocalFrame>(this_frame_.Get())->CanNavigate(*frame))
+  if (!nw && frame && !To<LocalFrame>(this_frame_.Get())->CanNavigate(*frame))
     frame = nullptr;
   return frame;
 }
@@ -203,18 +203,36 @@
   // Named frame lookup should always be relative to a local frame.
   DCHECK(IsA<LocalFrame>(this_frame_.Get()));
   LocalFrame* current_frame = To<LocalFrame>(this_frame_.Get());
+  bool policy_changed = false;
 
+  NavigationPolicy policy = request.GetNavigationPolicy();
+  NavigationPolicy policy0 = policy;
+  if (name == "_blank")
+    policy = kNavigationPolicyNewWindow;
+
+  const KURL& url = request.GetResourceRequest().Url();
+  Frame* frame = FindFrameForNavigationInternal(name, url, &request);
+
+  if (!frame || policy != kNavigationPolicyCurrentTab) {
+    WebString manifest;
+    current_frame->Client()->willHandleNavigationPolicy(request.GetResourceRequest(), &policy, &manifest);
+    if (policy == kNavigationPolicyIgnore)
+      return FindResult(nullptr, false);
+    request.SetNavigationPolicy(policy);
+    request.SetManifest(manifest);
+    if (!manifest.IsEmpty() || policy != policy0)
+      policy_changed = true;
+  }
   // A GetNavigationPolicy() value other than kNavigationPolicyCurrentTab at
   // this point indicates that a user event modified the navigation policy
   // (e.g., a ctrl-click). Let the user's action override any target attribute.
-  if (request.GetNavigationPolicy() != kNavigationPolicyCurrentTab)
+  if (policy0 != kNavigationPolicyCurrentTab && !policy_changed)
     return FindResult(current_frame, false);
 
-  const KURL& url = request.GetResourceRequest().Url();
-  Frame* frame = FindFrameForNavigationInternal(name, url, &request);
   bool new_window = false;
   if (!frame) {
-    frame = CreateNewWindow(*current_frame, request, name);
+    WebString manifest = request.GetManifest();
+    frame = CreateNewWindow(*current_frame, request, name, &manifest);
     new_window = true;
     // CreateNewWindow() might have modified NavigationPolicy.
     // Set it back now that the new window is known to be the right one.
@@ -249,8 +267,13 @@
     return this_frame_;
   }
 
-  if (EqualIgnoringASCIICase(name, "_top"))
+  if (EqualIgnoringASCIICase(name, "_top")) {
+    for (const LocalFrame* f = DynamicTo<LocalFrame>(this_frame_.Get()); f; f = DynamicTo<LocalFrame>(f->Tree().Parent())) {
+      if (f->isNwFakeTop())
+        return const_cast<LocalFrame*>(f);
+    }
     return &Top();
+  }
 
   // The target _unfencedTop should only be treated as a special name in
   // opaque-ads mode fenced frames.
@@ -268,6 +291,8 @@
   }
 
   if (EqualIgnoringASCIICase(name, "_parent")) {
+    if (this_frame_->isNwFakeTop())
+      return this_frame_.Get();
     return Parent() ? Parent() : this_frame_.Get();
   }
 
