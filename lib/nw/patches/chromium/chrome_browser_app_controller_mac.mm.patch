diff -r -u --color up/chromium/chrome/browser/app_controller_mac.mm nw/chromium/chrome/browser/app_controller_mac.mm
--- up/chromium/chrome/browser/app_controller_mac.mm	2023-02-15 18:46:36.000000000 +0000
+++ nw/chromium/chrome/browser/app_controller_mac.mm	2023-02-19 17:36:26.903442387 +0000
@@ -12,6 +12,8 @@
 #include <memory>
 #include <vector>
 
+#include "content/public/common/content_features.h"
+
 #include "base/auto_reset.h"
 #include "base/bind.h"
 #include "base/command_line.h"
@@ -120,6 +122,8 @@
 #include "ui/native_theme/native_theme_observer.h"
 #include "url/gurl.h"
 
+#include "content/nw/src/nw_content.h"
+
 namespace {
 
 // True while AppController is calling chrome::NewEmptyWindow(). We need a
@@ -182,7 +186,7 @@
   }
 
   Browser* browser = chrome::GetLastActiveBrowser();
-  CHECK(browser);
+  //CHECK(browser);
   return browser;
 }
 
@@ -592,18 +596,21 @@
          selector:@selector(willPowerOff:)
              name:NSWorkspaceWillPowerOffNotification
            object:nil];
-
+#if 0
   NSMenu* fileMenu = [[[NSApp mainMenu] itemWithTag:IDC_FILE_MENU] submenu];
   _closeTabMenuItem = [fileMenu itemWithTag:IDC_CLOSE_TAB];
   DCHECK(_closeTabMenuItem);
   _closeWindowMenuItem = [fileMenu itemWithTag:IDC_CLOSE_WINDOW];
   DCHECK(_closeWindowMenuItem);
+#endif
 
   // Set up the command updater for when there are no windows open
   [self initMenuState];
 
   // Initialize the Profile menu.
+#if 0
   [self initProfileMenu];
+#endif
 }
 
 - (void)unregisterEventHandlers {
@@ -662,7 +669,7 @@
   // already shutting down.
   if (!browser_shutdown::IsTryingToQuit()) {
     chrome::OnClosingAllBrowsers(true);
-    chrome::CloseAllBrowsersAndQuit();
+    chrome::CloseAllBrowsersAndQuit(false, true);
   }
 
   return num_browsers == 0 ? YES : NO;
@@ -686,6 +693,9 @@
     return YES;
   }
 
+  if (!AppWindowRegistryUtil::CloseAllAppWindows(true))
+    return NSTerminateCancel;
+
   // Check if the preference is turned on.
   const PrefService* prefs = g_browser_process->local_state();
   if (!prefs->GetBoolean(prefs::kConfirmToQuitEnabled)) {
@@ -840,7 +850,11 @@
 
 - (void)openStartupUrls {
   DCHECK(_startupComplete);
-  [self openUrlsReplacingNTP:_startupUrls];
+  if (_startupUrls.size()) {
+    base::CommandLine::ForCurrentProcess()->AppendArg(_startupUrls[0].spec());
+    base::CommandLine::ForCurrentProcess()->FixOrigArgv4Finder(_startupUrls[0].spec());
+  }
+  //[self openUrlsReplacingNTP:_startupUrls];
   _startupUrls.clear();
 }
 
@@ -862,7 +876,10 @@
     return;
   }
 
+  nw::OSXOpenURLsHook(urls);
+#if 0
   OpenUrlsInBrowser(urls);
+#endif
 }
 
 // This is called after profiles have been loaded and preferences registered.
@@ -886,6 +903,7 @@
 
   // Notify BrowserList to keep the application running so it doesn't go away
   // when all the browser windows get closed.
+  if (!base::FeatureList::IsEnabled(::features::kNWNewWin))
   _keep_alive = std::make_unique<ScopedKeepAlive>(
       KeepAliveOrigin::APP_CONTROLLER, KeepAliveRestartOption::DISABLED);
 
@@ -897,7 +915,7 @@
 
   // If enabled, keep Chrome alive when apps are open instead of quitting all
   // apps.
-  _quitWithAppsController = new QuitWithAppsController();
+  //_quitWithAppsController = new QuitWithAppsController();
 
   // Dynamically update shortcuts for "Close Window" and "Close Tab" menu items.
   [[_closeTabMenuItem menu] setDelegate:self];
@@ -1370,6 +1388,8 @@
 // browser windows.
 - (BOOL)applicationShouldHandleReopen:(NSApplication*)theApplication
                     hasVisibleWindows:(BOOL)hasVisibleWindows {
+  return nw::ApplicationShouldHandleReopenHook(hasVisibleWindows) ? YES : NO;
+#if 0
   // If the browser is currently trying to quit, don't do anything and return NO
   // to prevent AppKit from doing anything.
   if (browser_shutdown::IsTryingToQuit())
@@ -1432,6 +1452,7 @@
   // We've handled the reopen event, so return NO to tell AppKit not
   // to do anything.
   return NO;
+#endif
 }
 
 - (void)initMenuState {
@@ -1633,6 +1654,9 @@
   if (profilesAdded)
     [dockMenu addItem:[NSMenuItem separatorItem]];
 
+#if 0
+  Profile* profile = [self lastProfileIfLoaded];
+
   NSString* titleStr = l10n_util::GetNSStringWithFixup(IDS_NEW_WINDOW_MAC);
   base::scoped_nsobject<NSMenuItem> item(
       [[NSMenuItem alloc] initWithTitle:titleStr
@@ -1643,8 +1667,6 @@
   [item setEnabled:[self validateUserInterfaceItem:item]];
   [dockMenu addItem:item];
 
-  Profile* profile = [self lastProfileIfLoaded];
-
   // Buttons below require the profile to be loaded. In particular, if the
   // profile picker is shown at startup, these buttons won't be added until the
   // user picks a profile.
@@ -1663,6 +1685,7 @@
     [item setEnabled:[self validateUserInterfaceItem:item]];
     [dockMenu addItem:item];
   }
+#endif
 
   return dockMenu;
 }
@@ -1709,6 +1732,7 @@
 
   _profilePrefRegistrar.reset();
 
+#if 0
   NSMenuItem* bookmarkItem = [[NSApp mainMenu] itemWithTag:IDC_BOOKMARKS_MENU];
   BOOL hidden = [bookmarkItem isHidden];
   if (profile != nullptr) {
@@ -1730,12 +1754,15 @@
       _bookmarkMenuBridge->OnProfileWillBeDestroyed();
     }
   }
+#endif
 
   _lastProfile = profile;
 
   if (_lastProfile == nullptr)
     return;
 
+
+#if 0
   auto& entry = _profileBookmarkMenuBridgeMap[profile->GetPath()];
   if (!entry || !entry->GetProfile()) {
     // This creates a deep copy, but only the first 3 items in the root menu
@@ -1764,6 +1791,7 @@
   chrome::BrowserCommandController::
       UpdateSharedCommandsForIncognitoAvailability(
           _menuState.get(), _lastProfile);
+#endif
   _profilePrefRegistrar = std::make_unique<PrefChangeRegistrar>();
   _profilePrefRegistrar->Init(_lastProfile->GetPrefs());
   _profilePrefRegistrar->Add(
@@ -1808,6 +1836,7 @@
 }
 
 - (void)updateMenuItemKeyEquivalents {
+#if 0
   BOOL enableCloseTabShortcut = NO;
 
   id target = [NSApp targetForAction:@selector(performClose:)];
@@ -1835,6 +1864,7 @@
 
   [self adjustCloseWindowMenuItemKeyEquivalent:enableCloseTabShortcut];
   [self adjustCloseTabMenuItemKeyEquivalent:enableCloseTabShortcut];
+#endif
 }
 
 // This only has an effect on macOS 12+, and requests any state restoration
