diff -r -u --color up/chromium/chrome/browser/ui/views/apps/glass_app_window_frame_view_win.cc nw/chromium/chrome/browser/ui/views/apps/glass_app_window_frame_view_win.cc
--- up/chromium/chrome/browser/ui/views/apps/glass_app_window_frame_view_win.cc	2023-02-21 19:03:23.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/apps/glass_app_window_frame_view_win.cc	2023-02-25 19:07:10.365784933 +0000
@@ -63,6 +63,9 @@
 }
 
 gfx::Rect GlassAppWindowFrameViewWin::GetBoundsForClientView() const {
+#if 1
+  return bounds();
+#else
   if (widget_->IsFullscreen())
     return bounds();
 
@@ -71,6 +74,7 @@
                    insets.top(),
                    std::max(0, width() - insets.left() - insets.right()),
                    std::max(0, height() - insets.top() - insets.bottom()));
+#endif
 }
 
 gfx::Rect GlassAppWindowFrameViewWin::GetWindowBoundsForClientBounds(
@@ -98,6 +102,11 @@
   if (!bounds().Contains(point))
     return HTNOWHERE;
 
+  int client_component = widget_->client_view()->NonClientHitTest(point);
+  if (client_component != HTNOWHERE)
+    return client_component;
+
+
   // Check the frame first, as we allow a small area overlapping the contents
   // to be used for resize handles.
   bool can_ever_resize = widget_->widget_delegate()
@@ -113,10 +122,6 @@
   if (frame_component != HTNOWHERE)
     return frame_component;
 
-  int client_component = widget_->client_view()->NonClientHitTest(point);
-  if (client_component != HTNOWHERE)
-    return client_component;
-
   // Caption is a safe default.
   return HTCAPTION;
 }
