diff -r -u --color up/chromium/chrome/browser/ui/views/frame/glass_browser_frame_view.cc nw/chromium/chrome/browser/ui/views/frame/glass_browser_frame_view.cc
--- up/chromium/chrome/browser/ui/views/frame/glass_browser_frame_view.cc	2023-02-21 19:03:23.000000000 +0000
+++ nw/chromium/chrome/browser/ui/views/frame/glass_browser_frame_view.cc	2023-02-24 20:12:04.532824147 +0000
@@ -232,6 +232,14 @@
     caption_button_container_->SchedulePaint();
 }
 
+gfx::Size GlassBrowserFrameView::GetMaximumSize() const {
+  gfx::Size max_size(browser_view()->GetMaximumSize());
+  if (max_size.height() > 0 || max_size.width() > 0)
+    max_size.Enlarge(0, GetTopInset(false));
+
+  return max_size;
+}
+
 ///////////////////////////////////////////////////////////////////////////////
 // GlassBrowserFrameView, views::NonClientFrameView implementation:
 
@@ -243,14 +251,21 @@
     const gfx::Rect& client_bounds) const {
   HWND hwnd = views::HWNDForWidget(frame());
   if (!browser_view()->GetTabStripVisible() && hwnd) {
-    // If we don't have a tabstrip, we're either a popup or an app window, in
-    // which case we have a standard size non-client area and can just use
-    // AdjustWindowRectEx to obtain it. We check for a non-null window handle in
-    // case this gets called before the window is actually created.
-    RECT rect = client_bounds.ToRECT();
-    AdjustWindowRectEx(&rect, GetWindowLong(hwnd, GWL_STYLE), FALSE,
-                       GetWindowLong(hwnd, GWL_EXSTYLE));
-    return gfx::Rect(rect);
+    if (ShouldCustomDrawSystemTitlebar()) {
+      const int top_inset = GetTopInset(false);
+      const int thickness = std::floor(
+        FrameTopBorderThicknessPx(false) /
+        display::win::ScreenWin::GetScaleFactorForHWND(hwnd));
+      return gfx::Rect(std::max(0, client_bounds.x()),
+        std::max(0, client_bounds.y() - top_inset),
+        client_bounds.width() + 2 * thickness, client_bounds.height() + top_inset + thickness);
+    }
+    else {
+      RECT rect = client_bounds.ToRECT();
+      AdjustWindowRectEx(&rect, GetWindowLong(hwnd, GWL_STYLE), FALSE,
+        GetWindowLong(hwnd, GWL_EXSTYLE));
+      return gfx::Rect(rect);
+    }
   }
 
   const int top_inset = GetTopInset(false);
@@ -271,8 +286,11 @@
 
   // If the point isn't within our bounds, then it's in the native portion of
   // the frame so again Windows can figure it out.
-  if (!bounds().Contains(point))
+  if (!bounds().Contains(point)) {
+    if (browser_view()->size_constraints().HasFixedSize())
+      return HTCAPTION;
     return HTNOWHERE;
+  }
 
   int frame_component = frame()->client_view()->NonClientHitTest(point);
 
@@ -461,7 +479,10 @@
       frame()->IsFullscreen();
   if (needs_no_border && !restored)
     return 0;
-
+#if 0
+  if (!browser_view()->CanResize() && !restored)
+    return 0;
+#endif
   // Note that this method assumes an equal resize handle thickness on all
   // sides of the window.
   // TODO(dfried): Consider having it return a gfx::Insets object instead.
@@ -532,6 +553,8 @@
   // FrameTopBorderThickness()) and floor(system dsf) pixels when restored.
   // Unfortunately we can't represent either of those at hidpi without using
   // non-integral dips, so we return the closest reasonable values instead.
+  if (!browser_view()->CanResize() && IsMaximized())
+    return 1;
   if (IsMaximized())
     return FrameTopBorderThickness(false);
   return IsWebUITabStrip() ? FrameTopBorderThickness(true) : 1;
