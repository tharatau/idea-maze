diff -r -u --color up/chromium/components/remote_cocoa/app_shim/native_widget_ns_window_bridge.mm nw/chromium/components/remote_cocoa/app_shim/native_widget_ns_window_bridge.mm
--- up/chromium/components/remote_cocoa/app_shim/native_widget_ns_window_bridge.mm	2023-02-21 19:03:23.000000000 +0000
+++ nw/chromium/components/remote_cocoa/app_shim/native_widget_ns_window_bridge.mm	2023-02-25 19:07:14.689810764 +0000
@@ -56,6 +56,10 @@
 using remote_cocoa::mojom::VisibilityTransition;
 using remote_cocoa::mojom::WindowVisibilityState;
 
+namespace content {
+  extern bool g_force_cpu_draw;
+}
+
 namespace {
 constexpr auto kUIPaintTimeout = base::Seconds(5);
 
@@ -166,6 +170,17 @@
 
 using RankMap = std::map<NSView*, int>;
 
+bool NSWindowIsMaximized(NSWindow* window) {
+  // -[NSWindow isZoomed] only works if the zoom button is enabled.
+  if ([[window standardWindowButton:NSWindowZoomButton] isEnabled])
+    return [window isZoomed];
+
+  // We don't attempt to distinguish between a window that has been explicitly
+  // maximized versus one that has just been dragged by the user to fill the
+  // screen. This is the same behavior as -[NSWindow isZoomed] above.
+  return NSEqualRects([window frame], [[window screen] visibleFrame]);
+}
+
 // Return the content size for a minimum or maximum widget size.
 gfx::Size GetClientSizeForWindowSize(NSWindow* window,
                                      const gfx::Size& window_size) {
@@ -443,6 +458,12 @@
 
   [[NSNotificationCenter defaultCenter]
       addObserver:window_delegate_
+         selector:@selector(onWindowWillStartLiveResize:)
+             name:NSWindowWillStartLiveResizeNotification
+           object:nil];
+
+  [[NSNotificationCenter defaultCenter]
+      addObserver:window_delegate_
          selector:@selector(onSystemControlTintChanged:)
              name:NSControlTintDidChangeNotification
            object:nil];
@@ -502,8 +523,8 @@
 
   // A contentRect with zero width or height is a banned practice in ChromeMac,
   // due to unpredictable OSX treatment.
-  DCHECK(!clamped_content_size.IsEmpty())
-      << "Zero-sized windows not supported on Mac";
+  //DCHECK(!clamped_content_size.IsEmpty())
+  //    << "Zero-sized windows not supported on Mac";
 
   if (!window_visible_ && IsWindowModalSheet()) {
     // Window-Modal dialogs (i.e. sheets) are positioned by Cocoa when shown for
@@ -535,7 +556,7 @@
     const gfx::Size& content_size,
     const gfx::Size& minimum_content_size) {
   gfx::Rect new_window_bounds = gfx::ScreenRectFromNSRect([window_ frame]);
-  new_window_bounds.set_size(GetWindowSizeForClientSize(window_, content_size));
+  new_window_bounds.set_size(content_size); //GetWindowSizeForClientSize(window_, content_size));
   SetBounds(new_window_bounds, minimum_content_size);
 
   // Note that this is not the precise center of screen, but it is the standard
@@ -586,7 +607,16 @@
   [compositor_view setWantsLayer:YES];
   [bridged_view_ addSubview:compositor_view];
 
-  [bridged_view_ setWantsLayer:YES];
+  if (content::g_force_cpu_draw) {
+    [compositor_view setLayer:nil];
+    [compositor_view setWantsLayer:NO];
+    //DisplayCALayerTree flipped_layer_
+    CALayer* flipped_layer = background_layer.sublayers[0];
+    [bridged_view_ setForceCPUDrawLayer:flipped_layer];
+    [flipped_layer setGeometryFlipped:NO];
+  } else {
+    [bridged_view_ setWantsLayer:YES];
+  }
   [window_ setContentView:bridged_view_];
 }
 
@@ -1000,6 +1030,12 @@
   UpdateWindowGeometry();
 }
 
+void NativeWidgetNSWindowBridge::OnWindowWillStartLiveResize() {
+  if (!NSWindowIsMaximized(window_) && !fullscreen_controller_.IsInFullscreenTransition()) {
+    bounds_before_maximize_ = [window_ frame];
+  }
+}
+
 void NativeWidgetNSWindowBridge::OnVisibilityChanged() {
   const bool window_visible = [window_ isVisible];
   if (window_visible_ == window_visible)
@@ -1425,6 +1461,44 @@
   window.collectionBehavior = collectionBehavior;
 }
 
+bool NativeWidgetNSWindowBridge::IsMaximized(bool* maximized) {
+  *maximized = NSWindowIsMaximized(window_);
+  return true;
+}
+
+void NativeWidgetNSWindowBridge::IsMaximized(IsMaximizedCallback callback) {
+  bool maximized = false;
+  IsMaximized(&maximized);
+  std::move(callback).Run(maximized);
+}
+
+void NativeWidgetNSWindowBridge::SetRestoredBounds(const gfx::Rect& bounds) {
+  bounds_before_maximize_ = gfx::ScreenRectToNSRect(bounds);
+}
+
+bool NativeWidgetNSWindowBridge::GetRestoredBounds(gfx::Rect* bounds) {
+  *bounds = gfx::ScreenRectFromNSRect(bounds_before_maximize_);
+  return true;
+}
+
+void NativeWidgetNSWindowBridge::GetRestoredBounds(GetRestoredBoundsCallback callback) {
+  std::move(callback).Run(gfx::ScreenRectFromNSRect(bounds_before_maximize_));
+}
+
+void NativeWidgetNSWindowBridge::SetMaximized(bool maximized) {
+  if (!maximized) {
+    if (NSWindowIsMaximized(window_))
+      [window_ setFrame:bounds_before_maximize_ display:YES animate:YES];
+    return;
+  }
+  if (!NSWindowIsMaximized(window_))
+    [window_ setFrame:[[window_ screen] visibleFrame] display:YES animate:YES];
+
+  if ([window_ isMiniaturized])
+    [window_ deminiaturize:nil];
+}
+
+
 void NativeWidgetNSWindowBridge::SetMiniaturized(bool miniaturized) {
   // In headless mode the platform window is always hidden and WebKit
   // will not deminiaturize hidden windows. So instead of changing the window
@@ -1486,6 +1560,11 @@
   // the content display on-screen.
   display_ca_layer_tree_->UpdateCALayerTree(ca_layer_params);
 
+  if (content::g_force_cpu_draw) {
+    // this is to tell the NSView that the CALayer content has been updated
+    [bridged_view_ setNeedsDisplay:YES];
+  }
+
   if (ca_transaction_sync_suppressed_)
     ca_transaction_sync_suppressed_ = false;
 
@@ -1497,7 +1576,9 @@
 
 void NativeWidgetNSWindowBridge::SetIgnoresMouseEvents(
     bool ignores_mouse_events) {
-  [window_ setIgnoresMouseEvents:ignores_mouse_events];
+  if (!content::g_force_cpu_draw) {
+    [window_ setIgnoresMouseEvents:ignores_mouse_events];
+  }
 }
 
 void NativeWidgetNSWindowBridge::MakeFirstResponder() {
