diff -r -u --color up/chromium/chrome/browser/ui/browser.cc nw/chromium/chrome/browser/ui/browser.cc
--- up/chromium/chrome/browser/ui/browser.cc	2023-02-21 19:03:23.000000000 +0000
+++ nw/chromium/chrome/browser/ui/browser.cc	2023-02-24 20:12:04.404822844 +0000
@@ -4,6 +4,13 @@
 
 #include "chrome/browser/ui/browser.h"
 
+#include "extensions/browser/process_manager.h"
+#include "chrome/browser/web_applications/web_app_helpers.h"
+#include "extensions/common/mojom/event_dispatcher.mojom.h"
+#include "chrome/browser/extensions/api/tabs/tabs_windows_api.h"
+#include "chrome/browser/extensions/api/tabs/tabs_event_router.h"
+#include "components/javascript_dialogs/app_modal_dialog_manager.h"
+
 #include <stddef.h>
 
 #include <algorithm>
@@ -11,6 +18,14 @@
 #include <string>
 #include <utility>
 
+#include "extensions/common/extension_messages.h"
+#include "extensions/browser/app_window/app_window.h"
+#include "content/nw/src/nw_content.h"
+#include "content/nw/src/nw_base.h"
+#include "content/public/common/content_switches.h"
+#include "ui/display/display.h"
+#include "chrome/browser/extensions/extension_tab_util.h"
+
 #include "base/base_paths.h"
 #include "base/bind.h"
 #include "base/callback_helpers.h"
@@ -361,12 +376,19 @@
 // Browser, CreateParams:
 
 Browser::CreateParams::CreateParams(Profile* profile, bool user_gesture)
-    : CreateParams(TYPE_NORMAL, profile, user_gesture) {}
+    : CreateParams(TYPE_POPUP, profile, user_gesture) {}
+
+Browser::CreateParams::CreateParams(Profile* profile, bool user_gesture, const gfx::Rect& bounds)
+  : CreateParams(TYPE_POPUP, profile, user_gesture) {
+  initial_bounds = bounds;
+}
 
 Browser::CreateParams::CreateParams(Type type,
                                     Profile* profile,
                                     bool user_gesture)
-    : type(type), profile(profile), user_gesture(user_gesture) {}
+    : type(type == TYPE_DEVTOOLS ? TYPE_DEVTOOLS : TYPE_POPUP),
+      profile(profile),
+      user_gesture(user_gesture) {}
 
 Browser::CreateParams::CreateParams(const CreateParams& other) = default;
 
@@ -425,6 +447,21 @@
   return params;
 }
 
+void Browser::AddOnDidFinishFirstNavigationCallback(
+    DidFinishFirstNavigationCallback callback) {
+  on_did_finish_first_navigation_callbacks_.push_back(std::move(callback));
+}
+
+void Browser::OnDidFinishFirstNavigation() {
+  if (did_finish_first_navigation_)
+    return;
+  did_finish_first_navigation_ = true;
+  std::vector<DidFinishFirstNavigationCallback> callbacks;
+  std::swap(callbacks, on_did_finish_first_navigation_callbacks_);
+  for (auto&& callback : callbacks)
+    std::move(callback).Run(true /* did_finish */);
+}
+
 ///////////////////////////////////////////////////////////////////////////////
 // Browser, Constructors, Creation, Showing:
 
@@ -452,11 +489,17 @@
   // not possible, e.g. using the wrong profile or during shutdown. The caller
   // should handle this; see e.g. crbug.com/1141608 and crbug.com/1261628.
   CHECK_EQ(CreationStatus::kOk, GetCreationStatusForProfile(params.profile));
-  return new Browser(params);
+  Browser* ret = new Browser(params);
+  nw::CreateAppWindowHook(nullptr);
+  return ret;
 }
 
 Browser::Browser(const CreateParams& params)
-    : create_params_(params),
+   :  nw_menu_(nullptr),
+      extension_id_(params.extension_id),
+      create_params_(params),
+      frameless_(params.frameless),
+      alpha_enabled_(params.alpha_enabled),
       type_(params.type),
       profile_(params.profile),
       window_(nullptr),
@@ -470,6 +513,7 @@
       tab_menu_model_delegate_(
           std::make_unique<chrome::BrowserTabMenuModelDelegate>(this)),
       app_name_(params.app_name),
+      windows_key_(params.windows_key),
       is_trusted_source_(params.trusted_source),
       session_id_(SessionID::NewUnique()),
       omit_from_session_restore_(params.omit_from_session_restore),
@@ -481,6 +525,13 @@
       initial_visible_on_all_workspaces_state_(
           params.initial_visible_on_all_workspaces_state),
       creation_source_(params.creation_source),
+      initial_ontop_(params.always_on_top),
+      initial_allvisible_(params.all_visible),
+      initial_resizable_(params.resizable),
+      initial_showintaskbar_(params.show_in_taskbar),
+      initial_position_(params.position),
+      title_override_(params.title),
+      icon_override_(params.icon),
       unload_controller_(this),
       content_setting_bubble_model_delegate_(
           new BrowserContentSettingBubbleModelDelegate(this)),
@@ -503,12 +554,15 @@
           std::make_unique<extensions::ExtensionBrowserWindowHelper>(this))
 #endif
 {
+  content::g_support_transparency = !base::CommandLine::ForCurrentProcess()->HasSwitch(::switches::kDisableTransparency);
+  if (content::g_support_transparency) {
+    content::g_force_cpu_draw = base::CommandLine::ForCurrentProcess()->HasSwitch(::switches::kForceCpuDraw);
+  }
   if (!profile_->IsOffTheRecord()) {
     profile_keep_alive_ = std::make_unique<ScopedProfileKeepAlive>(
         params.profile->GetOriginalProfile(),
         ProfileKeepAliveOrigin::kBrowserWindow);
   }
-
   tab_strip_model_->AddObserver(this);
 
   location_bar_model_ = std::make_unique<LocationBarModelImpl>(
@@ -542,6 +596,9 @@
                                                 params.user_gesture,
                                                 params.in_tab_dragging);
 
+  if (!initial_showintaskbar_)
+    window_->SetShowInTaskbar(false);
+
   if (app_controller_)
     app_controller_->UpdateCustomTabBarVisibility(false);
 
@@ -650,6 +707,42 @@
     select_file_dialog_->ListenerDestroyed();
 }
 
+bool Browser::NWCanClose(bool user_force) {
+  const extensions::Extension* extension = GetExtension();
+  if (!extension)
+    return true;
+  //content::RenderFrameHost* rfh = web_contents->GetMainFrame();
+  extensions::EventRouter* event_router = extensions::EventRouter::Get(profile_);
+  std::string listener_extension_id;
+  int instance_id = extensions::ExtensionTabUtil::GetWindowId(this);
+  bool listening_to_close = event_router->
+    ExtensionHasEventListener(extension->id(), extensions::api::windows::OnRemoving::kEventName,
+                              extensions::ExtensionTabUtil::GetWindowId(this),
+                              &listener_extension_id);
+  if (listening_to_close) {
+    std::unique_ptr<base::Value::List> args(new base::Value::List());
+    args->Append(session_id().id());
+    if (user_force)
+      args->Append("quit");
+    auto event =
+      std::make_unique<extensions::Event>(extensions::events::UNKNOWN,
+                                          extensions::api::windows::OnRemoving::kEventName,
+                                          std::move(*args), profile());
+    event->filter_info = extensions::mojom::EventFilteringInfo::New();
+    event->filter_info->window_exposed_by_default = true;
+    event->filter_info->instance_id = instance_id;
+    event_router->BroadcastEvent(std::move(event));
+    return false;
+  }
+  return true;
+}
+
+const extensions::Extension* Browser::GetExtension() const {
+  return extensions::ExtensionRegistry::Get(profile_)
+      ->enabled_extensions()
+      .GetByID(extension_id_);
+}
+
 ///////////////////////////////////////////////////////////////////////////////
 // Getters & Setters
 
@@ -684,6 +777,8 @@
 }
 
 gfx::Image Browser::GetCurrentPageIcon() const {
+  if (!icon_override_.IsEmpty())
+    return icon_override_;
   WebContents* web_contents = tab_strip_model_->GetActiveWebContents();
   // |web_contents| can be NULL since GetCurrentPageIcon() is called by the
   // window during the window's creation (before tabs have been added).
@@ -766,7 +861,25 @@
 
   // |contents| can be NULL because GetWindowTitleForCurrentTab is called by the
   // window during the window's creation (before tabs have been added).
-  if (title.empty() && contents) {
+  std::u16string override = base::UTF8ToUTF16(title_override_);
+
+  // |contents| can be NULL because GetWindowTitleForCurrentTab is called by the
+  // window during the window's creation (before tabs have been added).
+  content::NavigationEntry* entry = contents ?
+      contents->GetController().GetLastCommittedEntry() : nullptr;
+  if (!entry || entry->GetTitle().empty()) {
+    if (override.empty()) {
+      const std::string extension_id =
+        web_app::GetAppIdFromApplicationName(app_name());
+      const Extension* extension =
+        extensions::ExtensionRegistry::Get(profile())
+          ->GetExtensionById(extension_id,
+                             extensions::ExtensionRegistry::EVERYTHING);
+      if (extension)
+        title = base::UTF8ToUTF16(extension->name());
+    } else
+      title = override;
+  } else if (title.empty() && contents) {
     title = FormatTitleForDisplay(app_controller_ ? app_controller_->GetTitle()
                                                   : contents->GetTitle());
 #if BUILDFLAG(ENABLE_CAPTIVE_PORTAL_DETECTION)
@@ -790,10 +903,13 @@
   if (title.empty() && (is_type_normal() || is_type_popup()))
     title = CoreTabHelper::GetDefaultTitle();
 
+  if (title.empty() && is_type_app())
+    return override;
 #if BUILDFLAG(IS_MAC)
   // On Mac, we don't want to suffix the page title with the application name.
   return title;
 #else
+
   // If there is no title and this is an app, fall back on the app name. This
   // ensures that the native window gets a title which is important for a11y,
   // for example the window selector uses the Aura window title.
@@ -1009,6 +1125,7 @@
 // Browser, Tab adding/showing functions:
 
 void Browser::WindowFullscreenStateChanged() {
+  if (exclusive_access_manager_)
   exclusive_access_manager_->fullscreen_controller()
       ->WindowFullscreenStateChanged();
   command_controller_->FullscreenStateChanged();
@@ -1690,12 +1807,12 @@
     // cannot switch their independent spaces simultaneously (crbug.com/1315749)
     fullscreen_controller->RunOrDeferUntilTransitionIsComplete(base::BindOnce(
         &chrome::AddWebContents, this, source, std::move(new_contents),
-        target_url, disposition, window_features, window_action));
+        target_url, disposition, window_features, window_action, tmp_manifest()));
     return;
   }
 
   chrome::AddWebContents(this, source, std::move(new_contents), target_url,
-                         disposition, window_features, window_action);
+                         disposition, window_features, window_action, tmp_manifest());
 }
 
 void Browser::ActivateContents(WebContents* contents) {
@@ -1712,6 +1829,24 @@
                                   bool should_show_loading_ui) {
   ScheduleUIUpdate(source, content::INVALIDATE_TYPE_LOAD);
   UpdateWindowForLoadingStateChanged(source, should_show_loading_ui);
+  std::string nwstatus;
+  if (source->IsLoading()) {
+    nwstatus = "loading";
+    last_to_different_document_ = should_show_loading_ui ? 1 : 0;
+    if (!should_show_loading_ui) //NWJS#5001
+      return;
+  } else {
+    if (last_to_different_document_ == 0)
+      return;
+    nwstatus = "loaded";
+  }
+  extensions::TabsWindowsAPI* tabs_window_api = extensions::TabsWindowsAPI::Get(profile_);
+  if (!tabs_window_api)
+    return;
+  extensions::TabsEventRouter* tabs_event_router = tabs_window_api->tabs_event_router();
+  if (!tabs_event_router)
+    return;
+  tabs_event_router->NWStatusUpdated(source, nwstatus);
 }
 
 void Browser::CloseContents(WebContents* source) {
@@ -1763,7 +1898,7 @@
 }
 
 void Browser::ContentsZoomChange(bool zoom_in) {
-  chrome::ExecuteCommand(this, zoom_in ? IDC_ZOOM_PLUS : IDC_ZOOM_MINUS);
+  //chrome::ExecuteCommand(this, zoom_in ? IDC_ZOOM_PLUS : IDC_ZOOM_MINUS);
 }
 
 bool Browser::TakeFocus(content::WebContents* source, bool reverse) {
@@ -1853,13 +1988,21 @@
                                  int opener_render_frame_id,
                                  const std::string& frame_name,
                                  const GURL& target_url,
-                                 WebContents* new_contents) {
+                                 WebContents* new_contents, const std::u16string& nw_window_manifest) {
   // Adopt the WebContents now, so all observers are in place, as the network
   // requests for its initial navigation will start immediately. The WebContents
   // will later be inserted into this browser using Browser::Navigate via
   // AddNewContents.
   TabHelpers::AttachTabHelpers(new_contents);
-
+  extensions::AppWindow::CreateParams params;
+  std::string js_doc_start, js_doc_end;
+  nw::CalcNewWinParams(new_contents, &params, &js_doc_start, &js_doc_end, std::string());
+  nw::SetCurrentNewWinManifest(std::u16string());
+  new_contents->GetMutableRendererPrefs()->
+    nw_inject_js_doc_start = js_doc_start;
+  new_contents->GetMutableRendererPrefs()->
+    nw_inject_js_doc_end = js_doc_end;
+  new_contents->SyncRendererPrefs();
   // Make the tab show up in the task manager.
   task_manager::WebContentsTags::CreateForTabContents(new_contents);
 }
@@ -1884,6 +2027,7 @@
     WebContents* source,
     content::RenderWidgetHost* render_widget_host,
     base::RepeatingClosure hang_monitor_restarter) {
+#if 0
   // Don't show the page hung dialog when a HTML popup hangs because
   // the dialog will take the focus and immediately close the popup.
   RenderWidgetHostView* view = render_widget_host->GetView();
@@ -1891,6 +2035,7 @@
     TabDialogs::FromWebContents(source)->ShowHungRendererDialog(
         render_widget_host, std::move(hang_monitor_restarter));
   }
+#endif
 }
 
 void Browser::RendererResponsive(
@@ -1906,11 +2051,13 @@
 void Browser::DidNavigatePrimaryMainFramePostCommit(WebContents* web_contents) {
   if (web_contents == tab_strip_model_->GetActiveWebContents())
     UpdateBookmarkBarState(BOOKMARK_BAR_STATE_CHANGE_TAB_STATE);
+  OnDidFinishFirstNavigation();
 }
 
 content::JavaScriptDialogManager* Browser::GetJavaScriptDialogManager(
     WebContents* source) {
-  return javascript_dialogs::TabModalDialogManager::FromWebContents(source);
+  //return javascript_dialogs::TabModalDialogManager::FromWebContents(source);
+  return javascript_dialogs::AppModalDialogManager::GetInstance();
 }
 
 bool Browser::GuestSaveFrame(content::WebContents* guest_web_contents) {
@@ -2339,12 +2486,14 @@
 
 void Browser::OnIsPageTranslatedChanged(content::WebContents* source) {
   DCHECK(source);
+#if 0
   if (tab_strip_model_->GetActiveWebContents() == source) {
     window_->SetTranslateIconToggled(
         ChromeTranslateClient::FromWebContents(source)
             ->GetLanguageState()
             .IsPageTranslated());
   }
+#endif
 }
 
 void Browser::OnTranslateEnabledChanged(content::WebContents* source) {
@@ -2423,6 +2572,7 @@
 
 void Browser::OnTabDeactivated(WebContents* contents) {
   exclusive_access_manager_->OnTabDeactivated(contents);
+  if (SearchTabHelper::FromWebContents(contents))
   SearchTabHelper::FromWebContents(contents)->OnTabDeactivated();
 
   // Save what the user's currently typing, so it can be restored when we
@@ -2515,7 +2665,7 @@
                                base::TimeTicks::Now());
   }
 
-  SearchTabHelper::FromWebContents(new_contents)->OnTabActivated();
+  //SearchTabHelper::FromWebContents(new_contents)->OnTabActivated();
 }
 
 void Browser::OnTabMoved(int from_index, int to_index) {
@@ -2830,15 +2980,15 @@
   // ...and all the helpers.
   WebContentsModalDialogManager::FromWebContents(web_contents)
       ->SetDelegate(delegate);
-  translate::ContentTranslateDriver* content_translate_driver =
-      ChromeTranslateClient::FromWebContents(web_contents)->translate_driver();
+  //translate::ContentTranslateDriver* content_translate_driver =
+  //    ChromeTranslateClient::FromWebContents(web_contents)->translate_driver();
   if (delegate) {
     zoom::ZoomController::FromWebContents(web_contents)->AddObserver(this);
-    content_translate_driver->AddTranslationObserver(this);
+    //content_translate_driver->AddTranslationObserver(this);
     BookmarkTabHelper::FromWebContents(web_contents)->AddObserver(this);
   } else {
     zoom::ZoomController::FromWebContents(web_contents)->RemoveObserver(this);
-    content_translate_driver->RemoveTranslationObserver(this);
+    //content_translate_driver->RemoveTranslationObserver(this);
     BookmarkTabHelper::FromWebContents(web_contents)->RemoveObserver(this);
   }
 }
@@ -2887,33 +3037,38 @@
 
 bool Browser::NormalBrowserSupportsWindowFeature(WindowFeature feature,
                                                  bool check_can_support) const {
-  bool fullscreen = ShouldHideUIForFullscreen();
+  //bool fullscreen = ShouldHideUIForFullscreen();
   switch (feature) {
     case FEATURE_BOOKMARKBAR:
-      return true;
+      return false;
     case FEATURE_TABSTRIP:
     case FEATURE_TOOLBAR:
     case FEATURE_LOCATIONBAR:
-      return check_can_support || !fullscreen;
+      return false;
     case FEATURE_TITLEBAR:
     case FEATURE_NONE:
       return false;
+    case FEATURE_NW_FRAMELESS:
+      return true;
   }
 }
 
 bool Browser::PopupBrowserSupportsWindowFeature(WindowFeature feature,
                                                 bool check_can_support) const {
-  bool fullscreen = ShouldHideUIForFullscreen();
+  //bool fullscreen = ShouldHideUIForFullscreen();
 
   switch (feature) {
     case FEATURE_TITLEBAR:
+      return true;
     case FEATURE_LOCATIONBAR:
-      return check_can_support || (!fullscreen && !is_trusted_source());
+      return false; //check_can_support || (!fullscreen && !is_trusted_source());
     case FEATURE_TABSTRIP:
     case FEATURE_TOOLBAR:
     case FEATURE_BOOKMARKBAR:
     case FEATURE_NONE:
       return false;
+    case FEATURE_NW_FRAMELESS:
+      return true;
   }
 }
 
@@ -2958,6 +3113,8 @@
     case FEATURE_BOOKMARKBAR:
     case FEATURE_NONE:
       return false;
+    case FEATURE_NW_FRAMELESS:
+      return true;
   }
 }
 
@@ -2983,6 +3140,7 @@
     bool check_can_support) const {
   switch (feature) {
     case FEATURE_TITLEBAR:
+    case FEATURE_NW_FRAMELESS:
       return true;
     case FEATURE_LOCATIONBAR:
     case FEATURE_TABSTRIP:
