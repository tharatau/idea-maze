diff -r -u --color up/v8/include/libplatform/libplatform.h nw/v8/include/libplatform/libplatform.h
--- up/v8/include/libplatform/libplatform.h	2023-02-22 17:57:31.370000000 -0500
+++ nw/v8/include/libplatform/libplatform.h	2016-05-11 19:19:17.000000000 -0400
@@ -18,8 +18,7 @@
  * of zero is passed, a suitable default based on the current number of
  * processors online will be chosen.
  */
-v8::Platform* CreateDefaultPlatform(int thread_pool_size = 0);
-
+v8::Platform* V8_EXPORT2 CreateDefaultPlatform(int thread_pool_size = 0);
 
 /**
  * Pumps the message loop for the given isolate.
@@ -29,7 +28,7 @@
  * not block if no task is pending. The |platform| has to be created using
  * |CreateDefaultPlatform|.
  */
-bool PumpMessageLoop(v8::Platform* platform, v8::Isolate* isolate);
+bool V8_EXPORT2 PumpMessageLoop(v8::Platform* platform, v8::Isolate* isolate);
 
 
 }  // namespace platform
diff -r -u --color up/v8/include/v8-platform.h nw/v8/include/v8-platform.h
--- up/v8/include/v8-platform.h	2023-02-22 17:57:31.428000000 -0500
+++ nw/v8/include/v8-platform.h	2016-05-11 19:19:17.000000000 -0400
@@ -7,6 +7,24 @@
 
 #include <stddef.h>
 #include <stdint.h>
+#include "v8config.h"
+
+#ifdef V8_OS_LINUX
+
+// Setup for Linux shared library export.
+#if V8_HAS_ATTRIBUTE_VISIBILITY && defined(V8_SHARED)
+# ifdef BUILDING_V8_SHARED
+#  define V8_EXPORT2 __attribute__ ((visibility("default")))
+# else
+#  define V8_EXPORT2
+# endif
+#else
+# define V8_EXPORT2
+#endif
+
+#else // V8_OS_LINUX
+#define V8_EXPORT2
+#endif  // V8_OS_WIN
 
 namespace v8 {
 
diff -r -u --color up/v8/include/v8-version.h nw/v8/include/v8-version.h
--- up/v8/include/v8-version.h	2023-02-22 17:57:31.531000000 -0500
+++ nw/v8/include/v8-version.h	2016-05-11 19:19:17.000000000 -0400
@@ -11,7 +11,7 @@
 #define V8_MAJOR_VERSION 5
 #define V8_MINOR_VERSION 0
 #define V8_BUILD_NUMBER 71
-#define V8_PATCH_LEVEL 54
+#define V8_PATCH_LEVEL 48
 
 // Use 1 for candidates and 0 otherwise.
 // (Boolean macro values are not supported by all preprocessors.)
diff -r -u --color up/v8/include/v8.h nw/v8/include/v8.h
--- up/v8/include/v8.h	2023-02-22 17:57:31.550000000 -0500
+++ nw/v8/include/v8.h	2016-05-11 19:19:17.000000000 -0400
@@ -4877,7 +4877,7 @@
 
 
 void V8_EXPORT RegisterExtension(Extension* extension);
-
+void V8_EXPORT FixSourceNWBin(Isolate* v8_isolate, Local<UnboundScript> script);
 
 // --- Statics ---
 
@@ -5305,6 +5305,8 @@
  */
 class V8_EXPORT Isolate {
  public:
+  ArrayBuffer::Allocator* array_buffer_allocator();
+  
   /**
    * Initial configuration parameters for a new Isolate.
    */
diff -r -u --color up/v8/src/api.cc nw/v8/src/api.cc
--- up/v8/src/api.cc	2023-02-22 17:57:31.969000000 -0500
+++ nw/v8/src/api.cc	2016-05-11 19:19:17.000000000 -0400
@@ -6978,6 +6978,10 @@
   return isolate->context() != NULL;
 }
 
+ArrayBuffer::Allocator* Isolate::array_buffer_allocator() {
+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(this);
+  return isolate->array_buffer_allocator();
+}
 
 v8::Local<v8::Context> Isolate::GetCurrentContext() {
   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(this);
@@ -8427,6 +8431,15 @@
 }
 
 
+void FixSourceNWBin(Isolate* v8_isolate, Local<UnboundScript> script) {
+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(v8_isolate);
+  i::Handle<i::HeapObject> obj =
+    i::Handle<i::HeapObject>::cast(v8::Utils::OpenHandle(*script));
+  i::Handle<i::SharedFunctionInfo>
+      function_info(i::SharedFunctionInfo::cast(*obj), obj->GetIsolate());
+  reinterpret_cast<i::Script*>(function_info->script())->set_source(isolate->heap()->undefined_value());
+}
+
 namespace internal {
 
 
diff -r -u --color up/v8/src/bootstrapper.cc nw/v8/src/bootstrapper.cc
--- up/v8/src/bootstrapper.cc	2023-02-22 17:57:33.491000000 -0500
+++ nw/v8/src/bootstrapper.cc	2016-05-11 19:19:17.000000000 -0400
@@ -1292,10 +1292,6 @@
                                    attribs);
       string_map->AppendDescriptor(&d);
     }
-
-    // Install the String.fromCharCode function.
-    SimpleInstallFunction(string_fun, "fromCharCode",
-                          Builtins::kStringFromCharCode, 1, false);
   }
 
   {
diff -r -u --color up/v8/src/builtins.cc nw/v8/src/builtins.cc
--- up/v8/src/builtins.cc	2023-02-22 17:57:33.515000000 -0500
+++ nw/v8/src/builtins.cc	2016-05-11 19:19:17.000000000 -0400
@@ -3732,74 +3732,6 @@
   return *result;
 }
 
-// -----------------------------------------------------------------------------
-// ES6 section 21.1 String Objects
-
-namespace {
-
-bool ToUint16(Handle<Object> value, uint16_t* result) {
-  if (value->IsNumber() || Object::ToNumber(value).ToHandle(&value)) {
-    *result = DoubleToUint32(value->Number());
-    return true;
-  }
-  return false;
-}
-
-}  // namespace
-
-// ES6 21.1.2.1 String.fromCharCode ( ...codeUnits )
-BUILTIN(StringFromCharCode) {
-  HandleScope scope(isolate);
-  // Check resulting string length.
-  int index = 0;
-  Handle<String> result;
-  int const length = args.length() - 1;
-  if (length == 0) return isolate->heap()->empty_string();
-  DCHECK_LT(0, length);
-  // Load the first character code.
-  uint16_t code;
-  if (!ToUint16(args.at<Object>(1), &code)) return isolate->heap()->exception();
-  // Assume that the resulting String contains only one byte characters.
-  if (code <= String::kMaxOneByteCharCodeU) {
-    // Check for single one-byte character fast case.
-    if (length == 1) {
-      return *isolate->factory()->LookupSingleCharacterStringFromCode(code);
-    }
-    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
-        isolate, result, isolate->factory()->NewRawOneByteString(length));
-    do {
-      Handle<SeqOneByteString>::cast(result)->Set(index, code);
-      if (++index == length) break;
-      if (!ToUint16(args.at<Object>(1 + index), &code)) {
-        return isolate->heap()->exception();
-      }
-    } while (code <= String::kMaxOneByteCharCodeU);
-  }
-  // Check if all characters fit into the one byte range.
-  if (index < length) {
-    // Fallback to two byte string.
-    Handle<String> new_result;
-    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
-        isolate, new_result, isolate->factory()->NewRawTwoByteString(length));
-    for (int new_index = 0; new_index < index; ++new_index) {
-      uint16_t new_code =
-          Handle<SeqOneByteString>::cast(result)->Get(new_index);
-      Handle<SeqTwoByteString>::cast(new_result)->Set(new_index, new_code);
-    }
-    while (true) {
-      Handle<SeqTwoByteString>::cast(new_result)->Set(index, code);
-      if (++index == length) break;
-      if (!ToUint16(args.at<Object>(1 + index), &code)) {
-        return isolate->heap()->exception();
-      }
-    }
-    result = new_result;
-  }
-  return *result;
-}
-
-// -----------------------------------------------------------------------------
-// ES6 section 21.1 ArrayBuffer Objects
 
 // ES6 section 24.1.2.1 ArrayBuffer ( length ) for the [[Call]] case.
 BUILTIN(ArrayBufferConstructor) {
diff -r -u --color up/v8/src/builtins.h nw/v8/src/builtins.h
--- up/v8/src/builtins.h	2023-02-22 17:57:33.549000000 -0500
+++ nw/v8/src/builtins.h	2016-05-11 19:19:17.000000000 -0400
@@ -149,8 +149,6 @@
   V(ReflectSet, kNone)                                         \
   V(ReflectSetPrototypeOf, kNone)                              \
                                                                \
-  V(StringFromCharCode, kNone)                                 \
-                                                               \
   V(SymbolConstructor, kNone)                                  \
   V(SymbolConstructor_ConstructStub, kTarget)                  \
                                                                \
diff -r -u --color up/v8/src/compiler/access-info.cc nw/v8/src/compiler/access-info.cc
--- up/v8/src/compiler/access-info.cc	2023-02-22 17:57:33.798000000 -0500
+++ nw/v8/src/compiler/access-info.cc	2016-05-11 19:19:17.000000000 -0400
@@ -192,12 +192,12 @@
   MapTransitionList transitions(maps.length());
   for (Handle<Map> map : maps) {
     if (Map::TryUpdate(map).ToHandle(&map)) {
-      Map* transition_target =
-          map->FindElementsKindTransitionedMap(&possible_transition_targets);
-      if (transition_target == nullptr) {
+      Handle<Map> transition_target =
+          Map::FindTransitionedMap(map, &possible_transition_targets);
+      if (transition_target.is_null()) {
         receiver_maps.Add(map);
       } else {
-        transitions.push_back(std::make_pair(map, handle(transition_target)));
+        transitions.push_back(std::make_pair(map, transition_target));
       }
     }
   }
diff -r -u --color up/v8/src/compiler/js-create-lowering.cc nw/v8/src/compiler/js-create-lowering.cc
--- up/v8/src/compiler/js-create-lowering.cc	2023-02-22 17:57:34.406000000 -0500
+++ nw/v8/src/compiler/js-create-lowering.cc	2016-05-11 19:19:17.000000000 -0400
@@ -905,17 +905,8 @@
         site_context->ExitScope(current_site, boilerplate_object);
       } else if (property_details.representation().IsDouble()) {
         // Allocate a mutable HeapNumber box and store the value into it.
-        Callable callable = CodeFactory::AllocateMutableHeapNumber(isolate());
-        CallDescriptor* desc = Linkage::GetStubCallDescriptor(
-            isolate(), jsgraph()->zone(), callable.descriptor(), 0,
-            CallDescriptor::kNoFlags, Operator::kNoThrow);
-        value = effect = graph()->NewNode(
-            common()->Call(desc), jsgraph()->HeapConstant(callable.code()),
-            jsgraph()->NoContextConstant(), effect, control);
-        effect = graph()->NewNode(
-            simplified()->StoreField(AccessBuilder::ForHeapNumberValue()),
-            value, jsgraph()->Constant(
-                       Handle<HeapNumber>::cast(boilerplate_value)->value()),
+        value = effect = AllocateMutableHeapNumber(
+            Handle<HeapNumber>::cast(boilerplate_value)->value(),
             effect, control);
       } else if (property_details.representation().IsSmi()) {
         // Ensure that value is stored as smi.
@@ -1037,6 +1028,23 @@
   return builder.Finish();
 }
 
+Node* JSCreateLowering::AllocateMutableHeapNumber(double value, Node* effect,
+                                                  Node* control) {
+  // TODO(turbofan): Support inline allocation of MutableHeapNumber
+  // (requires proper alignment on Allocate, and Begin/FinishRegion).
+  Callable callable = CodeFactory::AllocateMutableHeapNumber(isolate());
+  CallDescriptor* desc = Linkage::GetStubCallDescriptor(
+      isolate(), jsgraph()->zone(), callable.descriptor(), 0,
+      CallDescriptor::kNoFlags, Operator::kNoThrow);
+  Node* result = effect = graph()->NewNode(
+      common()->Call(desc), jsgraph()->HeapConstant(callable.code()),
+      jsgraph()->NoContextConstant(), effect, control);
+  effect = graph()->NewNode(
+      simplified()->StoreField(AccessBuilder::ForHeapNumberValue()), result,
+      jsgraph()->Constant(value), effect, control);
+  return result;
+}
+
 MaybeHandle<LiteralsArray> JSCreateLowering::GetSpecializationLiterals(
     Node* node) {
   Node* const closure = NodeProperties::GetValueInput(node, 0);
diff -r -u --color up/v8/src/compiler/js-create-lowering.h nw/v8/src/compiler/js-create-lowering.h
--- up/v8/src/compiler/js-create-lowering.h	2023-02-22 17:57:34.416000000 -0500
+++ nw/v8/src/compiler/js-create-lowering.h	2016-05-11 19:19:17.000000000 -0400
@@ -70,6 +70,7 @@
                                     Handle<JSObject> boilerplate,
                                     PretenureFlag pretenure,
                                     AllocationSiteUsageContext* site_context);
+  Node* AllocateMutableHeapNumber(double value, Node* effect, Node* control);
 
   // Infers the LiteralsArray to use for a given {node}.
   MaybeHandle<LiteralsArray> GetSpecializationLiterals(Node* node);
diff -r -u --color up/v8/src/compiler.cc nw/v8/src/compiler.cc
--- up/v8/src/compiler.cc	2023-02-22 17:57:33.752000000 -0500
+++ nw/v8/src/compiler.cc	2016-05-11 19:19:17.000000000 -0400
@@ -923,6 +923,7 @@
 
 
 bool Compiler::ParseAndAnalyze(ParseInfo* info) {
+  if (info->script()->source() == info->isolate()->heap()->undefined_value()) return false;
   if (!Parser::ParseStatic(info)) return false;
   return Compiler::Analyze(info);
 }
diff -r -u --color up/v8/src/crankshaft/arm/lithium-codegen-arm.cc nw/v8/src/crankshaft/arm/lithium-codegen-arm.cc
--- up/v8/src/crankshaft/arm/lithium-codegen-arm.cc	2023-02-22 17:57:35.124000000 -0500
+++ nw/v8/src/crankshaft/arm/lithium-codegen-arm.cc	2016-05-11 19:19:17.000000000 -0400
@@ -2443,12 +2443,11 @@
 
   __ JumpIfSmi(input, is_false);
 
-  __ CompareObjectType(input, temp, temp2, FIRST_FUNCTION_TYPE);
-  STATIC_ASSERT(LAST_FUNCTION_TYPE == LAST_TYPE);
+  __ CompareObjectType(input, temp, temp2, JS_FUNCTION_TYPE);
   if (String::Equals(isolate()->factory()->Function_string(), class_name)) {
-    __ b(hs, is_true);
+    __ b(eq, is_true);
   } else {
-    __ b(hs, is_false);
+    __ b(eq, is_false);
   }
 
   // Check if the constructor in the map is a function.
diff -r -u --color up/v8/src/crankshaft/arm64/lithium-codegen-arm64.cc nw/v8/src/crankshaft/arm64/lithium-codegen-arm64.cc
--- up/v8/src/crankshaft/arm64/lithium-codegen-arm64.cc	2023-02-22 17:57:35.187000000 -0500
+++ nw/v8/src/crankshaft/arm64/lithium-codegen-arm64.cc	2016-05-11 19:19:17.000000000 -0400
@@ -2225,12 +2225,11 @@
   __ JumpIfSmi(input, false_label);
 
   Register map = scratch2;
-  __ CompareObjectType(input, map, scratch1, FIRST_FUNCTION_TYPE);
-  STATIC_ASSERT(LAST_FUNCTION_TYPE == LAST_TYPE);
+  __ CompareObjectType(input, map, scratch1, JS_FUNCTION_TYPE);
   if (String::Equals(isolate()->factory()->Function_string(), class_name)) {
-    __ B(hs, true_label);
+    __ B(eq, true_label);
   } else {
-    __ B(hs, false_label);
+    __ B(eq, false_label);
   }
 
   // Check if the constructor in the map is a function.
diff -r -u --color up/v8/src/crankshaft/hydrogen.cc nw/v8/src/crankshaft/hydrogen.cc
--- up/v8/src/crankshaft/hydrogen.cc	2023-02-22 17:57:35.378000000 -0500
+++ nw/v8/src/crankshaft/hydrogen.cc	2016-05-11 19:19:17.000000000 -0400
@@ -7600,13 +7600,9 @@
   // Get transition target for each map (NULL == no transition).
   for (int i = 0; i < maps->length(); ++i) {
     Handle<Map> map = maps->at(i);
-    Map* transitioned_map =
-        map->FindElementsKindTransitionedMap(&possible_transitioned_maps);
-    if (transitioned_map != nullptr) {
-      transition_target.Add(handle(transitioned_map));
-    } else {
-      transition_target.Add(Handle<Map>());
-    }
+    Handle<Map> transitioned_map =
+        Map::FindTransitionedMap(map, &possible_transitioned_maps);
+    transition_target.Add(transitioned_map);
   }
 
   MapHandleList untransitionable_maps(maps->length());
diff -r -u --color up/v8/src/crankshaft/ia32/lithium-codegen-ia32.cc nw/v8/src/crankshaft/ia32/lithium-codegen-ia32.cc
--- up/v8/src/crankshaft/ia32/lithium-codegen-ia32.cc	2023-02-22 17:57:35.459000000 -0500
+++ nw/v8/src/crankshaft/ia32/lithium-codegen-ia32.cc	2016-05-11 19:19:17.000000000 -0400
@@ -2342,12 +2342,11 @@
   DCHECK(!temp.is(temp2));
   __ JumpIfSmi(input, is_false);
 
-  __ CmpObjectType(input, FIRST_FUNCTION_TYPE, temp);
-  STATIC_ASSERT(LAST_FUNCTION_TYPE == LAST_TYPE);
+  __ CmpObjectType(input, JS_FUNCTION_TYPE, temp);
   if (String::Equals(isolate()->factory()->Function_string(), class_name)) {
-    __ j(above_equal, is_true);
+    __ j(equal, is_true);
   } else {
-    __ j(above_equal, is_false);
+    __ j(equal, is_false);
   }
 
   // Now we are in the FIRST-LAST_NONCALLABLE_SPEC_OBJECT_TYPE range.
diff -r -u --color up/v8/src/crankshaft/mips/lithium-codegen-mips.cc nw/v8/src/crankshaft/mips/lithium-codegen-mips.cc
--- up/v8/src/crankshaft/mips/lithium-codegen-mips.cc	2023-02-22 17:57:35.550000000 -0500
+++ nw/v8/src/crankshaft/mips/lithium-codegen-mips.cc	2016-05-11 19:19:17.000000000 -0400
@@ -2355,11 +2355,10 @@
 
   __ JumpIfSmi(input, is_false);
   __ GetObjectType(input, temp, temp2);
-  STATIC_ASSERT(LAST_FUNCTION_TYPE == LAST_TYPE);
   if (String::Equals(isolate()->factory()->Function_string(), class_name)) {
-    __ Branch(is_true, hs, temp2, Operand(FIRST_FUNCTION_TYPE));
+    __ Branch(is_true, eq, temp2, Operand(JS_FUNCTION_TYPE));
   } else {
-    __ Branch(is_false, hs, temp2, Operand(FIRST_FUNCTION_TYPE));
+    __ Branch(is_false, eq, temp2, Operand(JS_FUNCTION_TYPE));
   }
 
   // Check if the constructor in the map is a function.
diff -r -u --color up/v8/src/crankshaft/mips64/lithium-codegen-mips64.cc nw/v8/src/crankshaft/mips64/lithium-codegen-mips64.cc
--- up/v8/src/crankshaft/mips64/lithium-codegen-mips64.cc	2023-02-22 17:57:35.593000000 -0500
+++ nw/v8/src/crankshaft/mips64/lithium-codegen-mips64.cc	2016-05-11 19:19:17.000000000 -0400
@@ -2473,11 +2473,10 @@
   __ JumpIfSmi(input, is_false);
 
   __ GetObjectType(input, temp, temp2);
-  STATIC_ASSERT(LAST_FUNCTION_TYPE == LAST_TYPE);
   if (String::Equals(isolate()->factory()->Function_string(), class_name)) {
-    __ Branch(is_true, hs, temp2, Operand(FIRST_FUNCTION_TYPE));
+    __ Branch(is_true, eq, temp2, Operand(JS_FUNCTION_TYPE));
   } else {
-    __ Branch(is_false, hs, temp2, Operand(FIRST_FUNCTION_TYPE));
+    __ Branch(is_false, eq, temp2, Operand(JS_FUNCTION_TYPE));
   }
 
   // Now we are in the FIRST-LAST_NONCALLABLE_SPEC_OBJECT_TYPE range.
diff -r -u --color up/v8/src/crankshaft/ppc/lithium-codegen-ppc.cc nw/v8/src/crankshaft/ppc/lithium-codegen-ppc.cc
--- up/v8/src/crankshaft/ppc/lithium-codegen-ppc.cc	2023-02-22 17:57:35.622000000 -0500
+++ nw/v8/src/crankshaft/ppc/lithium-codegen-ppc.cc	2016-05-11 19:19:17.000000000 -0400
@@ -2498,12 +2498,11 @@
 
   __ JumpIfSmi(input, is_false);
 
-  __ CompareObjectType(input, temp, temp2, FIRST_FUNCTION_TYPE);
-  STATIC_ASSERT(LAST_FUNCTION_TYPE == LAST_TYPE);
+  __ CompareObjectType(input, temp, temp2, JS_FUNCTION_TYPE);
   if (String::Equals(isolate()->factory()->Function_string(), class_name)) {
-    __ bge(is_true);
+    __ beq(is_true);
   } else {
-    __ bge(is_false);
+    __ beq(is_false);
   }
 
   // Check if the constructor in the map is a function.
diff -r -u --color up/v8/src/crankshaft/x64/lithium-codegen-x64.cc nw/v8/src/crankshaft/x64/lithium-codegen-x64.cc
--- up/v8/src/crankshaft/x64/lithium-codegen-x64.cc	2023-02-22 17:57:35.655000000 -0500
+++ nw/v8/src/crankshaft/x64/lithium-codegen-x64.cc	2016-05-11 19:19:17.000000000 -0400
@@ -2393,12 +2393,11 @@
 
   __ JumpIfSmi(input, is_false);
 
-  __ CmpObjectType(input, FIRST_FUNCTION_TYPE, temp);
-  STATIC_ASSERT(LAST_FUNCTION_TYPE == LAST_TYPE);
+  __ CmpObjectType(input, JS_FUNCTION_TYPE, temp);
   if (String::Equals(isolate()->factory()->Function_string(), class_name)) {
-    __ j(above_equal, is_true);
+    __ j(equal, is_true);
   } else {
-    __ j(above_equal, is_false);
+    __ j(equal, is_false);
   }
 
   // Check if the constructor in the map is a function.
diff -r -u --color up/v8/src/crankshaft/x87/lithium-codegen-x87.cc nw/v8/src/crankshaft/x87/lithium-codegen-x87.cc
--- up/v8/src/crankshaft/x87/lithium-codegen-x87.cc	2023-02-22 17:57:35.710000000 -0500
+++ nw/v8/src/crankshaft/x87/lithium-codegen-x87.cc	2016-05-11 19:19:17.000000000 -0400
@@ -2629,12 +2629,11 @@
   DCHECK(!temp.is(temp2));
   __ JumpIfSmi(input, is_false);
 
-  __ CmpObjectType(input, FIRST_FUNCTION_TYPE, temp);
-  STATIC_ASSERT(LAST_FUNCTION_TYPE == LAST_TYPE);
+  __ CmpObjectType(input, JS_FUNCTION_TYPE, temp);
   if (String::Equals(isolate()->factory()->Function_string(), class_name)) {
-    __ j(above_equal, is_true);
+    __ j(equal, is_true);
   } else {
-    __ j(above_equal, is_false);
+    __ j(equal, is_false);
   }
 
   // Now we are in the FIRST-LAST_NONCALLABLE_SPEC_OBJECT_TYPE range.
diff -r -u --color up/v8/src/full-codegen/arm/full-codegen-arm.cc nw/v8/src/full-codegen/arm/full-codegen-arm.cc
--- up/v8/src/full-codegen/arm/full-codegen-arm.cc	2023-02-22 17:57:36.117000000 -0500
+++ nw/v8/src/full-codegen/arm/full-codegen-arm.cc	2016-05-11 19:19:17.000000000 -0400
@@ -3075,10 +3075,9 @@
   // Map is now in r0.
   __ b(lt, &null);
 
-  // Return 'Function' for JSFunction and JSBoundFunction objects.
-  __ cmp(r1, Operand(FIRST_FUNCTION_TYPE));
-  STATIC_ASSERT(LAST_FUNCTION_TYPE == LAST_TYPE);
-  __ b(hs, &function);
+  // Return 'Function' for JSFunction objects.
+  __ cmp(r1, Operand(JS_FUNCTION_TYPE));
+  __ b(eq, &function);
 
   // Check if the constructor in the map is a JS function.
   Register instance_type = r2;
diff -r -u --color up/v8/src/full-codegen/arm64/full-codegen-arm64.cc nw/v8/src/full-codegen/arm64/full-codegen-arm64.cc
--- up/v8/src/full-codegen/arm64/full-codegen-arm64.cc	2023-02-22 17:57:36.128000000 -0500
+++ nw/v8/src/full-codegen/arm64/full-codegen-arm64.cc	2016-05-11 19:19:17.000000000 -0400
@@ -2863,9 +2863,8 @@
   __ B(lt, &null);
 
   // Return 'Function' for JSFunction objects.
-  __ Cmp(x11, FIRST_FUNCTION_TYPE);
-  STATIC_ASSERT(LAST_FUNCTION_TYPE == LAST_TYPE);
-  __ B(hs, &function);
+  __ Cmp(x11, JS_FUNCTION_TYPE);
+  __ B(eq, &function);
 
   // Check if the constructor in the map is a JS function.
   Register instance_type = x14;
diff -r -u --color up/v8/src/full-codegen/ia32/full-codegen-ia32.cc nw/v8/src/full-codegen/ia32/full-codegen-ia32.cc
--- up/v8/src/full-codegen/ia32/full-codegen-ia32.cc	2023-02-22 17:57:36.152000000 -0500
+++ nw/v8/src/full-codegen/ia32/full-codegen-ia32.cc	2016-05-11 19:19:17.000000000 -0400
@@ -2953,10 +2953,9 @@
   __ CmpObjectType(eax, FIRST_JS_RECEIVER_TYPE, eax);
   __ j(below, &null, Label::kNear);
 
-  // Return 'Function' for JSFunction and JSBoundFunction objects.
-  __ CmpInstanceType(eax, FIRST_FUNCTION_TYPE);
-  STATIC_ASSERT(LAST_FUNCTION_TYPE == LAST_TYPE);
-  __ j(above_equal, &function, Label::kNear);
+  // Return 'Function' for JSFunction objects.
+  __ CmpInstanceType(eax, JS_FUNCTION_TYPE);
+  __ j(equal, &function, Label::kNear);
 
   // Check if the constructor in the map is a JS function.
   __ GetMapConstructor(eax, eax, ebx);
diff -r -u --color up/v8/src/full-codegen/mips/full-codegen-mips.cc nw/v8/src/full-codegen/mips/full-codegen-mips.cc
--- up/v8/src/full-codegen/mips/full-codegen-mips.cc	2023-02-22 17:57:36.166000000 -0500
+++ nw/v8/src/full-codegen/mips/full-codegen-mips.cc	2016-05-11 19:19:17.000000000 -0400
@@ -3073,9 +3073,8 @@
   __ GetObjectType(v0, v0, a1);  // Map is now in v0.
   __ Branch(&null, lt, a1, Operand(FIRST_JS_RECEIVER_TYPE));
 
-  // Return 'Function' for JSFunction and JSBoundFunction objects.
-  STATIC_ASSERT(LAST_FUNCTION_TYPE == LAST_TYPE);
-  __ Branch(&function, hs, a1, Operand(FIRST_FUNCTION_TYPE));
+  // Return 'Function' for JSFunction objects.
+  __ Branch(&function, eq, a1, Operand(JS_FUNCTION_TYPE));
 
   // Check if the constructor in the map is a JS function.
   Register instance_type = a2;
diff -r -u --color up/v8/src/full-codegen/mips64/full-codegen-mips64.cc nw/v8/src/full-codegen/mips64/full-codegen-mips64.cc
--- up/v8/src/full-codegen/mips64/full-codegen-mips64.cc	2023-02-22 17:57:36.182000000 -0500
+++ nw/v8/src/full-codegen/mips64/full-codegen-mips64.cc	2016-05-11 19:19:17.000000000 -0400
@@ -3077,9 +3077,8 @@
   __ GetObjectType(v0, v0, a1);  // Map is now in v0.
   __ Branch(&null, lt, a1, Operand(FIRST_JS_RECEIVER_TYPE));
 
-  // Return 'Function' for JSFunction and JSBoundFunction objects.
-  STATIC_ASSERT(LAST_FUNCTION_TYPE == LAST_TYPE);
-  __ Branch(&function, hs, a1, Operand(FIRST_FUNCTION_TYPE));
+  // Return 'Function' for JSFunction objects.
+  __ Branch(&function, eq, a1, Operand(JS_FUNCTION_TYPE));
 
   // Check if the constructor in the map is a JS function.
   Register instance_type = a2;
diff -r -u --color up/v8/src/full-codegen/ppc/full-codegen-ppc.cc nw/v8/src/full-codegen/ppc/full-codegen-ppc.cc
--- up/v8/src/full-codegen/ppc/full-codegen-ppc.cc	2023-02-22 17:57:36.196000000 -0500
+++ nw/v8/src/full-codegen/ppc/full-codegen-ppc.cc	2016-05-11 19:19:17.000000000 -0400
@@ -3077,10 +3077,9 @@
   // Map is now in r3.
   __ blt(&null);
 
-  // Return 'Function' for JSFunction and JSBoundFunction objects.
-  __ cmpli(r4, Operand(FIRST_FUNCTION_TYPE));
-  STATIC_ASSERT(LAST_FUNCTION_TYPE == LAST_TYPE);
-  __ bge(&function);
+  // Return 'Function' for JSFunction objects.
+  __ cmpi(r4, Operand(JS_FUNCTION_TYPE));
+  __ beq(&function);
 
   // Check if the constructor in the map is a JS function.
   Register instance_type = r5;
diff -r -u --color up/v8/src/full-codegen/x64/full-codegen-x64.cc nw/v8/src/full-codegen/x64/full-codegen-x64.cc
--- up/v8/src/full-codegen/x64/full-codegen-x64.cc	2023-02-22 17:57:36.210000000 -0500
+++ nw/v8/src/full-codegen/x64/full-codegen-x64.cc	2016-05-11 19:19:17.000000000 -0400
@@ -2944,10 +2944,9 @@
   __ CmpObjectType(rax, FIRST_JS_RECEIVER_TYPE, rax);
   __ j(below, &null, Label::kNear);
 
-  // Return 'Function' for JSFunction and JSBoundFunction objects.
-  __ CmpInstanceType(rax, FIRST_FUNCTION_TYPE);
-  STATIC_ASSERT(LAST_FUNCTION_TYPE == LAST_TYPE);
-  __ j(above_equal, &function, Label::kNear);
+  // Return 'Function' for JSFunction objects.
+  __ CmpInstanceType(rax, JS_FUNCTION_TYPE);
+  __ j(equal, &function, Label::kNear);
 
   // Check if the constructor in the map is a JS function.
   __ GetMapConstructor(rax, rax, rbx);
diff -r -u --color up/v8/src/full-codegen/x87/full-codegen-x87.cc nw/v8/src/full-codegen/x87/full-codegen-x87.cc
--- up/v8/src/full-codegen/x87/full-codegen-x87.cc	2023-02-22 17:57:36.224000000 -0500
+++ nw/v8/src/full-codegen/x87/full-codegen-x87.cc	2016-05-11 19:19:17.000000000 -0400
@@ -2945,10 +2945,9 @@
   __ CmpObjectType(eax, FIRST_JS_RECEIVER_TYPE, eax);
   __ j(below, &null, Label::kNear);
 
-  // Return 'Function' for JSFunction and JSBoundFunction objects.
-  __ CmpInstanceType(eax, FIRST_FUNCTION_TYPE);
-  STATIC_ASSERT(LAST_FUNCTION_TYPE == LAST_TYPE);
-  __ j(above_equal, &function, Label::kNear);
+  // Return 'Function' for JSFunction objects.
+  __ CmpInstanceType(eax, JS_FUNCTION_TYPE);
+  __ j(equal, &function, Label::kNear);
 
   // Check if the constructor in the map is a JS function.
   __ GetMapConstructor(eax, eax, ebx);
diff -r -u --color up/v8/src/ic/ic-compiler.cc nw/v8/src/ic/ic-compiler.cc
--- up/v8/src/ic/ic-compiler.cc	2023-02-22 17:57:36.778000000 -0500
+++ nw/v8/src/ic/ic-compiler.cc	2016-05-11 19:19:17.000000000 -0400
@@ -235,11 +235,8 @@
   for (int i = 0; i < receiver_maps->length(); ++i) {
     Handle<Map> receiver_map(receiver_maps->at(i));
     Handle<Code> cached_stub;
-    Handle<Map> transitioned_map;
-    {
-      Map* tmap = receiver_map->FindElementsKindTransitionedMap(receiver_maps);
-      if (tmap != nullptr) transitioned_map = handle(tmap);
-    }
+    Handle<Map> transitioned_map =
+        Map::FindTransitionedMap(receiver_map, receiver_maps);
 
     // TODO(mvstanton): The code below is doing pessimistic elements
     // transitions. I would like to stop doing that and rely on Allocation Site
diff -r -u --color up/v8/src/ic/ic.cc nw/v8/src/ic/ic.cc
--- up/v8/src/ic/ic.cc	2023-02-22 17:57:36.786000000 -0500
+++ nw/v8/src/ic/ic.cc	2016-05-11 19:19:17.000000000 -0400
@@ -836,12 +836,11 @@
   ElementsKind target_elements_kind = target_map->elements_kind();
   bool more_general_transition = IsMoreGeneralElementsKindTransition(
       source_map->elements_kind(), target_elements_kind);
-  Map* transitioned_map = nullptr;
-  if (more_general_transition) {
-    MapHandleList map_list;
-    map_list.Add(handle(target_map));
-    transitioned_map = source_map->FindElementsKindTransitionedMap(&map_list);
-  }
+  Map* transitioned_map =
+      more_general_transition
+          ? source_map->LookupElementsTransitionMap(target_elements_kind)
+          : NULL;
+
   return transitioned_map == target_map;
 }
 
diff -r -u --color up/v8/src/js/array-iterator.js nw/v8/src/js/array-iterator.js
--- up/v8/src/js/array-iterator.js	2023-02-22 17:57:37.118000000 -0500
+++ nw/v8/src/js/array-iterator.js	2016-05-11 19:19:17.000000000 -0400
@@ -139,6 +139,7 @@
                   'entries', ArrayEntries, DONT_ENUM);
 %AddNamedProperty(GlobalTypedArray.prototype, 'values', ArrayValues, DONT_ENUM);
 %AddNamedProperty(GlobalTypedArray.prototype, 'keys', ArrayKeys, DONT_ENUM);
+%AddNamedProperty(GlobalTypedArray.prototype, '__nw_is_gta', 1, READ_ONLY | DONT_ENUM);
 %AddNamedProperty(GlobalTypedArray.prototype,
                   iteratorSymbol, ArrayValues, DONT_ENUM);
 
diff -r -u --color up/v8/src/js/string.js nw/v8/src/js/string.js
--- up/v8/src/js/string.js	2023-02-22 17:57:37.179000000 -0500
+++ nw/v8/src/js/string.js	2016-05-11 19:19:17.000000000 -0400
@@ -558,6 +558,18 @@
 }
 
 
+// ECMA-262, section 15.5.3.2
+function StringFromCharCode(_) {  // length == 1
+  "use strict";
+  var s = "";
+  var n = arguments.length;
+  for (var i = 0; i < n; ++i) {
+    s += %_StringCharFromCode(arguments[i] & 0xffff);
+  }
+  return s;
+}
+
+
 // ES6 draft, revision 26 (2014-07-18), section B.2.3.2.1
 function HtmlEscape(str) {
   return %_Call(StringReplace, TO_STRING(str), /"/g, "&quot;");
@@ -848,6 +860,7 @@
 
 // Set up the non-enumerable functions on the String object.
 utils.InstallFunctions(GlobalString, DONT_ENUM, [
+  "fromCharCode", StringFromCharCode,
   "fromCodePoint", StringFromCodePoint,
   "raw", StringRaw
 ]);
diff -r -u --color up/v8/src/js/typedarray.js nw/v8/src/js/typedarray.js
--- up/v8/src/js/typedarray.js	2023-02-22 17:57:37.195000000 -0500
+++ nw/v8/src/js/typedarray.js	2016-05-11 19:19:17.000000000 -0400
@@ -252,7 +252,9 @@
       // path that seems to be an optimized version of what's below, but
       // in an observably different way.
       var iteratorFn = arg1[iteratorSymbol];
-      if (IS_UNDEFINED(iteratorFn) || iteratorFn === ArrayValues) {
+      // The comparasion between iteratorFn and ArrayValues fail between contexts
+      // so a flag propery is used
+      if (IS_UNDEFINED(iteratorFn) || iteratorFn === ArrayValues || arg1['__nw_is_gta']) {
         NAMEConstructByArrayLike(this, arg1);
       } else {
         NAMEConstructByIterable(this, arg1, iteratorFn);
Only in nw/v8/src: nwjc.cc
diff -r -u --color up/v8/src/objects-inl.h nw/v8/src/objects-inl.h
--- up/v8/src/objects-inl.h	2023-02-22 17:57:37.785000000 -0500
+++ nw/v8/src/objects-inl.h	2016-05-11 19:19:17.000000000 -0400
@@ -18,7 +18,6 @@
 #include "src/conversions-inl.h"
 #include "src/factory.h"
 #include "src/field-index-inl.h"
-#include "src/field-type.h"
 #include "src/handles-inl.h"
 #include "src/heap/heap-inl.h"
 #include "src/heap/heap.h"
@@ -2725,25 +2724,6 @@
   return NULL;
 }
 
-// static
-Handle<Map> Map::ReconfigureProperty(Handle<Map> map, int modify_index,
-                                     PropertyKind new_kind,
-                                     PropertyAttributes new_attributes,
-                                     Representation new_representation,
-                                     Handle<FieldType> new_field_type,
-                                     StoreMode store_mode) {
-  return Reconfigure(map, map->elements_kind(), modify_index, new_kind,
-                     new_attributes, new_representation, new_field_type,
-                     store_mode);
-}
-
-// static
-Handle<Map> Map::ReconfigureElementsKind(Handle<Map> map,
-                                         ElementsKind new_elements_kind) {
-  return Reconfigure(map, new_elements_kind, -1, kData, NONE,
-                     Representation::None(), FieldType::None(map->GetIsolate()),
-                     ALLOW_IN_DESCRIPTOR);
-}
 
 Object** DescriptorArray::GetKeySlot(int descriptor_number) {
   DCHECK(descriptor_number < number_of_descriptors());
diff -r -u --color up/v8/src/objects.cc nw/v8/src/objects.cc
--- up/v8/src/objects.cc	2023-02-22 17:57:37.812000000 -0500
+++ nw/v8/src/objects.cc	2016-05-11 19:19:17.000000000 -0400
@@ -714,14 +714,9 @@
       case LookupIterator::NOT_FOUND:
       case LookupIterator::TRANSITION:
         UNREACHABLE();
-      case LookupIterator::JSPROXY: {
-        bool was_found;
-        MaybeHandle<Object> result =
-            JSProxy::GetProperty(it->isolate(), it->GetHolder<JSProxy>(),
-                                 it->GetName(), it->GetReceiver(), &was_found);
-        if (!was_found) it->NotFound();
-        return result;
-      }
+      case LookupIterator::JSPROXY:
+        return JSProxy::GetProperty(it->isolate(), it->GetHolder<JSProxy>(),
+                                    it->GetName(), it->GetReceiver());
       case LookupIterator::INTERCEPTOR: {
         bool done;
         Handle<Object> result;
@@ -761,9 +756,7 @@
 MaybeHandle<Object> JSProxy::GetProperty(Isolate* isolate,
                                          Handle<JSProxy> proxy,
                                          Handle<Name> name,
-                                         Handle<Object> receiver,
-                                         bool* was_found) {
-  *was_found = true;
+                                         Handle<Object> receiver) {
   if (receiver->IsJSGlobalObject()) {
     THROW_NEW_ERROR(
         isolate,
@@ -796,9 +789,7 @@
     // 7.a Return target.[[Get]](P, Receiver).
     LookupIterator it =
         LookupIterator::PropertyOrElement(isolate, receiver, name, target);
-    MaybeHandle<Object> result = Object::GetProperty(&it);
-    *was_found = it.IsFound();
-    return result;
+    return Object::GetProperty(&it);
   }
   // 8. Let trapResult be ? Call(trap, handler, «target, P, Receiver»).
   Handle<Object> trap_result;
@@ -2681,16 +2672,6 @@
   }
 }
 
-bool Map::InstancesNeedRewriting(Map* target) {
-  int target_number_of_fields = target->NumberOfFields();
-  int target_inobject = target->GetInObjectProperties();
-  int target_unused = target->unused_property_fields();
-  int old_number_of_fields;
-
-  return InstancesNeedRewriting(target, target_number_of_fields,
-                                target_inobject, target_unused,
-                                &old_number_of_fields);
-}
 
 bool Map::InstancesNeedRewriting(Map* target, int target_number_of_fields,
                                  int target_inobject, int target_unused,
@@ -3151,10 +3132,10 @@
   return result;
 }
 
+
 Handle<Map> Map::CopyGeneralizeAllRepresentations(
-    Handle<Map> map, ElementsKind elements_kind, int modify_index,
-    StoreMode store_mode, PropertyKind kind, PropertyAttributes attributes,
-    const char* reason) {
+    Handle<Map> map, int modify_index, StoreMode store_mode, PropertyKind kind,
+    PropertyAttributes attributes, const char* reason) {
   Isolate* isolate = map->GetIsolate();
   Handle<DescriptorArray> old_descriptors(map->instance_descriptors(), isolate);
   int number_of_own_descriptors = map->NumberOfOwnDescriptors();
@@ -3210,7 +3191,6 @@
           MaybeHandle<Object>());
     }
   }
-  new_map->set_elements_kind(elements_kind);
   return new_map;
 }
 
@@ -3448,9 +3428,9 @@
   }
 }
 
-// Reconfigures elements kind to |new_elements_kind| and/or property at
-// |modify_index| with |new_kind|, |new_attributes|, |store_mode| and/or
-// |new_representation|/|new_field_type|.
+
+// Reconfigures property at |modify_index| with |new_kind|, |new_attributes|,
+// |store_mode| and/or |new_representation|/|new_field_type|.
 // If |modify_index| is negative then no properties are reconfigured but the
 // map is migrated to the up-to-date non-deprecated state.
 //
@@ -3460,7 +3440,6 @@
 // any potential new (partial) version of the type in the transition tree.
 // To do this, on each rewrite:
 // - Search the root of the transition tree using FindRootMap.
-// - Find/create a |root_map| with requested |new_elements_kind|.
 // - Find |target_map|, the newest matching version of this map using the
 //   virtually "enhanced" |old_map|'s descriptor array (i.e. whose entry at
 //   |modify_index| is considered to be of |new_kind| and having
@@ -3476,13 +3455,12 @@
 //   Return it.
 // - Otherwise, invalidate the outdated transition target from |target_map|, and
 //   replace its transition tree with a new branch for the updated descriptors.
-Handle<Map> Map::Reconfigure(Handle<Map> old_map,
-                             ElementsKind new_elements_kind, int modify_index,
-                             PropertyKind new_kind,
-                             PropertyAttributes new_attributes,
-                             Representation new_representation,
-                             Handle<FieldType> new_field_type,
-                             StoreMode store_mode) {
+Handle<Map> Map::ReconfigureProperty(Handle<Map> old_map, int modify_index,
+                                     PropertyKind new_kind,
+                                     PropertyAttributes new_attributes,
+                                     Representation new_representation,
+                                     Handle<FieldType> new_field_type,
+                                     StoreMode store_mode) {
   DCHECK_NE(kAccessor, new_kind);  // TODO(ishell): not supported yet.
   DCHECK(store_mode != FORCE_FIELD || modify_index >= 0);
   Isolate* isolate = old_map->GetIsolate();
@@ -3497,8 +3475,7 @@
   // uninitialized value for representation None can be overwritten by both
   // smi and tagged values. Doubles, however, would require a box allocation.
   if (modify_index >= 0 && !new_representation.IsNone() &&
-      !new_representation.IsDouble() &&
-      old_map->elements_kind() == new_elements_kind) {
+      !new_representation.IsDouble()) {
     PropertyDetails old_details = old_descriptors->GetDetails(modify_index);
     Representation old_representation = old_details.representation();
 
@@ -3531,39 +3508,38 @@
   // Check the state of the root map.
   Handle<Map> root_map(old_map->FindRootMap(), isolate);
   if (!old_map->EquivalentToForTransition(*root_map)) {
-    return CopyGeneralizeAllRepresentations(
-        old_map, new_elements_kind, modify_index, store_mode, new_kind,
-        new_attributes, "GenAll_NotEquivalent");
+    return CopyGeneralizeAllRepresentations(old_map, modify_index, store_mode,
+                                            new_kind, new_attributes,
+                                            "GenAll_NotEquivalent");
   }
 
   ElementsKind from_kind = root_map->elements_kind();
-  ElementsKind to_kind = new_elements_kind;
+  ElementsKind to_kind = old_map->elements_kind();
   // TODO(ishell): Add a test for SLOW_SLOPPY_ARGUMENTS_ELEMENTS.
   if (from_kind != to_kind && to_kind != DICTIONARY_ELEMENTS &&
-      to_kind != SLOW_STRING_WRAPPER_ELEMENTS &&
       to_kind != SLOW_SLOPPY_ARGUMENTS_ELEMENTS &&
       !(IsTransitionableFastElementsKind(from_kind) &&
         IsMoreGeneralElementsKindTransition(from_kind, to_kind))) {
-    return CopyGeneralizeAllRepresentations(
-        old_map, to_kind, modify_index, store_mode, new_kind, new_attributes,
-        "GenAll_InvalidElementsTransition");
+    return CopyGeneralizeAllRepresentations(old_map, modify_index, store_mode,
+                                            new_kind, new_attributes,
+                                            "GenAll_InvalidElementsTransition");
   }
   int root_nof = root_map->NumberOfOwnDescriptors();
   if (modify_index >= 0 && modify_index < root_nof) {
     PropertyDetails old_details = old_descriptors->GetDetails(modify_index);
     if (old_details.kind() != new_kind ||
         old_details.attributes() != new_attributes) {
-      return CopyGeneralizeAllRepresentations(
-          old_map, to_kind, modify_index, store_mode, new_kind, new_attributes,
-          "GenAll_RootModification1");
+      return CopyGeneralizeAllRepresentations(old_map, modify_index, store_mode,
+                                              new_kind, new_attributes,
+                                              "GenAll_RootModification1");
     }
     if ((old_details.type() != DATA && store_mode == FORCE_FIELD) ||
         (old_details.type() == DATA &&
          (!new_field_type->NowIs(old_descriptors->GetFieldType(modify_index)) ||
           !new_representation.fits_into(old_details.representation())))) {
-      return CopyGeneralizeAllRepresentations(
-          old_map, to_kind, modify_index, store_mode, new_kind, new_attributes,
-          "GenAll_RootModification2");
+      return CopyGeneralizeAllRepresentations(old_map, modify_index, store_mode,
+                                              new_kind, new_attributes,
+                                              "GenAll_RootModification2");
     }
   }
 
@@ -3617,9 +3593,9 @@
     if (next_kind == kAccessor &&
         !EqualImmutableValues(old_descriptors->GetValue(i),
                               tmp_descriptors->GetValue(i))) {
-      return CopyGeneralizeAllRepresentations(
-          old_map, to_kind, modify_index, store_mode, new_kind, new_attributes,
-          "GenAll_Incompatible");
+      return CopyGeneralizeAllRepresentations(old_map, modify_index, store_mode,
+                                              new_kind, new_attributes,
+                                              "GenAll_Incompatible");
     }
     if (next_location == kField && tmp_details.location() == kDescriptor) break;
 
@@ -3712,9 +3688,9 @@
     if (next_kind == kAccessor &&
         !EqualImmutableValues(old_descriptors->GetValue(i),
                               tmp_descriptors->GetValue(i))) {
-      return CopyGeneralizeAllRepresentations(
-          old_map, to_kind, modify_index, store_mode, new_kind, new_attributes,
-          "GenAll_Incompatible");
+      return CopyGeneralizeAllRepresentations(old_map, modify_index, store_mode,
+                                              new_kind, new_attributes,
+                                              "GenAll_Incompatible");
     }
     DCHECK(!tmp_map->is_deprecated());
     target_map = tmp_map;
@@ -3945,9 +3921,9 @@
   // could be inserted regardless of whether transitions array is full or not.
   if (maybe_transition == NULL &&
       !TransitionArray::CanHaveMoreTransitions(split_map)) {
-    return CopyGeneralizeAllRepresentations(
-        old_map, to_kind, modify_index, store_mode, new_kind, new_attributes,
-        "GenAll_CantHaveMoreTransitions");
+    return CopyGeneralizeAllRepresentations(old_map, modify_index, store_mode,
+                                            new_kind, new_attributes,
+                                            "GenAll_CantHaveMoreTransitions");
   }
 
   old_map->NotifyLeafMapLayoutChange();
@@ -4028,27 +4004,18 @@
     if (root_map == NULL) return MaybeHandle<Map>();
     // From here on, use the map with correct elements kind as root map.
   }
-  Map* new_map = root_map->TryReplayPropertyTransitions(*old_map);
-  if (new_map == nullptr) return MaybeHandle<Map>();
-  return handle(new_map);
-}
-
-Map* Map::TryReplayPropertyTransitions(Map* old_map) {
-  DisallowHeapAllocation no_allocation;
-  DisallowDeoptimization no_deoptimization(GetIsolate());
-
-  int root_nof = NumberOfOwnDescriptors();
+  int root_nof = root_map->NumberOfOwnDescriptors();
 
   int old_nof = old_map->NumberOfOwnDescriptors();
   DescriptorArray* old_descriptors = old_map->instance_descriptors();
 
-  Map* new_map = this;
+  Map* new_map = root_map;
   for (int i = root_nof; i < old_nof; ++i) {
     PropertyDetails old_details = old_descriptors->GetDetails(i);
     Map* transition = TransitionArray::SearchTransition(
         new_map, old_details.kind(), old_descriptors->GetKey(i),
         old_details.attributes());
-    if (transition == NULL) return nullptr;
+    if (transition == NULL) return MaybeHandle<Map>();
     new_map = transition;
     DescriptorArray* new_descriptors = new_map->instance_descriptors();
 
@@ -4056,7 +4023,7 @@
     DCHECK_EQ(old_details.kind(), new_details.kind());
     DCHECK_EQ(old_details.attributes(), new_details.attributes());
     if (!old_details.representation().fits_into(new_details.representation())) {
-      return nullptr;
+      return MaybeHandle<Map>();
     }
     switch (new_details.type()) {
       case DATA: {
@@ -4064,20 +4031,20 @@
         // Cleared field types need special treatment. They represent lost
         // knowledge, so we must first generalize the new_type to "Any".
         if (FieldTypeIsCleared(new_details.representation(), new_type)) {
-          return nullptr;
+          return MaybeHandle<Map>();
         }
         PropertyType old_property_type = old_details.type();
         if (old_property_type == DATA) {
           FieldType* old_type = old_descriptors->GetFieldType(i);
           if (FieldTypeIsCleared(old_details.representation(), old_type) ||
               !old_type->NowIs(new_type)) {
-            return nullptr;
+            return MaybeHandle<Map>();
           }
         } else {
           DCHECK(old_property_type == DATA_CONSTANT);
           Object* old_value = old_descriptors->GetValue(i);
           if (!new_type->NowContains(old_value)) {
-            return nullptr;
+            return MaybeHandle<Map>();
           }
         }
         break;
@@ -4095,14 +4062,14 @@
         Object* old_value = old_descriptors->GetValue(i);
         Object* new_value = new_descriptors->GetValue(i);
         if (old_details.location() == kField || old_value != new_value) {
-          return nullptr;
+          return MaybeHandle<Map>();
         }
         break;
       }
     }
   }
-  if (new_map->NumberOfOwnDescriptors() != old_nof) return nullptr;
-  return new_map;
+  if (new_map->NumberOfOwnDescriptors() != old_nof) return MaybeHandle<Map>();
+  return handle(new_map);
 }
 
 
@@ -4760,30 +4727,17 @@
   return false;
 }
 
-Map* Map::FindElementsKindTransitionedMap(MapHandleList* candidates) {
-  DisallowHeapAllocation no_allocation;
-  DisallowDeoptimization no_deoptimization(GetIsolate());
 
-  ElementsKind kind = elements_kind();
+Handle<Map> Map::FindTransitionedMap(Handle<Map> map,
+                                     MapHandleList* candidates) {
+  ElementsKind kind = map->elements_kind();
   bool packed = IsFastPackedElementsKind(kind);
 
   Map* transition = nullptr;
   if (IsTransitionableFastElementsKind(kind)) {
-    // Check the state of the root map.
-    Map* root_map = FindRootMap();
-    if (!EquivalentToForTransition(root_map)) return nullptr;
-    root_map = root_map->LookupElementsTransitionMap(kind);
-    DCHECK_NOT_NULL(root_map);
-    // Starting from the next existing elements kind transition try to
-    // replay the property transitions that does not involve instance rewriting
-    // (ElementsTransitionAndStoreStub does not support that).
-    for (root_map = root_map->ElementsTransitionMap();
-         root_map != nullptr && root_map->has_fast_elements();
-         root_map = root_map->ElementsTransitionMap()) {
-      Map* current = root_map->TryReplayPropertyTransitions(this);
-      if (current == nullptr) continue;
-      if (InstancesNeedRewriting(current)) continue;
-
+    for (Map* current = map->ElementsTransitionMap();
+         current != nullptr && current->has_fast_elements();
+         current = current->ElementsTransitionMap()) {
       if (ContainsMap(candidates, current) &&
           (packed || !IsFastPackedElementsKind(current->elements_kind()))) {
         transition = current;
@@ -4791,14 +4745,11 @@
       }
     }
   }
-  return transition;
+  return transition == nullptr ? Handle<Map>() : handle(transition);
 }
 
 
 static Map* FindClosestElementsTransition(Map* map, ElementsKind to_kind) {
-  // Ensure we are requested to search elements kind transition "near the root".
-  DCHECK_EQ(map->FindRootMap()->NumberOfOwnDescriptors(),
-            map->NumberOfOwnDescriptors());
   Map* current_map = map;
 
   ElementsKind kind = map->elements_kind();
@@ -4929,7 +4880,7 @@
     return Map::CopyAsElementsKind(map, to_kind, OMIT_TRANSITION);
   }
 
-  return Map::ReconfigureElementsKind(map, to_kind);
+  return Map::AsElementsKind(map, to_kind);
 }
 
 
@@ -5255,7 +5206,7 @@
     } else {
       TransitionElementsKind(object, to_kind);
     }
-    map = Map::ReconfigureElementsKind(map, to_kind);
+    map = Map::AsElementsKind(map, to_kind);
   }
   JSObject::MigrateToMap(object, map);
 }
@@ -9603,10 +9554,6 @@
                                     TransitionFlag flag) {
   Map* maybe_elements_transition_map = NULL;
   if (flag == INSERT_TRANSITION) {
-    // Ensure we are requested to add elements kind transition "near the root".
-    DCHECK_EQ(map->FindRootMap()->NumberOfOwnDescriptors(),
-              map->NumberOfOwnDescriptors());
-
     maybe_elements_transition_map = map->ElementsTransitionMap();
     DCHECK(maybe_elements_transition_map == NULL ||
            (maybe_elements_transition_map->elements_kind() ==
@@ -9934,7 +9881,7 @@
     // There is no benefit from reconstructing transition tree for maps without
     // back pointers.
     return CopyGeneralizeAllRepresentations(
-        map, map->elements_kind(), descriptor, FORCE_FIELD, kind, attributes,
+        map, descriptor, FORCE_FIELD, kind, attributes,
         "GenAll_AttributesMismatchProtoMap");
   }
 
@@ -13398,18 +13345,6 @@
   return isolate->factory()->NewStringFromAsciiChecked(kNativeCodeSource);
 }
 
-// static
-MaybeHandle<String> JSBoundFunction::GetName(Isolate* isolate,
-                                             Handle<JSBoundFunction> function) {
-  Handle<String> prefix = isolate->factory()->bound__string();
-  if (!function->bound_target_function()->IsJSFunction()) return prefix;
-  Handle<JSFunction> target(JSFunction::cast(function->bound_target_function()),
-                            isolate);
-  Handle<Object> target_name = JSFunction::GetName(target);
-  if (!target_name->IsString()) return prefix;
-  Factory* factory = isolate->factory();
-  return factory->NewConsString(prefix, Handle<String>::cast(target_name));
-}
 
 // static
 Handle<String> JSFunction::ToString(Handle<JSFunction> function) {
diff -r -u --color up/v8/src/objects.h nw/v8/src/objects.h
--- up/v8/src/objects.h	2023-02-22 17:57:37.859000000 -0500
+++ nw/v8/src/objects.h	2016-05-11 19:19:17.000000000 -0400
@@ -5773,7 +5773,6 @@
   int NumberOfFields();
 
   // TODO(ishell): candidate with JSObject::MigrateToMap().
-  bool InstancesNeedRewriting(Map* target);
   bool InstancesNeedRewriting(Map* target, int target_number_of_fields,
                               int target_inobject, int target_unused,
                               int* old_number_of_fields);
@@ -5785,14 +5784,15 @@
   static void GeneralizeFieldType(Handle<Map> map, int modify_index,
                                   Representation new_representation,
                                   Handle<FieldType> new_field_type);
-
-  static inline Handle<Map> ReconfigureProperty(
-      Handle<Map> map, int modify_index, PropertyKind new_kind,
-      PropertyAttributes new_attributes, Representation new_representation,
-      Handle<FieldType> new_field_type, StoreMode store_mode);
-
-  static inline Handle<Map> ReconfigureElementsKind(
-      Handle<Map> map, ElementsKind new_elements_kind);
+  static Handle<Map> ReconfigureProperty(Handle<Map> map, int modify_index,
+                                         PropertyKind new_kind,
+                                         PropertyAttributes new_attributes,
+                                         Representation new_representation,
+                                         Handle<FieldType> new_field_type,
+                                         StoreMode store_mode);
+  static Handle<Map> CopyGeneralizeAllRepresentations(
+      Handle<Map> map, int modify_index, StoreMode store_mode,
+      PropertyKind kind, PropertyAttributes attributes, const char* reason);
 
   static Handle<Map> PrepareForDataProperty(Handle<Map> old_map,
                                             int descriptor_number,
@@ -6022,10 +6022,17 @@
   // Computes a hash value for this map, to be used in HashTables and such.
   int Hash();
 
+  // Returns the map that this map transitions to if its elements_kind
+  // is changed to |elements_kind|, or NULL if no such map is cached yet.
+  // |safe_to_add_transitions| is set to false if adding transitions is not
+  // allowed.
+  Map* LookupElementsTransitionMap(ElementsKind elements_kind);
+
   // Returns the transitioned map for this map with the most generic
-  // elements_kind that's found in |candidates|, or |nullptr| if no match is
+  // elements_kind that's found in |candidates|, or null handle if no match is
   // found at all.
-  Map* FindElementsKindTransitionedMap(MapHandleList* candidates);
+  static Handle<Map> FindTransitionedMap(Handle<Map> map,
+                                         MapHandleList* candidates);
 
   inline bool CanTransition();
 
@@ -6184,17 +6191,6 @@
       Handle<LayoutDescriptor> full_layout_descriptor);
 
  private:
-  // Returns the map that this (root) map transitions to if its elements_kind
-  // is changed to |elements_kind|, or |nullptr| if no such map is cached yet.
-  Map* LookupElementsTransitionMap(ElementsKind elements_kind);
-
-  // Tries to replay property transitions starting from this (root) map using
-  // the descriptor array of the |map|. The |root_map| is expected to have
-  // proper elements kind and therefore elements kinds transitions are not
-  // taken by this function. Returns |nullptr| if matching transition map is
-  // not found.
-  Map* TryReplayPropertyTransitions(Map* map);
-
   static void ConnectTransition(Handle<Map> parent, Handle<Map> child,
                                 Handle<Name> name, SimpleTransitionFlag flag);
 
@@ -6231,19 +6227,6 @@
   static Handle<Map> CopyNormalized(Handle<Map> map,
                                     PropertyNormalizationMode mode);
 
-  static Handle<Map> Reconfigure(Handle<Map> map,
-                                 ElementsKind new_elements_kind,
-                                 int modify_index, PropertyKind new_kind,
-                                 PropertyAttributes new_attributes,
-                                 Representation new_representation,
-                                 Handle<FieldType> new_field_type,
-                                 StoreMode store_mode);
-
-  static Handle<Map> CopyGeneralizeAllRepresentations(
-      Handle<Map> map, ElementsKind elements_kind, int modify_index,
-      StoreMode store_mode, PropertyKind kind, PropertyAttributes attributes,
-      const char* reason);
-
   // Fires when the layout of an object with a leaf map changes.
   // This includes adding transitions to the leaf map or changing
   // the descriptor array.
@@ -7411,9 +7394,6 @@
   // to ES6 section 19.2.3.5 Function.prototype.toString ( ).
   static Handle<String> ToString(Handle<JSBoundFunction> function);
 
-  static MaybeHandle<String> GetName(Isolate* isolate,
-                                     Handle<JSBoundFunction> function);
-
   // Layout description.
   static const int kBoundTargetFunctionOffset = JSObject::kHeaderSize;
   static const int kBoundThisOffset = kBoundTargetFunctionOffset + kPointerSize;
@@ -9751,7 +9731,7 @@
   // ES6 9.5.8
   MUST_USE_RESULT static MaybeHandle<Object> GetProperty(
       Isolate* isolate, Handle<JSProxy> proxy, Handle<Name> name,
-      Handle<Object> receiver, bool* was_found);
+      Handle<Object> receiver);
 
   // ES6 9.5.9
   MUST_USE_RESULT static Maybe<bool> SetProperty(Handle<JSProxy> proxy,
diff -r -u --color up/v8/src/profiler/heap-profiler.cc nw/v8/src/profiler/heap-profiler.cc
--- up/v8/src/profiler/heap-profiler.cc	2023-02-22 17:57:38.335000000 -0500
+++ nw/v8/src/profiler/heap-profiler.cc	2016-05-11 19:19:17.000000000 -0400
@@ -57,6 +57,7 @@
 v8::RetainedObjectInfo* HeapProfiler::ExecuteWrapperClassCallback(
     uint16_t class_id, Object** wrapper) {
   if (wrapper_callbacks_.length() <= class_id) return NULL;
+  if (!wrapper_callbacks_[class_id]) return NULL;
   return wrapper_callbacks_[class_id](
       class_id, Utils::ToLocal(Handle<Object>(wrapper)));
 }
diff -r -u --color up/v8/src/runtime/runtime-function.cc nw/v8/src/runtime/runtime-function.cc
--- up/v8/src/runtime/runtime-function.cc	2023-02-22 17:57:38.828000000 -0500
+++ nw/v8/src/runtime/runtime-function.cc	2016-05-11 19:19:17.000000000 -0400
@@ -16,20 +16,11 @@
 namespace internal {
 
 RUNTIME_FUNCTION(Runtime_FunctionGetName) {
-  HandleScope scope(isolate);
+  SealHandleScope shs(isolate);
   DCHECK(args.length() == 1);
 
-  CONVERT_ARG_HANDLE_CHECKED(JSReceiver, function, 0);
-  if (function->IsJSBoundFunction()) {
-  Handle<Object> result;
-    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
-        isolate, result, JSBoundFunction::GetName(
-                             isolate, Handle<JSBoundFunction>::cast(function)));
-    return *result;
-  } else {
-    RUNTIME_ASSERT(function->IsJSFunction());
-    return Handle<JSFunction>::cast(function)->shared()->name();
-  }
+  CONVERT_ARG_CHECKED(JSFunction, f, 0);
+  return f->shared()->name();
 }
 
 
diff -r -u --color up/v8/src/snapshot/serialize.cc nw/v8/src/snapshot/serialize.cc
--- up/v8/src/snapshot/serialize.cc	2023-02-22 17:57:38.906000000 -0500
+++ nw/v8/src/snapshot/serialize.cc	2016-05-11 19:19:17.000000000 -0400
@@ -2866,7 +2866,7 @@
                                                        String* source) {
   DisallowHeapAllocation no_gc;
   SerializedCodeData* scd = new SerializedCodeData(cached_data);
-  SanityCheckResult r = scd->SanityCheck(isolate, source);
+  SanityCheckResult r = CHECK_SUCCESS; //scd->SanityCheck(isolate, source);
   if (r == CHECK_SUCCESS) return scd;
   cached_data->Reject();
   source->GetIsolate()->counters()->code_cache_reject_reason()->AddSample(r);
diff -r -u --color up/v8/test/cctest/test-api.cc nw/v8/test/cctest/test-api.cc
--- up/v8/test/cctest/test-api.cc	2023-02-22 17:57:42.593000000 -0500
+++ nw/v8/test/cctest/test-api.cc	2016-05-11 19:19:17.000000000 -0400
@@ -12898,19 +12898,6 @@
   CHECK(try_catch.HasCaught());
   try_catch.Reset();
   CHECK(result.IsEmpty());
-
-  Local<Object> target = CompileRun("({})").As<Object>();
-  Local<Object> handler = CompileRun("({})").As<Object>();
-  Local<v8::Proxy> proxy =
-      v8::Proxy::New(context.local(), target, handler).ToLocalChecked();
-
-  result = target->GetRealNamedProperty(context.local(), v8_str("f"));
-  CHECK(!try_catch.HasCaught());
-  CHECK(result.IsEmpty());
-
-  result = proxy->GetRealNamedProperty(context.local(), v8_str("f"));
-  CHECK(!try_catch.HasCaught());
-  CHECK(result.IsEmpty());
 }
 
 
diff -r -u --color up/v8/test/cctest/test-field-type-tracking.cc nw/v8/test/cctest/test-field-type-tracking.cc
--- up/v8/test/cctest/test-field-type-tracking.cc	2023-02-22 17:57:42.957000000 -0500
+++ nw/v8/test/cctest/test-field-type-tracking.cc	2016-05-11 19:19:17.000000000 -0400
@@ -86,7 +86,6 @@
 class Expectations {
   static const int MAX_PROPERTIES = 10;
   Isolate* isolate_;
-  ElementsKind elements_kind_;
   PropertyType types_[MAX_PROPERTIES];
   PropertyAttributes attributes_[MAX_PROPERTIES];
   Representation representations_[MAX_PROPERTIES];
@@ -98,15 +97,8 @@
   int number_of_properties_;
 
  public:
-  explicit Expectations(Isolate* isolate, ElementsKind elements_kind)
-      : isolate_(isolate),
-        elements_kind_(elements_kind),
-        number_of_properties_(0) {}
-
   explicit Expectations(Isolate* isolate)
-      : Expectations(
-            isolate,
-            isolate->object_function()->initial_map()->elements_kind()) {}
+      : isolate_(isolate), number_of_properties_(0) {}
 
   void Init(int index, PropertyType type, PropertyAttributes attributes,
             Representation representation, Handle<Object> value) {
@@ -151,10 +143,6 @@
     os << "\n";
   }
 
-  void SetElementsKind(ElementsKind elements_kind) {
-    elements_kind_ = elements_kind;
-  }
-
   Handle<FieldType> GetFieldType(int index) {
     CHECK(index < MAX_PROPERTIES);
     CHECK(types_[index] == DATA || types_[index] == ACCESSOR);
@@ -264,7 +252,6 @@
   }
 
   bool Check(Map* map, int expected_nof) const {
-    CHECK_EQ(elements_kind_, map->elements_kind());
     CHECK(number_of_properties_ <= MAX_PROPERTIES);
     CHECK_EQ(expected_nof, map->NumberOfOwnDescriptors());
     CHECK(!map->is_dictionary_map());
@@ -292,13 +279,6 @@
   // given |map|.
   //
 
-  Handle<Map> AsElementsKind(Handle<Map> map, ElementsKind elements_kind) {
-    elements_kind_ = elements_kind;
-    map = Map::AsElementsKind(map, elements_kind);
-    CHECK_EQ(elements_kind_, map->elements_kind());
-    return map;
-  }
-
   Handle<Map> AddDataField(Handle<Map> map, PropertyAttributes attributes,
                            Representation representation,
                            Handle<FieldType> heap_type) {
@@ -1545,271 +1525,6 @@
 
 
 ////////////////////////////////////////////////////////////////////////////////
-// A set of tests for elements kind reconfiguration case.
-//
-
-// This test ensures that representation/field type generalization is correctly
-// propagated from one branch of transition tree (|map2) to another (|map|).
-//
-//   + - p0 - p1 - p2A - p3 - p4: |map|
-//   |
-//  ek
-//   |
-//  {} - p0 - p1 - p2B - p3 - p4: |map2|
-//
-// where "p2A" and "p2B" differ only in the representation/field type.
-//
-static void TestReconfigureElementsKind_GeneralizeRepresentation(
-    Representation from_representation, Handle<FieldType> from_type,
-    Representation to_representation, Handle<FieldType> to_type,
-    Representation expected_representation, Handle<FieldType> expected_type) {
-  Isolate* isolate = CcTest::i_isolate();
-
-  Expectations expectations(isolate, FAST_SMI_ELEMENTS);
-
-  // Create a map, add required properties to it and initialize expectations.
-  Handle<Map> initial_map = Map::Create(isolate, 0);
-  initial_map->set_elements_kind(FAST_SMI_ELEMENTS);
-
-  Handle<Map> map = initial_map;
-  map = expectations.AsElementsKind(map, FAST_ELEMENTS);
-  for (int i = 0; i < kPropCount; i++) {
-    map = expectations.AddDataField(map, NONE, from_representation, from_type);
-  }
-  CHECK(!map->is_deprecated());
-  CHECK(map->is_stable());
-  CHECK(expectations.Check(*map));
-
-  // Create another branch in transition tree (property at index |kDiffProp|
-  // has different representatio/field type), initialize expectations.
-  const int kDiffProp = kPropCount / 2;
-  Expectations expectations2(isolate, FAST_SMI_ELEMENTS);
-
-  Handle<Map> map2 = initial_map;
-  for (int i = 0; i < kPropCount; i++) {
-    if (i == kDiffProp) {
-      map2 = expectations2.AddDataField(map2, NONE, to_representation, to_type);
-    } else {
-      map2 = expectations2.AddDataField(map2, NONE, from_representation,
-                                        from_type);
-    }
-  }
-  CHECK(!map2->is_deprecated());
-  CHECK(map2->is_stable());
-  CHECK(expectations2.Check(*map2));
-
-  Zone zone;
-  Handle<Map> field_owner(map->FindFieldOwner(kDiffProp), isolate);
-  CompilationInfo info("testing", isolate, &zone);
-  CHECK(!info.dependencies()->HasAborted());
-  info.dependencies()->AssumeFieldType(field_owner);
-
-  // Reconfigure elements kinds of |map2|, which should generalize
-  // representations in |map|.
-  Handle<Map> new_map = Map::ReconfigureElementsKind(map2, FAST_ELEMENTS);
-
-  // |map2| should be left unchanged but marked unstable.
-  CHECK(!map2->is_stable());
-  CHECK(!map2->is_deprecated());
-  CHECK_NE(*map2, *new_map);
-  CHECK(expectations2.Check(*map2));
-
-  // |map| should be deprecated and |new_map| should match new expectations.
-  expectations.SetDataField(kDiffProp, expected_representation, expected_type);
-
-  CHECK(map->is_deprecated());
-  CHECK(!info.dependencies()->HasAborted());
-  info.dependencies()->Rollback();  // Properly cleanup compilation info.
-  CHECK_NE(*map, *new_map);
-
-  CHECK(!new_map->is_deprecated());
-  CHECK(expectations.Check(*new_map));
-
-  // Update deprecated |map|, it should become |new_map|.
-  Handle<Map> updated_map = Map::Update(map);
-  CHECK_EQ(*new_map, *updated_map);
-
-  // Ensure Map::FindElementsKindTransitionedMap() is able to find the
-  // transitioned map.
-  {
-    MapHandleList map_list;
-    map_list.Add(updated_map);
-    Map* transitioned_map = map2->FindElementsKindTransitionedMap(&map_list);
-    CHECK_EQ(*updated_map, transitioned_map);
-  }
-}
-
-// This test ensures that trivial representation/field type generalization
-// (from HeapObject to HeapObject) is correctly propagated from one branch of
-// transition tree (|map2|) to another (|map|).
-//
-//   + - p0 - p1 - p2A - p3 - p4: |map|
-//   |
-//  ek
-//   |
-//  {} - p0 - p1 - p2B - p3 - p4: |map2|
-//
-// where "p2A" and "p2B" differ only in the representation/field type.
-//
-static void TestReconfigureElementsKind_GeneralizeRepresentationTrivial(
-    Representation from_representation, Handle<FieldType> from_type,
-    Representation to_representation, Handle<FieldType> to_type,
-    Representation expected_representation, Handle<FieldType> expected_type,
-    bool expected_field_type_dependency = true) {
-  Isolate* isolate = CcTest::i_isolate();
-
-  Expectations expectations(isolate, FAST_SMI_ELEMENTS);
-
-  // Create a map, add required properties to it and initialize expectations.
-  Handle<Map> initial_map = Map::Create(isolate, 0);
-  initial_map->set_elements_kind(FAST_SMI_ELEMENTS);
-
-  Handle<Map> map = initial_map;
-  map = expectations.AsElementsKind(map, FAST_ELEMENTS);
-  for (int i = 0; i < kPropCount; i++) {
-    map = expectations.AddDataField(map, NONE, from_representation, from_type);
-  }
-  CHECK(!map->is_deprecated());
-  CHECK(map->is_stable());
-  CHECK(expectations.Check(*map));
-
-  // Create another branch in transition tree (property at index |kDiffProp|
-  // has different attributes), initialize expectations.
-  const int kDiffProp = kPropCount / 2;
-  Expectations expectations2(isolate, FAST_SMI_ELEMENTS);
-
-  Handle<Map> map2 = initial_map;
-  for (int i = 0; i < kPropCount; i++) {
-    if (i == kDiffProp) {
-      map2 = expectations2.AddDataField(map2, NONE, to_representation, to_type);
-    } else {
-      map2 = expectations2.AddDataField(map2, NONE, from_representation,
-                                        from_type);
-    }
-  }
-  CHECK(!map2->is_deprecated());
-  CHECK(map2->is_stable());
-  CHECK(expectations2.Check(*map2));
-
-  Zone zone;
-  Handle<Map> field_owner(map->FindFieldOwner(kDiffProp), isolate);
-  CompilationInfo info("testing", isolate, &zone);
-  CHECK(!info.dependencies()->HasAborted());
-  info.dependencies()->AssumeFieldType(field_owner);
-
-  // Reconfigure elements kinds of |map2|, which should generalize
-  // representations in |map|.
-  Handle<Map> new_map = Map::ReconfigureElementsKind(map2, FAST_ELEMENTS);
-
-  // |map2| should be left unchanged but marked unstable.
-  CHECK(!map2->is_stable());
-  CHECK(!map2->is_deprecated());
-  CHECK_NE(*map2, *new_map);
-  CHECK(expectations2.Check(*map2));
-
-  // In trivial case |map| should be returned as a result of the elements
-  // kind reconfiguration, respective field types should be generalized and
-  // respective code dependencies should be invalidated. |map| should be NOT
-  // deprecated and it should match new expectations.
-  expectations.SetDataField(kDiffProp, expected_representation, expected_type);
-  CHECK(!map->is_deprecated());
-  CHECK_EQ(*map, *new_map);
-  CHECK_EQ(expected_field_type_dependency, info.dependencies()->HasAborted());
-  info.dependencies()->Rollback();  // Properly cleanup compilation info.
-
-  CHECK(!new_map->is_deprecated());
-  CHECK(expectations.Check(*new_map));
-
-  Handle<Map> updated_map = Map::Update(map);
-  CHECK_EQ(*new_map, *updated_map);
-
-  // Ensure Map::FindElementsKindTransitionedMap() is able to find the
-  // transitioned map.
-  {
-    MapHandleList map_list;
-    map_list.Add(updated_map);
-    Map* transitioned_map = map2->FindElementsKindTransitionedMap(&map_list);
-    CHECK_EQ(*updated_map, transitioned_map);
-  }
-}
-
-TEST(ReconfigureElementsKind_GeneralizeRepresentationSmiToDouble) {
-  CcTest::InitializeVM();
-  v8::HandleScope scope(CcTest::isolate());
-  Isolate* isolate = CcTest::i_isolate();
-  Handle<FieldType> any_type = FieldType::Any(isolate);
-
-  TestReconfigureElementsKind_GeneralizeRepresentation(
-      Representation::Smi(), any_type, Representation::Double(), any_type,
-      Representation::Double(), any_type);
-}
-
-TEST(ReconfigureElementsKind_GeneralizeRepresentationSmiToTagged) {
-  CcTest::InitializeVM();
-  v8::HandleScope scope(CcTest::isolate());
-  Isolate* isolate = CcTest::i_isolate();
-  Handle<FieldType> any_type = FieldType::Any(isolate);
-  Handle<FieldType> value_type =
-      FieldType::Class(Map::Create(isolate, 0), isolate);
-
-  TestReconfigureElementsKind_GeneralizeRepresentation(
-      Representation::Smi(), any_type, Representation::HeapObject(), value_type,
-      Representation::Tagged(), any_type);
-}
-
-TEST(ReconfigureElementsKind_GeneralizeRepresentationDoubleToTagged) {
-  CcTest::InitializeVM();
-  v8::HandleScope scope(CcTest::isolate());
-  Isolate* isolate = CcTest::i_isolate();
-  Handle<FieldType> any_type = FieldType::Any(isolate);
-  Handle<FieldType> value_type =
-      FieldType::Class(Map::Create(isolate, 0), isolate);
-
-  TestReconfigureElementsKind_GeneralizeRepresentation(
-      Representation::Double(), any_type, Representation::HeapObject(),
-      value_type, Representation::Tagged(), any_type);
-}
-
-TEST(ReconfigureElementsKind_GeneralizeRepresentationHeapObjToHeapObj) {
-  CcTest::InitializeVM();
-  v8::HandleScope scope(CcTest::isolate());
-  Isolate* isolate = CcTest::i_isolate();
-  Handle<FieldType> any_type = FieldType::Any(isolate);
-
-  Handle<FieldType> current_type =
-      FieldType::Class(Map::Create(isolate, 0), isolate);
-
-  Handle<FieldType> new_type =
-      FieldType::Class(Map::Create(isolate, 0), isolate);
-
-  Handle<FieldType> expected_type = any_type;
-
-  TestReconfigureElementsKind_GeneralizeRepresentationTrivial(
-      Representation::HeapObject(), current_type, Representation::HeapObject(),
-      new_type, Representation::HeapObject(), expected_type);
-  current_type = expected_type;
-
-  new_type = FieldType::Class(Map::Create(isolate, 0), isolate);
-
-  TestReconfigureElementsKind_GeneralizeRepresentationTrivial(
-      Representation::HeapObject(), any_type, Representation::HeapObject(),
-      new_type, Representation::HeapObject(), any_type, false);
-}
-
-TEST(ReconfigureElementsKind_GeneralizeRepresentationHeapObjectToTagged) {
-  CcTest::InitializeVM();
-  v8::HandleScope scope(CcTest::isolate());
-  Isolate* isolate = CcTest::i_isolate();
-  Handle<FieldType> any_type = FieldType::Any(isolate);
-  Handle<FieldType> value_type =
-      FieldType::Class(Map::Create(isolate, 0), isolate);
-
-  TestReconfigureElementsKind_GeneralizeRepresentation(
-      Representation::HeapObject(), value_type, Representation::Smi(), any_type,
-      Representation::Tagged(), any_type);
-}
-
-////////////////////////////////////////////////////////////////////////////////
 // A set of tests checking split map deprecation.
 //
 
@@ -1925,16 +1640,15 @@
   CHECK(map->is_stable());
   CHECK(expectations.Check(*map));
 
-  Expectations expectations2 = expectations;
-
   // Apply some special transition to |map|.
   CHECK(map->owns_descriptors());
-  Handle<Map> map2 = config.Transition(map, expectations2);
+  Handle<Map> map2 = config.Transition(map);
 
   // |map| should still match expectations.
   CHECK(!map->is_deprecated());
   CHECK(expectations.Check(*map));
 
+  Expectations expectations2 = expectations;
   if (config.generalizes_representations()) {
     for (int i = 0; i < kPropCount; i++) {
       expectations2.GeneralizeRepresentation(i);
@@ -2006,15 +1720,13 @@
       FieldType::Class(Map::Create(isolate, 0), isolate);
 
   struct TestConfig {
-    Handle<Map> Transition(Handle<Map> map, Expectations& expectations) {
-      Handle<Symbol> frozen_symbol(map->GetHeap()->frozen_symbol());
-      expectations.SetElementsKind(DICTIONARY_ELEMENTS);
-      return Map::CopyForPreventExtensions(map, NONE, frozen_symbol,
-                                           "CopyForPreventExtensions");
+    Handle<Map> Transition(Handle<Map> map) {
+      return Map::CopyAsElementsKind(map, DICTIONARY_ELEMENTS,
+                                     INSERT_TRANSITION);
     }
     // TODO(ishell): remove once IS_PROTO_TRANS_ISSUE_FIXED is removed.
     bool generalizes_representations() const { return false; }
-    bool is_non_equevalent_transition() const { return true; }
+    bool is_non_equevalent_transition() const { return false; }
   };
   TestConfig config;
   TestGeneralizeRepresentationWithSpecialTransition(
@@ -2032,7 +1744,7 @@
       FieldType::Class(Map::Create(isolate, 0), isolate);
 
   struct TestConfig {
-    Handle<Map> Transition(Handle<Map> map, Expectations& expectations) {
+    Handle<Map> Transition(Handle<Map> map) {
       Isolate* isolate = CcTest::i_isolate();
       Handle<FieldType> any_type = FieldType::Any(isolate);
 
@@ -2044,14 +1756,12 @@
           .ToHandleChecked();
       CHECK(!map->owns_descriptors());
 
-      Handle<Symbol> frozen_symbol(map->GetHeap()->frozen_symbol());
-      expectations.SetElementsKind(DICTIONARY_ELEMENTS);
-      return Map::CopyForPreventExtensions(map, NONE, frozen_symbol,
-                                           "CopyForPreventExtensions");
+      return Map::CopyAsElementsKind(map, DICTIONARY_ELEMENTS,
+                                     INSERT_TRANSITION);
     }
     // TODO(ishell): remove once IS_PROTO_TRANS_ISSUE_FIXED is removed.
     bool generalizes_representations() const { return false; }
-    bool is_non_equevalent_transition() const { return true; }
+    bool is_non_equevalent_transition() const { return false; }
   };
   TestConfig config;
   TestGeneralizeRepresentationWithSpecialTransition(
@@ -2069,7 +1779,7 @@
       FieldType::Class(Map::Create(isolate, 0), isolate);
 
   struct TestConfig {
-    Handle<Map> Transition(Handle<Map> map, Expectations& expectations) {
+    Handle<Map> Transition(Handle<Map> map) {
       return Map::CopyForObserved(map);
     }
     // TODO(ishell): remove once IS_PROTO_TRANS_ISSUE_FIXED is removed.
@@ -2092,7 +1802,7 @@
       FieldType::Class(Map::Create(isolate, 0), isolate);
 
   struct TestConfig {
-    Handle<Map> Transition(Handle<Map> map, Expectations& expectations) {
+    Handle<Map> Transition(Handle<Map> map) {
       Isolate* isolate = CcTest::i_isolate();
       Handle<FieldType> any_type = FieldType::Any(isolate);
 
@@ -2135,7 +1845,7 @@
       prototype_ = factory->NewJSObjectFromMap(Map::Create(isolate, 0));
     }
 
-    Handle<Map> Transition(Handle<Map> map, Expectations& expectations) {
+    Handle<Map> Transition(Handle<Map> map) {
       return Map::TransitionToPrototype(map, prototype_, REGULAR_PROTOTYPE);
     }
     // TODO(ishell): remove once IS_PROTO_TRANS_ISSUE_FIXED is removed.
@@ -2169,7 +1879,7 @@
       prototype_ = factory->NewJSObjectFromMap(Map::Create(isolate, 0));
     }
 
-    Handle<Map> Transition(Handle<Map> map, Expectations& expectations) {
+    Handle<Map> Transition(Handle<Map> map) {
       Isolate* isolate = CcTest::i_isolate();
       Handle<FieldType> any_type = FieldType::Any(isolate);
 
diff -r -u --color up/v8/test/cctest/test-strings.cc nw/v8/test/cctest/test-strings.cc
--- up/v8/test/cctest/test-strings.cc	2023-02-22 17:57:43.085000000 -0500
+++ nw/v8/test/cctest/test-strings.cc	2016-05-11 19:19:17.000000000 -0400
@@ -1508,25 +1508,3 @@
       "'arg0' returned for property 'arg1' of object 'arg2' is not a function");
   CHECK(String::Equals(result, expected));
 }
-
-TEST(Regress609831) {
-  CcTest::InitializeVM();
-  LocalContext context;
-  Isolate* isolate = CcTest::i_isolate();
-  {
-    HandleScope scope(isolate);
-    v8::Local<v8::Value> result = CompileRun(
-        "String.fromCharCode(32, 32, 32, 32, 32, "
-        "32, 32, 32, 32, 32, 32, 32, 32, 32, 32, "
-        "32, 32, 32, 32, 32, 32, 32, 32, 32, 32)");
-    CHECK(v8::Utils::OpenHandle(*result)->IsSeqOneByteString());
-  }
-  {
-    HandleScope scope(isolate);
-    v8::Local<v8::Value> result = CompileRun(
-        "String.fromCharCode(432, 432, 432, 432, 432, "
-        "432, 432, 432, 432, 432, 432, 432, 432, 432, "
-        "432, 432, 432, 432, 432, 432, 432, 432, 432)");
-    CHECK(v8::Utils::OpenHandle(*result)->IsSeqTwoByteString());
-  }
-}
diff -r -u --color up/v8/test/mjsunit/mirror-function.js nw/v8/test/mjsunit/mirror-function.js
--- up/v8/test/mjsunit/mirror-function.js	2023-02-22 17:57:45.818000000 -0500
+++ nw/v8/test/mjsunit/mirror-function.js	2016-05-11 19:19:17.000000000 -0400
@@ -88,4 +88,3 @@
 testFunctionMirror(function(){});
 testFunctionMirror(function a(){return 1;});
 testFunctionMirror(Math.sin);
-testFunctionMirror((function(){}).bind({}), "Object");
Only in up/v8/test/mjsunit/regress: regress-5010.js
Only in up/v8/test/mjsunit/regress: regress-crbug-610228.js
Only in up/v8/test/mjsunit/regress: regress-crbug-617524.js
Only in nw/v8/test/mjsunit/regress: regress-seqstrsetchar-ex2.js
Only in up/v8/test/mjsunit/regress: regress-v8-5009.js
diff -r -u --color up/v8/test/mjsunit/string-fromcharcode.js nw/v8/test/mjsunit/string-fromcharcode.js
--- up/v8/test/mjsunit/string-fromcharcode.js	2023-02-22 17:57:46.243000000 -0500
+++ nw/v8/test/mjsunit/string-fromcharcode.js	2016-05-11 19:19:17.000000000 -0400
@@ -103,6 +103,11 @@
   test(i);
 }
 
+assertEquals("AAAA", String.fromCharCode(65, 65, 65, 65));
+assertEquals("AAAA", String.fromCharCode(65, 65, 65, 65));
+%OptimizeFunctionOnNextCall(String.fromCharCode);
+assertEquals("AAAA", String.fromCharCode(65, 65, 65, 65));
+
 // Test the custom IC works correctly when the map changes.
 for (var i = 0; i < 10; i++) {
   var expected = (i < 5) ? " " : 42;
diff -r -u --color up/v8/tools/gyp/v8.gyp nw/v8/tools/gyp/v8.gyp
--- up/v8/tools/gyp/v8.gyp	2023-02-22 17:57:47.380000000 -0500
+++ nw/v8/tools/gyp/v8.gyp	2016-05-11 19:19:17.000000000 -0400
@@ -49,12 +49,19 @@
           'toolsets': ['target'],
         }],
         ['component=="shared_library"', {
-          'type': '<(component)',
           'sources': [
             # Note: on non-Windows we still build this file so that gyp
             # has some sources to link into the component.
             '../../src/v8dll-main.cc',
           ],
+          'direct_dependent_settings': {
+            'defines': [
+              'USING_V8_SHARED',
+            ],
+          },
+        }],
+        ['1==1', {
+          'type': '<(component)',
           'include_dirs': [
             '../..',
           ],
@@ -65,7 +72,6 @@
           'direct_dependent_settings': {
             'defines': [
               'V8_SHARED',
-              'USING_V8_SHARED',
             ],
           },
           'target_conditions': [
@@ -172,7 +178,7 @@
             'js2c',
           ],
         }],
-        ['component=="shared_library"', {
+        ['1==1', {
           'defines': [
             'V8_SHARED',
             'BUILDING_V8_SHARED',
@@ -180,7 +186,6 @@
           'direct_dependent_settings': {
             'defines': [
               'V8_SHARED',
-              'USING_V8_SHARED',
             ],
           },
         }],
@@ -255,7 +260,7 @@
           'toolsets': ['target'],
           'dependencies': ['js2c'],
         }],
-        ['component=="shared_library"', {
+        ['1==1', {
           'defines': [
             'BUILDING_V8_SHARED',
             'V8_SHARED',
@@ -283,7 +288,7 @@
                 'natives_blob',
               ],
             }],
-            ['component=="shared_library"', {
+            ['1==1', {
               'defines': [
                 'V8_SHARED',
                 'BUILDING_V8_SHARED',
@@ -291,7 +296,6 @@
               'direct_dependent_settings': {
                 'defines': [
                   'V8_SHARED',
-                  'USING_V8_SHARED',
                 ],
               },
             }],
@@ -1557,7 +1561,7 @@
           # See http://crbug.com/485155.
           'msvs_shard': 4,
         }],
-        ['component=="shared_library"', {
+        ['1==1', {
           'defines': [
             'BUILDING_V8_SHARED',
             'V8_SHARED',
@@ -2188,6 +2192,30 @@
         ]
     },
     {
+      'target_name': 'nwjc',
+      'type': 'executable',
+      'dependencies': ['v8_base', 'v8_nosnapshot', 'v8_libplatform'],
+      'include_dirs+': [
+        '../..',
+      ],
+      'sources': [
+        '../../src/nwjc.cc',
+      ],
+      'conditions': [
+        ['v8_enable_i18n_support==1', {
+          'dependencies': [
+            '<(icu_gyp_path):icui18n',
+            '<(icu_gyp_path):icuuc',
+          ]
+        }],
+        ['want_separate_host_toolset==1', {
+          'toolsets': ['host'],
+        }, {
+          'toolsets': ['target'],
+        }],
+      ],
+    },
+    {
       'target_name': 'mksnapshot',
       'type': 'executable',
       'dependencies': ['v8_base', 'v8_nosnapshot', 'v8_libplatform'],
