diff --git a/chrome/app/chrome_exe_main_win.cc b/chrome/app/chrome_exe_main_win.cc
index b3672a1594..6523d65d2f 100644
--- a/chrome/app/chrome_exe_main_win.cc
+++ b/chrome/app/chrome_exe_main_win.cc
@@ -70,6 +70,7 @@ namespace {
 // process) created before MainDllLoader changes the current working directory
 // to the browser's version directory.
 void SetCwdForBrowserProcess() {
+#if 0
   if (!::IsBrowserProcess())
     return;

@@ -82,7 +83,9 @@ void SetCwdForBrowserProcess() {
   base::SetCurrentDirectory(
       base::FilePath(base::FilePath::StringPieceType(&buffer[0], length))
           .DirName());
+#endif
 }
+#if 0

 bool IsFastStartSwitch(const std::string& command_line_switch) {
   return command_line_switch == switches::kProfileDirectory;
@@ -114,6 +117,7 @@ bool AttemptFastNotify(const base::CommandLine& command_line) {
     return false;
   return chrome::AttemptToNotifyRunningChrome(chrome) == chrome::NOTIFY_SUCCESS;
 }
+#endif

 // Returns true if |command_line| contains a /prefetch:# argument where # is in
 // [1, 8].
@@ -229,8 +233,8 @@ __declspec(dllexport) __cdecl void GetPakFileHashes(
     const uint8_t** chrome_100_pak,
     const uint8_t** chrome_200_pak) {
   *resources_pak = kSha256_resources_pak.data();
-  *chrome_100_pak = kSha256_chrome_100_percent_pak.data();
-  *chrome_200_pak = kSha256_chrome_200_percent_pak.data();
+  *chrome_100_pak = kSha256_nw_100_percent_pak.data();
+  *chrome_200_pak = kSha256_nw_200_percent_pak.data();
 }

 #if !defined(WIN_CONSOLE_APP)
@@ -282,7 +286,6 @@ int main() {

   SetCwdForBrowserProcess();
   install_static::InitializeFromPrimaryModule();
-  SignalInitializeCrashReporting();
   if (IsBrowserProcess())
     chrome::DisableDelayLoadFailureHooksForMainExecutable();
 #if defined(ARCH_CPU_32_BITS)
@@ -325,9 +328,15 @@ int main() {
          HasValidWindowsPrefetchArgument(*command_line));

   if (process_type == crash_reporter::switches::kCrashpadHandler) {
+    // HACK: Let Windows know that we have started.  This is needed to suppress
+    // the IDC_APPSTARTING cursor from being displayed for a prolonged period
+    // while a subprocess is starting. NWJS#4685
+    PostThreadMessage(GetCurrentThreadId(), WM_NULL, 0, 0);
+    MSG msg;
+    PeekMessage(&msg, NULL, 0, 0, PM_REMOVE);
+
     // Check if we should monitor the exit code of this process
     std::unique_ptr<browser_watcher::ExitCodeWatcher> exit_code_watcher;
-
     crash_reporter::SetupFallbackCrashHandling(*command_line);
     // no-periodic-tasks is specified for self monitoring crashpad instances.
     // This is to ensure we are a crashpad process monitoring the browser
@@ -384,8 +393,10 @@ int main() {
   if (process_type.empty() || process_type == switches::kGpuProcess)
     base::win::EnableHighDPISupport();

+#if 0 //FIXME(nwjs)
   if (AttemptFastNotify(*command_line))
     return 0;
+#endif

   RemoveAppCompatFlagsEntry();

